Subject: Re: Need help w/ I/O in Windows
From: "modula2.org" <frank@modula2.org>
Newsgroups: comp.lang.modula2

When using the ISO libraries, look at STextIO for character and string
input/output, and use SWholeIO and SLongIO for numbers IO.  The procedures
in these modules do not require a ChanId, they use a default channel.  For
File IO use the RndFile module.  Link your project as a Console Application.

Alternatively you can use the StonyBrook (SB) specific Terminal module when
you require simple text output only.  The SB module BasicDialogs (in the
advapidef folder) provides simple dialog boxes to get input from the user.

When you want to do real Windows programming, look at the Win32 API tutorial
on the website www.modula2.org.

I have found Modula-2 to be a very suitable language for Windows
programming.

Frank Schoonjans.


"Robert Solomon" <rob@drrob1.com> wrote in message
news:MPG.192c04003808a82298969a@news-server.optonline.net...
> Hi.  I'm new to Windows pgm'g.  I did a lot of programming in DOS but
> never learned how to pgm in Windows.  I'm now looking at the ISO
> versions of Modula-2 and I'm confused by the need for a channel ID.  I'm
> used to the Wirth libraries of InOut.
>
> Could someone help me and explain how to use the various ISO libraries
> for I/O that require a CID?  And how does one use the Terminal module?
> Even a link to a good website would be useful.  I'm working my way thru
> using Petzold's book and the available translations for Stony Brook's
> Modula-2, but I'm still puzzled by the ISO libraries.
>
> Thanks,
> Rob


Subject: Re: Need help w/ I/O in Windows
From: "Norman Black" <nospam@nospam.com>
Reply-To: "Norman Black" <nospam@nospam.com>
Newsgroups: comp.lang.modula2

I would add that the modules WinShell, DlgShell, BasicDialogs and
TextWindows are cross platform portable GUI encapsulation libraries.
They are currently implemented on Win32 and Unix platforms. The
remaining major platform is under development. These are not all
encompassing modules. Functionality is added on an as needed basis.

> The SB module BasicDialogs (in the advapidef folder)

Forget the folder. Suffice it to say that BasicDialogs is in the Win32
RTL project like all other RTL modules. Let the environment worry about
where the file exists on disk.

--
Norman Black
Stony Brook Software

DEFINITION MODULE IOConsts;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs © 1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman
=========================================== *)
(* Types and constants for input/output modules *)
TYPE
    (* This type is used to classify the result of an input operation *)
    ReadResults =
    (
     notKnown,          (* no data read result is set *)
     allRight,          (* data is as expected or as required *)
     outOfRange,        (* data cannot be represented *)
     wrongFormat,       (* data not in expected format *)
     endOfLine,         (* end of line seen before expected data *)
     endOfInput         (* end of input seen before expected data *)
    );
END IOConsts.
DEFINITION MODULE STextIO;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs  1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman

          Implementation  1993
                by R. Sutcliffe
       (Portions coded by G. Tischer)
        Trinity Western University
7600 Glover Rd., Langley, BC Canada V3A 6H4
         e-mail: rsutc@twu.ca
    Last modification date 1993 10 20
=========================================== *)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END


  (* Input and output of character and string types over default channels. The read result is of the type IOConsts.ReadResults. *)

  (* The following procedures do not read past line marks *)

PROCEDURE ReadChar(VAR ch : CHAR);
  (* If possible, removes a character from the default input stream,
     and assigns the corresponding value to ch.  The read result is set
     to allRight, endOfLine or endOfInput. *)

PROCEDURE ReadRestLine(VAR s : ARRAY OF CHAR);
  (* Removes any remaining characters from the default input stream before
     the next line mark, copying to s as many as can be accommodated as a
     string value.  The read result is set to the value allRight,
     outOfRange, endOfLine, or endOfInput. *)

PROCEDURE ReadString(VAR s : ARRAY OF CHAR);
  (* Removes only those characters from the default input stream before the
     next line mark that can be accommodated in s as a string value, and
     copies them to s.  The read result is set to the value allRight,
     endOfLine, or endOfInput. *)

PROCEDURE ReadToken(VAR s : ARRAY OF CHAR);
  (* Skips leading spaces, and then removes characters from the default
     input stream before the next space or line mark, copying to s as
     many as can be accommodated as a string value.  The read result is
     set to the value allRight, outOfRange, endOfLine, or endOfInput. *)

  (* The following procedure reads past the next line mark *)

PROCEDURE SkipLine;
  (* Removes successive items from the default input stream up to and
     including the next line mark or until the end of input is reached.
     The read result is set to the value allRight, or endOfInput. *)


  (* Output procedures *)

PROCEDURE WriteChar(ch : CHAR);
  (* Writes the value of ch to the default output stream. *)

PROCEDURE WriteLn;
  (* Writes a line mark to the default output stream. *)

PROCEDURE WriteString(s : ARRAY OF CHAR);
  (* Writes the string value of s to the default output stream. *)

END STextIO.

DEFINITION MODULE SWholeIO;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs  1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman
=========================================== *)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

(* Input and output of whole numbers in decimal text form over default
   channels. The read result is of the type IOConsts.ReadResults. *)

(* The text form of a signed whole number is
   ["+" | "-"], decimal digit, {decimal digit}

   The text form of an unsigned whole number is
   decimal digit, {decimal digit}
*)

PROCEDURE ReadInt(VAR int : INTEGER);
(* Skips leading spaces, and removes any remaining characters from the
   default input channel that form part of a signed whole number.  The
   value of this number is assigned to int. The read result is set to
   the value allRight, outOfRange, wrongFormat, endOfLine, or endOfInput. *)

PROCEDURE WriteInt(int : INTEGER; width : CARDINAL);
(* Writes the value of int to the default output channel in text form,
 in a field of the given minimum width. A width of zero(0) is special
 and means a single space character will always be output before the number *)

PROCEDURE ReadCard(VAR card : CARDINAL);
  (* Skips leading spaces, and removes any remaining characters from the
     default input channel that form part of an unsigned whole number.
     The value of this  number is assigned to card.  The read result is
     set to the value allRight, outOfRange, wrongFormat, endOfLine,
     or endOfInput. *)

PROCEDURE WriteCard(card : CARDINAL; width : CARDINAL);
(* Writes the value of card to the default output channel in text form,
 in a field of the given minimum width. A width of zero(0) is special
 and means a single space character will always be output before the number *)

END SWholeIO.

DEFINITION MODULE IOConsts;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs © 1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman
=========================================== *)
(* Types and constants for input/output modules *)

TYPE
    (* This type is used to classify the result of an input operation *)
    ReadResults =
    (
     notKnown,          (* no data read result is set *)
     allRight,          (* data is as expected or as required *)
     outOfRange,        (* data cannot be represented *)
     wrongFormat,       (* data not in expected format *)
     endOfLine,         (* end of line seen before expected data *)
     endOfInput         (* end of input seen before expected data *)
    );

END IOConsts.

DEFINITION MODULE SIOResult;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs © 1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman
===========================================*)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END


(* Read results for the default input channel *)

IMPORT IOConsts;

TYPE
    ReadResults = IOConsts.ReadResults;

(*
  TYPE
    ReadResults =    (* This type is used to classify the result of an input operation *)
    (
      notKnown,      (* no data read result is set *)
      allRight,      (* data is as expected or as required *)
      outOfRange,    (* data cannot be represented *)
      wrongFormat,  (* data not in expected format *)
      endOfLine,    (* end of line seen before expected data *)
      endOfInput    (* end of input seen before expected data *)
    );
*)

PROCEDURE ReadResult() : ReadResults;

(* Returns the result for the last read operation on the default input
   channel *)

END SIOResult.
(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1996                                  *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)
DEFINITION MODULE SLWholeIO;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END


(* Input and output of whole numbers in decimal text form over default
   channels. The read result is of the type IOConsts.ReadResults. *)

(* The text form of a signed whole number is
   ["+" | "-"], decimal digit, {decimal digit}

   The text form of an unsigned whole number is
   decimal digit, {decimal digit}
*)

PROCEDURE ReadLongInt(VAR int : LONGINT);
(* Skips leading spaces, and removes any remaining characters from the
   default input channel that form part of a signed whole number.  The
   value of this number is assigned to int. The read result is set to
   the value allRight, outOfRange, wrongFormat, endOfLine, or endOfInput. *)

PROCEDURE WriteLongInt(int : LONGINT; width : CARDINAL);
  (* Writes the value of int to the default output channel in text form,
     in a field of the given minimum width.A width of zero(0) is special
 and means a single space character will always be output before the number *)

PROCEDURE ReadLongCard(VAR card : LONGCARD);
  (* Skips leading spaces, and removes any remaining characters from the
     default input channel that form part of an unsigned whole number.
     The value of this  number is assigned to card.  The read result is
     set to the value allRight, outOfRange, wrongFormat, endOfLine,
     or endOfInput. *)

PROCEDURE WriteLongCard(card : LONGCARD; width : CARDINAL);
  (* Writes the value of card to the default output channel in text form,
     in a field of the given minimum width.A width of zero(0) is special
 and means a single space character will always be output before the number *)

END SLWholeIO.

DEFINITION MODULE SLongIO;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs © 1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman
=========================================== *)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END



  (* Input and output of real numbers in decimal text form over default
     channels.  The read result is of the type IOConsts.ReadResults.
  *)

  (* The text form of a signed fixed-point real number is
       ["+" | "-"], decimal digit, {decimal digit},
       [".", {decimal digit}]

     The text form of a signed floating-point real number is
       signed fixed-point real number,
       "E", ["+" | "-"], decimal digit, {decimal digit}
  *)

PROCEDURE ReadReal(VAR real : LONGREAL);
  (* Skips leading spaces, and removes any remaining characters from
     the default input channel that form part of a signed fixed or
     floating point number. The value of this number is assigned to real.
     The read result is set to the value allRight, outOfRange, wrongFormat,
     endOfLine, or endOfInput.
  *)

PROCEDURE WriteFloat(real : LONGREAL; sigFigs : CARDINAL; width : CARDINAL);
  (* Writes the value of real to the default output channel in
     floating-point text form, with sigFigs significant figures, in a
     field of the given minimum width. *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

PROCEDURE WriteEng(real : LONGREAL; sigFigs : CARDINAL; width : CARDINAL);
  (* As for WriteFloat, except that the number is scaled with one to three
     digits in the whole number part, and with an exponent that is a
     multiple of three. *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

PROCEDURE WriteFixed(real : LONGREAL; place, width : CARDINAL);
  (* Writes the value of real to the default output channel in
     fixed-point text form, rounded to the given place relative to the
     decimal point, in a field of the given minimum width. *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

PROCEDURE WriteReal(real : LONGREAL; width : CARDINAL);
  (* Writes the value of real to the default output channel, as WriteFixed
     if the sign and magnitude can be shown in the given width, or otherwise
     as WriteFloat.  The number of places or significant digits depends on
     the given width. *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

END SLongIO.

DEFINITION MODULE SRealIO;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs © 1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman
=========================================== *)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

  (* Input and output of real numbers in decimal text form over default
     channels.  The read result is of the type IOConsts.ReadResults.
  *)

  (* The text form of a signed fixed-point real number is
       ["+" | "-"], decimal digit, {decimal digit},
       [".", {decimal digit}]

     The text form of a signed floating-point real number is
       signed fixed-point real number,
       "E", ["+" | "-"], decimal digit, {decimal digit}
  *)

PROCEDURE ReadReal(VAR real : REAL);
  (* Skips leading spaces, and removes any remaining characters from the
     default input channel that form part of a signed fixed or floating
     point number. The value of this number is assigned to real.  The
     read result is set to the value allRight, outOfRange, wrongFormat,
     endOfLine, or endOfInput. *)

PROCEDURE WriteFloat(real : REAL; sigFigs : CARDINAL; width : CARDINAL);
  (* Writes the value of real to the default output channel in
     floating-point text form, with sigFigs significant figures, in a
     field of the given minimum width.  *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

PROCEDURE WriteEng(real : REAL; sigFigs : CARDINAL; width : CARDINAL);
  (* As for WriteFloat, except that the number is scaled with one to
     three digits in the whole number part, and with an exponent that is a
     multiple of three.  *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

PROCEDURE WriteFixed(real : REAL; place, width : CARDINAL);
  (* Writes the value of real to the default output channel in
     fixed-point text form, rounded to the given place relative to the
     decimal point, in a field of the given minimum width.  *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

PROCEDURE WriteReal(real : REAL; width : CARDINAL);
  (* Writes the value of real to the default output channel, as WriteFixed
     if the sign and magnitude can be shown in the given width, or
     otherwise as WriteFloat.  The number of places or significant digits
     depends on the given width.  *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

END SRealIO.

DEFINITION MODULE RndFile;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs © 1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman
===========================================*)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END


IMPORT IOChan, ChanConsts, SYSTEM;

TYPE
    ChanId      = IOChan.ChanId;
    FlagSet     = ChanConsts.FlagSet;
    OpenResults = ChanConsts.OpenResults;

  (* Accepted singleton values of FlagSet *)

CONST
  read  = FlagSet{ChanConsts.readFlag}; (* input operations are requested/available *)
  write = FlagSet{ChanConsts.writeFlag};(* output operations are requested/available *)
  old   = FlagSet{ChanConsts.oldFlag};  (* a file may/must/did exist before the channel is opened *)
  text  = FlagSet{ChanConsts.textFlag}; (* text operations are requested/available *)
  raw   = FlagSet{ChanConsts.rawFlag};  (* raw operations are requested/available *)

PROCEDURE OpenOld(VAR cid : ChanId;
                  name : ARRAY OF CHAR;
                  flags : FlagSet;
                  VAR res : OpenResults);
  (* Attempts to obtain and open a channel connected to a stored random
     access file of the given name. The old flag is implied; without the
     write flag, read is implied; without the text flag, raw is implied.
     If successful, assigns to cid the identity of the opened channel,
     assigns the value opened to res, and sets the read/write position to
     the start of the file. If a channel cannot be opened as required, the
     value of res indicates the reason, and cid identifies the invalid
     channel.
  *)

PROCEDURE OpenClean(VAR cid : ChanId;
                    name : ARRAY OF CHAR;
                    flags : FlagSet;
                    VAR res : OpenResults);
  (* Attempts to obtain and open a channel connected to a stored random
     access file of the given name. The write flag is implied;
     without the text flag, raw is implied.
     If successful, assigns to cid the identity of the opened channel,
     assigns the value opened to res, and truncates the file to zero length.
     If a channel cannot be opened as required, the value of res indicates
     the reason, and cid identifies the invalid channel.
  *)

PROCEDURE IsRndFile(cid : ChanId) : BOOLEAN;
  (* Tests if the channel identified by cid is open to a random access file.
  *)

PROCEDURE IsRndFileException() : BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution
     state because of the raising of a RndFile exception;
     otherwise returns FALSE.
  *)

CONST
    FilePosSize = 4;

TYPE
    FilePos = ARRAY [1..FilePosSize] OF SYSTEM.LOC;

PROCEDURE StartPos(cid : ChanId) : FilePos;
  (* If the channel identified by cid is not open to a random access file,
     the exception wrongDevice is raised; otherwise returns the position of
     the start of the file.
  *)

PROCEDURE CurrentPos(cid : ChanId) : FilePos;
  (* If the channel identified by cid is not open to a random access file,
     the exception wrongDevice is raised; otherwise returns the position of
     the current read/write position.
  *)

PROCEDURE EndPos(cid : ChanId) : FilePos;
  (* If the channel identified by cid is not open to a random access file,
     the exception wrongDevice is raised; otherwise returns the first
     position after which there have been no writes.
  *)

PROCEDURE NewPos(cid : ChanId;
                 chunks : INTEGER;
                 chunkSize : CARDINAL;
                 from : FilePos) : FilePos;
  (* If the channel identified by cid is not open to a random access file,
     the exception wrongDevice is raised; otherwise returns the
     position (chunks * chunkSize) relative to the position given by from,
     or raises the exception posRange if the required position cannot be
     represented as a value of type FilePos.
  *)

PROCEDURE SetPos(cid : ChanId; pos : FilePos);
  (* If the channel identified by cid is not open to a random access file,
     the exception wrongDevice is raised; otherwise sets the read/write
     position to the value given by pos.
  *)

PROCEDURE Close(VAR cid : ChanId);
  (* If the channel identified by cid is not open to a random access file,
     the exception wrongDevice is raised; otherwise closes the channel, and
     assigns the value identifying the invalid channel to cid.
  *)

END RndFile.

DEFINITION MODULE SeqFile;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs © 1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman
===========================================*)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END


  (* Rewindable sequential files *)

IMPORT IOChan, ChanConsts;

TYPE
    ChanId      = IOChan.ChanId;
    FlagSet     = ChanConsts.FlagSet;
    OpenResults = ChanConsts.OpenResults;

  (* Accepted singleton values of FlagSet *)

CONST
  read  = FlagSet{ChanConsts.readFlag}; (* input operations are requested/available *)
  write = FlagSet{ChanConsts.writeFlag};(* output operations are requested/available *)
  old   = FlagSet{ChanConsts.oldFlag};  (* a file may/must/did exist before the channel is opened *)
  text  = FlagSet{ChanConsts.textFlag}; (* text operations are requested/available *)
  raw   = FlagSet{ChanConsts.rawFlag};  (* raw operations are requested/available *)

PROCEDURE OpenWrite(VAR cid : ChanId;
                    name : ARRAY OF CHAR;
                    flags : FlagSet;
                    VAR res : OpenResults);
  (* Attempts to obtain and open a channel connected to a stored rewindable
     file of the given name. The write flag is implied; without the raw flag,
     text is implied. If successful, assigns to cid the identity of the
     opened channel, assigns the value opened to res, and selects output mode,
     with the write position at the start of the file
     (i.e. the file is of zero length).
     If a channel cannot be opened as required, the value of res indicates
     the reason, and cid identifies the invalid channel.
  *)

PROCEDURE OpenAppend(VAR cid : ChanId;
                     name : ARRAY OF CHAR;
                     flags : FlagSet;
                     VAR res : OpenResults);
  (* Attempts to obtain and open a channel connected to a stored rewindable
     file of the given name.
     The write and old flags are implied; without the raw flag, text is
     implied. If successful, assigns to cid the identity of the opened
     channel, assigns the value opened to res, and selects output mode,
     with the write position corresponding to the length of the file.
     If a channel cannot be opened as required, the value of res indicates
     the reason, and cid identifies the invalid channel.
  *)

PROCEDURE OpenRead(VAR cid : ChanId;
                   name : ARRAY OF CHAR;
                   flags : FlagSet;
                   VAR res : OpenResults);
  (* Attempts to obtain and open a channel connected to a stored rewindable
     file of the given name. The read and old flags are implied; without the
     raw flag, text is implied.If successful, assigns to cid the identity
     of the opened channel, assigns the value opened to res, and selects
     input mode, with the read position corresponding to the start of the
     file. If a channel cannot be opened as required, the value of res
     indicates the reason, and cid identifies the invalid channel.
  *)

PROCEDURE IsSeqFile(cid : ChanId) : BOOLEAN;
  (* Tests if the channel identified by cid is open to a rewindable
     sequential file. *)

PROCEDURE Reread(cid : ChanId);
  (* If the channel identified by cid is not open to a rewindable sequential
     file, the exception wrongDevice is raised; otherwise attempts to set
     the read position to the start of the file, and to select input mode.
     If the operation cannot be performed (perhaps because of insufficient
     permissions) neither input mode nor output mode is selected.
  *)

PROCEDURE Rewrite(cid : ChanId);
  (* If the channel identified by cid is not open to a rewindable sequential
     file, the exception wrongDevice is raised; otherwise, attempts to
     truncate the file to zero length, and to select output mode.
     If the operation cannot be performed (perhaps because of insufficient
     permissions) neither input mode nor output mode is selected.
  *)

PROCEDURE Close(VAR cid : ChanId);
  (* If the channel identified by cid is not open to a rewindable sequential
     file, the exception wrongDevice is raised; otherwise closes the channel,
     and assigns the value identifying the invalid channel to cid.
  *)

END SeqFile.

DEFINITION MODULE Terminal;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

(* a simple text output *)
(* the size of the display is generally 80x25, but may be different *)

CONST
    (* these character codes are used for some non ASCII characters *)
    (* supported by this terminal module *)

    CursorUp    = CHR(1);
    CursorDown  = CHR(2);
    PageUp      = CHR(3);
    PageDown    = CHR(4);
    CursorLeft  = CHR(5);
    CursorRight = CHR(6);

    Escape      = CHR(27);
    Tab         = CHR(9);
    BackSpace   = CHR(8);
    Bell        = CHR(7);
    Enter       = CHR(13);
    LineFeed    = CHR(10);

PROCEDURE Write(ch : CHAR);
(* write a single character to the currsor cursor position *)

PROCEDURE WriteString(str : ARRAY OF CHAR);
(* write a string to the cursor position *)

PROCEDURE WriteLn;
(* set the cursor X position to 0, far left *)
(* and increment the Y positon, down *)
(* if the Y position is greater that the terminal window size *)
(* then the terminal window data is scrolled and a blank line *)
(* is displayed at the bottom of the terminal window *)
(* and the Y position of the cursor is at the bottom of the terminal *)
(* window *)

PROCEDURE Position(X, Y : CARDINAL);
(* set the cursor position *)

PROCEDURE CharAvail() : BOOLEAN;
(* is there a character keystroke available for input *)

PROCEDURE Read(VAR OUT ch : CHAR);
(* read a character keystroke *)

PROCEDURE ReadChar() : CHAR;
(* same as Read, but in function form *)

PROCEDURE Reset;
(* clears the screen and places the cursor at 0,0 *)

END Terminal.

DEFINITION MODULE BasicDialogs;
(* This module provides a host of basic dialogs common for various
   simple tasks where it would be useful to have something that is
   ready to go without the need for writing code.

   The parent window of all dialogs is the value returned by
   DlgShell.GetDialogParent()
*)
(* about threads
   Win32 - you may use the GUI features in a fully multi threaded
           manner.

   Gtk - Only one thread, the main thread, may use the GUI features.
*)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

FROM WinShell IMPORT
    FontInfo, PrintDriverInfo;

TYPE
    MessageTypes        = (MsgInfo,
                           MsgQuestion,
                           MsgWarning,
                           MsgAppError,
                           MsgException);

    PromptListWidth     = (NormalListWidth, WideListWidth);

VAR
    MessageTitle        : ARRAY [0..79] OF CHAR;
    (* The title bar for all dialogs not specifically specifying a title *)

    WasSystemMessageBox : BOOLEAN;
    (* Only Applicable to Win32.
       TRUE if a system dialog box was just displayed.
       This is useful when using the WSM_ACTIVATEAPP, WSM_DEACTIVATEAPP message.
       This lets you know that the foreground loss was just due to a
       system message box and not the user clicking away from the application.
    *)

(* the parent of all dialogs is DlgShell.GetDialogParent() *)

PROCEDURE MessageBox(mess : ARRAY OF CHAR; msgType : MessageTypes);
(* displays mess in a system message box
   the message box will have a single "ok" button
   carriage return/line feeds are allowed in the string and are
   correctly processed.
   msgType determines what type of ICON and sound are used when the
   message box is displayed.
   The MsgException type also displays the exception address in the dialog.
*)

PROCEDURE MessageBoxId(mess : CARDINAL; msgType : MessageTypes);
(* mess is a string resource identifier specifying the string
   to load from the resource and display in the message box.
   See MessageBox
*)

PROCEDURE YesNo(prompt : ARRAY OF CHAR; default : CHAR) : CHAR;
(* displays the prompt in a message box
   the message box will have a "yes" and "no" buttons
   if default = "Y" then the yes button will be the default button when
   the dialog opens otherwise the no button will be the default
   upon return the function will return "Y" or "N"
   "Y" is returned if the yes button is pressed
   "N" is returned if the no button is pressed
*)

PROCEDURE YesNoId(prompt : CARDINAL; default : CHAR) : CHAR;
(* prompt is a string resource identifier specifying the string
   to load from the resource and display in the message box.
   See YesNo
*)

PROCEDURE YesNoCancel(prompt : ARRAY OF CHAR;
                      default : CHAR) : CHAR;
(* displays the prompt in a message box
   the message box will have a "yes", "no" and "cancel" buttons
   if default = "Y" then the yes button will be the default button when
   the dialog opens, of default = "N" then the no button will be the default
   otherwise the cancel button will be the default button
   upon return the function will return "Y", "N" or "C"
   "Y" is returned if the yes button is pressed
   "N" is returned if the no button is pressed
   "C" is returned if the cancel button is pressed
*)

PROCEDURE YesNoCancelId(prompt : CARDINAL; default : CHAR) : CHAR;
(* prompt is a string resource identifier specifying the string
   to load from the resource and display in the message box.
   See YesNoCancel
*)

PROCEDURE OkCancel(prompt : ARRAY OF CHAR;
                   default : CHAR;
                   msgType : MessageTypes) : CHAR;
(* displays the prompt in a message box
   the message box will have a "ok" and "cancel" buttons
   if default = "O" then the ok button will be the default button when
   the dialog opens otherwise the cancel button will be the default button
   upon return the function will return "O" or "C"
   "O" is returned if the ok button is pressed
   "C" is returned if the cancel button is pressed
   msgType determines what type of ICON and sound are used when the
   message box is displayed.
*)

PROCEDURE OkCancelId(prompt : CARDINAL;
                     default : CHAR;
                     msgType : MessageTypes) : CHAR;
(* prompt is a string resource identifier specifying the string
   to load from the resource and display in the message box.
   See OkCancel
*)

PROCEDURE OpenBusyBox(prompt : ARRAY OF CHAR) : BOOLEAN;
(* opens a modeless dialog box.
   A return value of FALSE signifies failure.
   the dialog can display a single line of text, prompt, of a limited length.
   this is generally used when your application is performing a lengthy
   operation.
*)

PROCEDURE OpenBusyBoxId(prompt : CARDINAL) : BOOLEAN;
(* prompt identifies a string resource to retrieve the text to be
   displayed in the dialog.
   See OpenBusyBox
*)

PROCEDURE CloseBusyBox;
(* close a previously opened busy box dialog *)

PROCEDURE PromptString(prompt : ARRAY OF CHAR;
                       VAR INOUT response : ARRAY OF CHAR) : BOOLEAN;
(* open a modal dialog with a single edit field and a text label
   for the edit field contained in prompt.
   returns TRUE if the user enters text and presses OK, otherwise FALSE
   the text entered is contained in response
*)

PROCEDURE PromptStringId(prompt : CARDINAL;
                         VAR INOUT response : ARRAY OF CHAR) : BOOLEAN;
(* prompt identifies a string resource to retrieve the text to be
   displayed in the dialog.
   See PromptString
*)

PROCEDURE PromptPassword(prompt : ARRAY OF CHAR;
                         VAR INOUT response : ARRAY OF CHAR) : BOOLEAN;
(* same as the PromptString dialog except the text the user enters
   will be "greeked" and not be visible to anyone to looking at the screen
*)

PROCEDURE PromptPasswordId(prompt : CARDINAL;
                           VAR INOUT response : ARRAY OF CHAR) : BOOLEAN;
(* prompt identifies a string resource to retrieve the text to be
   displayed in the dialog.
   See PromptPassword
*)

PROCEDURE PromptCard(prompt : ARRAY OF CHAR;
                     min, max : CARDINAL;
                     allowZero : BOOLEAN;
                     VAR INOUT response : CARDINAL) : BOOLEAN;
(* open a modal dialog with a single edit field and a text label
   for the edit field contained in prompt.
   returns TRUE if the user enters a valid number and presses OK
   otherwise FALSE
   the number entered is contained in response
   min and max provide range checking for the number entered.
   if allowZero = TRUE then the number zero will be allowed even if outside
   the allowed number range. This can be used to allow the user to enter a
   "null" value.
*)

PROCEDURE PromptCardId(prompt : CARDINAL;
                       min, max : CARDINAL;
                       allowZero : BOOLEAN;
                       VAR INOUT response : CARDINAL) : BOOLEAN;
(* prompt identifies a string resource to retrieve the text to be
   displayed in the dialog.
   See PromptCard
*)

PROCEDURE PromptListStr(prompt : ARRAY OF CHAR;
                        VAR INOUT list : ARRAY OF CHAR;
                        listSep : CHAR;
                        VAR INOUT selStr : ARRAY OF CHAR;
                        listWidth : PromptListWidth) : BOOLEAN;
(* open a modal dialog with a single list box and a text label
   for the list field contained in prompt.
   returns TRUE if the user selects an item in the list and presses OK,
   or double clicks a list item.
   otherwise FALSE is returned.
   the item selected is contained in selStr. The value is the text of
   the item in the list.
   the list of items is contained in the parameter 'list'. Each item in the
   list is separated by the character listSep. The parameter list must be
   null terminated.
   If on entry selStr contains a value that matches an item in the list
   then that item will initially be selected, otherwise no item will be
   initially selected.
   listWidth specifies the size of the list box. Choose an appropriate size
   depending on the length of the list item strings.
   The list box will display a scroll bar when necessary.
*)

PROCEDURE PromptListStrId(prompt : CARDINAL;
                          VAR INOUT list : ARRAY OF CHAR;
                          listSep : CHAR;
                          VAR INOUT selStr : ARRAY OF CHAR;
                          listWidth : PromptListWidth) : BOOLEAN;
(* prompt identifies a string resource to retrieve the text to be
   displayed in the dialog.
   See PromptListStr
*)

PROCEDURE PromptListIndex(prompt : ARRAY OF CHAR;
                          VAR INOUT list : ARRAY OF CHAR;
                          listSep : CHAR;
                          VAR INOUT selIndex : CARDINAL;
                          listWidth : PromptListWidth) : BOOLEAN;
(* as PromptListStr except you specify the selection by position in the
   list starting with the value zero. Therefore the first item in the
   list has a value of zero and the second one, and so on.
   MAX(CARDINAL) signifies no selection
*)

PROCEDURE PromptListIndexId(prompt : CARDINAL;
                            VAR INOUT list : ARRAY OF CHAR;
                            listSep : CHAR;
                            VAR INOUT selIndex : CARDINAL;
                            listWidth : PromptListWidth) : BOOLEAN;
(* prompt identifies a string resource to retrieve the text to be
   displayed in the dialog.
   See PromptListIndex
*)

PROCEDURE PromptOpenFile(VAR INOUT name : ARRAY OF CHAR;
                         filters : ARRAY OF CHAR;
                         VAR INOUT defFilter : CARDINAL;
                         defDir : ARRAY OF CHAR;
                         defExt : ARRAY OF CHAR;
                         title : ARRAY OF CHAR;
                         createable : BOOLEAN) : BOOLEAN;
(* Opens an operating system common dialog for opening  a file
   filters specifies a list of file extension filters that are
   separated by semicolons.
   The format for filters is as follows.
   defDir = the default directory to start the dialog in
   an empty string "" means use the current directory.
   defExt = the default file extension to use if the user does not
   provide an extension. "" means no default extension.
   the extension should *not* have a leading '.' character.
   title = the caption text of the dialog. title can be empty "".
   in this case the default operating system title is used.
   If createable = TRUE then the file need not already exist, otherwise
   the file must exist for the dialog to return successful.
   RETURNs TRUE is successful and name will contain the file specification
   for the file the user has given.
*)

PROCEDURE PromptSaveAsFile(VAR INOUT name : ARRAY OF CHAR;
                           filters : ARRAY OF CHAR;
                           VAR INOUT defFilter : CARDINAL;
                           defDir : ARRAY OF CHAR;
                           defExt : ARRAY OF CHAR;
                           title : ARRAY OF CHAR;
                           overwritePrompt : BOOLEAN) : BOOLEAN;
(* As PromptOpenFile except this dialog is for saving a file.
   If overwritePrompt = TRUE then the user will be prompted when a file with
   the file name they enter already exists. They must answer yes to this
   dialog to continue and has this function return TRUE
*)

TYPE
    FontOptions = (FixedPitchOnly, NoStyle);
    FontOptionSet = PACKEDSET OF FontOptions;

PROCEDURE PromptChooseFont(VAR INOUT font : FontInfo;
                           opt : FontOptionSet) : BOOLEAN;
(* opens an operating system common dialog for selecting a font.
   RETURNs TRUE if successful and font will then contain the information
   describing the font the user selected. otherwise returns FALSE
   FixedPitchOnly if set will limit the font selections to fixed pitch
   fonts.
   NoStyle if set will not allow the user to select a font style
   such as Bold, Italic, etc..
   NoSize if set will not all the user to select a font point size
*)

TYPE
    PrintInfo =
        RECORD
        fromPage        : CARDINAL; (* in out *)
        toPage          : CARDINAL; (* in out *)
        minPage         : CARDINAL; (* in *)
        maxPage         : CARDINAL; (* in *)
        copies          : CARDINAL; (* in out *)
        selected        : BOOLEAN; (* in out *)
        duplex          : BOOLEAN; (* out *)
        collate         : BOOLEAN; (* in out *)
        driverInfo      : PrintDriverInfo; (* in out *)
        END;

PROCEDURE PromptPrint(VAR INOUT info : PrintInfo) : BOOLEAN;
(* opens an operating system common dialog for selecting a printer and
   various printer options for a specific print job.
   info contains the information to initialize the dialog fields
   an to also return the user entered information.
   Returns TRUE if the user does not cancel the dialog. In this case you
   continue by performing the print action the user has specified.
*)
(*
fromPage - initializes the dialog with the starting page to print, and upon
           return contains the starting page to print entered by the user.
           Normally initialized with 1. See toPage.
toPage - initializes the dialog with the ending page to print, and upon
         return contains the ending page to print entered by the user.
         If this value is initialized with 0 then the user will not be allowed
         to select a page range to print and no value is returned.
minPage - Only valid if toPage is initialized with a non zero value.
          The minimum page number the user will be allowed to enter in
          fromPage and toPage.
maxPage - Only valid if toPage is initialized with a non zero value.
          The maximum page number the user will be allowed to enter in
          fromPage and toPage.
copies - The number of copies to be printed. Normally initialized with a value
         of 1. Upon return the number of copies the user wants printed.
         If the printer driver supports multiple copies you will never
         reveive a value other than 1 upon return.
selected - If TRUE the user will be allowed to select if the current
           "selection" is to be printed, otherwise the entire document is
           assumed. Upon return TRUE means that the user wants only the
           selection to be printed.
duplex - Upon return if TRUE the document is to be printed two sided. This
         value can only be true if the printer supports duplex printing.
collate - If initialized with TRUE then the user will be allowed to select
          collated printing when printing multiple copies, otherwise they
          will not be allowed to make such a selection. Upon return the
          multiple copies of the document must be printed in a collated manner.
          It is up to you to do this since the printer driver does not have
          support doing this. If the printer driver supports collation you
          will never receive a value of TRUE.
driverInfo - This value may be initialized with NIL or a previously obtained
             value from PromptPrintSetup or this procedure.
             See PromptPrintSetup
*)

PROCEDURE PromptPrintSetup(VAR INOUT info : PrintDriverInfo) : BOOLEAN;
(* opens an operating system common dialog for setting up a printer and
   various custom printer options.
   Normally you will have a global variable that is initialized with a value
   of NIL and thereafter use that value. In this way your application will
   remember settings the user has made and not force them to reenter them
   every time they want to print.
   This value is usually passed to PromptPrint, although the user generally
   also has access to printer setup from the print dialog as well.
*)

PROCEDURE GetPrintDriverInfo(printerName : ARRAY OF CHAR;
                             VAR OUT info : PrintInfo) : BOOLEAN;
(* this procedure allows you to get print information if you know the
   system information detailing a printer driver
   this procedure exists for an application to support the operating system
   Print and PrintTo shell commands (right click and drag and drop). These
   commands are for files that are registered with the operating system.
   The operating system provides the first three parameters to you
   in the Print and PrintTo commands.
   If printerName = "" then the information for the default printer
   is returned.
   The function returns TRUE is successful
*)

END BasicDialogs.
(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1992-2002                             *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)
DEFINITION MODULE DlgShell;
(* This module provides an encapsulation of the interface to
   dialog boxes. This module is independent of the underlying
   operating system.
   This module also attempts to provide some automatic and simpler mechanisms
   for dealing with dialog boxes and their controls.
*)

(* about threads
   Win32 - you may use the GUI features in a fully multi threaded manner.

   Gtk - Only one thread, the main thread, may use the GUI features.
*)

<*/NOPACK*>
%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

FROM SYSTEM IMPORT
    ADDRESS, CAST, DWORD;

FROM WinShell IMPORT
    Window, COORDINATE;
IMPORT WinShell;

CONST
    CurrentAsParent     = CAST(Window, 1);
    (* Use this to specify the current dialog
      as the parent of the new dialog
      this is only used when one dialog creates another dialog. *)

VAR
    DlgError            : CARDINAL; (* operating system specific value *)

TYPE
    (* various types of dialog controls supported by this module *)
    ControlType = (
                   DialogTitle,
                   StaticText,
                   StaticTextAttrib,
                   CheckBox,
                   RadioGroup,
                   LineEdit,
                   NumberEdit,
                   IncDec,
                   MultiLineEdit,
                   EditTextFile,
                   ListBox,
                   ColumnListBox,
                   DropDownList,
                   ComboBox,
                   ColorDropDownList,
                   PushButton,
                   Timer,
                   UserData
                  );
(*

    ======= ControlType =======

    Most fields set the initial value of the control as well as holding
    the return value.

    StaticText  = The text to display in the field. Can be NIL on init.
                  Win32 - static text
                  Gtk - GtkLabel

    StaticTextAttrib    = The text to display in the field. Can be NIL.
                  Win32 - static text
                  Gtk - GtkLabel inside a GtkEventBox.
                          You should place a label inside and event box for this
                          control. A GtkLabel does not control its background color
                          so you need the EventBox to be able to set the background
                          color. If an event box is not the "parent" of this label,
                          then the background color will not be set but the foreground
                          and font attributes will still work.

        sta_fore = the foreground color to display the text in.
        sta_back = the background color to display the text in.
        sta_font = the font to used to display the text in. (Can be NIL)

    CheckBox
                  Win32 - check box
                  Gtk - GtkCheckButton

        on      = The state of the checkbox (checked is TRUE).
                  On entry sets box state and upon return contains the box state.

    RadioGroup
                  Win32 - radio button
                  Gtk - GtkRadioButton

        r_first = The id of the first radio button in the button group.
        r_last  = The id of the last radio button in the button group.
                  All items in the group must have consecutive id numbers
                  from first to last.

                  On entry id contains the initial item to check in the
                  radio group.
                  On return id contains the item in the group that is
                  currently checked.
                  This value is zero based from the first item in the group

    LineEdit
                  Win32 - edit
                  Gtk - GtkEntry

        le_text = Pointer to a null terminated string which holds the
                  edit field contents. Can be NIL. In this case
                  you will need to use the GetText procedure to fetch the
                  text from the control.
                  On entry the edit field is initialized with the text in
                  this string, and upon return the user entered text is
                  contained within this string.
        le_max  = The maximum number of characters allowed in the edit field.
                  The le_text buffer, if present, should be one character bigger
                  than the maximum allowable character count. This allows for
                  a null terminator.

    MultiLineEdit
                  Win32 - edit with multi line option
                  Gtk - GtkText

        mle_text = Pointer to a null terminated string which holds the
                   edit field contents. Can be NIL. To enter/retrieve text
                   you can use the supplied line read/write APIs.
                   If not NIL, on entry the edit field is initialized with the
                   text from this string.
        mle_max = The maximum number of characters allowed in the edit field.
                  mle_max can be zero which means that the edit file has not limit
                  other than that implied by the system.
                  The mle_text buffer, if present, should be one character bigger
                  than the maximum allowable character count. This allows for
                  a null terminator.

                  IF (mle_max <> 0) AND (mle_text <> NIL) THEN
                  mle_text will contain the value of the edit field upon return.
                  The buffer should be one character bigger than the maximum to
                  allow for a null terminator character.

    EditTextFile
        etf_name = Pointer to a NULL terminated string which holds the
                   file name of the file to be edited.
                   the file will be saved when the dialog is closed if the user alters
                   the file in any way. if the dialog is "canceled" then
                   the file will not be saved.
                   This control is compatible with the MultiLineEdit control.

    ListBox
                A list box that allows only a single item selected.
                  Win32 - list box, single selection
                  Gtk - GtkCList (1 column), browse/single selection

        lb_text
                = Pointer to an array of null terminated strings terminated
                  by a null, meaning the end of the string has a double null.
                  See the ConvertToNulls and ConvertFromNulls procedures in
                  this module for a simple method maintaining such strings.
        lb_selStr
                = Pointer to a string to hold the result as well as the
                  initial selection. This value can be NIL if you want to
                  set and receive the selection by index. The strings are
                  not case sensitive.
                  On termination this string has the users selection if it
                  does not have NIL.
                  selStr MUST be big enough to hold any string in the
                  list box.
        lb_selIndex
                = if selStr is NIL on entry, this has the initial selection
                  index. On termination this always has the users selection
                  by index regardless of if selStr <> NIL.
                  For sorted, this is the index of the order data was
                  added to the list box, not how it was displayed.
                  The index is zero based, and MAX(CARDINAL) signifies no
                  selection.

    ColumnListBox
                A list box that allows only a single item selected.
                The list box has 2 or more columns. The only way to initialize
                the list is to use API calls. You can do this in the dialog
                "init" message.
                  Win32 - ListView in report mode, single selection
                  Gtk - GtkCList, browse/single selection

        clb_columns = The number of columns, 2 or more

        clb_columnInfo =
                = Pointer to and array of CARDINAL values with the column
                  widths in screen pixels. Must have clb_columns number of
                  elements.
                  The first element is for column zero, and so on...

                  width = the column width in pixels. Can be zero if you are
                          going to set the column size via APIs
                  align = The alignment of the text in the column.
                  header = the header text. Can be NIL, which means the
                           header, if shown, with not have a title.
        clb_selStr
                = Pointer to a string to hold the result.
                  This value can be NIL if you want to receive the selection
                  by index.
                  On termination this string has the users selection if it
                  does not contain NIL.
                  selStr MUST be big enough to hold any string in the
                  list box.
                  selStr contains the text of all columns separated by null characters.
        clb_selIndex
                = On termination this always has the users selection.
                  The index is zero based, and MAX(CARDINAL) signifies no
                  selection.

    DropDownList
                This is an expandable list box that shows the selected item and the
                user can press a button to display the full list of items
                available to be selected.
                  Win32 - combo box with drop down list attribute
                  Gtk - GtkOptionMenu, or GtkCombo(not editable)
                        OptionMenu is the ideal widget but if you have a large
                        number of items in the list then OptionMenu does not work
                        well, if at all. In these cases use a GtkCombo with the
                        edit field marked as not editable.

        ddl_text = Pointer to an array of null terminated strings terminated
                  by a null, meaning the end of the string has a double null.
        ddl_selIndex
                = this has the initial selection index.
                  On termination this always has the users selection.
                  The index is zero based, and MAX(CARDINAL) signifies no
                  selection.

    ColorDropDownList
                    this control displays a selection of colors for the user to
                    choose from.

                  Win32 - combo box with drop down list attribute
                  Gtk - GtkOptionMenu

        cddl_colorData = pointer to an array of color values
        cddl_colorCount = number of items in the color array
        cddl_selIndex
                = this has the initial selection index.
                  On termination this always has the users selection.
                  The index is zero based, and MAX(CARDINAL) signifies no
                  selection.

    ComboBox
                  Win32 - ComboBox (simple or drop down)
                  Gtk - GtkCombo

        cb_text = Pointer to an array of null terminated strings terminated
                  by a null, meaning the end of the string has a double null.
        cb_max  = Maximum number of characters that edit portion will accept.
                  The cb_text buffer, if present, should be one character bigger
                  than the maximum allowable character count. This allows for
                  a null terminator.
        cb_selStr
                = Pointer to a string to hold the result as well as the
                  initial selection. The strings are not case sensitive.
                  On termination this string has the users selection.

    PushButton
                  Win32 - push button
                  Gtk - GtkButton

        buttonType = the type of button
                        CloseButton - the dialog is closed and data validation
                                          occurs.
                        CancelButton - the dialog is closed and data validation
                                          does not occur.
                        HelpButton - the Pressed notification is sent and data
                                          validation does not occur.
                        NotifyButton - the Pressed notification is sent and data
                                          validation occurs.
                        NotifyButtonNV - the Pressed notification is sent and data
                                          validation does not occur.

        returnValue = for CloseButton and CancelButton
                        the value to be returned by the dialog.

    UserData    = allows you to have some data attached to a dialog box
                  for access by the notify procedure

    Timer
                = the notify procedure will be called when the timerInterval
                  for this time has elapsed.

        id = A unique number to identify the timer. This number should be
             different for all possible timers in your program. This
             includes WinShell window timers.
        timerInterval = the timer interval in milliseconds. A value of
                        zero means the timer is not activated.

    IncDec
                = this control has up and down arrows to allow the user to
                  increment and decrement a numeric field.
                  Win32 - UpDown with autobuddy on an edit control
                  Gtk - GtkSpinButton

        incDec_Val = the numeric value.
        incDec_Min = the minimum value of the valid number range.
        incDec_Max = the maximum value of the valid number range.

    NumberEdit
                  Win32 - edit
                  Gtk - GtkEntry

        number_Val =  the initial and return value
        number_Min = the minimum value of the valid number range.
        number_Max = the maximum value of the valid number range.
        number_Hex = the number will be displayed in hexadecimal format
                     the user will be allowed to enter a number in hex
                     or decimal format
        number_msg = the string id number of the message displayed when
                     an invalid or out of range number is entered.
                     if 0, then a default message is displayed.
*)

    NotifyType   = (
                    Init, (* only dialogs *)
                    Destroy, (* only dialogs *)
                    ValueChanged, (* all that accept user input *)
                    LoseFocus, (* all *)
                    GainFocus, (* all *)
                    Validate, (* all that accept user input *)
                    SelectionChanged, (* all ListBoxes, DropDownLists, ComboBox *)
                    DoubleClicked, (* all ListBoxes *)
                    Pressed,  (* NotifyButton,
                                 CheckBox,
                                 RadioGroup *)
                    TimerElapsed, (* Timer *)
                    DialogModified, (* only dialogs *)
                    PageActivate,    (* only tabbed dialogs *)
                    PageDeactivate,  (* only tabbed dialogs *)
                    PageCancel,       (* only tabbed dialogs *)
                    ContextHelp(* all *)
                   );

(*
    ======= NotifyType =======

    Init
        The dialog is Initing and about to be displayed.

    Destroy
        The dialog is terminated. Do not access anything. Use this to
        free any memory or resources you may have allocated for the dialog.

    ValueChanged
        The text in a control has been changed.

    LoseFocus
        Input focus has been lost.

    GainFocus
        Input focus is now on the specified control.

    Validate
        The user is/has moved the input focus from one control to another.
        You can use this notification of validate the input of the current control.
        You can fail the validation and the input focus will be remain on
        the current control.

    SelectionChanged
        The selected item in a control has been changed.

    DoubleClicked
        An item in a control was double clicked.

    Pressed
        The button was pressed.

    TimerElapsed
        Self explanatory

    DialogModified
        Lets you know that the current dialog has been modified in some way.
        Very useful with tabbed dialogs. For tabbed dialogs each page will
        receive this message if something on that page has been altered.
        The dialog as a whole is considered altered if any single page has
        been altered.

    PageActivate
        For tabbed dialogs. Notifies you that the page is being activated.

    PageDeactivate
        For tabbed dialogs. Notifies you that the page is being deactivated.
        If you return ContinueDialog from this message the page will be
        allowed to deactivate. If you return DisallowPageDeactivate the
        page will remain the active page. For example you may want to
        validate some entry fields and disable switching/closing the current
        page until proper data has been entered.

    PageCancel
        For tabbed dialogs. The user has pressed the "cancel" button.
        All pages will receive this message when a tabbed dialog is being
        canceled. This will allow you to perform any necessary processing
        to satisfy "cancelling" the users modifications.

    ContextHelp
        Sent when context help was selected for the control but the control
        helpId value was 0.
*)

    PushButtonType = (
                      CloseButton,
                      CancelButton,
                      HelpButton,
                      NotifyButton,
                      NotifyButtonNV
                     );

    NotifyResult = (
                    ContinueDialog, (* means continue normally *)
                    TerminateDialog,(* the dialog is closed *)
                                    (* data fields will be validated *)
                                    (* this is considered a successfull *)
                                    (* dialog exit return *)
                    CancelDialog,(* the dialog is closed *)
                                 (* data fields will NOT be validated.
                                    this is considered a failed return.
                                 *)
                    DisallowPageDeactivate, (* use with tabbed dialogs *)
                    FailedValidation(*used with the Validate notify message*)
                   );

    NotifyProc  = PROCEDURE(
                            NotifyType, (* what happened *)
                            VAR INOUT CARDINAL
                                            (* on entry identifies the control
                                               associated with this notification.
                                               MAX(CARDINAL) signifies the
                                               entire dialog as the "control".

                                               See SetControlIdMode for a full
                                               description of how controls are
                                               identified.

                                               If you return TerminateDialog or
                                               CancelDialog,
                                               then assign the value you want the
                                               dialog call to return to this
                                               parameter. This only has
                                               meaning for modal dialogs.
                                            *)
                           ) : NotifyResult;

    DialogPositions     = (
                           NormalPosition, (* dialog resource position *)
                           CenterOnParent, (* center on parent window *)
                           CenterOnScreen  (* center on physical screen *)
                          );

    ColorValue  = WinShell.ColorValue;
    FontInfo    = WinShell.FontInfo;

    FontInfoPointer = POINTER TO FontInfo;

    StringData  = POINTER TO ARRAY [0..0] OF CHAR;

    TextAlignment = (AlignLeft, AlignCenter, AlignRight);

    ColumnInfo =
        RECORD
        width   : CARDINAL;
        align   : TextAlignment;
        header  : StringData;
        END;

    CONTROL     =
        RECORD
        id              : CARDINAL; (* the control identifier number *)
                                    (* For RadioGroup and Timer
                                       See the description of the control *)
                                    (* For DialogTitle and UserData this field
                                       has no meaning so just set it to zero *)
        helpId          : CARDINAL; (* context help id.
                                       this is the id number of a string resource entry.
                                       Use 0 for no help. In this case the Contexthelp
                                       notification is sent.

                                       On Win32 the standard dialog box context help
                                       mechanism is used. Your resource should have this
                                       dialog attribute.

                                       On Gtk no such mechanism exists so this module
                                       simulates it.

                                       For normal dialogs you should define a button
                                       with an id of 911 in the dialog. this module
                                       will treat that button as the initiator of the
                                       context help sequence. This button should NOT
                                       be listed in the control array. This module will
                                       replace the button label with a '?' icon.

                                       Tabbed dialogs simply look at the various controls
                                       in the dialog tabs and if any one of them has
                                       a non zero help id number then a context help
                                       button is added to the dialog. You do not need,
                                       and should not have, a 911 button defined
                                       in the dialog resource(s).

                                       As a convenience on these controls

                                       RadioGroup,
                                       LineEdit, MultiLineEdit, NumberEdit,
                                       ListBox, ColumnListBox
                                       ComboBox, DropDownList, ColorDropDownList

                                       the id number 1 less than the control(s) id
                                       is assumed to be a label/frame for the control,
                                       *unless* a specific control exists with that
                                       id number in the control array.
                                       This "label" will also get the help text
                                       of the control if the user asks for context
                                       help on this item.
                                       *)

        CASE ct : ControlType OF
        PushButton:
            buttonType          : PushButtonType;
            returnValue         : CARDINAL;
        |
        RadioGroup:
            r_first             : CARDINAL;
            r_last              : CARDINAL;
        |
        CheckBox:
            on                  : BOOLEAN;
        |
        LineEdit:
            le_text             : StringData;
            le_max              : CARDINAL;
        |
        MultiLineEdit:
            mle_text            : StringData;
            mle_max             : CARDINAL;
        |
        EditTextFile:
            etf_name            : StringData;
            etf_altered         : BOOLEAN;
        |
        StaticText:
            st_text             : StringData;
        |
        StaticTextAttrib:
            sta_text            : StringData;
            sta_fore            : ColorValue;
            sta_back            : ColorValue;
            sta_font            : FontInfoPointer;
        |
        ListBox:
            lb_text             : StringData;
            lb_selStr           : StringData;
            lb_selIndex         : CARDINAL;
        |
        ColumnListBox:
            clb_columns         : CARDINAL;
            clb_columnInfo      : POINTER TO ARRAY [0..0] OF ColumnInfo;
            clb_selStr          : StringData;
            clb_selIndex        : CARDINAL;
        |
        DropDownList:
            ddl_text            : StringData;
            ddl_selIndex        : CARDINAL;
        |
        ColorDropDownList:
            cddl_colorData      : POINTER TO ARRAY [0..0] OF ColorValue;
            cddl_colorCount     : CARDINAL;
            cddl_selIndex       : CARDINAL;
            cddl_palette        : WinShell.PaletteHandle;
        |
        ComboBox:
            cb_text             : StringData;
            cb_selStr           : StringData;
            cb_max              : CARDINAL;
        |
        IncDec:
            incDec_Val          : INTEGER;
            incDec_Min          : INTEGER;
            incDec_Max          : INTEGER;
        |
        NumberEdit:
            number_Val          : INTEGER;
            number_Min          : INTEGER;
            number_Max          : INTEGER;
            number_Msg          : CARDINAL;
            number_Hex          : BOOLEAN;
        |
        Timer:
            timerInterval       : CARDINAL;
        |
        DialogTitle:
            dlgTitle            : StringData;
        |
        UserData:
            userData            : ADDRESS;
        ELSE
        END;
    END;

    ControlsPointer     = POINTER TO ARRAY [0..0] OF CONTROL;
    PAGE =
        RECORD
        controls        : ControlsPointer;
        numControls     : CARDINAL;
        notify          : NotifyProc;
        name            : StringData;(*dialog resource*)
        title           : StringData;(*tab text, NIL to use the dialog resource
                                       title.
                                     *)
        END;

    DialogSizes = (NormalDialog, LargeDialog, ExtraLargeDialog);
    (* Win32
       this changes the size of the font used in a dialog. on Win32 this effectively
       makes the controls and thus the dialog larger. rememeber that dialog sizes are
       based on dialog units, which are based on the font used for a dialog.
       Large = +2 points, ExtraLarge = +4 points
       if the dialog resource used an 8pt font then, Large=10, ExtraLarge=12.

       GTK
       currently ignored.
    *)

    ControlIdModes = (ControlSubscript, ControlId);

VAR
    DialogSize  : DialogSizes;

PROCEDURE GetDialogParent() : Window;
(* a utility function to return the current foreground window, or
   the current modal dialog for use as a parent for a dialog.
   If the current foreground window is NIL then the value
   of WinShell.MainWindow is used.
*)

PROCEDURE SetControlIdMode(mode : ControlIdModes);
(*
  set how this module identifies individual controls.
  ControlIdSubscript
      Controls are identiifed by their control array subscript position, zero based.
      This is the original DlgShell mode and is the default mode at startup.
  ControlId
      Controls are identified by their id value.
      RadioGroups are identified by the id number, r_first.
      If you are using symbolic constants for your control ids then this
      mode is probably preferable.
*)

PROCEDURE CallDialog(parent : Window;
                     name : ARRAY OF CHAR;
                     VAR INOUT ctrls : ARRAY OF CONTROL;
                     notify : NotifyProc;
                     position : DialogPositions) : CARDINAL;
(*
   opens a modal dialog.
   The dialog is a named resource and the name is specified in the name parameter.

       Gtk - The dialog window should not have the visible attribute. This
             module will show the dialog once the controls and dialog are
             fully initialized.

   parent = the parent window of the dialog.
   ctrls = the controls in the dialog. This need not be all of the controls
           in the dialog resource but those controls that you need to
           perform some processing action with. For example a dialog may
           have many static text controls and if you have no need to change
           the text of these controls you need NOT specify them in the
           controls array.
           How controls are identified in the Notify procedure and in the API calls
           of this module depends on the control id mode.
           See SetControlIdMode.
   notify = the call back procedure. Pass NIL_NOTIFY if you have no
            need for a call back procedure. This is quite common.
            You generally only need a notification procedure if you need to
            validate data or perform other processing. You do not need
            a notification procedure to initialize the controls with
            information or to retrieve the information the user has entered.
            Mechanisms are in place to handle this without a call back
            notification procedure. However many times it is easier to fill
            a list box without generating the data structure to automatically
            fill the list and in this case you would "initialize" the
            list with NIL and then use API calls to add items to the list.
            Multi line edit controls are also probably easier to deal with
            using API calls rather than the control data structures. These
            are two examples of choices you will need to make in developing
            your dialog boxes.
   position = Allows you to specify where on the screen the dialog is displayed.
*)

PROCEDURE ModelessDialog(parent : Window;
                         name : ARRAY OF CHAR;
                         VAR INOUT ctrls : ARRAY OF CONTROL;
                         notify : NotifyProc;
                         position : DialogPositions) : CARDINAL;
(*
   opens a modeless dialog. The dialog is a named resource and the name
   is specified in the name parameter.
   The return value identifies the dialog for use in the various
   API calls provided in this module. Many times you may not need to save
   this value since while processing a notify message you are the current
   dialog, and if the modeless dialog terminates itself then you do not need
   the value to close the dialog.
   See CallDialog
*)

PROCEDURE CallTabbedDialog(parent : Window;
                           title : ARRAY OF CHAR;
                           VAR INOUT pages : ARRAY OF PAGE;
                           position : DialogPositions) : CARDINAL;
(*
   opens a modal "tabbed" dialog.
   Win32 - A property sheet is created.
   Gtk - a Window with a notebook widget is created.

   title = the dialog title. Null terminated
   pages = the list of "sub dialogs"/pages/tabs.

    controls = this is the same as the ARRAY OF CONTROL parameter
               in CallDialogByName.
    numControls = the number of controls in the controls array.
    notify = Same as the notify parameter in CallDialogByName
    name  = specifies the name of the dialog resource for this
            page of the tabbed dialog.
    title = the text of the tab. NIL if you want ot use the dialog resource
            title (the caption text of the source).

    Win32.
        Dialog resources should be marked with the PropertySheet and Child
        attributes.
    Gtk
        Dialog resources should be windows without the visible attribute.
        The container in the dialog must be named "mainbox". It does not
        matter what type of container it is. This module extracts the
        container from the dialog window and places it into the notebook
        page(s).

    You can use the same notify procedure for all pages in the dialog.
    If this is the case you may need to inquire about the current page.

   See CallDialog
*)

(*  --------------------------------------------------------------------*)
(*  --------------------------------------------------------------------*)
(*  --------------------------------------------------------------------*)

(*
   most of the following API procedures have two versions of the same
   procedure. One procedure explicitly takes the dialog number and the
   other assumes the current dialog.

   When you receive a notify message your dialog is the current dialog and you
   can use those API procedures assuming the current dialog.
   This is true for modal and modeless dialogs.

   To access a modeless dialog, outside of a notification you will need to use
   the dialog number APIs.

   For modal dialogs you NEVER know what the dialog number is unless you
   call GetDialogNumber() while you are the current dialog, and why bother
   doing such a thing.
*)

PROCEDURE ShowDialog(dlgNum : CARDINAL; yes : BOOLEAN);
(*
   If yes = TRUE then the dialog will be visible, otherwise the dialog
   will be invisible. This makes no sense for modal dialogs.
*)

PROCEDURE CloseDialog(dlgNum : CARDINAL; cancel : BOOLEAN);
(*
   close the dialog specified by dlgNum. Only use this with modeless dialogs
   remember that a dialog can terminate itself by simply returning
   TerminateDialog or CancelDialog from its notify procedure
*)

PROCEDURE GetDialogNumber() : CARDINAL;
(*   get the dialog number for the current dialog
*)

PROCEDURE GetActivePage() : CARDINAL;
(*
   For tabbed dialogs only
   get the currently active page number for the currently active dialog
   page numbers are zero based.
*)

PROCEDURE SetActivePage(page : CARDINAL);
(*
   For tabbed dialogs only
   set the active page of the current dialog
*)

PROCEDURE GetUserDataDlg(dlgNum : CARDINAL) : ADDRESS;
PROCEDURE GetUserData() : ADDRESS;
(*
   dlgNum specifies the dialog
   get the user data attached to the dialog.
   for tabbed dialogs operates on the current page only
*)

PROCEDURE PositionDialogDlg(dlgNum : CARDINAL; pos : DialogPositions);
PROCEDURE PositionDialog(pos : DialogPositions);
(*
   dlgNum specifies the dialog
   reposition the dialog on the screen using the pos parameter
*)

PROCEDURE GetDialogSizeDlg(dlgNum : CARDINAL; VAR OUT x, y : COORDINATE);
PROCEDURE GetDialogSize(VAR OUT x, y : COORDINATE);
(*
   dlgNum specifies the dialog
   get the size of the dialog in screen pixels
   x = width, y = height
*)

PROCEDURE GetDefaultButtonDlg(dlgNum : CARDINAL) : CARDINAL;
PROCEDURE GetDefaultButton() : CARDINAL;
(*
   dlgNum specifies the dialog
   get the button control that is the current default button
*)

PROCEDURE SetDefaultButtonDlg(dlgNum : CARDINAL; control : CARDINAL);
PROCEDURE SetDefaultButton(control : CARDINAL);
(*
   dlgNum specifies the dialog
   set the default button to the control.
*)

PROCEDURE SetPaintDlg(dlgNum : CARDINAL; control : CARDINAL; on : BOOLEAN);
PROCEDURE SetPaint(control : CARDINAL; on : BOOLEAN);
(*
   dlgNum specifies the dialog
   If on = TRUE then the control will repaint itself
   when necessary, otherwise it will not repaint itself until paint is
   turned on for this control. An example of using this would be loading
   a listbox control. It is senseless to have a list box repaint itself
   after each item you add until you have added all items to the list box.
*)

PROCEDURE SetEnableDlg(dlgNum : CARDINAL;
                       control : CARDINAL;
                       enabled : BOOLEAN);
PROCEDURE SetEnable(control : CARDINAL; enabled : BOOLEAN);
(*
   dlgNum specifies the dialog
   If enabled = TRUE the control will be enabled thus
   allowing the user to interact with the control, otherwise the control
   will be disabled or "grayed out"
   If this is used on a RadioGroup all radio buttons in the group will be
   disabled.
*)

PROCEDURE SetEnableRangeDlg(dlgNum : CARDINAL;
                            first, last : CARDINAL;
                            enabled : BOOLEAN);
PROCEDURE SetEnableRange(first, last : CARDINAL; enabled : BOOLEAN);
(*
  as SetEnable, except all controls from first..last are acted upon
*)

PROCEDURE SetEnableRadioDlg(dlgNum : CARDINAL;
                            control, item : CARDINAL;
                            enabled : BOOLEAN);
PROCEDURE SetEnableRadio(control, item : CARDINAL; enabled : BOOLEAN);
(*
   dlgNum specifies the dialog
   If enabled = TRUE the radio group i'th item identified
   by item will be enabled thus allowing the user to interact with the control,
   otherwise the item will be disabled or "grayed out"
*)

PROCEDURE SetVisibleDlg(dlgNum : CARDINAL;
                        control : CARDINAL;
                        visible : BOOLEAN);
PROCEDURE SetVisible(control : CARDINAL; visible : BOOLEAN);
(*
   dlgNum specifies the dialog
   If visible = TRUE the control will be visible thus
   allowing the user to interact with the control, otherwise the control
   will not be visible and thus not available to the user
   If this is used on a RadioGroup all radio buttons in the group will be
   invisible.
*)

PROCEDURE SetVisibleRadioDlg(dlgNum : CARDINAL;
                             control, item : CARDINAL;
                             visible : BOOLEAN);
PROCEDURE SetVisibleRadio(control, item : CARDINAL; visible : BOOLEAN);
(*
   dlgNum specifies the dialog
   If visible = TRUE the radio group i'th item identified by item will be visible thus
   allowing the user to interact with the control,
   otherwise the item will be invisible.
*)

PROCEDURE SetColorAndFontDlg(dlgNum : CARDINAL;
                      control : CARDINAL;
                      fore, back : ColorValue;
                      font : FontInfoPointer);
PROCEDURE SetColorAndFont(control : CARDINAL;
                          fore, back : ColorValue;
                          font : FontInfoPointer);
(*
   dlgNum specifies the dialog
   set the color and font of the control.
   font can be NIL if you do not want to set the font.

   currently can only be used with StaticTextAttrib controls
*)

PROCEDURE SetInputFocusToDlg(dlgNum : CARDINAL; control : CARDINAL);
PROCEDURE SetInputFocusTo(control : CARDINAL);
(*
   dlgNum specifies the dialog
   set the keyboard input focus to the specified control.
*)

PROCEDURE GetInputFocusControlDlg(dlgNum : CARDINAL) : CARDINAL;
PROCEDURE GetInputFocusControl() : CARDINAL;
(*
  return the control that currently has the input focus.
*)

PROCEDURE SetupStringMatchDlg(dlgNum : CARDINAL;
                              control : CARDINAL;
                              startPos : CARDINAL;
                              column : CARDINAL);
PROCEDURE SetupStringMatch(control : CARDINAL;
                           startPos : CARDINAL;
                           column : CARDINAL);
(*
   For ListBox, ColumnListBox.
   this sets up the ability of the list box to perform a full text
   search. The list box will automatically select the first item in the
   list that matches the text entered. When the spacebar is pressed the
   match string is reset and cleared.

   startPos = the string character position to start the comparison.
   column = if ColumnListBox, the column to compare.
*)

PROCEDURE ClearMatchBufferDlg(dlgNum : CARDINAL; control : CARDINAL);
PROCEDURE ClearMatchBuffer(control : CARDINAL);
(*
   clear the match buffer. This is the keystrokes that the user may have
   entered during ASCII matching. You could use this after reloading a list box
   with new data, so the match is not in the middle of some previous match search.
*)

PROCEDURE SetCheckBoxDlg(dlgNum : CARDINAL; control : CARDINAL; on : BOOLEAN);
PROCEDURE SetCheckBox(control : CARDINAL; on : BOOLEAN);
(*
   dlgNum specifies the dialog
   set the check box state of the check box control.
   on = TRUE = the check box will be "checked"
*)

PROCEDURE GetCheckBoxDlg(dlgNum : CARDINAL; control : CARDINAL) : BOOLEAN;
PROCEDURE GetCheckBox(control : CARDINAL) : BOOLEAN;
(*
   dlgNum specifies the dialog
   get the check box state of the check box control.
   returns TRUE when the check box is "checked"
*)

PROCEDURE SetRadioGroupDlg(dlgNum : CARDINAL;
                           control, item : CARDINAL);
PROCEDURE SetRadioGroup(control, item : CARDINAL);
(*
   dlgNum specifies the dialog
   set the selected/checked radio group item identified by item in the
   radio group control.
   The item will become the checked radio group item. If another item in the
   group is currently checked, it will be unchecked in favor of the new item
*)

PROCEDURE GetRadioGroupDlg(dlgNum : CARDINAL; control : CARDINAL) : CARDINAL;
PROCEDURE GetRadioGroup(control : CARDINAL) : CARDINAL;
(*
   dlgNum specifies the dialog
   get the checked item in the radio group.
*)

PROCEDURE SetRadioTextDlg(dlgNum : CARDINAL;
                          control, item : CARDINAL;
                          text : ARRAY OF CHAR);
PROCEDURE SetRadioText(control, item : CARDINAL; text : ARRAY OF CHAR);
(*
   dlgNum specifies the dialog
   set the text of a radio group item identified by item with the
   new text in the parameter text (null terminated).
*)

PROCEDURE GetRadioTextDlg(dlgNum : CARDINAL;
                          control, item : CARDINAL;
                          VAR OUT text : ARRAY OF CHAR);
PROCEDURE GetRadioText(control, item : CARDINAL; VAR OUT text : ARRAY OF CHAR);
(*
   dlgNum specifies the dialog
   get the text of a radio group item identified by item
   return the text in the text parameter
*)

PROCEDURE SetTimerIntervalDlg(dlgNum : CARDINAL;
                              control : CARDINAL;
                              time : CARDINAL);
PROCEDURE SetTimerInterval(control : CARDINAL; time : CARDINAL);
(*
   dlgNum specifies the dialog
   set the interval of the timer notifications in time. time is specified
   in milliseconds. The interval notifications are only approximate.
   If a value of zero is passed for the interval, the timer is disabled and
   you will receive no further timer notifications until the timer is again
   activated
*)

PROCEDURE SetTextDlg(dlgNum : CARDINAL;
                     control : CARDINAL;
                     text : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE SetText(control : CARDINAL; text : ARRAY OF CHAR) : BOOLEAN;
(*
   dlgNum specifies the dialog
   set the text of the control.
   the text parameter must be null terminated.
   the following controls have a special meaning for SetText
   RadioGroup use SetRadioText
   ListBox the effect is to select the list box item that matches the text parameter.
   ColumnListBox, the same effect as ListBox, the match is done to column 0.

   for TermButton, NotifyButton, CheckBox you can apply an accelerator
   in the label text. the underscore character '_' signifies that the
   following chracter should be an accelerator key for the button.

   returns TRUE is successful
*)

PROCEDURE GetTextDlg(dlgNum : CARDINAL;
                     control : CARDINAL;
                     VAR OUT text : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE GetText(control : CARDINAL; VAR OUT text : ARRAY OF CHAR) : BOOLEAN;
(*
   dlgNum specifies the dialog
   get the text of the control.
   RadioGroup use GetRadioText
   ListBox the effect is to fetch the text of the selected item in the list box.
   ColumnListBox as ListBox. Column 0 is used.
   returns TRUE is successful
*)

PROCEDURE SetNumericValueDlg(dlgNum : CARDINAL;
                             control : CARDINAL;
                             value : INTEGER) : BOOLEAN;
PROCEDURE SetNumericValue(control : CARDINAL; value : INTEGER) : BOOLEAN;
(* see the text of the control to the string representation of
   the passed numeric value.
   Any control that displays text can use this call.
   Also sets IncDec controls.
*)

PROCEDURE GetIncDecValueDlg(dlgNum : CARDINAL;
                            control : CARDINAL) : INTEGER;
PROCEDURE GetIncDecValue(control : CARDINAL) : INTEGER;
(*
   dlgNum specifies the dialog
   get the numeric value of the IncDec control.
   if the control is not an IncDec control MIN(INTEGER) is returned.
*)

PROCEDURE SetTextSelectionDlg(dlgNum : CARDINAL;
                              control : CARDINAL;
                              startPos, endPos : CARDINAL) : BOOLEAN;
PROCEDURE SetTextSelection(control : CARDINAL;
                           startPos, endPos : CARDINAL) : BOOLEAN;
(*
   dlgNum specifies the dialog
   set the text selection in a LineEdit, MultiLineEdit or ComboBox control.
   startPos and endPos are zero based and specify the starting and
   ending character position to the selection.
   use MAX(CARDINAL) for endPos to select all text from startPos
   to the end of the buffer.
*)

PROCEDURE ClearTextSelectionDlg(dlgNum : CARDINAL; control : CARDINAL);
PROCEDURE ClearTextSelection(control : CARDINAL);
(*
   dlgNum specifies the dialog
   clear any text section in a LineEdit, MultiLineEdit or ComboBox control.
*)

PROCEDURE GetItemCountDlg(dlgNum : CARDINAL; control : CARDINAL) : CARDINAL;
PROCEDURE GetItemCount(control : CARDINAL) : CARDINAL;
(*
   dlgNum specifies the dialog
   For all ListBox(s) and DropDownList(s) and ComboBox(s)
   returns the number of items in the list
   this result can be zero
*)

PROCEDURE GetSelectedDlg(dlgNum : CARDINAL; control : CARDINAL) : CARDINAL;
PROCEDURE GetSelected(control : CARDINAL) : CARDINAL;
(*
   dlgNum specifies the dialog
   For all ListBox(s), DropDownList(s) and ComboBox(s)
   returns the number of the selected item in the list.
   MAX(CARDINAL) signifies no selection.
*)

PROCEDURE SetSelectedDlg(dlgNum : CARDINAL;
                         control : CARDINAL;
                         sel : CARDINAL) : BOOLEAN;
PROCEDURE SetSelected(control : CARDINAL; sel : CARDINAL) : BOOLEAN;
(*
   dlgNum specifies the dialog
   For all ListBox(s), DropDownList(s), ComboBox(s)
   set the selected item in the control.
   MAX(CARDINAL) signifies no selection.
   returns TRUE if successful
*)

PROCEDURE AppendItemDlg(dlgNum : CARDINAL;
                        control : CARDINAL;
                        str : ARRAY OF CHAR) : INTEGER;
PROCEDURE AppendItem(control : CARDINAL; str : ARRAY OF CHAR) : INTEGER;
(*
   dlgNum specifies the dialog
   For ListBox, DropDownList and ComboBox
   add a new item at the end of the list of items in the control.
   returns the item number if successful, otherwise -1
   NOTE: If the control is an operating system sorted control then
   you do not know where in the list (ordinal position) the item exists
   after you add or delete another item. See SetItemData
*)

PROCEDURE ChangeItemDlg(dlgNum : CARDINAL;
                        control : CARDINAL;
                        item : CARDINAL;
                        str : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE ChangeItem(control : CARDINAL;
                     item : CARDINAL;
                     str : ARRAY OF CHAR) : BOOLEAN;
(*
   dlgNum specifies the dialog
   For ListBox, DropDownList and ComboBox
   change the text of a specific item in the list identified by item
   str must be null terminated
   returns TRUE if successful
*)

PROCEDURE RemoveItemDlg(dlgNum : CARDINAL; control : CARDINAL; item : CARDINAL);
PROCEDURE RemoveItem(control : CARDINAL; item : CARDINAL);
(*
   dlgNum specifies the dialog
   For ListBox, DropDownList, and ComboBox
   remove a specific item in the list identified by item
   items after this one in the list will of course be identified differently
   after this call
*)

PROCEDURE RemoveAllItemsDlg(dlgNum : CARDINAL; control : CARDINAL);
PROCEDURE RemoveAllItems(control : CARDINAL);
(*
   dlgNum specifies the dialog
   For all ListBox(s), DropDownList(s) and ComboBox(s)
   remove all items in the list leaving an empty list
*)

PROCEDURE SetItemDataDlg(dlgNum : CARDINAL;
                         control : CARDINAL;
                         item : CARDINAL;
                         data : DWORD);
PROCEDURE SetItemData(control : CARDINAL; item : CARDINAL; data : DWORD);
(*
   dlgNum specifies the dialog
   item identifies an already existing list item
   For all ListBox, ColumnListBox.
   You can attach a specific piece of data to each list item
   you might use this to identify a list item which you will need
   if the control is sorted
*)

PROCEDURE GetItemDataDlg(dlgNum : CARDINAL;
                         control : CARDINAL;
                         item : CARDINAL;
                         VAR OUT data : DWORD);
PROCEDURE GetItemData(control : CARDINAL; item : CARDINAL; VAR OUT data : DWORD);
(*
   dlgNum specifies the dialog
   item identifies an already existing list item
   For all ListBox, ColumnListBox
   get the user data associated with the list item
*)

PROCEDURE AppendItemColumnsDlg(dlgNum : CARDINAL;
                               control : CARDINAL;
                               strs : ARRAY OF StringData) : INTEGER;
PROCEDURE AppendItemColumns(control : CARDINAL;
                            strs : ARRAY OF StringData) : INTEGER;
(*
   dlgNum specifies the dialog
   For ColumnListBox
   add a new list item at the end of the list
   strs must have the same number of elements are there are columns in
   the control.

   returns the item number if successful, otherwise -1
*)

PROCEDURE SetColumnTextDlg(dlgNum : CARDINAL;
                           control : CARDINAL;
                           item : CARDINAL;
                           column : CARDINAL;
                           text : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE SetColumnText(control : CARDINAL;
                        item : CARDINAL;
                        column : CARDINAL;
                        text : ARRAY OF CHAR) : BOOLEAN;
(*
   For ColumnListBox
   dlgNum specifies the dialog
   set the text of the specified column of the control.
   the text parameter must be null terminated.
   item is the item in the list. (returned by AppendItem)
   column is the column number to set the text
   returns TRUE is successful
*)

PROCEDURE GetColumnWidthDlg(dlgNum : CARDINAL;
                            control : CARDINAL;
                            column : CARDINAL) : CARDINAL;
PROCEDURE GetColumnWidth(control : CARDINAL; column : CARDINAL) : CARDINAL;
(*
  For ColumnListBox
  return the current width, in pixels, of the specified column
*)

PROCEDURE GetOptimalColumnWidthDlg(dlgNum : CARDINAL;
                                   control : CARDINAL;
                                   column : CARDINAL) : CARDINAL;
PROCEDURE GetOptimalColumnWidth(control : CARDINAL;
                                column : CARDINAL) : CARDINAL;
(*
  For ColumnListBox
  return the optimal width, in pixels, of the specified column.
  the optimial width is usch that the column width is enough to display
  the longest string in the column. The column header, if any, is also
  considered in the computation.
*)

PROCEDURE SetColumnWidthDlg(dlgNum : CARDINAL;
                            control : CARDINAL;
                            column : CARDINAL;
                            width : CARDINAL);
PROCEDURE SetColumnWidth(control : CARDINAL;
                         column : CARDINAL;
                         width : CARDINAL);
(*
  For ColumnListBox
  set the width, in pixels, for the specified column
*)

PROCEDURE SetColumnWidthOptimalDlg(dlgNum : CARDINAL;
                                   control : CARDINAL;
                                   column : INTEGER);
PROCEDURE SetColumnWidthOptimal(control : CARDINAL; column : INTEGER);
(*
  For ColumnListBox
  set the column width to the optimal width for the specified column.
  the optimial width is such that the column width is enough to display
  the longest string in the column. The column header, if any, is also
  considered in the computation.

  if column < 0 then call columns in the list are adjusted.
*)

PROCEDURE MleGetCharCountDlg(dlgNum : CARDINAL; control : CARDINAL) : CARDINAL;
PROCEDURE MleGetCharCount(control : CARDINAL) : CARDINAL;
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   get the number of characters contained in the edit control. This includes
   any carriage returns, line feed pairs
   the lines in the edit control text are delimited by these characters
*)

PROCEDURE MleAppendDlg(dlgNum : CARDINAL;
                       control : CARDINAL;
                       text : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE MleAppend(control : CARDINAL; text : ARRAY OF CHAR) : BOOLEAN;
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   append text to the end of the text in the edit control
   text must be null terminated
   RETURNs TRUE is successful
*)

PROCEDURE MleAppendLineDlg(dlgNum : CARDINAL;
                           control : CARDINAL;
                           text : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE MleAppendLine(control : CARDINAL; text : ARRAY OF CHAR) : BOOLEAN;
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   like MlAppendDlg but also appends a line terminator in addition
   to the text
   text must be null terminated
   RETURNs TRUE is successful
*)

PROCEDURE MleGetLineCountDlg(dlgNum : CARDINAL; control : CARDINAL) : CARDINAL;
PROCEDURE MleGetLineCount(control : CARDINAL) : CARDINAL;
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   get the count of the number of lines of text in the edit control
*)

PROCEDURE MleGetLineLengthDlg(dlgNum : CARDINAL;
                              control : CARDINAL;
                              line : CARDINAL) : CARDINAL;
PROCEDURE MleGetLineLength(control : CARDINAL; line : CARDINAL) : CARDINAL;
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   get the length of the line identified by line.
   line is 1 based.
   a line can have a zero length
*)

PROCEDURE MleGetLineDlg(dlgNum : CARDINAL;
                        control : CARDINAL;
                        line : CARDINAL;
                        VAR OUT text : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE MleGetLine(control : CARDINAL;
                     line : CARDINAL;
                     VAR OUT text : ARRAY OF CHAR) : BOOLEAN;
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   fetch the text of the line identified by line into text
   line is 1 based.
   returns TRUE if successful
*)

PROCEDURE MleRemoveLineDlg(dlgNum : CARDINAL;
                           control : CARDINAL;
                           line : CARDINAL);
PROCEDURE MleRemoveLine(control : CARDINAL; line : CARDINAL);
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   delete all of the text and line terminator of the line
   identified by line.
   line is 1 based.
*)

PROCEDURE MleAppendToLineDlg(dlgNum : CARDINAL;
                             control : CARDINAL;
                             line : CARDINAL;
                             text : ARRAY OF CHAR);
PROCEDURE MleAppendToLine(control : CARDINAL;
                          line : CARDINAL;
                          text : ARRAY OF CHAR);
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   append the text in text to the end of the line identified by line.
   line is 1 based.
*)

PROCEDURE MlePositionToBottomDlg(dlgNum : CARDINAL; control : CARDINAL);
PROCEDURE MlePositionToBottom(control : CARDINAL);
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   position the text caret location to be visible at the bottom of the
   edit control.
*)

PROCEDURE SaveTextFileDlg(dlgNum : CARDINAL; control : CARDINAL);
PROCEDURE SaveTextFile(control : CARDINAL);
(*
  For ExitTextFile
  Save the text file to disk
*)

PROCEDURE NIL_NOTIFY(n : NotifyType; VAR INOUT item : CARDINAL) : NotifyResult;
(*   dummy notify procedure *)

(*
   The following two procedures are useful for maintaining lists of items
   for DropDownLists, combo boxes and list boxes.
   You use a special character to separate
   the list items from each other and before assigning the string to
   the dialog control call ConvertToNulls to change the special character
   to a null character. As long as the string parameter passed is already
   null terminated you then have a proper "list" to assigning to list boxes
   a combo boxes for automatic initialization by DlgShell
   ConvertFromNulls can revert your string back its previous state if
   this is necessary.
*)

PROCEDURE ConvertToNulls(ch : CHAR; VAR INOUT str : ARRAY OF CHAR);

PROCEDURE ConvertFromNulls(ch : CHAR; VAR INOUT str : ARRAY OF CHAR);

PROCEDURE GetNthString(list : ARRAY OF CHAR;
                       listSep : CHAR;
                       VAR OUT str : ARRAY OF CHAR;
                       n : CARDINAL);
(*
   use this procedure to fetch the i'th string from the list
   list = the list of items
   sep = the character that separates the list items
   str = the returned string. Will be "" if not i'th item does not exist
   n = the item to fetch
   items are numbered starting at zero
*)

PROCEDURE GetNthFromList(list : ARRAY OF CHAR;
                         listSep : CHAR;
                         str : ARRAY OF CHAR;
                         VAR OUT n : CARDINAL);
(*
   use this procedure to find the number position of the item in the list
   items are numbered starting at zero
   list = the list of items
   sep = the character that separates the list items
   str = the string to match in list. The match is not case sensitive
   n = the returned item number. MAX(CARDINAL) = not found
*)

PROCEDURE GetDlgWindowDlg(dlgNum : CARDINAL) : ADDRESS;
PROCEDURE GetDlgWindow() : ADDRESS;
(*
   dlgNum specifies the dialog
   returns the dialog box operating system specific window handle
*)

END DlgShell.

DEFINITION MODULE TextWindows;
(* this module is its own self contained system built on top of WinShell *)
(* for convenience  this module re-exports most WinShell symbols by the *)
(* same name as they exist in WinShell *)
(* this module provides for very high level windows that display text *)
(* within their client area *)
(* this module fully automates painting and scroll bars for text windows *)
(* manual control is available for applications where automatic control *)
(* is not suitable *)

(*
   For automatic control this module defines a virtual coordinate system.
   For the purposes of this description we will use the analogy of a text
   editor, something you should be familiar with. Also we will only discuss
   the Y or vertical coordinate. The width or X coordinate operates precisely
   the same way as the Y.
   We have a text editor using this module. We open a file with 5000 lines
   of text. Also assume that the window is sized such that 25 lines of text
   can be displayed. Our virtual coordinate range for this file is 0..5000.
   We set a virtual coordinate range by using the SetScrollRangeAllowed
   API procedure.
   Zero always exists because of the possibility of an empty file.
   With this module our text editor never knows what exactly is being
   displayed in the window or exactly where the text caret(cursor) is
   positioned. It can inquire about this but there is no need.
   When open the file and put the text caret at position 1, 1.
   When we first open the file we will receive a paint message for coordinates
   1..25. If the user scrolls the window down one line we will get a paint
   message for coordinate 26. You should get the idea what is going on here.
   The text caret is still at position 1, 1 which is no longer visible in the
   window since the user scrolled the window down one line and the window
   is now displaying the coordinates 2..26.
   Lets say the user performed a text search and we need to display the
   matched text to the user. We simply set the text caret position to the
   proper virtual coordinate lets say line 2000, column 1 and then tell
   the text window system  to make sure the text caret is visible the
   window. That will cause the window to scroll to the proper virtual
   coordinates and you will receive a paint message for the coordinates
   2000..2025.
   The basic point here is that once a virtual coordinate is set up the
   text window asks you to paint certain coordinates, and it worries about
   what and where that information is displayed in the window. You have
   available to you certain API calls to make a given coordinate/range visible
   within the window if/when necessary. The chain of command here is
   the user tells the text window what to do
       the text window tells you what to do
*)
(*
  this module operates with three coordinate systems overlaid on top of
  each other.
  Virtual space >= Screen buffer space >= Visible window space
  this module maintains a "screen buffer" for each window to hold any text
  painted to minimize paint requests to your code when the operating system
  is asking the window to paint. this screen buffer can be a fixed size or
  it can assume whatever size fits within the visible area of the window.
  if the screen buffer is variable in size then in essence you fold down to
  two coordinate systems since the screen buffer and window are exactly the
  same size and at the same position.
  You only need to worry about the virtual coordinate space, but you should
  know something about the others to use a few of the API calls in this module.
  The screen buffer is basically a sliding window into the virtual coordinate
  space. The Visible window is a sliding window into the screen buffer
  coordinate space.

  If manual scrolling is used then these coordinate spaces have no real
  meaning since nothing ever moves in the coordinate space. You are always
  at the bottom of the coordinate space. You have to maintain your own
  information about where you are currently displaying in your "document".
*)

<*/NOPACK*>
%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

FROM SYSTEM IMPORT
    ADDRESS, CAST;

IMPORT WinShell;

TYPE
    (* text windows simply re-exports WinShell types and constants *)
    (* for convenience *)

    COORDINATE          = WinShell.COORDINATE;
    twPOINT             = WinShell.wsPOINT;
    twRECT              = WinShell.wsRECT;
    KeyStateType        = WinShell.KeyStateType;
    KeyStateSet         = WinShell.KeyStateSet;
    CloseModes          = WinShell.CloseModes;
    MouseButton         = WinShell.MouseButton;
    MouseEventType      = WinShell.MouseEventType;
    MouseStateType      = WinShell.MouseStateType;
    MouseStateSet       = WinShell.MouseStateSet;
    ScrollDirection     = WinShell.ScrollDirection;
    ScrollClass         = WinShell.ScrollClass;

    ScrollRange         = COORDINATE[0..MAX(COORDINATE)];

    SizeType            = WinShell.SizeType;
    WinAttr             = WinShell.WinAttr;
    WinAttrSet          = WinShell.WinAttrSet;

CONST
    TOOLBAR_SEPARATOR   = WinShell.TOOLBAR_SEPARATOR;

TYPE
    StdToolbarBitmaps   = WinShell.StdToolbarBitmaps;
    ToolbarButtonTypes  = WinShell.ToolbarButtonTypes;
    ToolbarButtonInfo   = WinShell.ToolbarButtonInfo;

    SpecialKeys         = WinShell.SpecialKeys;
    ResponseType        = WinShell.ResponseType;

    ClipboardFormat     = WinShell.ClipboardFormat;
    HelpCommand         = WinShell.HelpCommand;
    MenuHandle          = WinShell.MenuHandle;
    PaletteHandle       = WinShell.PaletteHandle;
    FontInfo            = WinShell.FontInfo;
    FontWeights         = WinShell.FontWeights;
    CharacterSets       = WinShell.CharacterSets;
    PrintDriverInfo     = WinShell.PrintDriverInfo;

    CursorTypes         = WinShell.CursorTypes;
    CaretTypes          = WinShell.CaretTypes;
    DisplayModes        = WinShell.DisplayModes;
    Beeps               = WinShell.Beeps;
    WindowDisplayInfo   = WinShell.WindowDisplayInfo;

CONST
    NormalWindow        = WinShell.NormalWindow;
    NormalMdiChildWindow= WinShell.NormalMdiChildWindow;

    AddVScrollBar       = WinAttrSet{WinShell.WA_VSCROLL,
                                     WinShell.WA_VSCROLLTRACK};
    AddHScrollBar       = WinAttrSet{WinShell.WA_HSCROLL,
                                     WinShell.WA_HSCROLLTRACK};
    AddScrollBars       = AddHScrollBar + AddVScrollBar;
    AddStatusLine       = WinAttrSet{WinShell.WA_STATUSLINE};

TYPE
    TextWindow;

    WindowTypes         = (TopLevel, MdiChild);

    ScreenAttribute     = CARDINAL16;(* magic cookie *)

    Cell = (* the format of an individual text character cell *)
        RECORD
        ch      : CHAR;
        attr    : ScreenAttribute;
        END;

    TextWindowsMsg      = (
                            TWM_CREATE,
                            TWM_GAINFOCUS,
                            TWM_LOSEFOCUS,
                            TWM_ACTIVATEAPP,
                            TWM_DEACTIVATEAPP,
                            TWM_MOUSE,
                            TWM_KEY,
                            TWM_CLOSE,
                            TWM_MENU,
                            TWM_MENUSELECT,
                            TWM_MENUSTART,
                            TWM_MENUEND,
                            TWM_MDIACTIVE,
                            TWM_PAINT,
                            TWM_SIZE,
                            TWM_POSITIONCHANGED,
                            TWM_SCROLL,
                            TWM_NOTIFYSCROLL,
                            TWM_TIMER,
                            TWM_USER
                          );

(******************** Message Definitions ************************************
    TWM_CREATE          same as WinShell
    TWM_GAINFOCUS       same as WinShell
    TWM_LOSEFOCUS       same as WinShell
    TWM_MDIACTIVE       same as WinShell
    WSM_ACTIVATEAPP     same as WinShell
    WSM_DEACTIVATEAPP   same as WinShell
    TWM_KEY             same as WinShell
    TWM_CLOSE           same as WinShell
    TWM_MENU            same as WinShell
    TWM_MENUSELECT      same as WinShell
    TWM_STARTMENU       same as WinShell
    TWM_ENDMENU         same as WinShell
    TWM_TIMER           same as WinShell
    TWM_USER            same as WinShell
    TWM_SCROLL          same as WinShell
    TWM_POSITIONCHANGED same as WinShell

    TWM_MOUSE           this window received a mouse event
        m_pos = Window Coordinates of click in text cells, not pixels
        m_button = Which button the event is for
        m_event = the type of event
        m_state = the state of various other keys at the time of the mouse event
        m_wheel = the mouse wheel movement. positive is forward towards the front
                of the mouse. This value is scroll increments.
                1 = one scroll increment

    TWM_PAINT           this window needs repainting
        paintRect = rectangle of region that needs to be painted
               this is in text cells, not pixels

    TWM_SIZE            the size of this window is/has changed
        sizeType = The type of sizing operation
        width = the new width in text cells, not pixels
        height = the new height in text cells, not pixels

            for variable buffer windows the size is changing and a
                paint message will follow this message
            for fixed buffer windows the size has changed
                can be used to set the page size

    TWM_NOTIFYSCROLL    notification that the window has automatically
                        scrolled in some way.

*****************************************************************************)

    TWMessageRec =
        RECORD
        CASE msg : TextWindowsMsg OF
        TWM_GAINFOCUS, TWM_LOSEFOCUS,
        TWM_MENUSTART, TWM_MENUEND,
        TWM_ACTIVATEAPP, TWM_DEACTIVATEAPP,
        TWM_MDIACTIVE,
        TWM_NOTIFYSCROLL:
            (* no data for these *)
        |
        TWM_CREATE:
            createParam : ADDRESS;
        |
        TWM_MOUSE:
            m_pos       : twPOINT;
            m_wheel     : INTEGER;
            m_button    : MouseButton;
            m_event     : MouseEventType;
            m_state     : MouseStateSet;
        |
        TWM_KEY:
            k_count     : CARDINAL;
            k_special   : SpecialKeys;
            k_state     : KeyStateSet;
            k_ch        : CHAR;
        |
        TWM_CLOSE:
            closeMode   : CloseModes;
        |
        TWM_MENUSELECT,
        TWM_MENU:
            menuId      : INTEGER;
            accel       : BOOLEAN; (* used only with MENU *)
        |
        TWM_PAINT:
            paintRect   : twRECT;
        |
        TWM_SIZE:
            sizeType: SizeType;
            width       : COORDINATE;
            height      : COORDINATE;
        |
        TWM_POSITIONCHANGED:
            windowPos   : WinShell.wsPOINT;
        |
        TWM_SCROLL:
            scrollDir   : ScrollDirection;
            scrollClass : ScrollClass;
            scrollPos   : ScrollRange;
        |
        TWM_TIMER:
            timerId     : CARDINAL;
        |
        TWM_USER:
            userId      : CARDINAL;
            userData: ADDRESS;
        END;
    END;

    TextWindowProcedure = PROCEDURE(TextWindow, TWMessageRec) : ResponseType;

    (* colors available in a text window *)
    Colors      = (
                    Black,
                    Blue,
                    Green,
                    Cyan,
                    Red,
                    Purple,
                    Brown,
                    DarkGray,
                    LightGray,
                    LightBlue,
                    LightGreen,
                    LightCyan,
                    LightRed,
                    Magenta,
                    Yellow,
                    White
                );

    (* font styles available in a text window *)
    FontStyles = (FsItalic, FsBold);
    FontStyleSet = PACKEDSET OF FontStyles;

    ColorValue  = WinShell.ColorValue;
    ColorTable = ARRAY Colors OF ColorValue;

CONST
    NormalFont  = FontStyleSet{};
    BoldFont    = FontStyleSet{FsBold};
    ItalicFont  = FontStyleSet{FsItalic};

    NullTextWnd = CAST(TextWindowProcedure, NIL);

VAR
    StartupDisplayMode  : DisplayModes;(* same as WinShell *)
    DefaultFontInfo     : FontInfo;(* the default font that a text window
                                      will use *)

PROCEDURE WinShellToTextWindowMessage(wmsg : WinShell.MessageRec;
                                      VAR OUT msg : TWMessageRec) : BOOLEAN;
(* convert a WinShell message to a TextWindow message *)
(* not all message types can be converted *)
(* returns TRUE if successful *)

PROCEDURE CreateWindow(windowType : WindowTypes;
                       parent : WinShell.Window;
                       name : ARRAY OF CHAR;
                       menu : ARRAY OF CHAR;
                       icon : ARRAY OF CHAR;
                       x, y : COORDINATE;
                       xSize, ySize : COORDINATE;
                       xBuffer, yBuffer : COORDINATE;
                       gutter : BOOLEAN;
                       font : FontInfo;
                       background : ScreenAttribute;
                       wndProc : TextWindowProcedure;
                       attribs : WinAttrSet;
                       createParam : ADDRESS) : TextWindow;
(* create a new window *)
(* parent = as WinShell  *)
(* name = as WinShell  *)
(* menu = the menu for the window. Can be "". *)
(* icon =  as WinShell *)
(* attribs = as WinShell *)
(* wndProc = the window procedure *)
(* createParam = an arbitrary value you can use to pass information
                 to the window procedure of the window. this value is
                 passed in the WSM_CREATE message. *)
(* font = the font to use for this window *)
(* background = the background color for this window *)
(* gutter = TRUE then the text window will always have a blank "gutter"
            on the left edge of the text window.
            FALSE the text will start at the left edge of the client area.
            *)
(* x, y = the initial screen coordinates for the window to be displayed
          if a parameter is -1 then the operating system will choose
          a default location for that coordinate.
          these positions are in pixels and are relative to the
          parent window client area origin for child windows
          or relative to the screen origin for all other windows. *)
(* xSize, ySize = the initial width and height in character cells
                  if -1 then a system default size will be used *)
(* xBuffer, yBuffer = the size of the screen buffer. the window can never
                      be larger than the screen buffer. if either xBuffer
                      or yBuffer is -1 the screen buffer is a variable size
                      and is sized to the number of cells the window client
                      area currently is capable displaying. *)
(* returns the window handle is successfull, otherwise NIL*)

PROCEDURE ConvertMdiChildToTopLevel(tw : TextWindow);
(* convert the MdiChild window to a TopLevel window.
   if the frame window has a toolbar and/or statusline the new
   toplevel window will create copies of these for itself.
*)

PROCEDURE CycleActiveMdiChild(tw : TextWindow; direction : INTEGER);
(*
  w must be an MdiChild window.
  if direction > 0 then the next MdiChild becomes the active child window.
  if direction < 0 then the previous MdiChild becomes the active child window.
*)

PROCEDURE CloseWindow(tw : TextWindow; mode : CloseModes) : BOOLEAN;
(* close an existing window. *)
(* mode = CM_REQUEST you are requesting that the window close.
          for example this can give a window a change to prompt for saving any
          unsaved changes and possibly aborting the close. *)
(* mode = CM_DICTATE the window *WILL* be closed *)
(* returns TRUE if the window is closing *)

PROCEDURE IsTextWindow(tw : TextWindow) : BOOLEAN;
(* is the window handle passed in tw a valid window handle *)
(* for example a window might have been closed and a copy of the window *)
(* handle an application had stored somewhere may no longer be valid *)
(* returns TRUE if the window handle is a valid text window *)

PROCEDURE GetTextWindowType(tw : TextWindow) : WindowTypes;
(* return the WindowType of the window *)

PROCEDURE SetWindowBackground(tw : TextWindow;
                              background : ScreenAttribute);
(* set the background color for the specified window *)

PROCEDURE GetWindowFont(tw : TextWindow; VAR OUT font : FontInfo);
(* get the font that is currently used by this window *)

PROCEDURE SetWindowFont(tw : TextWindow; font : FontInfo) : BOOLEAN;
(* set the font to be used for this window *)
(* returns TRUE if successful *)

PROCEDURE SetScrollRangeAllowed(tw : TextWindow;
                                which : WinAttr;
                                range : ScrollRange);
(* set the scroll range for the horizontal or vertical scroll bar *)
(* range is the upper end of the scroll range. the lower end is always zero. *)

PROCEDURE SetScrollRangesAllowed(tw : TextWindow;
                                 rangeX, rangeY : ScrollRange);
(* set the scroll range for both the horizontal and vertical scroll bar *)
(* rangeX and rangeY respectively. *)
(* rangeX and rangeY are the upper end of the scroll range. the lower end is
   always zero. *)

PROCEDURE SetPageSize(tw : TextWindow; x, y : ScrollRange);
(* set the granularity in character cells that a PAGE scroll *)
(* operation should move *)

PROCEDURE SetAutoScroll(tw : TextWindow; on : BOOLEAN);
(* windows are created with the scroll bars handled automatically *)
(* by this module, use this to disable and handle scroll bars manually *)
(* on = TRUE then scroll bars are handled by this module
             you will never receive a TWM_SCROLL message
             you will receive TWM_SCROLLNOTIFY messages when this module
             automatically scrolls the window
        FALSE then you will receive TWM_SCROLL messages and should perform
              appropriate actions for the messages
              you will not receive TWM_NOTIFYSCROLL messages *)

PROCEDURE SetMinClientSize(tw : TextWindow; x, y : COORDINATE);
(* set the minimum size in character cells the specified window *)
(* will be allowed to assume *)

PROCEDURE GetClientSize(tw : TextWindow; VAR OUT x, y : COORDINATE);
(* get the current size of the text area in character cells of the *)
(* specified window *)

PROCEDURE SetClientSize(tw : TextWindow; x, y : COORDINATE);
(* set the current size of the text area in character cells of the *)
(* specified window *)

PROCEDURE SnapWindowToFont(tw : TextWindow; on : BOOLEAN);
(* TRUE = window client area will be sized so that only full characters *)
(* will be shown *)
(* FALSE = the bottom and/or right may have partial characters shown *)

PROCEDURE ResizeScreen(tw : TextWindow; xSize, ySize : COORDINATE) : BOOLEAN;
(* resize the screen buffer for the specified window *)
(* if the window was create with -1 buffer size values this call has no *)
(* effect. therefore only use this call on windows with fixed screen buffers *)
(* returns TRUE is successful *)

PROCEDURE RedirectMessage(tw : TextWindow; msg : TWMessageRec);
(* this call simply passes the message to the window specified *)
(* the window should be of the same thread as the window that received *)
(* the message originally. Everything should work if not, but problems *)
(* may occur. *)

PROCEDURE ScrollWindow(tw : TextWindow;
                       dir : ScrollDirection;
                       class  : ScrollClass;
                       pos : ScrollRange;
                       amount : COORDINATE);
(* scroll the window by the specified amount an direction *)
(* dir can be LEFT, RIGHT, UP or DOWN *)
(* class can be LINE, PAGE, ABSOLUTE or EXTREME *)
(* pos is only used with a class of ABSOLUTE *)
(* amount is used with LINE and PAGE and specifies how may scrolls to do *)
(* ABSOLUTE is used with UP or LEFT and pos. Where pos specifies a *)
(*          absolute virtual coordinate for the upper left coordinate *)
(*          of the text window *)
(* EXTREME is used with an ScrollDirection and position the screen *)
(*         at the extreme edge of the virtual coordinate space *)

PROCEDURE ScrollBuffer(tw : TextWindow;
                       dir : ScrollDirection;
                       amount : CARDINAL);
(* scroll the data held in the screen buffer *)
(* the virtual coordinates of the screen buffer will not change *)
(* in manual scrolling the coordinates of the  screen buffer never  *)
(* change since it is your code that is handling this *)
(* use this call when performing manual scrolling *)
(* this call simply moves the data in the screen buffer and generates a *)
(* paint message to fill in the resulting empty space *)

PROCEDURE MoveCaretTo(tw : TextWindow; x, y : COORDINATE);
(* move the caret to the specified location in character cells *)
(* a window need not have a caret for this function to work. *)
(* the position is remembered and is used if/when the caret is turned on *)

PROCEDURE GetCaretPos(tw : TextWindow; VAR OUT x, y : COORDINATE);
(*
  get the current position of the text caret
*)

PROCEDURE IsCaretVisible(tw : TextWindow) : BOOLEAN;
(* is the caret visible (where the user can see it) within the current *)
(* window display *)
(* returns TRUE if the caret is visible *)
(* manual scrolling windows have no use for this call *)

PROCEDURE MakeCaretVisible(tw : TextWindow);
(* make sure the caret is visible within the current window display *)
(* any necessary scroll actions will be performed by calling *)
(* the ScrollWindow procedure *)
(* manual scrolling windows have no use for this call *)

PROCEDURE ComposeAttribute(fore, back : Colors;
                           style : FontStyleSet) : ScreenAttribute;
(* combine the various screen components into a screen attribute *)

PROCEDURE DecomposeAttribute(sc : ScreenAttribute;
                             VAR OUT fore, back : Colors;
                             VAR OUT style : FontStyleSet);
(* break a screen attribute into its various components *)

PROCEDURE PutStringAt(tw : TextWindow;
                      x, y : COORDINATE;
                      str : ARRAY OF CHAR;
                      a : ScreenAttribute);
(* write the string at the specified position in character cells *)
(* output will be clipped if the text is/extends outside the screen buffer *)
(* x, y = the coordinates of the first character of the string to paint *)
(* str = the string to paint *)
(* a = the screen attribute to use when painting the text *)

PROCEDURE PutAttrAt(tw : TextWindow;
                    x, y : COORDINATE;
                    attr : ARRAY OF ScreenAttribute);
(* write the attributes at the specified position in character cells *)
(* the text remains unaltered, only the attribute is written *)
(* output will be clipped if the attributes are outside the screen buffer *)
(* x, y = the coordinates of the first character of the string to paint *)
(* attr = the attribute string to paint. the HIGH bound of the array
          determines the number of attributes to paint *)

PROCEDURE WriteString(tw : TextWindow;
                      str : ARRAY OF CHAR;
                      a : ScreenAttribute);
(* write the string at the specified position in character cells *)
(* output will be clipped if the text is/extends outside the screen buffer *)
(* str = the string to paint *)
(* a = the screen attribute to use when painting the text *)
(* the text is written at the current caret position, and the x caret *)
(* position is advanced by the length of the string. *)

PROCEDURE WriteStringAt(tw : TextWindow;
                        x, y : COORDINATE;
                        str : ARRAY OF CHAR;
                        a : ScreenAttribute);
(* this call has the same effect as *)
(*
    MoveCaretTo(tw, x, y);
    WriteString(tw, str, a);
*)

PROCEDURE WriteCellsAt(tw : TextWindow;
                       x, y : COORDINATE;
                       s : ARRAY OF Cell);
(* this call is like PutStringAt except you are writing whole character *)
(* rather than a string all with the same attribute. *)
(* the number of cells to write is determined by the HIGH bound of the *)
(* array of cells passed *)

PROCEDURE WriteCells(tw : TextWindow; s : ARRAY OF Cell);
(* this call is like WriteCellsAt except output is to the *)
(* current caret position *)

PROCEDURE WriteLn(tw : TextWindow);
(* place the caret at the beginning of the screen buffer for the *)
(* X coordinate and advance the Y coordinate by one position *)
(* may cause the screen to scroll if the Y coordinate is at the bottom *)
(* of the screen buffer *)
(* the caret position is advanced by this call *)

PROCEDURE EraseToEOL(tw : TextWindow; a : ScreenAttribute);
(* erase to the end of the screen buffer with spaces and the attribute *)
(* specified from the current caret position *)
(* the caret position is advanced by the call *)

PROCEDURE ChangeAttr(tw : TextWindow;
                     y, x1, x2 : COORDINATE;
                     a : ScreenAttribute);
(* change the attributes from coordinate x1 to x2 on coordinate y*)
(* output will be clipped if the range is/extends outside the screen buffer *)

PROCEDURE ReadBufferString(tw : TextWindow;
                           y, x1, x2 : COORDINATE;
                           VAR OUT str : ARRAY OF CHAR);
(* read data from the screen buffer maintained for the specified window *)
(* read from coordinate y from coordinate x1 to x2 *)
(* place the data into the parameter string *)
(* if x1..x2 is larger than the size of str then the range x1..x2 is reduced *)
(* to the size of str *)
(* the string will be null terminated if x1..x2 is smaller than the size *)
(* the parameter str *)

PROCEDURE RepaintRect(tw : TextWindow; rect : twRECT);
(* send yourself a TWM_PAINT message for the specified rectangle *)
(* the rectangle will be clipped to the size of the screen buffer if *)
(* necessary *)

PROCEDURE RepaintScreen(tw : TextWindow);
(* send yourself a TWM_PAINT message for the entire screen buffer *)

PROCEDURE MakeRowVisible(tw : TextWindow; y : COORDINATE);
(* make the specified row, y coordinate, visible in the display window *)
(* you may receive TWM_PAINT, TWM_SCROLL or TWM_NOTIFYSCROLL messages as a *)
(* result of this call *)
(* manual scrolling windows have no use for this call *)

PROCEDURE IsRectVisible(tw : TextWindow; theRect : twRECT) : BOOLEAN;
(* returns TRUE if the entire specified rectangle visible in the window *)
(* manual scrolling windows have no use for this call *)

PROCEDURE MakeRectVisible(tw : TextWindow; theRect : twRECT);
(* make the specified rectangle visible in the window *)
(* you may receive TWM_PAINT, TWM_SCROLL or TWM_NOTIFYSCROLL messages as a *)
(* result of this call *)
(* if the rectange is larger than the current window size then as much *)
(* of the rectangle that can be made visible will be made visible *)
(* manual scrolling windows have no use for this call *)

PROCEDURE GetVisibleRect(tw : TextWindow; VAR OUT theRect : twRECT);
(* retrieve the rectangle currently visible in the window in *)
(* virtual coordinates *)
(* manual scrolling windows have no use for this call *)

PROCEDURE GetBufferRect(tw : TextWindow; VAR OUT theRect : twRECT);
(* retrieve the rectangle of the screen buffer in virtual coordinates *)
(* manual scrolling windows have no use for this call *)

PROCEDURE EraseScreen(tw : TextWindow; a : ScreenAttribute);
(* Erase the entire screen buffer with spaces and the given attribute *)

PROCEDURE EraseRect(tw : TextWindow; rect : twRECT; a : ScreenAttribute);
(* Erase the specified region with spaces and the specified attribute *)
(* output will be clipped if the rectangle is/extends outside the *)
(* screen buffer *)

PROCEDURE Xpos(tw : TextWindow) : COORDINATE;
(* the X coordinate of the caret position in virtual coordinates *)

PROCEDURE Ypos(tw : TextWindow) : COORDINATE;
(* the Y coordinate of the caret position in virtual coordinates *)

PROCEDURE Xorg(tw : TextWindow) : COORDINATE;
(* the X coordinate of the upper left corner of the screen buffer *)
(* in virtual coordinates *)
(* manual scrolling windows have no use for this call *)

PROCEDURE Yorg(tw : TextWindow) : COORDINATE;
(* the Y coordinate of the upper left corner of the screen buffer *)
(* in virtual coordinates *)
(* manual scrolling windows have no use for this call *)

PROCEDURE Xmax(tw : TextWindow) : COORDINATE;
(* the highest X coordinate of the screen buffer in virtual coordinates *)

PROCEDURE Ymax(tw : TextWindow) : COORDINATE;
(* the highest Y coordinate of the screen buffer in virtual coordinates *)

(* conversion routines to and from Virtual and Buffer coordinates *)
(* for example if you had an absolute screen coordinate and you wanted *)
(* to convert that to a text cell coordinate you would *)
(*
    WinShell.ScreenToClient(GetWinShellHandle(tw), pt);
    ClientToBuffer(tw, pt);
    BufferToVirtual(tw, pt);
*)
(* if you had a text window virtual coordinate and you wanted a screen pixel *)
(*
    VirtualToBuffer(tw, pt);
    BufferToClient(tw, pt);
    WinShell.ClientToScreen(GetWinShellHandle(tw), pt);
*)

PROCEDURE VirtualToBuffer(tw : TextWindow; VAR INOUT pt : twPOINT);

PROCEDURE BufferToVirtual(tw : TextWindow; VAR INOUT pt : twPOINT);

PROCEDURE ClientToBuffer(tw : TextWindow; VAR INOUT pt : twPOINT);
(* client pixel coordinates to text cell buffer coordinates *)

PROCEDURE BufferToClient(tw : TextWindow; VAR INOUT pt : twPOINT);
(* text cell buffer coordinates to client pixel coordinates *)

PROCEDURE GetCursorPos(tw : TextWindow; VAR OUT pt : twPOINT);
(* returns the cursor position in Virtual coordinates *)

PROCEDURE GetColorTable(VAR OUT table : ColorTable);
(* get the table of colors used by this module *)
(* the table associates the color enumeration this module uses *)
(* with the RGB color information the operating system uses *)

PROCEDURE GetColorPalette() : PaletteHandle;
(* get the handle of the color palette used by this module. *)
(* the palette can be NIL, if no palette is necessary *)

PROCEDURE PaintOff(tw : TextWindow);
(* function for turning off the updating of the display per "write" call. *)
(* this will increase display updating performance dramatically. *)
(* Off and On calls can be nested, thus you must turn painting On for *)
(* every Off *)
(* Whenever a window receives a TWM_PAINT message painting is automatically *)
(* turned off for the duration of the PAINT message. *)
(* turn paint updates OFF.  the window remembers anything that needs *)
(* be repainted for when painting is again turned ON *)

PROCEDURE PaintOn(tw : TextWindow);
(* reverses a PaintOff call *)

PROCEDURE FlushPaint(tw : TextWindow);
(* if painting is off, flush all pending paint updates to the screen *)
(* if painting is on this call has no effect *)

PROCEDURE IsPaintOn(tw : TextWindow) : BOOLEAN;
(* returns TRUE if paint updates is currently on for the specified window *)

PROCEDURE GetWinShellHandle(tw : TextWindow) : WinShell.Window;
(* get the WinShell window handle for the text window in question *)

PROCEDURE FindTextWindow(w : WinShell.Window) : TextWindow;
(* find the text window associated with the WinShell handle *)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

(* Stuff TextWindows simply re-exports from WinShell. *)
(* these procedures take a text window handle and just transfer the *)
(* call to the appropriate WinShell procedure of the same name *)
(* coordinates and sizes are in pixels for these calls, not character cells *)
(* as "native" TextWindows API calls *)

PROCEDURE Beep(beep : Beeps);

PROCEDURE BooBox(str : ARRAY OF CHAR);

PROCEDURE SetDisplayMode(tw : TextWindow; dispMode : DisplayModes);

PROCEDURE GetDisplayMode(tw : TextWindow) : DisplayModes;

PROCEDURE SetWindowEnable(tw : TextWindow; enabled : BOOLEAN);

PROCEDURE IsMinimized(tw : TextWindow) : BOOLEAN;

PROCEDURE IsMaximized(tw : TextWindow) : BOOLEAN;

PROCEDURE SetWindowTitle(tw : TextWindow; title : ARRAY OF CHAR);

PROCEDURE SendUserMessage(tw : TextWindow;
                          userId : CARDINAL; userData : ADDRESS);
PROCEDURE PostUserMessage(tw : TextWindow;
                          userId : CARDINAL; userData : ADDRESS);

PROCEDURE IsUserMessageWaiting(tw : TextWindow;
                               userIdLow, userIdHigh : CARDINAL) : BOOLEAN;

PROCEDURE CaretOn(tw : TextWindow);

PROCEDURE CaretOff(tw : TextWindow);

PROCEDURE SetCaretType(tw : TextWindow; ct : CaretTypes);

PROCEDURE SetScrollBarPos(tw : TextWindow;
                          which : WinAttr;
                          pos : ScrollRange);

PROCEDURE SetWindowData(tw : TextWindow;
                        index : CARDINAL;
                        data : ADDRESS) : BOOLEAN;
PROCEDURE SetWindowDataNum(tw : TextWindow;
                           index : CARDINAL;
                           data : CARDINAL) : BOOLEAN;

PROCEDURE GetWindowData(tw : TextWindow;
                        index : CARDINAL) : ADDRESS;
PROCEDURE GetWindowDataNum(tw : TextWindow;
                           index : CARDINAL) : CARDINAL;

PROCEDURE GetWindowSize(tw : TextWindow; VAR OUT width, height : COORDINATE);

PROCEDURE SetWindowSize(tw : TextWindow; width, height : COORDINATE);

PROCEDURE GetWindowPos(tw : TextWindow; VAR OUT x, y : COORDINATE);

PROCEDURE SetWindowPos(tw : TextWindow; x, y : COORDINATE);

PROCEDURE CascadeWindow(cascadeThis, onThis : TextWindow);

PROCEDURE SetWindowIsBusy(tw : TextWindow; busy : BOOLEAN);

PROCEDURE GetWindowDisplayInfo(tw : TextWindow; VAR OUT info : WindowDisplayInfo);

PROCEDURE SetWindowDisplayInfo(tw : TextWindow; info : WindowDisplayInfo);

PROCEDURE SetScrollDisableWhenNone(tw : TextWindow; yesH, yesV : BOOLEAN);

PROCEDURE SetActiveMdiChild(tw : TextWindow);

PROCEDURE SetMdiChildPosition(tw : TextWindow; index : CARDINAL);

PROCEDURE GetForegroundWindow() : TextWindow;

PROCEDURE SetForegroundWindow(tw : TextWindow);

PROCEDURE CreateStatusLine(tw : TextWindow; fmt : ARRAY OF INTEGER) : BOOLEAN;

PROCEDURE RemoveStatusLine(tw :TextWindow);

PROCEDURE SetStatusFormat(tw :TextWindow; fmt : ARRAY OF INTEGER);

PROCEDURE WriteStatusField(tw :TextWindow;
                           field : CARDINAL;
                           text : ARRAY OF CHAR);

PROCEDURE SetWindowIcon(tw : TextWindow; icon : ARRAY OF CHAR) : BOOLEAN;

PROCEDURE SetWindowCursor(tw : TextWindow; typ : CursorTypes);

PROCEDURE SetWindowMenu(tw : TextWindow; menu : ARRAY OF CHAR) : BOOLEAN;

PROCEDURE SetMenuItemEnable(tw : TextWindow; id : CARDINAL; state : BOOLEAN);

PROCEDURE GetMenuItemEnable(tw : TextWindow; id : CARDINAL) : BOOLEAN;

PROCEDURE SetMenuItemCheck(tw : TextWindow; id : CARDINAL; state : BOOLEAN);

PROCEDURE GetMenuItemCheck(tw : TextWindow; id : CARDINAL) : BOOLEAN;

PROCEDURE SetMenuItemRadioCheck(tw : TextWindow;
                                first, last, set : CARDINAL);

PROCEDURE GetMenuItemRadioCheck(tw : TextWindow;
                                first, last : CARDINAL) : CARDINAL;

PROCEDURE GetWindowMenu(tw : TextWindow) : MenuHandle;

PROCEDURE LoadMenu(tw : TextWindow;
                   menuId : ARRAY OF CHAR;
                   popup : BOOLEAN) : MenuHandle;

PROCEDURE DestroyMenu(menuH : MenuHandle);

PROCEDURE GetSubMenu(menuH : MenuHandle; subMenu  : CARDINAL) : MenuHandle;

PROCEDURE AppendMenuItemStr(tw : TextWindow;
                            menuH : MenuHandle;
                            str : ARRAY OF CHAR;
                            id : CARDINAL) : BOOLEAN;

PROCEDURE AppendMenuItemSeparator(tw : TextWindow; menuH : MenuHandle) : BOOLEAN;

PROCEDURE DeleteMenuItemPosition(menuH : MenuHandle; pos : CARDINAL) : BOOLEAN;

PROCEDURE PopupMenuHandle(tw : TextWindow;
                          menuH : MenuHandle;
                          button : MouseButton;
                          x, y : COORDINATE);

PROCEDURE PopupMenu(tw : TextWindow;
                    menuId : ARRAY OF CHAR;
                    button : MouseButton;
                    x, y : COORDINATE);

PROCEDURE SetTimer(tw : TextWindow; timerId : CARDINAL; interval : CARDINAL);

PROCEDURE KillTimer(tw : TextWindow; timerId : CARDINAL);

PROCEDURE OpenClipboard(w : TextWindow) : BOOLEAN;

PROCEDURE CloseClipboard(w : TextWindow);

PROCEDURE EmptyClipboard(w : TextWindow) : BOOLEAN;

PROCEDURE ClipboardFormatAvailable(fmt : ClipboardFormat) : BOOLEAN;

PROCEDURE AllocClipboardMemory(size : CARDINAL) : ADDRESS;

PROCEDURE UnlockClipboardMemory(data : ADDRESS);

PROCEDURE SetClipboard(fmt : ClipboardFormat;
                       data : ADDRESS;
                       amount : CARDINAL) : BOOLEAN;

PROCEDURE GetClipboard(fmt : ClipboardFormat) : ADDRESS;

PROCEDURE AddIdleProcedure(idle : WinShell.IdleProcType;
                           data : ADDRESS) : CARDINAL;

PROCEDURE RemoveIdleProcedure(id : CARDINAL);

PROCEDURE DispatchMessages() : CARDINAL;

PROCEDURE CheckMessages() : BOOLEAN;

PROCEDURE WaitForAMessage;

PROCEDURE TerminateDispatchMessages(code : CARDINAL);

PROCEDURE CreateToolbar(tw : TextWindow;
                        buttons : ARRAY OF ToolbarButtonInfo;
                        hasText : BOOLEAN;
                        hasHelp : BOOLEAN;
                        canCustomize : BOOLEAN) : BOOLEAN;

PROCEDURE DestroyToolbar(tw : TextWindow);

PROCEDURE SetToolbarButtons(tw : TextWindow; fmt : ARRAY OF CARDINAL);

PROCEDURE GetToolbarButtons(tw : TextWindow;
                            VAR OUT fmt : ARRAY OF CARDINAL) : CARDINAL;

PROCEDURE IsToolbarButtonShown(tw : TextWindow; index : CARDINAL) : BOOLEAN;

PROCEDURE IsToolbarButtonDown(tw : TextWindow; index : CARDINAL) : BOOLEAN;

PROCEDURE IsToolbarButtonEnabled(tw : TextWindow; index : CARDINAL) : BOOLEAN;

PROCEDURE ShowToolbarButton(tw : TextWindow;
                            index : CARDINAL;
                            show : BOOLEAN) : BOOLEAN;

PROCEDURE ToggleToolbarButton(tw : TextWindow;
                              index : CARDINAL;
                              down : BOOLEAN) : BOOLEAN;

PROCEDURE EnableToolbarButton(tw : TextWindow;
                              index : CARDINAL;
                              enable : BOOLEAN) : BOOLEAN;

PROCEDURE DisplayHelp(tw : TextWindow;
                      command : HelpCommand;
                      helpFile : ARRAY OF CHAR;
                      helpIndex : CARDINAL) : BOOLEAN;

END TextWindows.

(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1992-2002                             *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)
DEFINITION MODULE WinShell;
(*
  This module provides an encapsulation of the underlying operating system
  interface for handling windows and messages.
  no operating system types, constants or procedures are exported from
  this module. therefore any code that uses this module will not change
  when ported to another system. Only the implementation of this module
  need be ported.
  This module does not try to create a "high level" interface.
  It mostly maps itself directly to the underlying system. However there
  is some functionality not typically provided by a single system API call
  This module does not attempt to map the entire underlying system.
  Features are added to this module on an as needed basis. In other words,
  why write the code if it has no immediate use.
  The messaging structure is very clean via the use of a variant record.
*)

(* about resources.
   See also, SetResourceFile API call in this module.

   Resource names are not case sensitive.

   Win32 - normal Windows resources are used.

           An accelerator table resource needs to have the same name
           as the menu resource it is associated with.

           Additional "bitmap" resource types are supported in addition to the
           Windows native bitmap format. !!! not yet implemented !!!
           JPEG, PNG and TIFF formats are supported.
           When loading a bitmap from the resource file this module first looks
           for a native bitmap resource of the given name, and if this is not found
           then looks for JPEG, PNG and TIFF resources in that order.
           JPEG resources are identified by the "JPEG" resource type.
           PNG resources are identified by the "PNG" resource type.
           TIFF resources are identified by the "TIFF" resource type.

   Gtk - The concept of resources does not exist in the Unix toolkit
         world, and Gtk is no exception.
         We use a combination of various files to get the same effect.

       Dialogs - Glade XML files.
           For further information consult DlgShell.

       ---------------------------------------------------------------
       Menu's and accelerators. Glade XML files.
           Create a window in glade, mark the window as NOT visible.
           The name of the window is the name of your menu resource.
           Put your menubar into this window. The menu bar name must be named
           "menubar". The accelerators you define in the menubar will be used.

           For accelerators not tied to a menu item you create a menu in
           your menubar named "hiddenaccel" and put your accelerators
           on menu items within this menu. This menu will be hidden by
           this module.

           Popup menus are glade popup menu resources.

       ---------------------------------------------------------------
       String table - Proprietary format used by this module.
           This file format is the one that the Win32 resource editor uses
           to export/import string tables to stand alone files.

           Format.
           IdNumber = "...

           IdNumber = the string id number
           '=' the equal character.
           '"' the double quote character.
           The string is all data after the '"' character to the end of
           the line.

           Carrage return, line feed, tab, and backspace characters are
               in "escape" notation. These characters are converted to binary
               format when the string is loaded.
           \r = Carriage return = CHR(13). ignored on Unix systems.
           \n = line feed (new line) = CHR(10)
           \t = tab = CHR(9)
           \b = backspace = CHR(8)
           \\ = \ backslash character.

        ---------------------------------------------------------------
        Bitmaps - Proprietary format used by this module.
            This is a text file that describes the resource name
            and the associated bitmap file to load. Therefore each
            bitmap resource is an individual file. The bitmap file names
            can be relative file names that are relative to the bitmap
            resource file.

            Format
            ResourceName = FileName
            where ResoruceName and FileName must be enclosed in double quote
            characters.
            Only one resource description entry per line.

            Example
            "Splash" = "pixmaps/splash.png"

            Assuming the resource file is in directory "/opt/MyCompany",
            then the full path of the example bitmap file is
            "/opt/MyCompany/pixmaps/splash.png"

            Bitmap resource files can be any graphics file format supported
            by the Gdk Pixbuf library.
            This includes
                BMP, JPEG, PNG, TIFF.
                XPM, GIF, ICO.
*)

(* about threads
   Win32 - you may use the GUI features in a fully multi threaded manner.

   Gtk - Only one thread, the main thread, may use the GUI features.

   In all systems you can have any thread safely use the LoadString API.

   In all systems you can have a background thread send or post a message
   to a window. For send, the background thread will wait until the message is
   received and processed by the UI thread before returning from the
   send message call.
*)

<*/NOPACK*>
%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

FROM SYSTEM IMPORT
    ADDRESS;

TYPE
    Window;
    Drawable;
    DrawContext;

    WindowTypes         = (TopLevel, MdiChild, MdiFrame);

    MdiTabPosition      = (MdiTabTop, MdiTabBottom, MdiTabLeft, MdiTabRight);

    WinShellMsg         = (
                           WSM_CREATE,
                           WSM_GAINFOCUS,
                           WSM_LOSEFOCUS,
                           WSM_ACTIVATEAPP,
                           WSM_DEACTIVATEAPP,
                           WSM_MOUSE,
                           WSM_KEY,
                           WSM_CLOSE,
                           WSM_PAINT,
                           WSM_SIZE,
                           WSM_POSITIONCHANGED,
                           WSM_SCROLL,
                           WSM_MENU,
                           WSM_MENUSELECT,
                           WSM_MENUSTART,
                           WSM_MENUEND,
                           WSM_MDIACTIVE,
                           WSM_TIMER,
                           WSM_USER
                          );

(******************** Message Definitions ************************************
    WSM_CREATE          this window is being created

    WSM_GAINFOCUS       this window has gained the input focus

    WSM_LOSEFOCUS       this window has lost the input focus

    WSM_ACTIVATEAPP     the application is now the foreground application the
                        user is using.

    WSM_DEACTIVATEAPP   the application is no longer the foreground application the
                        user is using.

    WSM_MDIACTIVE     this MdiChild window is the foreground MdiChild window in
                      the childs parent frame window.

    WSM_MOUSE           this window received a mouse event
        m_pos = Window Coordinates of click
        m_button = Which button the event is for
        m_event = the type of event
        m_state = the state of various other keys at the time of the mouse event
        m_wheel = the mouse wheel movement. positive is forward towards the front
                of the mouse. This value is scroll increments.
                1 = one scroll increment

    WSM_KEY             this window received keyboard input
        k_ch = character keystroke if not special
        k_state = various extended keys when not a normal ASCII character
        k_special = the various special keys. If NOTSPECIAL then
                  ch contains the ANSI character
        k_count = The key repeat count. Normally 1.

    WSM_CLOSE           this window hasbeen or may be closed
        closeMode =  the close "mode"
                CM_REQUEST = you are being asked if you will close the window
                    RETURN OkayToClose
                        you will then later get a TWM_CLOSE with a mode of
                        CM_DICTATE
                    RETURN NotOkayToClose
                        at which point no further close action will take place
                        and the window will remain open.
                CM_DICTATE = you *ARE* closing
                        the return value is ignored in this case

    WSM_PAINT   a region of this window needs to be repainted.
                the text caret, if any, is automatically hidden and
                restored around this message.
        paintRect = rectangle of region that needs to be painted
        paintDraw = a drawable available to use for painting

    WSM_SIZE            the window *HAS* been resized
        sizeType = The type of sizing operation
        width = the new width
        height = the new height

    WSM_POSITIONCHANGED         the window has been moved on screen
        windowPos       = The window position

    WSM_SCROLL          the window has been scrolled
        dir = indicates direction to scroll
        class = the amount to scroll
        absOffs = absolute scroll position within the scroll range

    WSM_STARTMENU       the user has opened a menu
        you should use this to check/uncheck, activate/disable any menu items
        as necessary here. You do not know which menu was opened so you
        should just do all menus in the menu hierarchy of the window.

    WSM_MENU            a menu item has been selected
        menuId = the menu resource id number for the menu item

    WSM_MENUSELECT      a menu is highlighted
        menuId = the menu resource id number for the menu item
                 Typically this is used if a program has a status line
                 and you want to display simple single line help
                 descriptions of each menu item.

    WSM_ENDMENU         the user has exited the menu system
        If you were using MENUSELECT to display quick help you can use this
        to restore the status line to its proper state.

    WSM_TIMER           the specified timer duration has elapsed
        timerId = identifies which timer has elapsed

    WSM_USER
        userId = user defined value to identify the user message type
        userData =  if not used should be NIL
                    otherwise generally used to
                    pass a pointer to some data

*****************************************************************************)

    ResponseType        = (
                           USER_HANDLE, (* you handled the message *)
                           DEFAULT_HANDLE, (* use default message processing *)
                           OkayToClose,(* see WSM_CLOSE *)
                           NotOkayToClose(* see WSM_CLOSE *)
                          );

    WinAttr             = (
                           WA_SYSMENU, (* has system menu in caption *)
                           WA_MINIMIZEBOX,(* has minimize button in caption *)
                           WA_MAXIMIZEBOX,(* has maximize button in caption *)
                           WA_TITLE,(* has a caption title bar *)
                           WA_RESIZABLE,(* can be sized by the user *)
                           WA_HSCROLL,(* has/can have horizontal scroll bar *)
                           WA_VSCROLL,(* has/can have vertical scroll bar *)
                           WA_HSCROLLTRACK,(* receive scroll messages while
                                               the user is dragging the
                                               scroll bar thumb *)
                           WA_VSCROLLTRACK,(* receive scroll messages while
                                               the user is dragging the
                                               scroll bar thumb *)
                           WA_STATUSLINE,(* has a status line *)
                                         (* only frame windows can have this *)
                                         (* in the current implementation *)
                           WA_VISIBLE(* window is visible *)
                          );
    WinAttrSet          = SET OF WinAttr;

    CloseModes          = (CM_REQUEST, CM_DICTATE);(* see WSM_CLOSE *)

    ScrollDirection     = (DIR_UP, DIR_DOWN, DIR_LEFT, DIR_RIGHT); (* obvious *)

    ScrollClass         = (
                           SCROLL_LINE,(* scroll by lines *)
                           SCROLL_PAGE,(* scroll by pages *)
                           SCROLL_EXTREME,(* position to the extreme edges of the
                                      scroll range. ScrollDirection
                                      determines which edge is scrolled to *)
                           SCROLL_ABSOLUTE(* set to absolute scroll position within
                                      the scroll range *)
                          );

    SizeType    = (
                   SizeNormal,(* window no minimize or maximized *)
                   SizeMinimized,(* window is minimized *)
                   SizeMaximized(* window is maximized *)
                  );

    SpecialKeys = (
                   KEY_NOTSPECIAL,(* normal character *)
                   KEY_PAGEUP, KEY_PAGEDOWN, KEY_INSERT, KEY_DELETE, KEY_HOME, KEY_END,
                   KEY_MENU(*not all keyboards have this*),
                   KEY_RIGHTARROW, KEY_LEFTARROW, KEY_UPARROW, KEY_DOWNARROW,
                   KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6,
                   KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11, KEY_F12
                  );

    KeyStateType = (
                    KS_CONTROL,
                    KS_ALT,
                    KS_SHIFT
                   );
    KeyStateSet  = SET OF KeyStateType;

    SystemColors = (
                    SC_WINDOW_BACKGROUND,
                    SC_TEXT,
                    SC_HIGHLIGHT,
                    SC_HIGHLIGHTTEXT,
                    SC_GRAYTEXT,
                    SC_BUTTON_FACE
                   );

CONST
    (* some usefull predefined window attributes *)

    NormalWindow        = WinAttrSet{WA_VISIBLE,
                                     WA_TITLE,
                                     WA_RESIZABLE,
                                     WA_SYSMENU,
                                     WA_MINIMIZEBOX,
                                     WA_MAXIMIZEBOX
                                    };
    NormalMdiChildWindow= NormalWindow;(* because a MdiChild can be converted to TopLevel *)

    AddVScrollBar       = WinAttrSet{WA_VSCROLL};
    AddHScrollBar       = WinAttrSet{WA_HSCROLL};
    AddScrollBars       = AddVScrollBar + AddHScrollBar;
    AddScrollTrack      = WinAttrSet{WA_HSCROLLTRACK, WA_VSCROLLTRACK};
    AddStatusLine       = WinAttrSet{WA_STATUSLINE};

TYPE
    MouseButton         = (LeftButton, MiddleButton, RightButton, NoButton);
    MouseEventType      = (ButtonDown, ButtonUp,
                           ButtonDouble, ButtonTriple,
                           MouseMove, MouseWheel);
                           (* ButtonDouble and ButtonTriple are "software"
                              mouse events. You always receive the hardware
                              mouse Down and Up events.
                              You always receive an Up for every Down.
                              You will never receive an Up without a preceeding
                              Down.
                              ButtonTriple may not be portable.
                              MouseWheel may not be portable.
                            *)

    MouseStateType      = (
                           MS_SHIFT,(* shift key was down *)
                           MS_CONTROL,(* control key was down *)
                           MS_ALT,(*alt key was down*)
                           MS_LEFTBUTTON,(* is pressed *)
                           MS_RIGHTBUTTON,(* is pressed *)
                           MS_MIDDLEBUTTON(* is pressed *)
                          );
    MouseStateSet       = SET OF MouseStateType;

    COORDINATE  = INTEGER;

    wsPOINT =
        RECORD
        x        : COORDINATE;
        y        : COORDINATE;
        END;

    wsRECT =
        RECORD
        x1, y1   : COORDINATE;(*upper left*)
        x2, y2   : COORDINATE;(*lower right*)
        END;

    ColorValue          = CARDINAL32;(*00BBGGRRh*)(*red in LSB*)

    ClipboardFormat     = (CLIPBOARD_ASCII, CLIPBOARD_UNICODE);

    HelpCommand         = (
                           HelpTopic,(* open help to a specific topic *)
                           HelpContents(*Win32 only, open help in table of contents *)
                          );

    MenuHandle;(* magic cookie *)
    BitmapHandle;(* magic cookie *)
    PaletteHandle;(* magic cookie *)
    FontHandle;(* magic cookie *)
    PrintDriverInfo;(* magic cookie *)

    FontWeights         = (FwLight, FwNormal, FwDemiBold, FwBold, FwHeavy);

    CharacterSets       = (
                           LATIN1_CHARSET,(*ansi, iso*)
                           LATIN2_CHARSET,(*east europe*)
                           SYMBOL_CHARSET,
                           ASCII_CHARSET,
                           DEFAULT_CHARSET
                          );
    FontInfo            =
        RECORD
        height          : INTEGER;(* positive = points,
                                     negative = pixels*)
        italic          : BOOLEAN;
        fixedPitch      : BOOLEAN;(* if TRUE then only fixed pitch *)
                                  (* if FALSE then any pitch *)
        weight          : FontWeights;
        charSet         : CharacterSets;
        name            : ARRAY [0..63] OF CHAR;
        END;

    TextMetrics         =
        RECORD
        ascent          : CARDINAL;(*maximum ascent*)
        descent         : CARDINAL;(*maximum descent*)
        height          : CARDINAL;(*the maximum height of the font*)
                                   (*this is max ascent + max decent *)
        aveCharWidth    : CARDINAL;(*average character width.
                                     for fixed pitch fonts this is the
                                     character width. *)
        externalLeading : CARDINAL;(*extra spacing not in font,
                                     but specified by the font designer *)
        END;

    TextDrawOrigin      = (
                           OriginBaseLeft,
                           OriginTopLeft,
                           OriginBaseCenter,
                           OriginTopCenter
                          );
                          (*
                             BaseLeft = the x origin is the left side of the
                                            first character.
                                        the y origin is on the font
                                            baseline.
                             TopLeft = the x origin is the left side of the
                                            first character.
                                       the y origin is at the top of the
                                       font. The is basically above the
                                       baseline by the ascender amount of
                                       the string.
                             BaseCenter = the x origin is the middle of
                                          the string in device pixels.
                                        the y origin is on the font
                                            baseline.
                             TopCenter = the x origin is the middle of
                                          the string in device pixels.
                                       the y origin is at the top of the
                                       font. The is basically above the
                                       baseline by the ascender amount of
                                       the string.
                          *)

    JoinStyles       = (JoinBevel, JoinMiter, JoinRound);
    EndCaps          = (
                        EndCapFlat,
                        EndCapSquare,(* the line entends beyond the line end
                                        points by have the line width.*)
                        EndCapRound(* the line will extend beyond the line
                                      end points to draw the rounded end. *)
                       );

    DrawContextValues   =
        RECORD
        foreground              : ColorValue;
        background              : ColorValue;
        font                    : FontHandle;
        textExtraSpacing        : INTEGER;
        textOrigin              : TextDrawOrigin;
        lineWidth               : CARDINAL;
        joinStyle               : JoinStyles;
        endCap                  : EndCaps;
        END;

CONST
    DrawContextDefaults =
                DrawContextValues{0,(*foreground (black) *)
                                  0FFFFFFh,(*background (white) *)
                                  NIL,(*font*)
                                  0,(*extra spacing*)
                                  OriginTopLeft,
                                  1,(*line width*)
                                  JoinBevel,
                                  EndCapFlat
                                 };

TYPE
    DrawTextOptions     = (DT_CLIPPED, DT_OPAQUE);
    DrawTextOptionSet   = SET OF DrawTextOptions;

CONST
    DrawTextOpaque      = DrawTextOptionSet{DT_OPAQUE};
    DrawTextClipped     = DrawTextOptionSet{DT_CLIPPED};

TYPE
    CursorTypes         = (
                           LeftArrowCursor,(* arrow pointing left, default *)
                           RightArrowCursor,(* arrow pointing right *)
                           WaitCursor,(* an hourglass or similar *)
                           TextCursor,(* standard text cursor *)
                           CrossHairCursor(*just like it sounds*)
                          );

    CaretTypes          = ((* text cursor shape *)
                           CtVerticalBar,
                           CtHorizontalBar,
                           CtHalfBlock,
                           CtFullBlock
                          );


    DisplayModes        = (
                           DisplayNormal, (* will activate window *)
                                          (* make it visible *)
                                          (* reverses minimized or maximized *)
                           DisplayVisible,(* makes window visible *)
                                          (* will not activate window *)
                           DisplayHidden,(* hides window *)
                                         (* active window changes *)
                           DisplayMinimized,(* minimizes window *)
                                            (* does not change active window *)
                           DisplayMaximized(* will activate window *)
                                           (* maximizes window *)
                          ) BIG;

    Beeps               = (NormalBeep, QuestionBeep, WarningBeep, ErrorBeep);

    ScrollRange         = INTEGER32;

    WindowDisplayInfo =
        RECORD
        x       : COORDINATE;(* upper left corner *)
        y       : COORDINATE;(* upper left corner *)
        width   : COORDINATE;
        height  : COORDINATE;
        mode    : DisplayModes;
        END;

    ScreenMetrics =
        RECORD
        xSize   : CARDINAL;(* width is pixels *)
        ySize   : CARDINAL;(* height in pixels *)
        colors  : CARDINAL;(* number of simultaneous color supported *)
        END;

    MessageRec          = RECORD
        CASE msg : WinShellMsg OF
        WSM_GAINFOCUS, WSM_LOSEFOCUS,
        WSM_MENUSTART, WSM_MENUEND,
        WSM_ACTIVATEAPP, WSM_DEACTIVATEAPP,
        WSM_MDIACTIVE:
            (* no data fields for these *)
        |
        WSM_CREATE:
            createParam : ADDRESS;
        |
        WSM_MOUSE:
            m_pos       : wsPOINT;
            m_wheel     : INTEGER;
            m_button    : MouseButton;
            m_event     : MouseEventType;
            m_state     : MouseStateSet;
        |
        WSM_KEY:
            k_count     : CARDINAL;
            k_special   : SpecialKeys;
            k_state     : KeyStateSet;
            k_ch        : CHAR;
        |
        WSM_CLOSE:
            closeMode   : CloseModes;
        |
        WSM_PAINT:
            paintRect   : wsRECT;
            paintDraw   : Drawable;
        |
        WSM_SIZE:
            sizeType    : SizeType;
            width       : COORDINATE;
            height      : COORDINATE;
        |
        WSM_POSITIONCHANGED:
            windowPos   : wsPOINT;
        |
        WSM_SCROLL:
            scrollDir   : ScrollDirection;
            scrollClass : ScrollClass;
            scrollPos   : ScrollRange;
        |
        WSM_MENUSELECT,
        WSM_MENU:
            menuId      : CARDINAL;
        |
        WSM_TIMER:
            timerId     : CARDINAL;
        |
        WSM_USER:
            userId      : CARDINAL;
            userData    : ADDRESS;
        END;
    END;

CONST
    TOOLBAR_SEPARATOR                   = MAX(CARDINAL);

TYPE
    StdToolbarBitmaps =
    ((* standard built-in bitmaps for toolbars *)
     TB_BMP_CUT,
     TB_BMP_COPY,
     TB_BMP_PASTE,
     TB_BMP_UNDO,
     TB_BMP_REDO,
     TB_BMP_DELETE,
     TB_BMP_FILENEW,
     TB_BMP_FILEOPEN,
     TB_BMP_FILESAVE,
     TB_BMP_PROPERTIES,
     TB_BMP_HELP,
     TB_BMP_FIND,
     TB_BMP_REPLACE,
     TB_BMP_PRINT
    );

    ToolbarButtonTypes  = (TbPushButton, TbToggleButton);

    ToolbarButtonInfo =
        RECORD
        image           : ADDRESS;(* non user field, for internal WinShell use.
                                     Win32 -> bitmap,  GTK -> GtkPixmap.
                                     should be inited to NIL
                                  *)
        actionId        : CARDINAL;(* menu id number *)
        textId          : CARDINAL;(* button label string resource id number *)
        helpId          : CARDINAL;(* tooltip string resource id number *)
        type            : ToolbarButtonTypes;
        CASE stdButton : BOOLEAN OF
        FALSE:
            bmpResName  : ARRAY [0..31] OF CHAR;(*bitmap resource name *)
        |
        TRUE:
            stdName     : StdToolbarBitmaps;
        END;
        END;

    WindowProcedure     = PROCEDURE(Window, MessageRec) : ResponseType;

    WindowNotification = (
                          WindowMinimized,
                          WindowMaximized,
                          WindowSized,
                          WindowMoved,
                          WindowClosed
                         );

    WindowNotifyProcedure = PROCEDURE((*w : *)Window,
                                      (*notify :*)WindowNotification,
                                      (*data : *)ADDRESS);
    (* this is the format of a window notification procedure.
       w = the window in question
       notify = the action that occured
       data = user data.
    *)

    HostSystem  = (
                   Windows,(* Windows95, Windows98, Windows ME,
                              Win32s, WindowsCE *)
                   WindowsNT,(* Windows NT/2000/XP *)
                   GTK
                  );

VAR
    MainWindow          : Window;
    (* this value is initialied with the first TopLevel or MdiFrame
       window created. You may assign your own value to this.
       This value is used by DlgShell.GetDialogParent().
    *)

    StartupDisplayMode  : DisplayModes;(* the display mode the user
                                          requested the application be started
                                          in *)

    Host                : HostSystem;
    HostMajorVersion    : CARDINAL;(* Win32s = 3
                                      Windows95, Windows98 = 4
                                      Windows ME = ? 4
                                      WindowsCE = ?
                                      WindowsNT = 3, 4
                                      Windows2000/XP = 5
                                      *)
    HostMinorVersion    : CARDINAL;(* Win32s = 10 for 3.10
                                      Windows95 = 0 for 4.0
                                      Windows98 = 10 for 4.10
                                      WindowsME = ?
                                      WindowsCE = ?
                                      WindowsNT = 50 for 3.50
                                                  51 for 3.51
                                                  00 for 4.00
                                      Windows2000 = 00
                                      WindowsXP =
                                      *)

    UnicodeSupported    : BOOLEAN;

    ScreenInfo          : ScreenMetrics;

PROCEDURE SetResourceFile(name : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE GetResourceFile(VAR OUT name : ARRAY OF CHAR);
(* for Win32 name = "" means the resources are in the executable,
  otherwise it is some DLL and a .dll extension is provided if not
  supplied.

  for Gtk it specifies the base path and name for various resource files.
  the various resource files are identified by file extension.
  .xml file contains menus, dialogs and accelerators
  .str file contains a string table
  .img file contains bitmaps
*)

TYPE
    IdleResults         = (ContinueIdle, SuspendIdle, TerminateIdle);
    IdleProcType        = PROCEDURE((*userdata*)ADDRESS,
                                    (*count*)CARDINAL) : IdleResults;
                        (* count is the number of times the idle procedure.
                           has been called in the current idle cycle.
                           userdata is arbitrary user data
                           *)

PROCEDURE AddIdleProcedure(idle : IdleProcType; data : ADDRESS) : CARDINAL;
(* add an idle procedure to the system.
   the return value identifies the idle procedure for removal.
   a return value of zero indicates failure.
   the idle procedure will be called when no messages are pending for the
   input thread.
   the idle procedure will be repeatedly called while no messages are being
   received and the idle procedure returns ContinueIdle.
   if it returns SuspendIdle then it will not be called until the next idle
   cycle. an idle cycle is the idle period between receiving messages.
   if it returns TerminateIdle the idle handler is removed from the system.
*)

PROCEDURE RemoveIdleProcedure(id : CARDINAL);
(* remove a previously installed idle procedure *)

PROCEDURE DispatchMessages() : CARDINAL;
(* any thread that has windows must have a message dispatch loop.
   a dispatch loop just loops forever sending messages to the appropriate
   window in the thread. A window is attached to a specific thread. this
   thread is the thread the window was created in. A thread will only
   receive messages for windows created within itself.
   this is why each thread that creates windows needs a dispatch procedure
   call.
   message boxes and modal dialogs do not count as "windows" for this
   definition since they create their own temporary message dispatch loop.
   this procedure contains a message dispatch loop. This procedure never
   returns until the message loop is terminated.
   A message dispatch loop is terminated with a call to
   TerminateDispatchMessages. The return value from this procedure is
   the value passed to TerminateDispatchMessages.

   you can create your own temporary dispatch loops in a thread that
   already has a dispatch loop. Remember that TerminateDispatchMessages
   only terminates the most recent call to DispatchMessages.
*)

PROCEDURE CheckMessages() : BOOLEAN;
(* many times you perform tasks that will take a reasonable amount of time
   so that the user interface will not become unresponsive you can call
   this procedure to dispatch any messages that are already sitting
   in the message queue. If no messages are available this procedure
   returns.
   If this function returns TRUE it means that the message loop has received
   a "quit" message and the dispatch loop will be terminated.
*)

PROCEDURE WaitForAMessage();
(* this procedure does not return until there is at least one message
   waiting in the current threads message queue.
*)

PROCEDURE TerminateDispatchMessages(code : CARDINAL);
(* this procedure terminates a previous call to DispatchMessages
   code = an arbitrary value that DispatchMessages will return as
   its function result. You can use it as a result code
*)

PROCEDURE CreateWindow(windowType : WindowTypes;
                       parent : Window;
                       name : ARRAY OF CHAR;
                       menu : ARRAY OF CHAR;
                       icon : ARRAY OF CHAR;
                       wndProc : WindowProcedure;
                       attribs : WinAttrSet;
                       x, y : COORDINATE;
                       width, height : COORDINATE;
                       createParam : ADDRESS) : Window;
(* create a new window
   parent = the parent window of this window. Can be NIL.
            An owned is destroyed, CM_DICTATE, when its parent
            is destroyed.

            For Win32 owned windows are always displayed above
            the parent window. Owned windows are minimized when
            when the parent is minimized.

            For Gtk the parent is the window that is the leader
            in a window manager "group" of windows. Just what this means
            is dependent on the specific window manager in use.

            For MdiChild windows parent must be an MdiFrame window.

   name = the caption text of the window. if the window does not have a
          caption then this parameter is ignored. On MdiChild windows
          the caption is the window selection tab.

   menu = the menu for the window. Can be "", which means no menu.

   icon = the icon associated with this window. Can be "".
           For Win32 you should have both 16x16 and 32x32 icons in the icon
           set.
           For Gtk this parameter currently is ignored.

   wndProc = the window procedure

   attribs = the window attributes for the window

   x, y = the initial screen coordinates for the window to be displayed
          if a parameters is -1 then the operating system will choose
          a default location. these coordinates are relative to the
          origin to the screen

   width, height = the initial size of the window when created.
                   if a parameter is -1 the operating system will
                   choose a default size

   createParam = an arbitrary value you can use to pass information
                 to the window procedure of the window. this value is
                 passed in the WSM_CREATE message.

   For MdiChild windows Ctrl+Tab, Ctrl+Shift+Tab are accelerator keys to
   cycle through the various MdiChild windows.

   returns the window handle if success full, otherwise NIL
*)

PROCEDURE SetMdiTabPosition(w : Window; tabPos : MdiTabPosition);
(* set the position of the MDI child tabs.
   w must be an MDI frame window.
   the default tab position is MdiTabBottom.

   Win32
       Windows seems to have issues with changing from various tab positions.
       Changing between top and bottom works. Changing left/right to/from top/bottom
       does not work.
*)

PROCEDURE CycleActiveMdiChild(w : Window; direction : INTEGER);
(*
  w can be an MdiChild or MdiFrame window.
  if direction > 0 then the next MdiChild becomes the active child window.
  if direction < 0 then the previous MdiChild becomes the active child window.
*)

PROCEDURE ConvertMdiChildToTopLevel(w : Window);
(* convert the MdiChild window to a TopLevel window.
   if the frame window has a toolbar and/or statusline the new
   toplevel window will create copies of these for itself.
*)

PROCEDURE AddWindowNotify(w : Window;
                          proc : WindowNotifyProcedure;
                          data : ADDRESS) : BOOLEAN;
(* the passed procedure "proc" will be called when the window "w"
   has one of the notify actions occur.
   "data" is aribtrary data you can have passed to the close procedure.
   you can have multiple notify procedures attached to a window.
   returns TRUE if the notify procedure was added.
*)

PROCEDURE CloseWindow(w : Window; mode : CloseModes) : BOOLEAN;
(* close an existing window.
   mode = CM_REQUEST you are requesting that the window close.
          for example this can give a window a change to prompt for saving any
          unsaved changes and possibly aborting the close.
   mode = CM_DICTATE the window *WILL* be closed
   returns TRUE if the window is closing
*)

PROCEDURE CloseAllChildren(parent : Window; mode : CloseModes) : BOOLEAN;
(* the effect here is to call CloseWindow with the given close mode
   for all child windows of the given window.
   returns TRUE if all child windows were closed
*)

PROCEDURE DisplayMdiChildNumber(w : Window; yes : BOOLEAN);
(*
  w must be an MdiFrame window.
  yes = TRUE means that the Mdi child titles will be prefixed with a number 0-9.
        This corresponds to the position of the child in the frame window.
        This can be used in conjunction with the GetIthMdiChild API call.
        The 10th child and beyond will not have a number.
*)

PROCEDURE SetBackgroundAutoErase(w : Window; color : ColorValue);
(* this will have the window automatically erase any region that
   needs to be painted with a background color before any paint
   message is sent.
*)

PROCEDURE IsWindow(w : Window) : BOOLEAN;
(* is the window handle passed in w a valid window handle
   for example a window might have been closed and a copy of the window
   handle an application had stored somewhere may no longer be valid
   retuns TRUE if the window handle is valid
*)

PROCEDURE GetWindowType(w : Window) : WindowTypes;
(* return the window type for the specified window *)

PROCEDURE GetWindowParent(w : Window) : Window;
(* return the parent window *)

PROCEDURE GetIthMdiChild(w : Window; num : CARDINAL) : Window;
(* return the ith child in the list of child windows.
   the first child is number 0.
   child windows are ordered by the order of creation.
   hidden child windows are not considered by this procedure.
*)

PROCEDURE GetActiveMdiChild(w : Window) : Window;
(*
  w = an MDI frame window.
  the return value is the child window that is on top of all the
  other MDI child windows.
*)

PROCEDURE SetActiveMdiChild(w : Window);
(*
  w must be an MDI child window.
  set w to be the active MDI child window. this is the child that
  is on top of all the other MDI child windows.
*)

PROCEDURE SetMdiChildPosition(w : Window; index : CARDINAL);
(*
  set the position of the window in the child window selection tabs.
  0 = the "first" tab.
*)

PROCEDURE SetDisplayMode(w : Window; mode : DisplayModes);
(* set the display mode for the window identified by w *)

PROCEDURE GetDisplayMode(w : Window) : DisplayModes;
(* get the display mode for the window identified by w *)

PROCEDURE SetWindowEnable(w : Window; enabled : BOOLEAN);
(* enable/disable the window identified by w
   if enabled = TRUE then the window will be enabled, otherwise the window
   will be disabled
   A disabled window cannot receive any user interaction
*)

PROCEDURE IsMinimized(w : Window) : BOOLEAN;
(* retuns TRUE if the window identified by w is currently minimized *)

PROCEDURE IsMaximized(w : Window) : BOOLEAN;
(* retuns TRUE if the window identified by w is currently maximized *)

PROCEDURE ClientAreaIsClipped(w : Window) : BOOLEAN;
(* returns TRUE if the client area of the window identified by w is
   currently clipped by some other window.
   By clipped we mean that the entire client area is not visible.
*)

PROCEDURE GetForegroundWindow() : Window;
(* get the current window with input focus.
   if the focused window is not a window managed by this module
   the returned value will be NIL
*)

PROCEDURE SetForegroundWindow(w : Window);
(* makes the window the foreground window
  also makes the window have the keyboard input focus.

   depending on the underlying system this function may FAIL if the thread
   associated with the window is not the current foreground thread.
*)

PROCEDURE RepaintRect(w : Window; rect : wsRECT);
(* force the rectangle in rect to be repainted in the window identified by w *)
(* the repaint is queued, and not drawn immediately *)

PROCEDURE UpdateWindow(w : Window);
(* force any pending repaint messsages to be sent before this call returns *)

PROCEDURE GetClientSize(w : Window; VAR OUT width, height : COORDINATE);
(* get the size of the windows client area in screen coordinates *)

PROCEDURE SetClientSize(w : Window; width, height : COORDINATE);
(* set the size of the windows client area in screen coordinates
   the actual size of the window will likely be larger due to a caption,
   border, menus, scroll bars and other goodies
*)

PROCEDURE SetMinClientSize(w : Window; width, height : COORDINATE);
(* limit the window to a certain minimum client area size
   this does not effect the windows ability to be minimized.
*)

PROCEDURE SetMaxClientSize(w : Window; width, height : COORDINATE);
(* limit the window to a certain maximum client area size
   Such a window should probably not be capable of being maximized
*)

PROCEDURE SetWindowGrains(w : Window; width, height : COORDINATE);
(* use this procedure to limit the possible window sizes to values
   such that the client area will be an even multiple of width and height.

   this setting has no effect on a maximized, or minimized window.

   Gtk - not implemented
   Window managers have a geometry hints option but when I used this the
   Window manager(s)/X/Gtk freak out and strange things happen.
   Manual implemenation also had other wierd side effects.
*)

PROCEDURE GetWindowSize(w : Window; VAR OUT width, height : COORDINATE);
(* get the size of the window area in screen coordinates
   this includes the client area and all the other goodies.

   Gtk
       On X the border and caption title are not a part of a user window.
       they are the domain of the window manager.
*)

PROCEDURE SetWindowSize(w : Window; width, height : COORDINATE);
(* set the size of the window area in screen coordinates
   this includes the client area and all the other goodies.

   Gtk
       On X the border and caption title are not a part of a user window.
       they are the domain of the window manager.
*)

PROCEDURE GetWindowPos(w : Window; VAR OUT x, y : COORDINATE);
(* get the screen coordinates of the upper left corner of the window

   Gtk
       X and/or window managers have issues with this. The position retrieved
       seems to be interpreted differently than a when setting a window position.
*)

PROCEDURE SetWindowPos(w : Window; x, y : COORDINATE);
(* set the screen coordinates of the upper left corner of the window.

   Gtk
       X and/or window managers have issues with this. The position retrieved
       seems to be interpreted differently than a when setting a window position.
*)

PROCEDURE GetWindowDisplayInfo(w : Window; VAR OUT info : WindowDisplayInfo);
(* get the size a position information for the window
   this is useful for remembering the size and position of a window
   across multiple execution sessions
   if info.mode = SizeMinimized or SizeMaximized then the size and
   position information is the size and position information for the window
   when it is not minimized or maximized.

   Gtk
       X and/or window managers have issues with this. The position retrieved
       seems to be interpreted differently than a when setting a window position.
       On X the border and caption title are not a part of a user window.
       they are the domain of the window manager.
*)

PROCEDURE SetWindowDisplayInfo(w : Window; info : WindowDisplayInfo);
(* set the size and position information for the window.

   Gtk
       X and/or window managers have issues with this. The position retrieved
       seems to be interpreted differently than a when setting a window position.
       On X the border and caption title are not a part of a user window.
       they are the domain of the window manager.
*)

PROCEDURE CascadeWindow(cascadeThis, onThis : Window);
(* this positions the window 'cascadeThis' just below and to the right of the
   caption of the window 'onThis'.
   the window size is not altered
*)

PROCEDURE SetWindowTitle(w : Window; title : ARRAY OF CHAR);
(* set the caption text for the window
   if the window does not have a caption then nothing happens
   title must be null terminated.
*)

PROCEDURE SetWindowData(w : Window;
                        index : CARDINAL;
                        data : ADDRESS) : BOOLEAN;
PROCEDURE SetWindowDataNum(w : Window;
                           index : CARDINAL;
                           data : CARDINAL) : BOOLEAN;
(* this procedure will place the store the data in "data"
   into the window storage array position specified by index.
   index positions are from 0..31
   returns TRUE if successful
*)

PROCEDURE GetWindowData(w : Window;
                        index : CARDINAL) : ADDRESS;
PROCEDURE GetWindowDataNum(w : Window;
                           index : CARDINAL) : CARDINAL;
(* returns the data from the window storage array from the location
   index positions are from 0..31
   specified by index.
*)

PROCEDURE SetWindowIsBusy(w : Window; busy : BOOLEAN);
(* set the window to a "busy" state
   for each call with busy = TRUE, you must have a corresponding call
   with busy = FALSE to remove the busy state.
   this call changes the mouse cursor of the window to "busy" cursor
   generally an hourglass cursor.
   when the window reverts back to not busy, whatever the mouse cursor
   was before the window was busy is restored.
   generally you use this call when your user interface thread is performing
   a task that might take a while so you give the user some feedback
   with this call
*)

PROCEDURE RedirectMessage(w : Window; msg : MessageRec);
(* this call simply passes the message to the window specified.
   the window should be of the same thread as the window that received
   the message originally. Everything should work if not, but unforseen problems
   may occur.
*)

PROCEDURE SendUserMessage(w : Window;
                          userId : CARDINAL; userData : ADDRESS);
PROCEDURE PostUserMessage(w : Window;
                          userId : CARDINAL; userData : ADDRESS);
(* send a user message to a window
   the window receiving the message can be associated with any thread and
   need not be associated with the current thread.
   userId = arbitrary number
   userData = arbitrary data
   SendUserMessage waits for the message to be received and processed before returning.

   PostUserMessage send the message and return immediately.
   when using PostUserMessage you should not pass the address of local data
   in the item userData since it is not known when the other window
   will process the message and when the procedure that calls this API
   procedure ends the local data is invalidated.
   global variables, constants, and allocated memory can be safe to use
   for the userData item. "can be" because you can use safe memory in an
   unsafe manner.
*)

PROCEDURE IsUserMessageWaiting(w : Window;
                               userIdLow, userIdHigh : CARDINAL) : BOOLEAN;
(* returns TRUE if a user message within the range of userLow..userHigh
   is currently waiting in the message queue of the current thread
*)

PROCEDURE ClientToScreen(w : Window; VAR INOUT pt : wsPOINT);
(* convert client coordinates, in pt, of the given window to screen
   relative coordinates
*)

PROCEDURE ScreenToClient(w : Window; VAR INOUT pt : wsPOINT);
(* convert screen coordinates, in pt, to client relative coordinates for
   the given window. The returned coordinates can be negative.
*)

PROCEDURE GetCursorPos(w : Window; VAR OUT pt : wsPOINT);
(* get the screen coordinate position of the mouse cursor
   relative to the specified window client area
*)

PROCEDURE CreateStatusLine(w : Window; fmt : ARRAY OF INTEGER) : BOOLEAN;
(* add a status line to a window that does not have a status line.
   see SetStatusFormat for the meaning of the fmt parameter.
   returns TRUE if successfull.
   FALSE is returned if the window already has a status line, or
   some other error occurred.
*)

PROCEDURE RemoveStatusLine(w : Window);
(* if the window has a status line then remove the status line
   from the window
*)

PROCEDURE SetStatusFormat(w : Window; fmt : ARRAY OF INTEGER);
(* set the format of the status line
   each element in the fmt array defines a status line field.
   the numeric value in the field defines the number characters
   in size the field should be. The average character width is used to
   determine this size in screen coordinates.
   The last field can contain the value -1 which means
   the field will go all the way to the right side of the window.
   As a convenience if a MdiChild window is passed as the window
   parameter, the write will affect the parent window (MdiFrame).
*)

PROCEDURE WriteStatusField(w : Window;
                           field : CARDINAL;
                           text : ARRAY OF CHAR);
(* write the text given in txt to the field identified by field
   in the status line for the window w
   if the window does not have a status line nothing happens
   txt must be null terminated. if txt is too long for the defined size
   of the field the text will be clipped.
   As a convenience if a MdiChild window is passed as the window
   parameter, the write will affect the parent window (MdiFrame).
*)

PROCEDURE LoadToolbarBitmaps(VAR INOUT buttons : ARRAY OF ToolbarButtonInfo;
                             transparent : ColorValue) : BOOLEAN;
(* load the bitmaps for the toolbar buttons from the resource file.
   For standard bitmaps the stdButton = TRUE and stdName = the button.
   otherwise, the bitmap resource names are taken from bmpResName field.
   This call will not load a bitmap unless the image field is NIL,
   and the bmpResName field is <> "".

   transparent is the color in the bitmap that is to be "transparent", having the
   same color as the button background.
   The loaded bitmaps will be altered to make this so.
   if the transparent color does not exist in a bitmap then the bitmap is loaded
   unaltered without error.

   returns TRUE if successful, which means ALL bitmaps were loaded.
*)

PROCEDURE UnloadToolbarBitmaps(VAR INOUT buttons : ARRAY OF ToolbarButtonInfo);
(* unload the bitmaps for the toolbar buttons.
   if a button does not have a bitmap currently loaded that button is
   skipped.
*)

PROCEDURE CreateToolbar(w : Window;
                        buttons : ARRAY OF ToolbarButtonInfo;
                        hasText : BOOLEAN;
                        hasHelp : BOOLEAN;
                        canCustomize : BOOLEAN) : BOOLEAN;
(* create a toolbar for the given window.
   buttons = the buttons of the toolbar. this is ALL possible buttons.
             button bitmaps should be 24x24.
             this call does not use the bmpResId field of the button
             info record.
             the bitmap field must be initialized with the handle
             of your bitmap, or the value of a standard bitmap.
             Use SYSTEM.MAKEADR to create an address with the
             standard bitmap ordinal. MAKEADR(ORD(TB_BMP_CUT))
             You can use LoadToolbarBitmaps to load your bitmaps
             or you can load them via other means.
   hasText = TRUE the buttons will display text labels if available.
             FALSE only the bitmaps will be displayed.
   hasHelp = TRUE the buttons will display tooltip help popups if available
             FALSE the buttons will not display tooltips
   canCustomize = TRUE the toolbar will allow the user to customize the
                  buttons displayed and the order they are displayed.
                  You should fetch this information and save it so you can
                  remember the user preferred toolbar settings.
*)

PROCEDURE DestroyToolbar(w : Window);
(* destroy the toolbar for the window if it has one *)

PROCEDURE SetToolbarButtons(w : Window; fmt : ARRAY OF CARDINAL);
(* set which buttons from the list of available buttons will be
   displayed. The HIGH bound of the passed array determines the
   number of toolbar buttons.
   the numeric value if each array element specifies the ordinal index
   into the list of available buttons passed to CreateToolbar.
   if the window does not have a toolbar nothing happens
*)

PROCEDURE GetToolbarButtons(w : Window; VAR OUT fmt : ARRAY OF CARDINAL) : CARDINAL;
(* get the current buttons displayed and their layout.
   the returned value is number of buttons returned into the parameter
   fmt. you should  make sure fmt is big enough to hold all possible
   buttons so you will not lose information. the maximum number of buttons
   is known from the CreateToolbar procedure call.
   the numeric value if each array element specifies the ordinal index
   into the list of available buttons passed to CreateToolbar.
   if the window does not have a toolbar nothing happens.

   Win32
       the system toolbar control supports toolbar customization by the user
       with no interaction necessary on our part.
       the user customizes a toolbar by double clicking on an empty area in the tool
       bar. Windows displays a customization dialog the user interacts with.
   GTK
       no user customization is currently implemented.
*)

PROCEDURE IsToolbarButtonDown(w : Window; index : CARDINAL) : BOOLEAN;
(* is the button identified by index currenly in the down position.
   this call is only valid for TbToggle buttons
   a button must be shown before it can be toggled.
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if the button is shown and checked in the toolbar
*)

PROCEDURE IsToolbarButtonEnabled(w : Window; index : CARDINAL) : BOOLEAN;
(* is the button identified by index currently enabled
   returns TRUE means the button is active an can be pressed
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if the button is enabled in the toolbar
*)

PROCEDURE IsToolbarButtonShown(w : Window; index : CARDINAL) : BOOLEAN;
(* is the button identified by index currently shown
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if the button is shown in the toolbar
*)

PROCEDURE ToggleToolbarButton(w : Window;
                             index : CARDINAL;
                             down : BOOLEAN) : BOOLEAN;
(* set the toggled state of the button identified by index
   this call is only valid for TbToggle buttons
   down = TRUE means the button should be in the down position.
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if successful
*)

PROCEDURE EnableToolbarButton(w : Window;
                              index : CARDINAL;
                              enable : BOOLEAN) : BOOLEAN;
(* set the enabled state of the button identified by index
   enable = TRUE means the button should be enabled
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if successful
*)

PROCEDURE ShowToolbarButton(w : Window;
                            index : CARDINAL;
                            show : BOOLEAN) : BOOLEAN;
(* set the shown state of the button identified by index
   show = TRUE means the button should be shown
   index is the ordinal index into the button list array passed
   to CreateToolbar
*)

PROCEDURE CaretOn(w : Window);
(* turn the display of a text caret ON in the window.
   if the window is the input focus window then the caret will be
   displayed otherwise the caret is not displayed
*)

PROCEDURE CaretOff(w : Window);
(* turn the display of a text caret OFF in the window *)

PROCEDURE HideCaret(w : Window);
(* this call is not normally necessary.
   the caret must not be displayed when you paint to maintain a proper display.
   BeginPaint, and PAINT messages automatically hide/show the caret.
   this call is only necessary when using non transient window drawables,
   since in these cases you may not be using BeginPaint.
   HideCaret maintain a hide count therefore you must call ShowCaret
   once for each call to HideCaret.
*)

PROCEDURE ShowCaret(w : Window);
(* see HideCaret *)

PROCEDURE MoveCaretTo(w : Window; x, y : INTEGER);
(*
   move the text caret to a specific location
   the coordinates are client area relative
   the window need not have the caret turned on for this function
   to operate. the coordinates will be remembered
*)

PROCEDURE GetCaretPos(w : Window; VAR OUT x, y : COORDINATE);
(* fetch the current text caret position *)

PROCEDURE SetCaretType(w : Window; ct : CaretTypes; width, height : CARDINAL);
(* set the type and size of the caret for this window
   ct = the shape of the caret
   width, height = the width and height in screen coordinates of the caret
   the window need not have the caret turned on for this function
   to operate. the information will be remembered
*)

PROCEDURE SetScrollBarRange(w : Window;
                            which : WinAttr;
                            min : ScrollRange;
                            max : ScrollRange;
                            pageSize : ScrollRange);
(* set the range information for the given scroll bar in the given window
   which = which scroll bar
   min = the lower limit of the scroll bar range
   max = the upper limit of the scroll bar range
         if min = max then the scroll bar is remove or disabled
   pageSize = the size of a "page" in scroll bar range units.
   for example in a text file
    the range might be (min = 1) (max = 534) and (pageSize = 10)
    in this case the lower limit is always line number 1.
    the upper limit is the number of lines in the text file.
    pageSize is the most likely the size of the window in lines or one or two
        lines less than this.
    scroll bar ranges are whatever you what them to be
*)

PROCEDURE SetScrollBarRanges(w : Window;
                             minX : ScrollRange;
                             maxX : ScrollRange;
                             pageX : ScrollRange;
                             minY : ScrollRange;
                             maxY : ScrollRange;
                             pageY : ScrollRange);
(* like SetScrollBarRange except that you are setting the range for
   both the horizontal, X, and vertical, Y, scroll bars.
   See SetScrollBarRange
*)

PROCEDURE SetScrollBarPos(w : Window;
                          which : WinAttr;
                          pos : ScrollRange);
(* set the position of the scroll bar thumb
   which = which scroll bar
   pos = the position. (pos >= minRange) AND (pos <= maxRange)
*)

PROCEDURE GetScrollBarPos(w : Window;
                          which : WinAttr) : ScrollRange;
(* get the position of the scroll bar thumb
   which = which scroll bar
*)

PROCEDURE SetScrollDisableWhenNone(w : Window; yesH, yesV : BOOLEAN);
(* this procedure controls whether a scroll bar disappears or becomes
   disabled when the window is large enough to display the entire
   "document" and thus a scroll bar is not necessary.
   this sets the policy for both scroll bars, but each scroll bar
   acts independently regarding its own state.
   yes = TRUE means the scroll bar(s) will disable
         FALSE means the scroll bar(s) will disappear
   yesH = horizontal, yesV = vertical
   default = FALSE
*)

PROCEDURE SetWindowIcon(w : Window; icon : ARRAY OF CHAR) : BOOLEAN;
(*
   set the icon associated with the window
   the resource can have many icon formats and the most appropriate
   icon will be chosen depending on how the icon is going to
   be used by the system. generally 32x32 and a 16x16 16color icons should
   be provided at a minimum in the icon resource.

   Gtk
       not currently implemented.
*)

PROCEDURE SetWindowCursor(w : Window; typ : CursorTypes);
(* set the cursor type displayed when the mouse cursor is within the
   confines of the windows client area.
*)

PROCEDURE SetWindowMenu(w : Window;
                        menu : ARRAY OF CHAR) : BOOLEAN;
(* set/change the menu for the given window.
   menu = the menu resource. Can be "", which means no menu.
*)

PROCEDURE GetWindowMenu(w : Window) : MenuHandle;
(* get the menu handle for menu currently associated with the window
   the return value can be NIL if the window has no menu
*)

PROCEDURE SetMenuItemEnable(w : Window; id : CARDINAL; enabled : BOOLEAN);
(* set whether a menu item identified by id is enabled
   enabled = TRUE the menu item is enabled
             FLASE the menu item is disabled
*)

PROCEDURE GetMenuItemEnable(w : Window; id : CARDINAL) : BOOLEAN;
(* get whether a menu item identified by id is enabled
   returns = TRUE the menu item is enabled
             FLASE the menu item is disabled
*)

PROCEDURE SetMenuItemCheck(w : Window; id : CARDINAL; checked : BOOLEAN);
(* set whether a menu item identified by id has a check mark displayed
   in the menu
   checked = TRUE a check mark will be displayed
             FLASE no check mark will be displayed
*)

PROCEDURE GetMenuItemCheck(w : Window; id : CARDINAL) : BOOLEAN;
(* get the checked state a menu item identified by id
   returns = TRUE a check mark is displayed
             FLASE no check mark is displayed
*)

PROCEDURE SetMenuItemRadioCheck(w : Window;
                                first, last, set : CARDINAL);
(* similar to check menu item, however this identifies a group of
   menu items of which one is checked and the others are unchecked.

   first..last is the range of menu items in the radio group.
   set is the menu item in the group to be "checked".
*)

PROCEDURE GetMenuItemRadioCheck(w : Window; first, last : CARDINAL) : CARDINAL;
(* get the checked menu item in a radio menu item group
   returns 0 if some error occurs, or none are checked.
*)

PROCEDURE LoadMenu(w : Window;
                   menu : ARRAY OF CHAR;
                   popup : BOOLEAN) : MenuHandle;
(* load a menu resource identified by menu.
   the menu is associated with the identified window.
   the return value will be NIL if the resource does not exist
   or there was an error loading the resource.

   popup = TRUE if the menu being loaded is a popup menu.
           For Win32 the menu resource is loaded and the first menu
           is returned.
           For Gtk a popup menu resource is loaded.
*)

PROCEDURE DestroyMenu(VAR INOUT menuH : MenuHandle);
(* destroy a previously loaded menu resource *)

PROCEDURE GetSubMenu(menuH : MenuHandle; subMenu : CARDINAL) : MenuHandle;
(*
   get the menu handle of a sub menu within a menu
   can return NIL of the sub menu does not exist or there was an error
   the sub menu is identified by position in the menu, zero being first.

   for example if the menu bar shows
   File Edit Search

   Edit is ordinal position 1 in the main menu.
   You can continue on though the menu hierarchy if any hierarchy exists
   to get a menu handle for any menu within the hierarchy.
*)

PROCEDURE AppendMenuItemStr(w : Window;
                            menuH : MenuHandle;
                            str : ARRAY OF CHAR;
                            id : CARDINAL) : BOOLEAN;
(* append a new menu item to the menu identified by menuH
   str = the text of the menu. must be null terminated
   id = the id number used to identify the menu item.
   you can "underscore" a character in the menu for keyboard activation
   by preceeding the desired character with an underscore character ('_').
   returns TRUE is successfull
*)

PROCEDURE AppendMenuItemSeparator(w : Window; menuH : MenuHandle) : BOOLEAN;
(* append a new menu item to the menu identified by menuH
   the menu item appended is a menu separator
   this is usually a thin line drawn across the menu
   returns TRUE is successfull
*)

PROCEDURE DeleteMenuItemPosition(menuH : MenuHandle;
                                 pos : CARDINAL) : BOOLEAN;
(* remove a menu item from the menu identified by menuH
   pos = the ordinal position of the menu item starting at zero for the
         first item in the menu
*)

PROCEDURE PopupMenu(w : Window;
                    menu : ARRAY OF CHAR;
                    button : MouseButton;
                    x, y : COORDINATE);
(* display a popup menu at client coordinates x, y.
   the menu is identified the parameter menu.
   button = the button used to "open" the popup menu and thus when this
            button is released the menu will close.

   This call is modal, meaning the call does not return until the popup
   menu is closed.

   For Win32 the menu resource is loaded and the first menu is used.
   For Gtk a popup menu resource is used.
*)

PROCEDURE PopupMenuHandle(w : Window;
                          menu : MenuHandle;
                          button : MouseButton;
                          x, y : COORDINATE);
(* like PopupMenu except that the menu is identified by a MenuHandle.
   this allows you to modify the menu resource before displaying the menu
   See PopupMenu

   This call is modal, meaning the call does not return until the popup
   menu is closed.
*)

PROCEDURE LoadString(idNum : CARDINAL; VAR OUT str : ARRAY OF CHAR);
(*
  Load a string from the string resource file.
  the string is identified by idNum.
  str = "" if not successfull.
*)

PROCEDURE CreatePalette(colors : ARRAY OF ColorValue) : PaletteHandle;
(* create a color palette
   some screen displays are limited in the number of colors they
   can simultaneously display. this means that the color range is larger
   than the number of colors that can be displayed.
   what we are talking about here are 256 and 16(yuck) color displays.
   the number of colors in the palette is determined by the HIGH bound
   of the passed array
   the return value is the handle used for the palette.
   NIL is returned if the function did not succeed, or if display does
   not use palettes (16, 24 and 32 bit color modes).
*)

PROCEDURE DestroyPalette(VAR INOUT palette : PaletteHandle);
(* dispose of a previously created color palette
   no window should be using this palette or an error is likely to occur
   at some later point of execution
*)

PROCEDURE SetWindowPalette(w : Window; pal : PaletteHandle);
(* set a specific window to use a given color palette
   the window will set the palette into the system whenever necessary
   when the window is not the foreground window the colors displayed
   may not match those in the color palette depending on various factors
   in the system
*)

PROCEDURE OpenClipboard(w : Window) : BOOLEAN;
(* open the system clipboard and give ownership to the specified window
   returns TRUE is successful
   only a foreground window should make such a request, and then only
   on behalf of a users request

   Gtk
       on X systems the "clipboard" can be many different things and some programs
       may only support one type of "clipboard". X calls these "selections".
       This module defines its own selection, and also tries to use other selections
       to try and be compatible with as many programs as possible.
*)

PROCEDURE CloseClipboard(w : Window);
(* close and release ownership of the clipboard. *)

PROCEDURE EmptyClipboard(w : Window) : BOOLEAN;
(* empty all contents of the clipboard
   if the window does not own the clipboard the call will fail
   returns TRUE if the operation is successfull
*)

PROCEDURE ClipboardFormatAvailable(fmt : ClipboardFormat) : BOOLEAN;
(* returns TRUE if data of the given clipboard format is available
   in the clipboard.
   returns TRUE if the format is available, otherwise FALSE if the
   clipboard is empty or some other data type is available.
   all text formats are automatically converted to other text formats
   on demand. Therefore if you put ASCII into the clipboard you can
   retrieve Unicode from the clipboard.
*)

PROCEDURE AllocClipboardMemory(size : CARDINAL) : ADDRESS;
(* allocate and lock system memory suitable for placing in the clipboard
   size = the amount of memory in bytes
   if NIL is returned the call failed, otherwise a valid address is returned.

   Win32
       the operating system will deallocate this memory for you since you
       cannot know how long the data will exist in the clipboard.
   Gtk
       Data put into the clipboard is only available to other programs as long
       as your process is running.
*)

PROCEDURE UnlockClipboardMemory(data : ADDRESS);
(* unlock locked clipboard memory.
   memory must be unlocked before placed into the clipboard.
   clipboard memory received must be unlocked after it is used.
*)

PROCEDURE SetClipboard(fmt : ClipboardFormat;
                       data : ADDRESS;
                       amount : CARDINAL) : BOOLEAN;
(* place data, identified by data, into the clipboard
   the format of the data is given in fmt parameter
   the data MUST be unlocked before setting into the clipboard.
   the memory is automatically freed by the system.
   returns TRUE if successfull *)

PROCEDURE GetClipboard(fmt : ClipboardFormat) : ADDRESS;
(* get clipboard data of the given format.
   returns NIL if the format was not available or the clip board was empty.
   otherwise a valid address is returned and the data is locked.
   you MUST unlock the data when you are done reading the data.
   all text formats are automatically converted to other text formats
   on demand. Therefore if you put ASCII into the clipboard you can
   retrieve Unicode from the clipboard.
   text formats are returned null terminated.
*)

PROCEDURE SetTimer(w : Window; timerId : CARDINAL; interval : CARDINAL);
(* create/reset a timer associated with the specified window
   timerId = a unique number to identify the timer.
   interval = the amount of time in milliseconds between WSM_TIMER messages
              this interval is only an approximate time
   calling SetTimer with the same timerId as a previous call but with
   a different interval has the effect of resetting the interval from
   the previous value to the new value *)

PROCEDURE KillTimer(w : Window; timerId : CARDINAL);
(* dispose of a previously created timer
   timerId = the identification number of an existing timer *)

PROCEDURE Beep(beep : Beeps);
(* make a sound on the computer.
   beep = various sound signatures. what these sounds sound like is defined
          by the user on their machine
*)

PROCEDURE PointInRect(x, y : COORDINATE; rect : wsRECT) : BOOLEAN;

PROCEDURE IntersectRect(r1, r2 : wsRECT; VAR OUT r3 : wsRECT) : BOOLEAN;

PROCEDURE RectOverlap(r1, r2 : wsRECT) : BOOLEAN;

PROCEDURE UnionRect(r1, r2 : wsRECT; VAR OUT r3 : wsRECT);

PROCEDURE OffsetRect(x, y : COORDINATE; VAR INOUT rect : wsRECT);

PROCEDURE RgbToColorValue(red, green, blue : CARDINAL8) : ColorValue;
(* take the separate red, green and blue color components and
   create a composite color value
*)

PROCEDURE ColorValueToRgb(colorVal : ColorValue;
                          VAR OUT red, green, blue : CARDINAL8);
(* break a compositie color value into its various components *)

PROCEDURE GetSystemColor(sysColor : SystemColors) : ColorValue;
(* return a color value for the system color *)

PROCEDURE LoadFont(font : FontInfo) : FontHandle;
(* load the font as specified by the parameter font *)
(* returns a valid font handle if successfull, otherwise NIL *)

PROCEDURE DeleteFont(font : FontHandle);
(* remove a previously loaded font *)

PROCEDURE GetTextMetrics(font : FontHandle; VAR OUT metrics : TextMetrics);
(* retrieve information about the font specified in the font parameter *)

PROCEDURE LoadBitmap(name : ARRAY OF CHAR; shared : BOOLEAN) : BitmapHandle;
(*
  Load a bitmap from resource.

  IF shared = TRUE, loaded bitmaps will be cached and on subsequent
  loads the bitmap handle of the first load will be returned.

  You should call DeleteBitmap when you are done using the bitmap.
  If shared = TRUE then the bitmap will not be freed until
  DeleteBitmap is called once for each active Load.
*)

PROCEDURE LoadBitmapFromFile(name : ARRAY OF CHAR) : BitmapHandle;
(*
  as LoadBitmap except the image is loaded from a stand alone file.
*)

PROCEDURE CreateBitmap(w : Window; width, height : CARDINAL) : BitmapHandle;
(*
  create a bitmap compatible with the window.
  The bitmap can be used with any Drawable that it is compatible with,
  meaning the color depth.
*)

PROCEDURE GetBitmapSize(bmp : BitmapHandle; VAR OUT width, height : CARDINAL);
(*
   return the width and height of the specified bitmap.
   returns 0 if bmp is not a valid bitmap handle.
*)

PROCEDURE ExtractBitmap(bmp : BitmapHandle;
                        x, y : COORDINATE;
                        width, height : CARDINAL) : BitmapHandle;
(*
    this function creates a new bitmap from a portion of another
    bitmap.
    This can be usefull with buttons for toolbars. Since these are
    small bitmaps and there are usually many buttons, it can be
    nice to edit all off the buttons in one larger bitmap.
    This function can be used to extract the individual bitmaps
    from the large bitmap button array.
*)

PROCEDURE DeleteBitmap(bmp : BitmapHandle);
(* delete a previously loaded/created bitmap.
  For shared bitmaps the bitmap will not be freed until
  DeleteBitmap is called once for each active Load.
*)

PROCEDURE CreateDrawContext(w : Window;
                            dcValues : DrawContextValues) : DrawContext;
(* create a new DrawContext. the context will be compatigble with
   the passed Window, w. You can use the context with other windows
   as long as the windows use the same color depth.
   If you wish to associate a Palette with a window you should do so
   before using this call, so the DrawContext, will note the change.

   Normally it is not possible to have windows with differing color
   depths. However different windows may have different palettes.
   Palettes are only used for <= 256 color displays.
*)

PROCEDURE DestroyDrawContext(VAR INOUT dc : DrawContext);
(* dispose of a previously created DrawContext.
   The context must not be selected into any Drawable.
*)

PROCEDURE SetDrawContextValues(dc : DrawContext;
                               dcValues : DrawContextValues);
(* set the values associated with the DrawContext. *)

PROCEDURE GetDrawContextValues(dc : DrawContext; VAR OUT dcValues : DrawContextValues);
(* get the values associated with the DrawContext. *)

PROCEDURE SetForegroundColor(dc : DrawContext; color : ColorValue);
(* set the foreground color used for painting *)

PROCEDURE SetBackgroundColor(dc : DrawContext; color : ColorValue);
(* set the background color used for painting *)

PROCEDURE SetFont(dc : DrawContext; font : FontHandle);
(* set the font as the font used for painting text *)

PROCEDURE SetTextExtraSpacing(dc : DrawContext; extra : INTEGER);
(* this alters the normal character spacing of the text written
   a positive value adds space (pixels) between each character drawn
   a negative value removes space.
*)

PROCEDURE SetTextDrawOrigin(dc : DrawContext; origin : TextDrawOrigin);
(*
  Sets the text origin of text drawing operations.
  See the comments at the TextDrawOrigin type declaration.
*)

PROCEDURE SetLineWidth(dc : DrawContext; width : CARDINAL);
(* set the line width *)

PROCEDURE SetLineAttributes(dc : DrawContext;
                            join : JoinStyles;
                            endCap : EndCaps;
                            width : CARDINAL);
(* set all line attributes *)

PROCEDURE BeginPaint(w : Window; dc : DrawContext) : Drawable;
(* use this to obtain a Drawable for the specific window.
   the DrawContext, dc, is selected into the returned Drawable.
   when you are finished painting you must call EndPaint which releases
   any system resources allocated by this call.

   this call will automatically hide the text caret if active.

   when you receive a PAINT message you can use the Drawable passed
   in the paint message, therefore you do not need this call in that
   circumstance, however you will need to select a DrawContext into
   the paint Drawable.
*)

PROCEDURE EndPaint(w : Window);
(* call this when you are done painting to a window.
  this call is the book end to the BeginPaint call.
  The Drawable returned by the BeginPaint call is invalid after this call.
  Any DrawContext selected into the Drawable is automatically deselected.
  This call will show the text caret if the window has an active caret.
*)

PROCEDURE CreateOffscreenDrawable(w : Window;
                                  width, height : CARDINAL;
                                  context : DrawContext) : Drawable;
(* create a Drawable where all draw operations are drawing into
   a offscreen bitmap.  The Drawable is compatible with the given window.

   The size of the Drawable is width and height. If width or height are
   zero then the Drawable size for that dimension is set to the current size
   of the client area of the Window.

   Normally it is not possible to have windows with differing color
   depths. However different windows may have different palettes.
   Palettes are only used for <= 256 color displays.
*)

PROCEDURE CreateBitmapDrawable(bmp : BitmapHandle;
                               context : DrawContext) : Drawable;
(* create a Drawable where all draw operations are drawing into the specified bitmap.

   Use this to draw a bitmap onto another drawable, or to draw into
   the bitmap itself.
   The size of this drawable is the size of the bitmap.
*)

PROCEDURE ChangeDrawableBitmap(draw : Drawable; bmp : BitmapHandle);
(*
  changes the bitmap associated with the existing bitmap drawable.
  if the drawable is not a bitmap drawable then this procedure
  takes no action.
*)

PROCEDURE DestroyDrawable(draw : Drawable);
(*
  Delete a previously created Drawable.
  Do not use this call with a Drawable returned by BeginPaint or the Drawable
  passed in the WSM_PAINT message.
*)

PROCEDURE SelectDrawContext(draw : Drawable; context : DrawContext);
(* associate the DrawContext with the Drawable, draw.
   any previously selected DrawContext is deselected.
*)

PROCEDURE GetTextWidth(draw : Drawable;
                       text : ARRAY OF CHAR;
                       length : CARDINAL) : CARDINAL;
(* this calls returns the width of the text in pixels when drawn.
   the number of characters measured is length.
   if length = 0 the the number of characters measured is LENGTH(text)
   the font currently selected for drawing is used for the measurement.
   The SetTextExtraSpacing API procedure affects this call.
*)

PROCEDURE DrawText(draw : Drawable;
                   x, y : COORDINATE;
                   text : ARRAY OF CHAR;
                   length : CARDINAL);
(* draw text at the coordinates x, y
 length = the number of characters drawn
 if length = 0 then the number of characters draw is LENGTH(text)
 the text is drawn in the foreground color.
 the text is drawn transparently over the background.
*)

PROCEDURE DrawTextRect(draw : Drawable;
                       x, y : COORDINATE;
                       text : ARRAY OF CHAR;
                       length : CARDINAL;
                       rect : wsRECT;
                       flags : DrawTextOptionSet);
(* draw text at the coordinates x, y
   length = the number of characters drawn
   if length = 0 then the number of characters drawn is LENGTH(text).
   the text is drawn in the foreground color.
   the rectangle specifies the rectangle that is used for clipping and/or filling.
   flags specifies options for drawing.
*)

PROCEDURE DrawLine(draw : Drawable;
                   x1, y1, x2, y2 : COORDINATE);
(* draw a line from x1,y1 to x2,y2 in the current foreground color
   and line attributes.
*)

PROCEDURE DrawLines(draw : Drawable; points : ARRAY OF wsPOINT);
(* draw a series of connected lines starting at the first point
   and ending at the last point.
   the line is drawn in the current foreground color, and line attributes.
*)

PROCEDURE DrawRectangle(draw : Drawable;
                        x, y : COORDINATE;
                        width, height : CARDINAL;
                        filled : BOOLEAN);
(* draw the rectangle with the foreground color.
   if filled = FALSE  then the rectangle outline is drawn with
   the current line attributes.
   example x=0,y=0,width=20,height=20
   the coordinates of the drawn rectangle are
   upper left (0, 0), and lower right (19, 19)
*)

PROCEDURE EraseRectangle(draw : Drawable;
                         x, y : COORDINATE;
                         width, height : CARDINAL);
(* as DrawRectangle, except the rectangle is filled with the background color.
*)

PROCEDURE DrawPie(draw : Drawable;
                  x, y : COORDINATE;
                  radius : CARDINAL;
                  startAngle, sliceWidth : REAL;
                  filled : BOOLEAN);
(* draw a pie slice within in the foreground color.
   x, y define the center of the circle the pie slice is a part of.
   radius is the radius of the circle.
   startAngle and width define the size of the pie slice.
   a startAngle value of zero begins at the 3 o'clock position and increasing
   values go in the counter clockwise direction.
   the angle values are specified in degrees.
   width is the number of degrees of the pie slice and must be <= 360.0.
   if filled = FALSE then the pie outline is drawn with
   the current line attributes.
*)

PROCEDURE CopyDrawableArea(destDraw : Drawable;
                           destX, destY : COORDINATE;
                           srcDraw : Drawable;
                           srcX, srcY,
                           width, height : COORDINATE);
(* this call copies a reqion from one drawable to another.
   you may use the same drawable for both the source and destination.

   The for a window, it should not be clipped,
   otherwise you may be copying other windows.
   See the ClientAreaIsClipped API call.
   The UpdateWindow API call can be useful before issuing this call with Window
   drawables as the source.
*)

PROCEDURE InitHtmlHelp;
(*
   On Win32 this initializes support for using the HtmlHelp API.
   On Gtk this call does nothing.
*)

PROCEDURE DisplayHelp(w : Window;
                      command : HelpCommand;
                      helpFile : ARRAY OF CHAR;
                      helpIndex : CARDINAL) : BOOLEAN;
(* call the operating system help program
   helpFile = the file specification of the help file to be opened
   helpIndex = help topic number within the given help file
   command = what you want the help program to do
       HelpTopic        open help to a specific topic.
       HelpContents     open help in table of contents (Win32 only)
                        helpIndex is ignored in this case


   Win32.
   All features are available.
   On Windows you can use WinHelp or HTML help. WinHelp is used unless
   InitHtmlHelp is called.

   GTK+
   command and helpIndex are ignored.
   helpFile is assumed to be an HTML file and an HTML browser is executed for
   the specified file.
*)

PROCEDURE BooBox(a : ARRAY OF CHAR);
(* just a quick and dirty way to display a simple message box
   can be used for diagnostic messages *)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

(* functions that export native operating system values
   these functions are not part of the WinShell API
   they are here to allow "special" actions to be performed when necessary
   and to allow someone to provide additional operating system
   encapsulation in a separate module from this one *)

PROCEDURE GetWindowHandle(w : Window) : ADDRESS;
(* get the operating system handle for window specified *)

PROCEDURE GetClientHandle(w : Window) : ADDRESS;
(* get the operating system handle for the client window
   of the specified window. *)

PROCEDURE GetDrawableHandle(draw : Drawable) : ADDRESS;
(* for Win32 - return the HDC handle associated with the drawable.
   for GTK - return the GDK drawable handle
*)

%IF WIN32 %THEN
PROCEDURE SetModelessDialog(wnd : ADDRESS; add : BOOLEAN) : BOOLEAN;
(* This procedure is here to support DlgShell in Win32
   wnd = the operating system window handle of the modeless dialog
   add = TRUE then you are adding a new dialog to the message loop
         FALSE then you are remove a dialog from the message loop
   returns TRUE if successful
*)
%END

END WinShell.
