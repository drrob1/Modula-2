DEFINITION MODULE BasicDialogs;
(* This module provides a host of basic dialogs common for various
   simple tasks where it would be useful to have something that is
   ready to go without the need for writing code.

   The parent window of all dialogs is the value returned by
   DlgShell.GetDialogParent()
*)
(* about threads
   Win32 - you may use the GUI features in a fully multi threaded
           manner.

   Gtk - Only one thread, the main thread, may use the GUI features.
*)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

FROM WinShell IMPORT
    FontInfo, PrintDriverInfo;

TYPE
    MessageTypes        = (MsgInfo,
                           MsgQuestion,
                           MsgWarning,
                           MsgAppError,
                           MsgException);

    PromptListWidth     = (NormalListWidth, WideListWidth);

VAR
    MessageTitle        : ARRAY [0..79] OF CHAR;
    (* The title bar for all dialogs not specifically specifying a title *)

    WasSystemMessageBox : BOOLEAN;
    (* Only Applicable to Win32.
       TRUE if a system dialog box was just displayed.
       This is useful when using the WSM_ACTIVATEAPP, WSM_DEACTIVATEAPP message.
       This lets you know that the foreground loss was just due to a
       system message box and not the user clicking away from the application.
    *)

(* the parent of all dialogs is DlgShell.GetDialogParent() *)

PROCEDURE MessageBox(mess : ARRAY OF CHAR; msgType : MessageTypes);
(* displays mess in a system message box
   the message box will have a single "ok" button
   carriage return/line feeds are allowed in the string and are
   correctly processed.
   msgType determines what type of ICON and sound are used when the
   message box is displayed.
   The MsgException type also displays the exception address in the dialog.
*)

PROCEDURE MessageBoxId(mess : CARDINAL; msgType : MessageTypes);
(* mess is a string resource identifier specifying the string
   to load from the resource and display in the message box.
   See MessageBox
*)

PROCEDURE YesNo(prompt : ARRAY OF CHAR; default : CHAR) : CHAR;
(* displays the prompt in a message box
   the message box will have a "yes" and "no" buttons
   if default = "Y" then the yes button will be the default button when
   the dialog opens otherwise the no button will be the default
   upon return the function will return "Y" or "N"
   "Y" is returned if the yes button is pressed
   "N" is returned if the no button is pressed
*)

PROCEDURE YesNoId(prompt : CARDINAL; default : CHAR) : CHAR;
(* prompt is a string resource identifier specifying the string
   to load from the resource and display in the message box.
   See YesNo
*)

PROCEDURE YesNoCancel(prompt : ARRAY OF CHAR;
                      default : CHAR) : CHAR;
(* displays the prompt in a message box
   the message box will have a "yes", "no" and "cancel" buttons
   if default = "Y" then the yes button will be the default button when
   the dialog opens, of default = "N" then the no button will be the default
   otherwise the cancel button will be the default button
   upon return the function will return "Y", "N" or "C"
   "Y" is returned if the yes button is pressed
   "N" is returned if the no button is pressed
   "C" is returned if the cancel button is pressed
*)

PROCEDURE YesNoCancelId(prompt : CARDINAL; default : CHAR) : CHAR;
(* prompt is a string resource identifier specifying the string
   to load from the resource and display in the message box.
   See YesNoCancel
*)

PROCEDURE OkCancel(prompt : ARRAY OF CHAR;
                   default : CHAR;
                   msgType : MessageTypes) : CHAR;
(* displays the prompt in a message box
   the message box will have a "ok" and "cancel" buttons
   if default = "O" then the ok button will be the default button when
   the dialog opens otherwise the cancel button will be the default button
   upon return the function will return "O" or "C"
   "O" is returned if the ok button is pressed
   "C" is returned if the cancel button is pressed
   msgType determines what type of ICON and sound are used when the
   message box is displayed.
*)

PROCEDURE OkCancelId(prompt : CARDINAL;
                     default : CHAR;
                     msgType : MessageTypes) : CHAR;
(* prompt is a string resource identifier specifying the string
   to load from the resource and display in the message box.
   See OkCancel
*)

PROCEDURE OpenBusyBox(prompt : ARRAY OF CHAR) : BOOLEAN;
(* opens a modeless dialog box.
   A return value of FALSE signifies failure.
   the dialog can display a single line of text, prompt, of a limited length.
   this is generally used when your application is performing a lengthy
   operation.
*)

PROCEDURE OpenBusyBoxId(prompt : CARDINAL) : BOOLEAN;
(* prompt identifies a string resource to retrieve the text to be
   displayed in the dialog.
   See OpenBusyBox
*)

PROCEDURE CloseBusyBox;
(* close a previously opened busy box dialog *)

PROCEDURE PromptString(prompt : ARRAY OF CHAR;
                       VAR INOUT response : ARRAY OF CHAR) : BOOLEAN;
(* open a modal dialog with a single edit field and a text label
   for the edit field contained in prompt.
   returns TRUE if the user enters text and presses OK, otherwise FALSE
   the text entered is contained in response
*)

PROCEDURE PromptStringId(prompt : CARDINAL;
                         VAR INOUT response : ARRAY OF CHAR) : BOOLEAN;
(* prompt identifies a string resource to retrieve the text to be
   displayed in the dialog.
   See PromptString
*)

PROCEDURE PromptPassword(prompt : ARRAY OF CHAR;
                         VAR INOUT response : ARRAY OF CHAR) : BOOLEAN;
(* same as the PromptString dialog except the text the user enters
   will be "greeked" and not be visible to anyone to looking at the screen
*)

PROCEDURE PromptPasswordId(prompt : CARDINAL;
                           VAR INOUT response : ARRAY OF CHAR) : BOOLEAN;
(* prompt identifies a string resource to retrieve the text to be
   displayed in the dialog.
   See PromptPassword
*)

PROCEDURE PromptCard(prompt : ARRAY OF CHAR;
                     min, max : CARDINAL;
                     allowZero : BOOLEAN;
                     VAR INOUT response : CARDINAL) : BOOLEAN;
(* open a modal dialog with a single edit field and a text label
   for the edit field contained in prompt.
   returns TRUE if the user enters a valid number and presses OK
   otherwise FALSE
   the number entered is contained in response
   min and max provide range checking for the number entered.
   if allowZero = TRUE then the number zero will be allowed even if outside
   the allowed number range. This can be used to allow the user to enter a
   "null" value.
*)

PROCEDURE PromptCardId(prompt : CARDINAL;
                       min, max : CARDINAL;
                       allowZero : BOOLEAN;
                       VAR INOUT response : CARDINAL) : BOOLEAN;
(* prompt identifies a string resource to retrieve the text to be
   displayed in the dialog.
   See PromptCard
*)

PROCEDURE PromptListStr(prompt : ARRAY OF CHAR;
                        VAR INOUT list : ARRAY OF CHAR;
                        listSep : CHAR;
                        VAR INOUT selStr : ARRAY OF CHAR;
                        listWidth : PromptListWidth) : BOOLEAN;
(* open a modal dialog with a single list box and a text label
   for the list field contained in prompt.
   returns TRUE if the user selects an item in the list and presses OK,
   or double clicks a list item.
   otherwise FALSE is returned.
   the item selected is contained in selStr. The value is the text of
   the item in the list.
   the list of items is contained in the parameter 'list'. Each item in the
   list is separated by the character listSep. The parameter list must be
   null terminated.
   If on entry selStr contains a value that matches an item in the list
   then that item will initially be selected, otherwise no item will be
   initially selected.
   listWidth specifies the size of the list box. Choose an appropriate size
   depending on the length of the list item strings.
   The list box will display a scroll bar when necessary.
*)

PROCEDURE PromptListStrId(prompt : CARDINAL;
                          VAR INOUT list : ARRAY OF CHAR;
                          listSep : CHAR;
                          VAR INOUT selStr : ARRAY OF CHAR;
                          listWidth : PromptListWidth) : BOOLEAN;
(* prompt identifies a string resource to retrieve the text to be
   displayed in the dialog.
   See PromptListStr
*)

PROCEDURE PromptListIndex(prompt : ARRAY OF CHAR;
                          VAR INOUT list : ARRAY OF CHAR;
                          listSep : CHAR;
                          VAR INOUT selIndex : CARDINAL;
                          listWidth : PromptListWidth) : BOOLEAN;
(* as PromptListStr except you specify the selection by position in the
   list starting with the value zero. Therefore the first item in the
   list has a value of zero and the second one, and so on.
   MAX(CARDINAL) signifies no selection
*)

PROCEDURE PromptListIndexId(prompt : CARDINAL;
                            VAR INOUT list : ARRAY OF CHAR;
                            listSep : CHAR;
                            VAR INOUT selIndex : CARDINAL;
                            listWidth : PromptListWidth) : BOOLEAN;
(* prompt identifies a string resource to retrieve the text to be
   displayed in the dialog.
   See PromptListIndex
*)

PROCEDURE PromptOpenFile(VAR INOUT name : ARRAY OF CHAR;
                         filters : ARRAY OF CHAR;
                         VAR INOUT defFilter : CARDINAL;
                         defDir : ARRAY OF CHAR;
                         defExt : ARRAY OF CHAR;
                         title : ARRAY OF CHAR;
                         createable : BOOLEAN) : BOOLEAN;
(* Opens an operating system common dialog for opening  a file
   filters specifies a list of file extension filters that are
   separated by semicolons.
   The format for filters is as follows.
   defDir = the default directory to start the dialog in
   an empty string "" means use the current directory.
   defExt = the default file extension to use if the user does not
   provide an extension. "" means no default extension.
   the extension should *not* have a leading '.' character.
   title = the caption text of the dialog. title can be empty "".
   in this case the default operating system title is used.
   If createable = TRUE then the file need not already exist, otherwise
   the file must exist for the dialog to return successful.
   RETURNs TRUE is successful and name will contain the file specification
   for the file the user has given.
*)

PROCEDURE PromptSaveAsFile(VAR INOUT name : ARRAY OF CHAR;
                           filters : ARRAY OF CHAR;
                           VAR INOUT defFilter : CARDINAL;
                           defDir : ARRAY OF CHAR;
                           defExt : ARRAY OF CHAR;
                           title : ARRAY OF CHAR;
                           overwritePrompt : BOOLEAN) : BOOLEAN;
(* As PromptOpenFile except this dialog is for saving a file.
   If overwritePrompt = TRUE then the user will be prompted when a file with
   the file name they enter already exists. They must answer yes to this
   dialog to continue and has this function return TRUE
*)

TYPE
    FontOptions = (FixedPitchOnly, NoStyle);
    FontOptionSet = PACKEDSET OF FontOptions;

PROCEDURE PromptChooseFont(VAR INOUT font : FontInfo;
                           opt : FontOptionSet) : BOOLEAN;
(* opens an operating system common dialog for selecting a font.
   RETURNs TRUE if successful and font will then contain the information
   describing the font the user selected. otherwise returns FALSE
   FixedPitchOnly if set will limit the font selections to fixed pitch
   fonts.
   NoStyle if set will not allow the user to select a font style
   such as Bold, Italic, etc..
   NoSize if set will not all the user to select a font point size
*)

TYPE
    PrintInfo =
        RECORD
        fromPage        : CARDINAL; (* in out *)
        toPage          : CARDINAL; (* in out *)
        minPage         : CARDINAL; (* in *)
        maxPage         : CARDINAL; (* in *)
        copies          : CARDINAL; (* in out *)
        selected        : BOOLEAN; (* in out *)
        duplex          : BOOLEAN; (* out *)
        collate         : BOOLEAN; (* in out *)
        driverInfo      : PrintDriverInfo; (* in out *)
        END;

PROCEDURE PromptPrint(VAR INOUT info : PrintInfo) : BOOLEAN;
(* opens an operating system common dialog for selecting a printer and
   various printer options for a specific print job.
   info contains the information to initialize the dialog fields
   an to also return the user entered information.
   Returns TRUE if the user does not cancel the dialog. In this case you
   continue by performing the print action the user has specified.
*)
(*
fromPage - initializes the dialog with the starting page to print, and upon
           return contains the starting page to print entered by the user.
           Normally initialized with 1. See toPage.
toPage - initializes the dialog with the ending page to print, and upon
         return contains the ending page to print entered by the user.
         If this value is initialized with 0 then the user will not be allowed
         to select a page range to print and no value is returned.
minPage - Only valid if toPage is initialized with a non zero value.
          The minimum page number the user will be allowed to enter in
          fromPage and toPage.
maxPage - Only valid if toPage is initialized with a non zero value.
          The maximum page number the user will be allowed to enter in
          fromPage and toPage.
copies - The number of copies to be printed. Normally initialized with a value
         of 1. Upon return the number of copies the user wants printed.
         If the printer driver supports multiple copies you will never
         reveive a value other than 1 upon return.
selected - If TRUE the user will be allowed to select if the current
           "selection" is to be printed, otherwise the entire document is
           assumed. Upon return TRUE means that the user wants only the
           selection to be printed.
duplex - Upon return if TRUE the document is to be printed two sided. This
         value can only be true if the printer supports duplex printing.
collate - If initialized with TRUE then the user will be allowed to select
          collated printing when printing multiple copies, otherwise they
          will not be allowed to make such a selection. Upon return the
          multiple copies of the document must be printed in a collated manner.
          It is up to you to do this since the printer driver does not have
          support doing this. If the printer driver supports collation you
          will never receive a value of TRUE.
driverInfo - This value may be initialized with NIL or a previously obtained
             value from PromptPrintSetup or this procedure.
             See PromptPrintSetup
*)

PROCEDURE PromptPrintSetup(VAR INOUT info : PrintDriverInfo) : BOOLEAN;
(* opens an operating system common dialog for setting up a printer and
   various custom printer options.
   Normally you will have a global variable that is initialized with a value
   of NIL and thereafter use that value. In this way your application will
   remember settings the user has made and not force them to reenter them
   every time they want to print.
   This value is usually passed to PromptPrint, although the user generally
   also has access to printer setup from the print dialog as well.
*)

PROCEDURE GetPrintDriverInfo(printerName : ARRAY OF CHAR;
                             VAR OUT info : PrintInfo) : BOOLEAN;
(* this procedure allows you to get print information if you know the
   system information detailing a printer driver
   this procedure exists for an application to support the operating system
   Print and PrintTo shell commands (right click and drag and drop). These
   commands are for files that are registered with the operating system.
   The operating system provides the first three parameters to you
   in the Print and PrintTo commands.
   If printerName = "" then the information for the default printer
   is returned.
   The function returns TRUE is successful
*)

END BasicDialogs.
=======================================================================================
DEFINITION MODULE TextWindows;
(* this module is its own self contained system built on top of WinShell *)
(* for convenience  this module re-exports most WinShell symbols by the *)
(* same name as they exist in WinShell *)
(* this module provides for very high level windows that display text *)
(* within their client area *)
(* this module fully automates painting and scroll bars for text windows *)
(* manual control is available for applications where automatic control *)
(* is not suitable *)

(*
   For automatic control this module defines a virtual coordinate system.
   For the purposes of this description we will use the analogy of a text
   editor, something you should be familiar with. Also we will only discuss
   the Y or vertical coordinate. The width or X coordinate operates precisely
   the same way as the Y.
   We have a text editor using this module. We open a file with 5000 lines
   of text. Also assume that the window is sized such that 25 lines of text
   can be displayed. Our virtual coordinate range for this file is 0..5000.
   We set a virtual coordinate range by using the SetScrollRangeAllowed
   API procedure.
   Zero always exists because of the possibility of an empty file.
   With this module our text editor never knows what exactly is being
   displayed in the window or exactly where the text caret(cursor) is
   positioned. It can inquire about this but there is no need.
   When open the file and put the text caret at position 1, 1.
   When we first open the file we will receive a paint message for coordinates
   1..25. If the user scrolls the window down one line we will get a paint
   message for coordinate 26. You should get the idea what is going on here.
   The text caret is still at position 1, 1 which is no longer visible in the
   window since the user scrolled the window down one line and the window
   is now displaying the coordinates 2..26.
   Lets say the user performed a text search and we need to display the
   matched text to the user. We simply set the text caret position to the
   proper virtual coordinate lets say line 2000, column 1 and then tell
   the text window system  to make sure the text caret is visible the
   window. That will cause the window to scroll to the proper virtual
   coordinates and you will receive a paint message for the coordinates
   2000..2025.
   The basic point here is that once a virtual coordinate is set up the
   text window asks you to paint certain coordinates, and it worries about
   what and where that information is displayed in the window. You have
   available to you certain API calls to make a given coordinate/range visible
   within the window if/when necessary. The chain of command here is
   the user tells the text window what to do
       the text window tells you what to do
*)
(*
  this module operates with three coordinate systems overlaid on top of
  each other.
  Virtual space >= Screen buffer space >= Visible window space
  this module maintains a "screen buffer" for each window to hold any text
  painted to minimize paint requests to your code when the operating system
  is asking the window to paint. this screen buffer can be a fixed size or
  it can assume whatever size fits within the visible area of the window.
  if the screen buffer is variable in size then in essence you fold down to
  two coordinate systems since the screen buffer and window are exactly the
  same size and at the same position.
  You only need to worry about the virtual coordinate space, but you should
  know something about the others to use a few of the API calls in this module.
  The screen buffer is basically a sliding window into the virtual coordinate
  space. The Visible window is a sliding window into the screen buffer
  coordinate space.

  If manual scrolling is used then these coordinate spaces have no real
  meaning since nothing ever moves in the coordinate space. You are always
  at the bottom of the coordinate space. You have to maintain your own
  information about where you are currently displaying in your "document".
*)

<*/NOPACK*>
%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

FROM SYSTEM IMPORT
    ADDRESS, CAST;

IMPORT WinShell;

TYPE
    (* text windows simply re-exports WinShell types and constants *)
    (* for convenience *)

    COORDINATE          = WinShell.COORDINATE;
    twPOINT             = WinShell.wsPOINT;
    twRECT              = WinShell.wsRECT;
    KeyStateType        = WinShell.KeyStateType;
    KeyStateSet         = WinShell.KeyStateSet;
    CloseModes          = WinShell.CloseModes;
    MouseButton         = WinShell.MouseButton;
    MouseEventType      = WinShell.MouseEventType;
    MouseStateType      = WinShell.MouseStateType;
    MouseStateSet       = WinShell.MouseStateSet;
    ScrollDirection     = WinShell.ScrollDirection;
    ScrollClass         = WinShell.ScrollClass;

    ScrollRange         = COORDINATE[0..MAX(COORDINATE)];

    SizeType            = WinShell.SizeType;
    WinAttr             = WinShell.WinAttr;
    WinAttrSet          = WinShell.WinAttrSet;

CONST
    TOOLBAR_SEPARATOR   = WinShell.TOOLBAR_SEPARATOR;

TYPE
    StdToolbarBitmaps   = WinShell.StdToolbarBitmaps;
    ToolbarButtonTypes  = WinShell.ToolbarButtonTypes;
    ToolbarButtonInfo   = WinShell.ToolbarButtonInfo;

    SpecialKeys         = WinShell.SpecialKeys;
    ResponseType        = WinShell.ResponseType;

    ClipboardFormat     = WinShell.ClipboardFormat;
    HelpCommand         = WinShell.HelpCommand;
    MenuHandle          = WinShell.MenuHandle;
    PaletteHandle       = WinShell.PaletteHandle;
    FontInfo            = WinShell.FontInfo;
    FontWeights         = WinShell.FontWeights;
    CharacterSets       = WinShell.CharacterSets;
    PrintDriverInfo     = WinShell.PrintDriverInfo;

    CursorTypes         = WinShell.CursorTypes;
    CaretTypes          = WinShell.CaretTypes;
    DisplayModes        = WinShell.DisplayModes;
    Beeps               = WinShell.Beeps;
    WindowDisplayInfo   = WinShell.WindowDisplayInfo;

CONST
    NormalWindow        = WinShell.NormalWindow;
    NormalMdiChildWindow= WinShell.NormalMdiChildWindow;

    AddVScrollBar       = WinAttrSet{WinShell.WA_VSCROLL,
                                     WinShell.WA_VSCROLLTRACK};
    AddHScrollBar       = WinAttrSet{WinShell.WA_HSCROLL,
                                     WinShell.WA_HSCROLLTRACK};
    AddScrollBars       = AddHScrollBar + AddVScrollBar;
    AddStatusLine       = WinAttrSet{WinShell.WA_STATUSLINE};

TYPE
    TextWindow;

    WindowTypes         = (TopLevel, MdiChild);

    ScreenAttribute     = CARDINAL16;(* magic cookie *)

    Cell = (* the format of an individual text character cell *)
        RECORD
        ch      : CHAR;
        attr    : ScreenAttribute;
        END;

    TextWindowsMsg      = (
                            TWM_CREATE,
                            TWM_GAINFOCUS,
                            TWM_LOSEFOCUS,
                            TWM_ACTIVATEAPP,
                            TWM_DEACTIVATEAPP,
                            TWM_MOUSE,
                            TWM_KEY,
                            TWM_CLOSE,
                            TWM_MENU,
                            TWM_MENUSELECT,
                            TWM_MENUSTART,
                            TWM_MENUEND,
                            TWM_MDIACTIVE,
                            TWM_PAINT,
                            TWM_SIZE,
                            TWM_POSITIONCHANGED,
                            TWM_SCROLL,
                            TWM_NOTIFYSCROLL,
                            TWM_TIMER,
                            TWM_USER
                          );

(******************** Message Definitions ************************************
    TWM_CREATE          same as WinShell
    TWM_GAINFOCUS       same as WinShell
    TWM_LOSEFOCUS       same as WinShell
    TWM_MDIACTIVE       same as WinShell
    WSM_ACTIVATEAPP     same as WinShell
    WSM_DEACTIVATEAPP   same as WinShell
    TWM_KEY             same as WinShell
    TWM_CLOSE           same as WinShell
    TWM_MENU            same as WinShell
    TWM_MENUSELECT      same as WinShell
    TWM_STARTMENU       same as WinShell
    TWM_ENDMENU         same as WinShell
    TWM_TIMER           same as WinShell
    TWM_USER            same as WinShell
    TWM_SCROLL          same as WinShell
    TWM_POSITIONCHANGED same as WinShell

    TWM_MOUSE           this window received a mouse event
        m_pos = Window Coordinates of click in text cells, not pixels
        m_button = Which button the event is for
        m_event = the type of event
        m_state = the state of various other keys at the time of the mouse event
        m_wheel = the mouse wheel movement. positive is forward towards the front
                of the mouse. This value is scroll increments.
                1 = one scroll increment

    TWM_PAINT           this window needs repainting
        paintRect = rectangle of region that needs to be painted
               this is in text cells, not pixels

    TWM_SIZE            the size of this window is/has changed
        sizeType = The type of sizing operation
        width = the new width in text cells, not pixels
        height = the new height in text cells, not pixels

            for variable buffer windows the size is changing and a
                paint message will follow this message
            for fixed buffer windows the size has changed
                can be used to set the page size

    TWM_NOTIFYSCROLL    notification that the window has automatically
                        scrolled in some way.

*****************************************************************************)

    TWMessageRec =
        RECORD
        CASE msg : TextWindowsMsg OF
        TWM_GAINFOCUS, TWM_LOSEFOCUS,
        TWM_MENUSTART, TWM_MENUEND,
        TWM_ACTIVATEAPP, TWM_DEACTIVATEAPP,
        TWM_MDIACTIVE,
        TWM_NOTIFYSCROLL:
            (* no data for these *)
        |
        TWM_CREATE:
            createParam : ADDRESS;
        |
        TWM_MOUSE:
            m_pos       : twPOINT;
            m_wheel     : INTEGER;
            m_button    : MouseButton;
            m_event     : MouseEventType;
            m_state     : MouseStateSet;
        |
        TWM_KEY:
            k_count     : CARDINAL;
            k_special   : SpecialKeys;
            k_state     : KeyStateSet;
            k_ch        : CHAR;
        |
        TWM_CLOSE:
            closeMode   : CloseModes;
        |
        TWM_MENUSELECT,
        TWM_MENU:
            menuId      : INTEGER;
            accel       : BOOLEAN; (* used only with MENU *)
        |
        TWM_PAINT:
            paintRect   : twRECT;
        |
        TWM_SIZE:
            sizeType: SizeType;
            width       : COORDINATE;
            height      : COORDINATE;
        |
        TWM_POSITIONCHANGED:
            windowPos   : WinShell.wsPOINT;
        |
        TWM_SCROLL:
            scrollDir   : ScrollDirection;
            scrollClass : ScrollClass;
            scrollPos   : ScrollRange;
        |
        TWM_TIMER:
            timerId     : CARDINAL;
        |
        TWM_USER:
            userId      : CARDINAL;
            userData: ADDRESS;
        END;
    END;

    TextWindowProcedure = PROCEDURE(TextWindow, TWMessageRec) : ResponseType;

    (* colors available in a text window *)
    Colors      = (
                    Black,
                    Blue,
                    Green,
                    Cyan,
                    Red,
                    Purple,
                    Brown,
                    DarkGray,
                    LightGray,
                    LightBlue,
                    LightGreen,
                    LightCyan,
                    LightRed,
                    Magenta,
                    Yellow,
                    White
                );

    (* font styles available in a text window *)
    FontStyles = (FsItalic, FsBold);
    FontStyleSet = PACKEDSET OF FontStyles;

    ColorValue  = WinShell.ColorValue;
    ColorTable = ARRAY Colors OF ColorValue;

CONST
    NormalFont  = FontStyleSet{};
    BoldFont    = FontStyleSet{FsBold};
    ItalicFont  = FontStyleSet{FsItalic};

    NullTextWnd = CAST(TextWindowProcedure, NIL);

VAR
    StartupDisplayMode  : DisplayModes;(* same as WinShell *)
    DefaultFontInfo     : FontInfo;(* the default font that a text window
                                      will use *)

PROCEDURE WinShellToTextWindowMessage(wmsg : WinShell.MessageRec;
                                      VAR OUT msg : TWMessageRec) : BOOLEAN;
(* convert a WinShell message to a TextWindow message *)
(* not all message types can be converted *)
(* returns TRUE if successful *)

PROCEDURE CreateWindow(windowType : WindowTypes;
                       parent : WinShell.Window;
                       name : ARRAY OF CHAR;
                       menu : ARRAY OF CHAR;
                       icon : ARRAY OF CHAR;
                       x, y : COORDINATE;
                       xSize, ySize : COORDINATE;
                       xBuffer, yBuffer : COORDINATE;
                       gutter : BOOLEAN;
                       font : FontInfo;
                       background : ScreenAttribute;
                       wndProc : TextWindowProcedure;
                       attribs : WinAttrSet;
                       createParam : ADDRESS) : TextWindow;
(* create a new window *)
(* parent = as WinShell  *)
(* name = as WinShell  *)
(* menu = the menu for the window. Can be "". *)
(* icon =  as WinShell *)
(* attribs = as WinShell *)
(* wndProc = the window procedure *)
(* createParam = an arbitrary value you can use to pass information
                 to the window procedure of the window. this value is
                 passed in the WSM_CREATE message. *)
(* font = the font to use for this window *)
(* background = the background color for this window *)
(* gutter = TRUE then the text window will always have a blank "gutter"
            on the left edge of the text window.
            FALSE the text will start at the left edge of the client area.
            *)
(* x, y = the initial screen coordinates for the window to be displayed
          if a parameter is -1 then the operating system will choose
          a default location for that coordinate.
          these positions are in pixels and are relative to the
          parent window client area origin for child windows
          or relative to the screen origin for all other windows. *)
(* xSize, ySize = the initial width and height in character cells
                  if -1 then a system default size will be used *)
(* xBuffer, yBuffer = the size of the screen buffer. the window can never
                      be larger than the screen buffer. if either xBuffer
                      or yBuffer is -1 the screen buffer is a variable size
                      and is sized to the number of cells the window client
                      area currently is capable displaying. *)
(* returns the window handle is successfull, otherwise NIL*)

PROCEDURE ConvertMdiChildToTopLevel(tw : TextWindow);
(* convert the MdiChild window to a TopLevel window.
   if the frame window has a toolbar and/or statusline the new
   toplevel window will create copies of these for itself.
*)

PROCEDURE CycleActiveMdiChild(tw : TextWindow; direction : INTEGER);
(*
  w must be an MdiChild window.
  if direction > 0 then the next MdiChild becomes the active child window.
  if direction < 0 then the previous MdiChild becomes the active child window.
*)

PROCEDURE CloseWindow(tw : TextWindow; mode : CloseModes) : BOOLEAN;
(* close an existing window. *)
(* mode = CM_REQUEST you are requesting that the window close.
          for example this can give a window a change to prompt for saving any
          unsaved changes and possibly aborting the close. *)
(* mode = CM_DICTATE the window *WILL* be closed *)
(* returns TRUE if the window is closing *)

PROCEDURE IsTextWindow(tw : TextWindow) : BOOLEAN;
(* is the window handle passed in tw a valid window handle *)
(* for example a window might have been closed and a copy of the window *)
(* handle an application had stored somewhere may no longer be valid *)
(* returns TRUE if the window handle is a valid text window *)

PROCEDURE GetTextWindowType(tw : TextWindow) : WindowTypes;
(* return the WindowType of the window *)

PROCEDURE SetWindowBackground(tw : TextWindow;
                              background : ScreenAttribute);
(* set the background color for the specified window *)

PROCEDURE GetWindowFont(tw : TextWindow; VAR OUT font : FontInfo);
(* get the font that is currently used by this window *)

PROCEDURE SetWindowFont(tw : TextWindow; font : FontInfo) : BOOLEAN;
(* set the font to be used for this window *)
(* returns TRUE if successful *)

PROCEDURE SetScrollRangeAllowed(tw : TextWindow;
                                which : WinAttr;
                                range : ScrollRange);
(* set the scroll range for the horizontal or vertical scroll bar *)
(* range is the upper end of the scroll range. the lower end is always zero. *)

PROCEDURE SetScrollRangesAllowed(tw : TextWindow;
                                 rangeX, rangeY : ScrollRange);
(* set the scroll range for both the horizontal and vertical scroll bar *)
(* rangeX and rangeY respectively. *)
(* rangeX and rangeY are the upper end of the scroll range. the lower end is
   always zero. *)

PROCEDURE SetPageSize(tw : TextWindow; x, y : ScrollRange);
(* set the granularity in character cells that a PAGE scroll *)
(* operation should move *)

PROCEDURE SetAutoScroll(tw : TextWindow; on : BOOLEAN);
(* windows are created with the scroll bars handled automatically *)
(* by this module, use this to disable and handle scroll bars manually *)
(* on = TRUE then scroll bars are handled by this module
             you will never receive a TWM_SCROLL message
             you will receive TWM_SCROLLNOTIFY messages when this module
             automatically scrolls the window
        FALSE then you will receive TWM_SCROLL messages and should perform
              appropriate actions for the messages
              you will not receive TWM_NOTIFYSCROLL messages *)

PROCEDURE SetMinClientSize(tw : TextWindow; x, y : COORDINATE);
(* set the minimum size in character cells the specified window *)
(* will be allowed to assume *)

PROCEDURE GetClientSize(tw : TextWindow; VAR OUT x, y : COORDINATE);
(* get the current size of the text area in character cells of the *)
(* specified window *)

PROCEDURE SetClientSize(tw : TextWindow; x, y : COORDINATE);
(* set the current size of the text area in character cells of the *)
(* specified window *)

PROCEDURE SnapWindowToFont(tw : TextWindow; on : BOOLEAN);
(* TRUE = window client area will be sized so that only full characters *)
(* will be shown *)
(* FALSE = the bottom and/or right may have partial characters shown *)

PROCEDURE ResizeScreen(tw : TextWindow; xSize, ySize : COORDINATE) : BOOLEAN;
(* resize the screen buffer for the specified window *)
(* if the window was create with -1 buffer size values this call has no *)
(* effect. therefore only use this call on windows with fixed screen buffers *)
(* returns TRUE is successful *)

PROCEDURE RedirectMessage(tw : TextWindow; msg : TWMessageRec);
(* this call simply passes the message to the window specified *)
(* the window should be of the same thread as the window that received *)
(* the message originally. Everything should work if not, but problems *)
(* may occur. *)

PROCEDURE ScrollWindow(tw : TextWindow;
                       dir : ScrollDirection;
                       class  : ScrollClass;
                       pos : ScrollRange;
                       amount : COORDINATE);
(* scroll the window by the specified amount an direction *)
(* dir can be LEFT, RIGHT, UP or DOWN *)
(* class can be LINE, PAGE, ABSOLUTE or EXTREME *)
(* pos is only used with a class of ABSOLUTE *)
(* amount is used with LINE and PAGE and specifies how may scrolls to do *)
(* ABSOLUTE is used with UP or LEFT and pos. Where pos specifies a *)
(*          absolute virtual coordinate for the upper left coordinate *)
(*          of the text window *)
(* EXTREME is used with an ScrollDirection and position the screen *)
(*         at the extreme edge of the virtual coordinate space *)

PROCEDURE ScrollBuffer(tw : TextWindow;
                       dir : ScrollDirection;
                       amount : CARDINAL);
(* scroll the data held in the screen buffer *)
(* the virtual coordinates of the screen buffer will not change *)
(* in manual scrolling the coordinates of the  screen buffer never  *)
(* change since it is your code that is handling this *)
(* use this call when performing manual scrolling *)
(* this call simply moves the data in the screen buffer and generates a *)
(* paint message to fill in the resulting empty space *)

PROCEDURE MoveCaretTo(tw : TextWindow; x, y : COORDINATE);
(* move the caret to the specified location in character cells *)
(* a window need not have a caret for this function to work. *)
(* the position is remembered and is used if/when the caret is turned on *)

PROCEDURE GetCaretPos(tw : TextWindow; VAR OUT x, y : COORDINATE);
(*
  get the current position of the text caret
*)

PROCEDURE IsCaretVisible(tw : TextWindow) : BOOLEAN;
(* is the caret visible (where the user can see it) within the current *)
(* window display *)
(* returns TRUE if the caret is visible *)
(* manual scrolling windows have no use for this call *)

PROCEDURE MakeCaretVisible(tw : TextWindow);
(* make sure the caret is visible within the current window display *)
(* any necessary scroll actions will be performed by calling *)
(* the ScrollWindow procedure *)
(* manual scrolling windows have no use for this call *)

PROCEDURE ComposeAttribute(fore, back : Colors;
                           style : FontStyleSet) : ScreenAttribute;
(* combine the various screen components into a screen attribute *)

PROCEDURE DecomposeAttribute(sc : ScreenAttribute;
                             VAR OUT fore, back : Colors;
                             VAR OUT style : FontStyleSet);
(* break a screen attribute into its various components *)

PROCEDURE PutStringAt(tw : TextWindow;
                      x, y : COORDINATE;
                      str : ARRAY OF CHAR;
                      a : ScreenAttribute);
(* write the string at the specified position in character cells *)
(* output will be clipped if the text is/extends outside the screen buffer *)
(* x, y = the coordinates of the first character of the string to paint *)
(* str = the string to paint *)
(* a = the screen attribute to use when painting the text *)

PROCEDURE PutAttrAt(tw : TextWindow;
                    x, y : COORDINATE;
                    attr : ARRAY OF ScreenAttribute);
(* write the attributes at the specified position in character cells *)
(* the text remains unaltered, only the attribute is written *)
(* output will be clipped if the attributes are outside the screen buffer *)
(* x, y = the coordinates of the first character of the string to paint *)
(* attr = the attribute string to paint. the HIGH bound of the array
          determines the number of attributes to paint *)

PROCEDURE WriteString(tw : TextWindow;
                      str : ARRAY OF CHAR;
                      a : ScreenAttribute);
(* write the string at the specified position in character cells *)
(* output will be clipped if the text is/extends outside the screen buffer *)
(* str = the string to paint *)
(* a = the screen attribute to use when painting the text *)
(* the text is written at the current caret position, and the x caret *)
(* position is advanced by the length of the string. *)

PROCEDURE WriteStringAt(tw : TextWindow;
                        x, y : COORDINATE;
                        str : ARRAY OF CHAR;
                        a : ScreenAttribute);
(* this call has the same effect as *)
(*
    MoveCaretTo(tw, x, y);
    WriteString(tw, str, a);
*)

PROCEDURE WriteCellsAt(tw : TextWindow;
                       x, y : COORDINATE;
                       s : ARRAY OF Cell);
(* this call is like PutStringAt except you are writing whole character *)
(* rather than a string all with the same attribute. *)
(* the number of cells to write is determined by the HIGH bound of the *)
(* array of cells passed *)

PROCEDURE WriteCells(tw : TextWindow; s : ARRAY OF Cell);
(* this call is like WriteCellsAt except output is to the *)
(* current caret position *)

PROCEDURE WriteLn(tw : TextWindow);
(* place the caret at the beginning of the screen buffer for the *)
(* X coordinate and advance the Y coordinate by one position *)
(* may cause the screen to scroll if the Y coordinate is at the bottom *)
(* of the screen buffer *)
(* the caret position is advanced by this call *)

PROCEDURE EraseToEOL(tw : TextWindow; a : ScreenAttribute);
(* erase to the end of the screen buffer with spaces and the attribute *)
(* specified from the current caret position *)
(* the caret position is advanced by the call *)

PROCEDURE ChangeAttr(tw : TextWindow;
                     y, x1, x2 : COORDINATE;
                     a : ScreenAttribute);
(* change the attributes from coordinate x1 to x2 on coordinate y*)
(* output will be clipped if the range is/extends outside the screen buffer *)

PROCEDURE ReadBufferString(tw : TextWindow;
                           y, x1, x2 : COORDINATE;
                           VAR OUT str : ARRAY OF CHAR);
(* read data from the screen buffer maintained for the specified window *)
(* read from coordinate y from coordinate x1 to x2 *)
(* place the data into the parameter string *)
(* if x1..x2 is larger than the size of str then the range x1..x2 is reduced *)
(* to the size of str *)
(* the string will be null terminated if x1..x2 is smaller than the size *)
(* the parameter str *)

PROCEDURE RepaintRect(tw : TextWindow; rect : twRECT);
(* send yourself a TWM_PAINT message for the specified rectangle *)
(* the rectangle will be clipped to the size of the screen buffer if *)
(* necessary *)

PROCEDURE RepaintScreen(tw : TextWindow);
(* send yourself a TWM_PAINT message for the entire screen buffer *)

PROCEDURE MakeRowVisible(tw : TextWindow; y : COORDINATE);
(* make the specified row, y coordinate, visible in the display window *)
(* you may receive TWM_PAINT, TWM_SCROLL or TWM_NOTIFYSCROLL messages as a *)
(* result of this call *)
(* manual scrolling windows have no use for this call *)

PROCEDURE IsRectVisible(tw : TextWindow; theRect : twRECT) : BOOLEAN;
(* returns TRUE if the entire specified rectangle visible in the window *)
(* manual scrolling windows have no use for this call *)

PROCEDURE MakeRectVisible(tw : TextWindow; theRect : twRECT);
(* make the specified rectangle visible in the window *)
(* you may receive TWM_PAINT, TWM_SCROLL or TWM_NOTIFYSCROLL messages as a *)
(* result of this call *)
(* if the rectange is larger than the current window size then as much *)
(* of the rectangle that can be made visible will be made visible *)
(* manual scrolling windows have no use for this call *)

PROCEDURE GetVisibleRect(tw : TextWindow; VAR OUT theRect : twRECT);
(* retrieve the rectangle currently visible in the window in *)
(* virtual coordinates *)
(* manual scrolling windows have no use for this call *)

PROCEDURE GetBufferRect(tw : TextWindow; VAR OUT theRect : twRECT);
(* retrieve the rectangle of the screen buffer in virtual coordinates *)
(* manual scrolling windows have no use for this call *)

PROCEDURE EraseScreen(tw : TextWindow; a : ScreenAttribute);
(* Erase the entire screen buffer with spaces and the given attribute *)

PROCEDURE EraseRect(tw : TextWindow; rect : twRECT; a : ScreenAttribute);
(* Erase the specified region with spaces and the specified attribute *)
(* output will be clipped if the rectangle is/extends outside the *)
(* screen buffer *)

PROCEDURE Xpos(tw : TextWindow) : COORDINATE;
(* the X coordinate of the caret position in virtual coordinates *)

PROCEDURE Ypos(tw : TextWindow) : COORDINATE;
(* the Y coordinate of the caret position in virtual coordinates *)

PROCEDURE Xorg(tw : TextWindow) : COORDINATE;
(* the X coordinate of the upper left corner of the screen buffer *)
(* in virtual coordinates *)
(* manual scrolling windows have no use for this call *)

PROCEDURE Yorg(tw : TextWindow) : COORDINATE;
(* the Y coordinate of the upper left corner of the screen buffer *)
(* in virtual coordinates *)
(* manual scrolling windows have no use for this call *)

PROCEDURE Xmax(tw : TextWindow) : COORDINATE;
(* the highest X coordinate of the screen buffer in virtual coordinates *)

PROCEDURE Ymax(tw : TextWindow) : COORDINATE;
(* the highest Y coordinate of the screen buffer in virtual coordinates *)

(* conversion routines to and from Virtual and Buffer coordinates *)
(* for example if you had an absolute screen coordinate and you wanted *)
(* to convert that to a text cell coordinate you would *)
(*
    WinShell.ScreenToClient(GetWinShellHandle(tw), pt);
    ClientToBuffer(tw, pt);
    BufferToVirtual(tw, pt);
*)
(* if you had a text window virtual coordinate and you wanted a screen pixel *)
(*
    VirtualToBuffer(tw, pt);
    BufferToClient(tw, pt);
    WinShell.ClientToScreen(GetWinShellHandle(tw), pt);
*)

PROCEDURE VirtualToBuffer(tw : TextWindow; VAR INOUT pt : twPOINT);

PROCEDURE BufferToVirtual(tw : TextWindow; VAR INOUT pt : twPOINT);

PROCEDURE ClientToBuffer(tw : TextWindow; VAR INOUT pt : twPOINT);
(* client pixel coordinates to text cell buffer coordinates *)

PROCEDURE BufferToClient(tw : TextWindow; VAR INOUT pt : twPOINT);
(* text cell buffer coordinates to client pixel coordinates *)

PROCEDURE GetCursorPos(tw : TextWindow; VAR OUT pt : twPOINT);
(* returns the cursor position in Virtual coordinates *)

PROCEDURE GetColorTable(VAR OUT table : ColorTable);
(* get the table of colors used by this module *)
(* the table associates the color enumeration this module uses *)
(* with the RGB color information the operating system uses *)

PROCEDURE GetColorPalette() : PaletteHandle;
(* get the handle of the color palette used by this module. *)
(* the palette can be NIL, if no palette is necessary *)

PROCEDURE PaintOff(tw : TextWindow);
(* function for turning off the updating of the display per "write" call. *)
(* this will increase display updating performance dramatically. *)
(* Off and On calls can be nested, thus you must turn painting On for *)
(* every Off *)
(* Whenever a window receives a TWM_PAINT message painting is automatically *)
(* turned off for the duration of the PAINT message. *)
(* turn paint updates OFF.  the window remembers anything that needs *)
(* be repainted for when painting is again turned ON *)

PROCEDURE PaintOn(tw : TextWindow);
(* reverses a PaintOff call *)

PROCEDURE FlushPaint(tw : TextWindow);
(* if painting is off, flush all pending paint updates to the screen *)
(* if painting is on this call has no effect *)

PROCEDURE IsPaintOn(tw : TextWindow) : BOOLEAN;
(* returns TRUE if paint updates is currently on for the specified window *)

PROCEDURE GetWinShellHandle(tw : TextWindow) : WinShell.Window;
(* get the WinShell window handle for the text window in question *)

PROCEDURE FindTextWindow(w : WinShell.Window) : TextWindow;
(* find the text window associated with the WinShell handle *)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

(* Stuff TextWindows simply re-exports from WinShell. *)
(* these procedures take a text window handle and just transfer the *)
(* call to the appropriate WinShell procedure of the same name *)
(* coordinates and sizes are in pixels for these calls, not character cells *)
(* as "native" TextWindows API calls *)

PROCEDURE Beep(beep : Beeps);

PROCEDURE BooBox(str : ARRAY OF CHAR);

PROCEDURE SetDisplayMode(tw : TextWindow; dispMode : DisplayModes);

PROCEDURE GetDisplayMode(tw : TextWindow) : DisplayModes;

PROCEDURE SetWindowEnable(tw : TextWindow; enabled : BOOLEAN);

PROCEDURE IsMinimized(tw : TextWindow) : BOOLEAN;

PROCEDURE IsMaximized(tw : TextWindow) : BOOLEAN;

PROCEDURE SetWindowTitle(tw : TextWindow; title : ARRAY OF CHAR);

PROCEDURE SendUserMessage(tw : TextWindow;
                          userId : CARDINAL; userData : ADDRESS);
PROCEDURE PostUserMessage(tw : TextWindow;
                          userId : CARDINAL; userData : ADDRESS);

PROCEDURE IsUserMessageWaiting(tw : TextWindow;
                               userIdLow, userIdHigh : CARDINAL) : BOOLEAN;

PROCEDURE CaretOn(tw : TextWindow);

PROCEDURE CaretOff(tw : TextWindow);

PROCEDURE SetCaretType(tw : TextWindow; ct : CaretTypes);

PROCEDURE SetScrollBarPos(tw : TextWindow;
                          which : WinAttr;
                          pos : ScrollRange);

PROCEDURE SetWindowData(tw : TextWindow;
                        index : CARDINAL;
                        data : ADDRESS) : BOOLEAN;
PROCEDURE SetWindowDataNum(tw : TextWindow;
                           index : CARDINAL;
                           data : CARDINAL) : BOOLEAN;

PROCEDURE GetWindowData(tw : TextWindow;
                        index : CARDINAL) : ADDRESS;
PROCEDURE GetWindowDataNum(tw : TextWindow;
                           index : CARDINAL) : CARDINAL;

PROCEDURE GetWindowSize(tw : TextWindow; VAR OUT width, height : COORDINATE);

PROCEDURE SetWindowSize(tw : TextWindow; width, height : COORDINATE);

PROCEDURE GetWindowPos(tw : TextWindow; VAR OUT x, y : COORDINATE);

PROCEDURE SetWindowPos(tw : TextWindow; x, y : COORDINATE);

PROCEDURE CascadeWindow(cascadeThis, onThis : TextWindow);

PROCEDURE SetWindowIsBusy(tw : TextWindow; busy : BOOLEAN);

PROCEDURE GetWindowDisplayInfo(tw : TextWindow; VAR OUT info : WindowDisplayInfo);

PROCEDURE SetWindowDisplayInfo(tw : TextWindow; info : WindowDisplayInfo);

PROCEDURE SetScrollDisableWhenNone(tw : TextWindow; yesH, yesV : BOOLEAN);

PROCEDURE SetActiveMdiChild(tw : TextWindow);

PROCEDURE SetMdiChildPosition(tw : TextWindow; index : CARDINAL);

PROCEDURE GetForegroundWindow() : TextWindow;

PROCEDURE SetForegroundWindow(tw : TextWindow);

PROCEDURE CreateStatusLine(tw : TextWindow; fmt : ARRAY OF INTEGER) : BOOLEAN;

PROCEDURE RemoveStatusLine(tw :TextWindow);

PROCEDURE SetStatusFormat(tw :TextWindow; fmt : ARRAY OF INTEGER);

PROCEDURE WriteStatusField(tw :TextWindow;
                           field : CARDINAL;
                           text : ARRAY OF CHAR);

PROCEDURE SetWindowIcon(tw : TextWindow; icon : ARRAY OF CHAR) : BOOLEAN;

PROCEDURE SetWindowCursor(tw : TextWindow; typ : CursorTypes);

PROCEDURE SetWindowMenu(tw : TextWindow; menu : ARRAY OF CHAR) : BOOLEAN;

PROCEDURE SetMenuItemEnable(tw : TextWindow; id : CARDINAL; state : BOOLEAN);

PROCEDURE GetMenuItemEnable(tw : TextWindow; id : CARDINAL) : BOOLEAN;

PROCEDURE SetMenuItemCheck(tw : TextWindow; id : CARDINAL; state : BOOLEAN);

PROCEDURE GetMenuItemCheck(tw : TextWindow; id : CARDINAL) : BOOLEAN;

PROCEDURE SetMenuItemRadioCheck(tw : TextWindow;
                                first, last, set : CARDINAL);

PROCEDURE GetMenuItemRadioCheck(tw : TextWindow;
                                first, last : CARDINAL) : CARDINAL;

PROCEDURE GetWindowMenu(tw : TextWindow) : MenuHandle;

PROCEDURE LoadMenu(tw : TextWindow;
                   menuId : ARRAY OF CHAR;
                   popup : BOOLEAN) : MenuHandle;

PROCEDURE DestroyMenu(menuH : MenuHandle);

PROCEDURE GetSubMenu(menuH : MenuHandle; subMenu  : CARDINAL) : MenuHandle;

PROCEDURE AppendMenuItemStr(tw : TextWindow;
                            menuH : MenuHandle;
                            str : ARRAY OF CHAR;
                            id : CARDINAL) : BOOLEAN;

PROCEDURE AppendMenuItemSeparator(tw : TextWindow; menuH : MenuHandle) : BOOLEAN;

PROCEDURE DeleteMenuItemPosition(menuH : MenuHandle; pos : CARDINAL) : BOOLEAN;

PROCEDURE PopupMenuHandle(tw : TextWindow;
                          menuH : MenuHandle;
                          button : MouseButton;
                          x, y : COORDINATE);

PROCEDURE PopupMenu(tw : TextWindow;
                    menuId : ARRAY OF CHAR;
                    button : MouseButton;
                    x, y : COORDINATE);

PROCEDURE SetTimer(tw : TextWindow; timerId : CARDINAL; interval : CARDINAL);

PROCEDURE KillTimer(tw : TextWindow; timerId : CARDINAL);

PROCEDURE OpenClipboard(w : TextWindow) : BOOLEAN;

PROCEDURE CloseClipboard(w : TextWindow);

PROCEDURE EmptyClipboard(w : TextWindow) : BOOLEAN;

PROCEDURE ClipboardFormatAvailable(fmt : ClipboardFormat) : BOOLEAN;

PROCEDURE AllocClipboardMemory(size : CARDINAL) : ADDRESS;

PROCEDURE UnlockClipboardMemory(data : ADDRESS);

PROCEDURE SetClipboard(fmt : ClipboardFormat;
                       data : ADDRESS;
                       amount : CARDINAL) : BOOLEAN;

PROCEDURE GetClipboard(fmt : ClipboardFormat) : ADDRESS;

PROCEDURE AddIdleProcedure(idle : WinShell.IdleProcType;
                           data : ADDRESS) : CARDINAL;

PROCEDURE RemoveIdleProcedure(id : CARDINAL);

PROCEDURE DispatchMessages() : CARDINAL;

PROCEDURE CheckMessages() : BOOLEAN;

PROCEDURE WaitForAMessage;

PROCEDURE TerminateDispatchMessages(code : CARDINAL);

PROCEDURE CreateToolbar(tw : TextWindow;
                        buttons : ARRAY OF ToolbarButtonInfo;
                        hasText : BOOLEAN;
                        hasHelp : BOOLEAN;
                        canCustomize : BOOLEAN) : BOOLEAN;

PROCEDURE DestroyToolbar(tw : TextWindow);

PROCEDURE SetToolbarButtons(tw : TextWindow; fmt : ARRAY OF CARDINAL);

PROCEDURE GetToolbarButtons(tw : TextWindow;
                            VAR OUT fmt : ARRAY OF CARDINAL) : CARDINAL;

PROCEDURE IsToolbarButtonShown(tw : TextWindow; index : CARDINAL) : BOOLEAN;

PROCEDURE IsToolbarButtonDown(tw : TextWindow; index : CARDINAL) : BOOLEAN;

PROCEDURE IsToolbarButtonEnabled(tw : TextWindow; index : CARDINAL) : BOOLEAN;

PROCEDURE ShowToolbarButton(tw : TextWindow;
                            index : CARDINAL;
                            show : BOOLEAN) : BOOLEAN;

PROCEDURE ToggleToolbarButton(tw : TextWindow;
                              index : CARDINAL;
                              down : BOOLEAN) : BOOLEAN;

PROCEDURE EnableToolbarButton(tw : TextWindow;
                              index : CARDINAL;
                              enable : BOOLEAN) : BOOLEAN;

PROCEDURE DisplayHelp(tw : TextWindow;
                      command : HelpCommand;
                      helpFile : ARRAY OF CHAR;
                      helpIndex : CARDINAL) : BOOLEAN;

END TextWindows.
===================================================================================
MODULE TabToSpace;
FROM Strings IMPORT Insert, Delete;
FROM FileFunc IMPORT
    File, AccessModes, FileSpecString, EOL, SearchEntry,
    StdAttributes, MustHaveNormalFile,
    OpenFile, CreateTempFile, CloseFile, SetFileBuffer,
    ReadChar, WriteChar, WriteBlock,
    FindFirst, FindNext, FindClose,
    DeleteFile, RenameFile, ConstructFileName;

FROM Environment IMPORT GetCommandLine;
FROM STextIO IMPORT WriteString, WriteLn;

VAR
    InBuf,
    OutBuf      : ARRAY [1..8*1024] OF CHAR;
    Line        : ARRAY [0..(1*1024)-1] OF CHAR;

    TabWidth    : CARDINAL;

PROCEDURE StripTabs;
VAR
    i, l        : CARDINAL;
BEGIN
    i := 0;
    l := LENGTH(Line);
    LOOP
        IF i < l THEN
            IF Line[i] <> CHR(9) THEN
                INC(i);
            ELSE
                Delete(Line, i, 1);
                DEC(l);
                REPEAT
                    Insert(' ', i, Line);
                    INC(i);
                    INC(l);
                UNTIL (i REM TabWidth) = 0;
            END;
        ELSE
            EXIT;
        END;
    END;
END StripTabs;

PROCEDURE ReadLine(VAR f : File) : BOOLEAN;
VAR
    ch  : CHAR;
    i   : CARDINAL;
BEGIN
    i := 0;
    LOOP
        ch := ReadChar(f);
        IF NOT f.eof THEN
            IF ch <> EOL THEN
                IF i < HIGH(Line) THEN
                    Line[i] := ch;
                    INC(i);
                ELSE
                    RETURN FALSE;
                END;
            ELSE
                Line[i] := '';
                EXIT;
            END;
        ELSE
            IF i = 0 THEN
                RETURN FALSE;
            ELSE
                Line[i] := '';
                EXIT;
            END;
        END;
    END;
    RETURN TRUE;
END ReadLine;

PROCEDURE DoFile(fileName : ARRAY OF CHAR);
VAR
    inFile,
    outFile     : File;
    tempName    : FileSpecString;
    l           : CARDINAL;
    ok          : BOOLEAN;
BEGIN
    WriteString(fileName);
    ok := FALSE;

    OpenFile(inFile, fileName, ReadOnlyDenyWrite);
    IF inFile.status = 0 THEN
        tempName := "";
        CreateTempFile(outFile, tempName);
        IF outFile.status = 0 THEN
            SetFileBuffer(inFile, InBuf);
            SetFileBuffer(outFile, OutBuf);

            WHILE ReadLine(inFile) DO
                StripTabs;
                l := LENGTH(Line);
                IF l > 0 THEN
                    WriteBlock(outFile, Line, l);
                END;
                WriteChar(outFile, EOL);
            END;

            CloseFile(inFile);
            CloseFile(outFile);

            IF DeleteFile(fileName) THEN
                IF RenameFile(tempName, fileName) THEN
                    ok := TRUE;
                END;
            END;
        ELSE
            CloseFile(inFile);
        END;
    END;

    IF NOT ok THEN
        WriteString("***** Failed *****");
    END;
    WriteLn;
END DoFile;

PROCEDURE ParseCommandLine(VAR fileName : ARRAY OF CHAR) : BOOLEAN;
VAR
    i, j, l     : CARDINAL;
    cLine       : ARRAY [0..255] OF CHAR;
BEGIN
    GetCommandLine(cLine);
    i := 0;
    l := LENGTH(cLine);

    IF l = 0 THEN
        WriteString("USAGE: TabToSpace TabWidth FileSpec");
        WriteLn;
        WriteString("       1 >= TabWidth <= 9");
        WriteLn;
        WriteString("       FileSpec may contain wildcards");
        WriteLn;
        RETURN FALSE;
    END;

    WHILE (i < l) AND (cLine[i] = ' ') DO
        INC(i);
    END;

    IF (cLine[i] >= '1') AND (cLine[i] <= '9') THEN
        TabWidth := ORD(cLine[i])-ORD('0');
        INC(i);
    ELSE
        RETURN FALSE;
    END;

    WHILE (i < l) AND (cLine[i] = ' ') DO
        INC(i);
    END;

    j := 0;
    IF (i < l) AND (cLine[i] = '"') THEN
        INC(i);
        WHILE (i < l) AND (cLine[i] <> '"') DO
            IF j < HIGH(fileName) THEN
                fileName[j] := cLine[i];
                INC(j);
            END;

            INC(i);
        END;
    ELSE
        WHILE i < l DO
            IF j < HIGH(fileName) THEN
                fileName[j] := cLine[i];
                INC(j);
            END;

            INC(i);
        END;
    END;
    fileName[j] := '';

    RETURN fileName[0] <> '';
END ParseCommandLine;

VAR
    entry       : SearchEntry;
    fileName    : FileSpecString;
BEGIN
    IF ParseCommandLine(fileName) THEN
        IF FindFirst(fileName, StdAttributes, MustHaveNormalFile, entry) THEN
            REPEAT
                ConstructFileName(entry.name, fileName, fileName);
                DoFile(fileName);
            UNTIL NOT FindNext(entry);
            FindClose(entry);
        END;
    END;
END TabToSpace.

(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1998-2000                             *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)
MODULE whereis;

FROM SYSTEM IMPORT
    FUNC;

FROM STextIO IMPORT
    WriteString, WriteLn, ReadChar, WriteChar, SkipLine;

FROM Strings IMPORT
    Append, Concat;

FROM ExStrings IMPORT
    AppendCharCond;

FROM Storage IMPORT
    ALLOCATE, DEALLOCATE;

FROM FileFunc IMPORT
    FileSpecString, SearchEntry, FileAttributes,
    StdAttributes, AddDirectory,
    MustHaveNormalFile, MustHaveDirectory,
    FindFirst, FindNext, FindClose;

FROM Environment IMPORT
    GetCommandLine;

VAR
    StartPath   : FileSpecString;
    FileName    : FileSpecString;

PROCEDURE SearchDirectory(searchDir : ARRAY OF CHAR) : BOOLEAN;
TYPE
    DirPointer = POINTER TO DirRec;
    DirRec =
        RECORD
        next : DirPointer;
        name : FileSpecString;
        END;
VAR
    abort       : BOOLEAN;
    valid       : BOOLEAN;
    ch          : CHAR;
    firstDir    : DirPointer;
    lastDir     : DirPointer;
    dir         : DirPointer;
    workingPath : FileSpecString;
    entry       : SearchEntry;
BEGIN
    firstDir := NIL;
    Concat(searchDir, FileName, workingPath);
    abort := FALSE;

    IF FindFirst(workingPath, StdAttributes, MustHaveNormalFile, entry) THEN
        REPEAT
            (*
            WriteString(searchDir);
            WriteChar('\');
            WriteString(entry.name);
            WriteLn;
            *)
            WriteString(searchDir);
            WriteString(entry.name);

            REPEAT
                WriteString('  -> More (Y/N)');
                valid := TRUE;
                ReadChar(ch);
                SkipLine;
                ch := CAP(ch);
                IF ch = 'N' THEN
                    abort := TRUE
                ELSIF ch <> 'Y' THEN
                    valid := FALSE;
                    WriteChar(CHR(7));
                END;
            UNTIL valid;
        UNTIL abort OR (NOT FindNext(entry));
        FindClose(entry);
    END;

    IF NOT abort THEN
        (* now recurse the directories *)

        Concat(searchDir, "*", workingPath);
        IF FindFirst(workingPath,
                     StdAttributes+AddDirectory,
                     MustHaveDirectory,
                     entry)
        THEN
            REPEAT
                (*
                WriteString(searchDir);
                WriteChar('\');
                WriteString(entry.name);
                WriteLn;
                *)
                IF entry.name[0] <> '.' THEN
                    IF Directory IN entry.attribute THEN
                        NEW(dir);
                        dir^.next := NIL;
                        dir^.name := entry.name;
                        IF firstDir = NIL THEN
                            firstDir := dir;
                        ELSE
                            lastDir^.next := dir;
                        END;
                        lastDir := dir;
                    END;
                END;
            UNTIL NOT FindNext(entry);
            FindClose(entry);
        END;

        dir := firstDir;
        WHILE (NOT abort) AND (dir <> NIL) DO
            workingPath := searchDir;
            Append(dir^.name, workingPath);
            AppendCharCond('\', workingPath);

            abort := NOT SearchDirectory(workingPath);

            dir := dir^.next;
        END;

        WHILE firstDir <> NIL DO
            dir := firstDir^.next;
            DISPOSE(firstDir);
            firstDir := dir;
        END;
    END;

    RETURN NOT abort;
END SearchDirectory;

PROCEDURE ParseCommandLine() : BOOLEAN;
VAR
    cLine       : ARRAY [0..511] OF CHAR;
    i, l        : CARDINAL;

    PROCEDURE getParam(VAR param : ARRAY OF CHAR);
    VAR
        j       : CARDINAL;
    BEGIN
        WHILE (i < l) AND ((cLine[i] = ' ') OR (cLine[i] = CHR(9))) DO
            INC(i);
        END;

        j := 0;
        IF cLine[i] = '"' THEN
            INC(i);
            WHILE (i < l) AND (cLine[i] <> '"') DO
                IF j < HIGH(param) THEN
                    param[j] := cLine[i];
                    INC(j);
                END;
                INC(i);
            END;
            INC(i);
        ELSE
            WHILE (i < l) AND (cLine[i] <> ' ') AND (cLine[i] <> CHR(9)) DO
                IF j < HIGH(param) THEN
                    param[j] := cLine[i];
                    INC(j);
                END;
                INC(i);
            END;
        END;
        param[j] := '';
    END getParam;

BEGIN
    GetCommandLine(cLine);
    i := 0;
    l := LENGTH(cLine);

    getParam(FileName);
    getParam(StartPath);

    IF (FileName[0] = '') OR (StartPath[0] = '') THEN
        WriteString("Finds one or more occurances of a file in a path");
        WriteLn;
        WriteString("USAGE: Whereis fileName path");
        WriteLn;
        RETURN FALSE;
    END;

    AppendCharCond('\', StartPath);

    RETURN TRUE;
END ParseCommandLine;

BEGIN
    IF ParseCommandLine() THEN
        FUNC SearchDirectory(StartPath);
    END;
END whereis.
(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1998-2000                             *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)
MODULE search;
<*/INLINE:N*>

FROM CharClass IMPORT
    IsWhiteSpace, IsControl;

FROM FileFunc IMPORT
    File, FileSpecString, AccessModes, SearchEntry,
    PathSepChar, StdAttributes, MustHaveNormalFile, MustHaveDirectory,
    FileUseInfoSet, (*FileUseInfo,*)
    OpenFileEx, CloseFile, ReadBlock,
    FindFirst, FindNext, FindClose,
    ConstructFileName, FileNameParts, ParseFileName;

FROM STextIO IMPORT
    WriteString, WriteChar, WriteLn;

FROM SWholeIO IMPORT
    WriteCard;

FROM Environment IMPORT
    GetCommandLine;

FROM Strings IMPORT
    Concat, Append;

FROM ExStrings IMPORT
    AppendChar;

FROM ExStorage IMPORT
    ALLOCATE, DEALLOCATE;

CONST
    MaxLineSize = (1*1024)-1;
VAR
    cLine               : ARRAY [0..(2*1024)-1] OF CHAR;
    Cp                  : CARDINAL;
    Cl                  : CARDINAL;

    LastChar            : CHAR;
    MatchString         : ARRAY [0..63] OF CHAR;
    MatchData           : ARRAY [0..63] OF CHAR;
    MatchLength         : CARDINAL;

    Command             : FileSpecString;

    Buf                 : ARRAY [0..(16*1024)-1] OF CHAR;
    Bp                  : CARDINAL;
    Be                  : CARDINAL;
    CurFile             : File;

    Line                : ARRAY [0..MaxLineSize] OF CHAR;
    LineLength          : CARDINAL;
    LineNum             : CARDINAL;
    ColumnNum           : CARDINAL;
    Count               : CARDINAL;
    CountInFile         : CARDINAL;

    TotalLines          : CARDINAL;
    LineLengths         : CARDINAL;
    NumFiles            : CARDINAL;
    MatchedFiles        : CARDINAL;
    NonBlankLines       : CARDINAL;

    Entry               : SearchEntry;

    (* have these as globals get their memory out of the recursion of the search *)
    CurrentFile         : FileSpecString;
    CurPath             : FileSpecString;
    SearchName          : FileSpecString;
    Parts               : FileNameParts;
    NewDir              : FileSpecString;

    WhiteSpace          : ARRAY CHAR OF BOOLEAN;

    EnvCommands         : BOOLEAN;
    Recurse             : BOOLEAN;

PROCEDURE Match() : CARDINAL;
VAR
    done        : BOOLEAN;
    endPos      : CARDINAL;
    i           : CARDINAL;
    j           : CARDINAL;
    k           : CARDINAL;
    matchPos    : CARDINAL;
BEGIN
    matchPos := SIZE(Line);
    i := 0;
    done := FALSE;

    IF MatchLength <= LineLength THEN
        endPos := MatchLength-1;
        REPEAT
            (* check the first and last character of the match *)
            (* if these match we are likely to have found a match *)
            (* and therefore the compute expense of doing the full compare *)
            (* will not hurt performance *)

            IF (Line[i] = MatchData[0]) AND (Line[endPos] = LastChar) THEN
                (* probably a match, now check the rest *)

                j := 1;
                k := i + 1;
                WHILE (MatchData[j] = Line[k]) AND (j < MatchLength) DO
                    INC(k);
                    INC(j);
                END;

                IF j = MatchLength THEN
                    (* got one *)
                    matchPos := i;
                    done := TRUE;
                END;
            END;

            INC(i);
            INC(endPos);
        UNTIL done OR (endPos = LineLength);
    END;

    RETURN matchPos;
END Match;

PROCEDURE ReadLine;
VAR
    i           : CARDINAL;
    ch          : CHAR;
    lbp         : CARDINAL;
    notBlank    : BOOLEAN;
BEGIN
    (* copy the global Bp variable to a local variable so that *)
    (* it will most likely be enregistered *)

    i := 0;
    lbp := Bp;
    notBlank := FALSE;

    LOOP
        IF lbp < Be THEN
            ch := CAP(Buf[lbp]);
            notBlank := notBlank OR NOT WhiteSpace[ch];

            IF i < MaxLineSize THEN
                Line[i] := ch;
                INC(i);
            ELSE
                Bp := lbp;
                LineLength := MaxLineSize;
                Line[MaxLineSize] := '';
                INC(TotalLines);
                EXIT;
            END;

            INC(lbp);

            IF ch = CHR(10) THEN
                Bp := lbp;
                LineLength := i;
                Line[i] := '';
                INC(TotalLines);
                EXIT;
            END;
        ELSE
            IF CurFile.eof THEN
                Bp := lbp;
                Line[i] := '';
                LineLength := i;
                EXIT;
            END;

            ReadBlock(CurFile, Buf, SIZE(Buf));
            IF CurFile.status <> 0 THEN
                WriteString("...file read error...");
                WriteLn;
                HALT;
            END;

            Be := CurFile.count;
            lbp := 0;
            IF Be <> 0 THEN
                CurFile.eof := FALSE;
            END;
        END;
    END;

    LineLengths := LineLengths + LineLength;
    IF notBlank THEN
        INC(NonBlankLines);
    END;
END ReadLine;

PROCEDURE SkipSpaces;
BEGIN
    WHILE (Cp < Cl) AND ((cLine[Cp] = ' ') OR (cLine[Cp] = CHR(9))) DO
        INC(Cp);
    END;
END SkipSpaces;

PROCEDURE GetCommand() : BOOLEAN;
VAR
    i           : CARDINAL;
    termChar    : CHAR;
BEGIN
    i := 0;
    SkipSpaces;

    IF Cp < Cl THEN
        (* handle quoted file names *)

        termChar := ' ';
        IF cLine[Cp] = '"' THEN
            termChar := cLine[Cp];
            INC(Cp);
        END;

        WHILE (Cp < Cl) AND (cLine[Cp] <> termChar) DO
            IF i < HIGH(Command) THEN
                Command[i] := cLine[Cp];
                INC(i);
            END;
            INC(Cp);
        END;

        IF (Cp < Cl) AND (cLine[Cp] = termChar) THEN
            INC(Cp);
        END;
    END;
    Command[i] := '';
    RETURN i <> 0;
END GetCommand;

PROCEDURE ParseCommandLine() : BOOLEAN;
VAR
    i           : CARDINAL;

    PROCEDURE usage;
    BEGIN
        WriteString("Searches files for a specific text string");
        WriteLn;
        WriteString("The search is not case sensitive");
        WriteLn;
        WriteLn;
        WriteString('USAGE: search [-r][-e] "matchString" pathSpec {pathSpec}');
        WriteLn;
        WriteString("matchString must be specified in quotes");
        WriteLn;
        WriteString("You can specify as many pathSpec's as you want");
        WriteLn;
        WriteString("pathSpec may contain wildcards");
        WriteLn;
        WriteString("The 'R' option will have the search recurse directories");
        WriteLn;
        WriteString("The 'E' option will cause only environemnt");
        WriteLn;
        WriteString("file open commands to be output for found files.");
        WriteLn;
    END usage;
BEGIN
    GetCommandLine(cLine);
    Cl := LENGTH(cLine);
    Cp := 0;

    IF Cl = 0 THEN
        usage;
        RETURN FALSE;
    END;

    SkipSpaces;

    EnvCommands := FALSE;
    Recurse := FALSE;
    IF cLine[Cp] = '-' THEN
        INC(Cp);
        IF CAP(cLine[Cp]) = 'E' THEN
            INC(Cp);
            EnvCommands := TRUE;
        ELSIF CAP(cLine[Cp]) = 'R' THEN
            INC(Cp);
            Recurse := TRUE;
        ELSE
            usage;
            RETURN FALSE;
        END;
    END;

    SkipSpaces;

    IF cLine[Cp] = '"' THEN
        INC(Cp);

        i := 0;
        WHILE (Cp < Cl) AND (cLine[Cp] <> '"') DO
            IF i < HIGH(MatchString) THEN
                MatchString[i] := cLine[Cp];
                MatchData[i] := CAP(cLine[Cp]);
                INC(i);
            END;
            INC(Cp);
        END;

        IF i <> 0 THEN
            MatchString[i] := '';
            MatchData[i] := '';
            MatchLength := i;

            MatchLength := LENGTH(MatchString);
            LastChar := MatchData[MatchLength-1];

            IF (Cp < Cl) AND (cLine[Cp] = '"') THEN
                INC(Cp);
                RETURN TRUE;
            END;
        END;
    END;
    RETURN FALSE;
END ParseCommandLine;

PROCEDURE SearchDir(name : ARRAY OF CHAR);
TYPE
    DirPointer  = POINTER TO DirRecord;
    DirRecord   =
        RECORD
        next    : DirPointer;
        name    : ARRAY [0..255] OF CHAR;
        END;
CONST
    Spaces      : ARRAY [0..79] OF CHAR = {' ' BY 80};
VAR
    len         : CARDINAL;
    first,
    last,
    ptr         : DirPointer;
BEGIN
    IF FindFirst(name, StdAttributes, MustHaveNormalFile, Entry) THEN
        REPEAT
            CountInFile := 0;

            ConstructFileName(Entry.name, name, CurrentFile);
            OpenFileEx(CurFile,
                       CurrentFile,
                       ReadOnlyDenyWrite,
                       FileUseInfoSet{(*SequentialAccess*)});
            IF CurFile.status <> 0 THEN
                WriteString("...file open error...");
                WriteLn;
                WriteString(CurrentFile);
                WriteChar(' ');
                WriteCard(CurFile.status, 0);
                WriteLn;
                HALT;
            END;

            len := 0;
            IF NOT EnvCommands THEN
                WriteString("Searching ");
                WriteString(CurrentFile);
                len := 10 + LENGTH(CurrentFile);
                IF len > 80 THEN
                    len := 0;
                END;
            END;

            INC(NumFiles);

            Bp := 0;
            Be := 0;
            LineNum := 0;
            REPEAT
                INC(LineNum);
                ReadLine;
                ColumnNum := Match();
                IF ColumnNum < SIZE(Line) THEN
                    INC(Count);
                    INC(CountInFile);
                END;
            UNTIL CurFile.eof;
            CloseFile(CurFile);

            IF EnvCommands THEN
                IF CountInFile <> 0 THEN
                    INC(MatchedFiles);
                    WriteString("!!!OPENTEXT=");
                    WriteString(CurrentFile);
                    WriteLn;
                END;
            ELSE
                IF CountInFile <> 0 THEN
                    INC(MatchedFiles);
                    WriteChar(' ');
                    WriteCard(CountInFile, 0);
                    WriteString(" Matches");
                    WriteLn;
                ELSE
                    IF len <> 0 THEN
                        WriteChar(CHR(13));
                        WriteString(Spaces[0..len-1]);
                        WriteChar(CHR(13));
                    END;
                END;
            END;
        UNTIL NOT FindNext(Entry);

        FindClose(Entry);
    END;

    IF Recurse THEN
        (* we want any directories, not just those that match the
           wildcard the user may be using
        *)

        first := NIL;
        last := NIL;
        ParseFileName(name, Parts);
        Concat(Parts.drive, Parts.path, CurPath);
        Concat(Parts.name, Parts.extension, SearchName);
        Concat(CurPath, "*", NewDir);

        IF FindFirst(NewDir, StdAttributes, MustHaveDirectory, Entry) THEN
            REPEAT
                IF Entry.name[0] <> '.' THEN
                    NEW(ptr);
                    ptr^.next := NIL;
                    ptr^.name := CurPath;
                    Append(Entry.name, ptr^.name);
                    AppendChar(PathSepChar, ptr^.name);
                    Append(SearchName, ptr^.name);

                    IF first <> NIL THEN
                        last^.next := ptr;
                    ELSE
                        first := ptr;
                    END;
                    last := ptr;
                END;
            UNTIL NOT FindNext(Entry);
        END;

        WHILE first <> NIL DO
            SearchDir(first^.name);

            last := first^.next;
            DISPOSE(first);
            first := last;
        END;
    END;
END SearchDir;

VAR
    ch          : CHAR;
BEGIN
    IF ParseCommandLine() THEN
        NumFiles := 0;
        MatchedFiles := 0;
        TotalLines := 0;
        CurrentFile := "";
        Count := 0;
        CountInFile := 0;
        NonBlankLines := 0;
        FOR ch := MIN(CHAR) TO MAX(CHAR) DO
            WhiteSpace[ch] := IsWhiteSpace(ch) OR IsControl(ch);
        END;

        WHILE GetCommand() DO
            SearchDir(Command);
        END;

        WriteLn;
        WriteLn;

        WriteCard(NumFiles, 0);
        WriteString(" files searched ");
        WriteLn;

        WriteString("Found ");
        WriteCard(Count, 0);
        WriteString(' total occurances of "');
        WriteString(MatchString);
        WriteString('"');
        WriteString(" in ");
        WriteCard(MatchedFiles, 0);
        WriteString(" files.");
        WriteLn;

        WriteString("In ");
        WriteCard(TotalLines, 0);
        WriteString(" total lines scanned. Non blank lines = ");
        WriteCard(NonBlankLines, 0);
        WriteChar('.');
        WriteLn;
        IF TotalLines <> 0 THEN
            WriteString("Average line length ");
            WriteCard(LineLengths / TotalLines, 0);
            WriteString(". Non blank everage ");
            WriteCard(LineLengths / NonBlankLines, 0);
            WriteChar('.');
            WriteLn;
        END;
    END;
END search.
(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1998-2000                             *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)
MODULE switchname;

IMPORT Strings;

FROM ExStrings IMPORT
    AppendChar, EqualI, FindNextI;

FROM FileFunc IMPORT
    FileSpecString, File, EOL, ReadOnlyDenyWrite,
    OpenFile, CloseFile, SetFileBuffer, ReadChar,
    SearchEntry, FindFirst, FindNext, FindClose,
    FileNameParts, ParseFileName,
    StdAttributes, MustHaveNormalFile,
    RenameFile, ConstructFileName;

FROM Environment IMPORT
    GetCommandLine;

FROM STextIO IMPORT
    WriteString, WriteLn;

VAR
    Language    : (Modula2, Ada95, Unknown);
    FileBuf     : ARRAY [0..511] OF CHAR;
    cLine       : ARRAY [0..511] OF CHAR;
    Cp          : CARDINAL;
    Cl          : CARDINAL;

PROCEDURE GetCommand(VAR command : ARRAY OF CHAR);
VAR
    j           : CARDINAL;
BEGIN
    command := "";
    IF Cp < Cl THEN
        WHILE (Cp < Cl) AND (cLine[Cp] = " ") DO
            INC(Cp);
        END;
        IF Cp < Cl THEN
            j := 0;
            WHILE (Cp < Cl) AND (cLine[Cp] <> " ") DO
                IF j < HIGH(command) THEN
                    command[j] := cLine[Cp];
                    INC(j);
                END;
                INC(Cp);
            END;
            command[j] := '';
        END;
    END;
END GetCommand;

PROCEDURE ReadLine(VAR f : File; VAR line : ARRAY OF CHAR) : CARDINAL;
VAR
    ch          : CHAR;
    i           : CARDINAL;
BEGIN
    i := 0;
    LOOP
        ch := ReadChar(f);
        IF f.eof OR (ch = EOL) THEN
            EXIT;
        ELSE
            IF i < HIGH(line) THEN
                line[i] := ch;
                INC(i);
            END;
        END;
    END;
    line[i] := '';
    RETURN i;
END ReadLine;

PROCEDURE GetModuleName(VAR f : File; VAR moduleName : ARRAY OF CHAR);
VAR
    i           : CARDINAL;
    lineLen     : CARDINAL;
    found       : BOOLEAN;
    line        : ARRAY [0..255] OF CHAR;
BEGIN
    moduleName := "";
    LOOP
        lineLen := ReadLine(f, line);
        IF (lineLen = 0) AND f.eof THEN
            EXIT;
        END;

        IF Language = Modula2 THEN
            Strings.FindNext("MODULE", line, 0, found, i);
        ELSE
            FindNextI("Package", line, 0, found, i);
        END;
        IF found THEN
            IF Language = Ada95 THEN
                FindNextI("body", line, i, found, i);
            END;

            WHILE (i < lineLen) AND (line[i] <> " ") DO
                INC(i);
            END;
            WHILE (i < lineLen) AND (line[i] = " ") DO
                INC(i);
            END;

            WHILE (i < lineLen) AND
                  (line[i] <> " ") AND
                  (line[i] <> ";")
            DO
                AppendChar(line[i], moduleName);
                INC(i);
            END;
            EXIT;
        END;
    END;
END GetModuleName;

PROCEDURE DoCommand() : BOOLEAN;
VAR
    moduleName  : ARRAY [0..63] OF CHAR;
    thisFile    : FileSpecString;
    newFile     : FileSpecString;
    command     : FileSpecString;
    entry       : SearchEntry;
    parts       : FileNameParts;
    f           : File;
BEGIN
    GetCommand(command);
    IF FindFirst(command, StdAttributes, MustHaveNormalFile, entry) THEN
        REPEAT
            ParseFileName(entry.name, parts);
            Language := Unknown;
            IF EqualI(parts.extension, ".def") OR
               EqualI(parts.extension, ".mod")
            THEN
                Language := Modula2;
            ELSIF EqualI(parts.extension, ".ads") OR
                  EqualI(parts.extension, ".adb") OR
                  EqualI(parts.extension, ".ada") OR
                  EqualI(parts.extension, ".adp")
            THEN
                Language := Ada95;
            END;
            IF Language <> Unknown THEN
                ConstructFileName(entry.name, command, thisFile);
                OpenFile(f, thisFile, ReadOnlyDenyWrite);
                IF f.status = 0 THEN
                    SetFileBuffer(f, FileBuf);
                    GetModuleName(f, moduleName);
                    CloseFile(f);

                    IF moduleName[0] <> '' THEN
                        ConstructFileName(moduleName, command, newFile);
                        IF EqualI(newFile, thisFile) THEN
                            (* we are currently long, or out name is <= 8 *)

                            IF LENGTH(moduleName) > 8 THEN
                                (* we are currently long *)

                                moduleName[8] := '';
                                ConstructFileName(moduleName,
                                                  command,
                                                  newFile);
                            ELSE
                                thisFile := "";
                            END;
                        ELSE
                            (* we are currently short *)
                        END;

                        IF thisFile[0] <> '' THEN
                            WriteString(thisFile);
                            WriteString(" -> ");
                            WriteString(newFile);
                            WriteString("  ");
                            IF NOT RenameFile(thisFile, newFile) THEN
                                WriteString("NOT ");
                            END;
                            WriteString("OK");
                            WriteLn;
                        END;
                    END;
                END;
            END;
        UNTIL NOT FindNext(entry);
        FindClose(entry);

        RETURN TRUE;
    END;
    RETURN FALSE;
END DoCommand;

PROCEDURE DoBanner;
TYPE
    str         = ARRAY [0..50] OF CHAR;
CONST
    banner      : ARRAY OF str =
        {
         {"Converts the file(s) names to a short, 8 character,"},
         {"or a long file name depending on the current form."},
         {"The full name is read from the source file."},
         {"Usage: switchname FileSpec {FileSpec}"},
         {"Filespecs may contain wildcards"}
        };
VAR
    i   : CARDINAL;
BEGIN
    FOR i := 0 TO HIGH(banner) DO
        WriteString(banner[i]);
        WriteLn;
    END;
END DoBanner;

BEGIN
    GetCommandLine(cLine);
    Cl := LENGTH(cLine);
    Cp := 0;

    IF Cl <> 0 THEN
        WHILE DoCommand() DO
        END;
    ELSE
        DoBanner;
    END;
END switchname.
(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1998-2000                             *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)
MODULE replace;

FROM SYSTEM IMPORT
    FUNC;

FROM SysClock IMPORT
    DateTime;

FROM FileFunc IMPORT
    File, FileSpecString, AccessModes, SearchEntry,
    StdAttributes, MustHaveNormalFile, GetFileDateTime,
    OpenFile, CreateFile, CloseFile, ReadBlock, WriteBlock,
    FindFirst, FindNext, FindClose, SetFileDateTime, TruncateFile,
    ConstructFileName;

FROM ExStrings IMPORT
    AppendCharCond;

FROM TimeFunc IMPORT
    DateTimeGreater;

FROM Environment IMPORT
    GetCommandLine;

FROM STextIO IMPORT
    WriteString, WriteLn;

VAR
    cLine       : ARRAY [0..511] OF CHAR;
    src, dst    : FileSpecString;
    i, l        : CARDINAL;
    inF, outF   : File;
    inDt, outDt : DateTime;
    Buffer      : ARRAY [0..(64*1024)-1] OF CARDINAL8;
    Entry       : SearchEntry;

PROCEDURE DoCopy;
BEGIN
    LOOP
        ReadBlock(inF, Buffer, SIZE(Buffer));
        IF inF.status = 0 THEN
            IF inF.count <> 0 THEN
                WriteBlock(outF, Buffer, inF.count);
                IF (outF.status <> 0) OR (outF.count <> inF.count) THEN
                    WriteString("***** DISK ERROR *****");
                    WriteLn;
                    EXIT;
                END;
            ELSE
                EXIT;
            END;
        ELSE
            WriteString("***** DISK ERROR *****");
            WriteLn;
            EXIT;
        END;
    END;
    TruncateFile(outF);
END DoCopy;

PROCEDURE GetParam(VAR param : ARRAY OF CHAR);
VAR
    j   : CARDINAL;
BEGIN
    WHILE (i < l) AND (cLine[i] = ' ') DO
        INC(i);
    END;

    j := 0;
    IF cLine[i] = '"' THEN
        INC(i);
        WHILE (i < l) AND (cLine[i] <> '"') DO
            IF j < HIGH(param) THEN
                param[j] := cLine[i];
                INC(j);
            END;
            INC(i);
        END;
        IF cLine[i] = '"' THEN
            INC(i);
        END;
    ELSE
        WHILE (i < l) AND (cLine[i] <> ' ') DO
            IF j < HIGH(param) THEN
                param[j] := cLine[i];
                INC(j);
            END;
            INC(i);
        END;
    END;
    param[j] := '';
END GetParam;

BEGIN
    src := "";
    dst := "";

    GetCommandLine(cLine);
    i := 0;
    l := LENGTH(cLine);
    IF l = 0 THEN
        WriteString("USAGE: replace sourceFileSpec destDirectory");
        WriteLn;
        WriteString("Update an existing file if the source is newer.");
        WriteLn;
        WriteString("Create the file if it does not exist.");
        WriteLn;
        HALT;
    END;

    GetParam(src);
    GetParam(dst);
    IF dst[0] = '' THEN
        dst := ".";
    END;
    AppendCharCond('\', dst);

    IF FindFirst(src, StdAttributes, MustHaveNormalFile, Entry) THEN
        REPEAT
            ConstructFileName(Entry.name, src, src);
            GetFileDateTime(src, inDt);
            OpenFile(inF, src, ReadOnlyDenyWrite);
            IF inF.status = 0 THEN
                ConstructFileName(Entry.name, dst, dst);
                GetFileDateTime(dst, outDt);

                OpenFile(outF, dst, ReadWriteDenyAll);
                IF outF.status = 0 THEN
                    IF DateTimeGreater(inDt, outDt) THEN
                        WriteString("Replaced ");
                        WriteString(src);
                        WriteLn;
                        DoCopy;
                    ELSE
                        WriteString("Nothing ");
                        WriteString(src);
                        WriteLn;
                    END;
                    CloseFile(outF);
                    FUNC SetFileDateTime(dst, inDt);
                ELSE
                    CreateFile(outF, dst);
                    IF outF.status = 0 THEN
                        WriteString("Created ");
                        WriteString(src);
                        WriteLn;
                        DoCopy;
                        CloseFile(outF);
                        FUNC SetFileDateTime(dst, inDt);
                    END;
                END;
                CloseFile(inF);
            END;
        UNTIL NOT FindNext(Entry);
        FindClose(Entry);
    END;
END replace.
(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1998-2000                             *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)
MODULE diff;
<*/INLINE:N*>

<*/VALIDVER:Crc*>
<*/VERSION:Crc*>

FROM Strings IMPORT
    Equal;

FROM ExStorage IMPORT
    ALLOCATE;

FROM FileFunc IMPORT
    File, AccessModes, FileSpecString, EOL, FileUseInfo, FileUseInfoSet,
    OpenFileEx, CloseFile, SetFileBuffer, ReadChar;

FROM STextIO IMPORT
    WriteString, WriteLn;

FROM SWholeIO IMPORT
    WriteCard;

FROM Environment IMPORT
    GetCommandLine;

%IF Crc %THEN
FROM GenCRC IMPORT
    CrcPrecondition, CrcPostcondition, CrcBlock;
%END

TYPE
    Status = (Okay, File1Error, File2Error, CommandError, Diffs);

CONST
    (* the hash size must be prime *)

    MaxHashSize         = 32971;(* 16381, 32971, 65551, 99991 *)
    MaxLineSize         = 1*1024;

    FileBufferSize      = 8*1024;

TYPE
    StringRecord =
        RECORD
        len     : CARDINAL;
        st      : CARDINAL;
        str     : ARRAY [0..MaxLineSize-1] OF CHAR;
        END;

    StringPointer       = POINTER TO StringRecord;
    LinesType           = ARRAY [1..MaxHashSize] OF CARDINAL;
    HashType            = ARRAY [0..MaxHashSize-1] OF StringPointer;

VAR
    FileNames   : ARRAY [1..2] OF FileSpecString;

    HashTable   : HashType;
    HashLines   : CARDINAL;

    Lines1      : LinesType;
    Count1      : CARDINAL;
    Lines2      : LinesType;
    Count2      : CARDINAL;

    FileBuffer  : ARRAY [0..FileBufferSize-1] OF CARDINAL8;

    Line        : ARRAY [0..MaxLineSize-1] OF CHAR;
    LineSize    : CARDINAL;
    LineSt      : CARDINAL;
    HashVal     : CARDINAL;
    Listing     : BOOLEAN;

PROCEDURE HexChar(ch : CHAR) : BOOLEAN;
BEGIN
    RETURN ((ch >= '0') AND (ch <= '9')) OR
           ((CAP(ch) >= 'A') AND (CAP(ch) <= 'F'))
END HexChar;

PROCEDURE DoctorLine;
BEGIN
    IF (Line[0] = ' ') AND
       (Line[1] = ' ') AND
       (Line[2] = ' ') AND
       (Line[3] = ' ') AND
       (Line[8] = ' ') AND
       HexChar(Line[4]) AND
       HexChar(Line[5]) AND
       HexChar(Line[6]) AND
       HexChar(Line[7])
    THEN
        (* this is a likely assembly line *)
        (* if this zaps a source or comment line we do not really care *)
        (* because we are really interested in comparing assembly *)
        LineSt := 8;
    END;
END DoctorLine;

PROCEDURE ReadLine(VAR f : File) : BOOLEAN;
VAR
    ch  : CHAR;
    i   : CARDINAL;
    %IF %NOT Crc %THEN
    hv  : CARDINAL;
    %END
BEGIN
    i := 0;
    LOOP
        ch := ReadChar(f);
        IF NOT f.eof THEN
            IF ch <> EOL THEN
                IF i < MaxLineSize-1 THEN
                    Line[i] := ch;
                    INC(i);
                ELSE
                    RETURN FALSE;
                END;
            ELSE
                Line[i] := '';
                EXIT;
            END;
        ELSE
            IF i = 0 THEN
                RETURN FALSE;
            ELSE
                Line[i] := '';
                EXIT;
            END;
        END;

    END;

    LineSt := 0;
    IF Listing THEN
        (* we are comparing Stony Brook compiler code listings *)
        (* we want to ignore the code file offset in the hash *)
        DoctorLine;
    END;

    (* compute a hash value *)
    (* the CRC is much slower but should generate a better distribution *)

    %IF Crc %THEN
        HashVal := CrcPrecondition;
        IF i > LineSt THEN
            HashVal := CrcBlock(Line[LineSt..i-1], HashVal);
        END;
        HashVal := CrcPostcondition(HashVal);
    %ELSE
        hv := 0;
        IF i > LineSt THEN
            FOR i := LineSt TO i-1 DO
                <*/PUSH/NOCHECK:O*>
                hv := hv + hv + ORD(Line[i]);
                <*/POP*>
            END;
        END;
        HashVal := hv;
    %END
    LineSize := i;
    RETURN TRUE;
END ReadLine;

PROCEDURE ReadFile(VAR f : File;
                   VAR lines : LinesType;
                   VAR count : CARDINAL) : BOOLEAN;
VAR
    h, d, fh    : CARDINAL;
    hp          : StringPointer;
BEGIN
    count := 0;

    (* actually comparing the strings whould be MUCH too slow *)
    (* we only compare strings when the hash results are the same *)
    (* each line will have a unique position in the hash table *)
    (* this is how we identify lines for comparison *)
    (* by their ordinal hash table position *)
    (* we also save memory because identical lines are only stored once *)

    WHILE ReadLine(f) DO
        IF (count <= MaxHashSize) AND (HashLines <= MaxHashSize) THEN
            h := HashVal REM MaxHashSize;
            d := (HashVal / MaxHashSize) REM MaxHashSize;
            fh := h;
            IF d = 0 THEN
                d := 1;
            END;

            REPEAT
                hp := HashTable[h];
                IF hp = NIL THEN
                    (* short allocate the record, saves memory *)

                    ALLOCATE(HashTable[h],
                             SIZE(hp^)-SIZE(hp^.str)+LineSize+1);

                    HashTable[h]^.len := LineSize;
                    HashTable[h]^.st := LineSt;
                    HashTable[h]^.str[0..LineSize] := Line;
                    hp := HashTable[h];
                    INC(HashLines);
                ELSIF NOT Equal(hp^.str[hp^.st..hp^.len],
                                Line[LineSt..LineSize])
                THEN
                    (* same hash value, but different strings, rehash *)

                    h := (h + d) REM MaxHashSize;
                    hp := NIL;
                END;
            UNTIL (hp <> NIL) OR (h = fh);

            IF hp <> NIL THEN
                INC(count);
                lines[count] := h;
            ELSE
                RETURN FALSE;
            END;
        ELSE
            RETURN FALSE;
        END;
    END;

    RETURN f.eof;
END ReadFile;

PROCEDURE ReSync(i1, i2 : CARDINAL; VAR s1, s2 : CARDINAL);
VAR
    d1  : CARDINAL;
    d2  : CARDINAL;
    n   : CARDINAL;
BEGIN
    (* we resync when two successive lines match as near as possible *)
    (* to our current positions *)

    (* n is the number of positions out from the current position *)
    (* to look, start obviously with 1 *)

    n := 1;

    REPEAT
        (* file 1 is searched current positon down n steps *)
        (* file 2 is searched n steps down back up to the current position *)
        (* the net effect of this is that with a single loop we compare *)
        (* all lines in both ranges against each other *)

        d1 := 0;

        WHILE d1 <= n DO
            d2 := n-d1;

            IF (i1 + d1 <= Count1) AND
               (i2 + d2 <= Count2) AND
               (Lines1[i1+d1] = Lines2[i2+d2]) AND
               (Lines1[i1+d1+1] = Lines2[i2+d2+1])
            THEN
                s1 := i1+d1;
                s2 := i2+d2;
                RETURN;
            END;

            INC(d1);
        END;

        (* failed, look at a larger range *)

        INC(n);
    UNTIL (n > Count1-i1+Count2-i2);

    (* we could not sync, we hit the end of the file(s) *)

    s1 := Count1+1;
    s2 := Count2+1;
END ReSync;

PROCEDURE WriteDiffs() : Status;
VAR
    i1, i2      : CARDINAL;
    s1, s2      : CARDINAL;
    stat        : Status;
BEGIN
    (* we have not found an difference as yet *)

    stat := Okay;

    (* start at the top of the file *)

    i1 := 1;
    i2 := 1;

    WHILE (i1 <= Count1) OR (i2 <= Count2) DO
        IF (i1 <= Count1) AND
           (i2 <= Count2) AND
           (Lines1[i1] = Lines2[i2])
        THEN
            (* the two files are in sync *)

            INC(i1);
            INC(i2);
        ELSE
            stat := Diffs;
            IF i1 > Count1 THEN
                s1 := i1;
                s2 := Count2+1;
            ELSIF i2 > Count2 THEN
                s2 := i2;
                s1 := Count1+1;
            ELSE
                ReSync(i1, i2, s1, s2);
            END;

            (* i1, i2 = current position *)
            (* s1, s2 = the new sync position *)

            WriteString("<File ");
            WriteString(FileNames[1]);
            WriteString(">");
            WriteLn;

            WHILE i1 <= s1 DO
                IF i1 > Count1 THEN
                    WriteString(">>eof<<");
                    WriteLn;
                ELSE
                    WriteCard(i1, 5);
                    WriteString(" ");
                    WriteString(HashTable[Lines1[i1]]^.str);
                    WriteLn;
                END;
                INC(i1);
            END;

            WriteString("<File ");
            WriteString(FileNames[2]);
            WriteString(">");
            WriteLn;

            WHILE i2 <= s2 DO
                IF i2 > Count2 THEN
                    WriteString(">>eof<<");
                    WriteLn;
                ELSE
                    WriteCard(i2, 5);
                    WriteString(" ");
                    WriteString(HashTable[Lines2[i2]]^.str);
                    WriteLn;
                END;
                INC(i2);
            END;

            WriteString("<End>");
            WriteLn;
            WriteLn;
        END;
    END;
    RETURN stat;
END WriteDiffs;

PROCEDURE Diff() : Status;
VAR
    f1, f2      : File;
    i           : CARDINAL;
BEGIN
    FOR i := 0 TO MaxHashSize-1 DO
        HashTable[i] := NIL;
    END;
    HashLines := 0;

    OpenFileEx(f1,
               FileNames[1],
               ReadOnlyDenyWrite,
               FileUseInfoSet{SequentialAccess});
    IF f1.status <> 0 THEN
        RETURN File1Error;
    END;

    OpenFileEx(f2,
               FileNames[2],
               ReadOnlyDenyWrite,
               FileUseInfoSet{SequentialAccess});
    IF f2.status <> 0 THEN
        CloseFile(f1);
        RETURN File2Error;
    END;

    SetFileBuffer(f1, FileBuffer);
    IF NOT ReadFile(f1, Lines1, Count1) THEN
        CloseFile(f1);
        CloseFile(f2);
        RETURN File1Error;
    END;
    CloseFile(f1);

    SetFileBuffer(f2, FileBuffer);
    IF NOT ReadFile(f2, Lines2, Count2) THEN
        CloseFile(f2);
        RETURN File2Error;
    END;
    CloseFile(f2);

    RETURN WriteDiffs();
END Diff;

PROCEDURE ParseCommandLine() : Status;
    PROCEDURE usage;
    CONST
        text : ARRAY OF ARRAY [0..63] OF CHAR =
            {
             "Finds differences, by line, between two text files",
             "",
             "USAGE: Diff [/L] fileName1 fileName2",
             "/L = special compare of Stony Brook compiler code listings",
             "exit codes",
             "0 = No Changes",
             "1 = Error on fileName1",
             "2 = Error on fileName2",
             "3 = Command line error",
             "4 = Files have differences"
            };
    VAR
        i       : CARDINAL;
    BEGIN
        FOR i := 0 TO HIGH(text) DO
            WriteString(text[i]);
            WriteLn;
        END;
    END usage;

VAR
    cLine       : ARRAY [0..511] OF CHAR;
    ci          : CARDINAL;
    cl          : CARDINAL;
    i           : CARDINAL;
    j           : CARDINAL;
    termChar    : CHAR;
BEGIN
    GetCommandLine(cLine);
    cl := LENGTH(cLine);

    IF cl = 0 THEN
        usage;
        RETURN CommandError;
    END;

    ci := 0;
    WHILE (ci < cl) AND (cLine[ci] = ' ') DO
        INC(ci);
    END;

    Listing := FALSE;
    IF cLine[ci] = '/' THEN
        INC(ci);
        IF CAP(cLine[ci]) = 'L' THEN
            Listing := TRUE;
            INC(ci);
        ELSE
            usage;
            RETURN CommandError;
        END;
    END;

    FOR i := 1 TO 2 DO
        WHILE (ci < cl) AND (cLine[ci] = ' ') DO
            INC(ci);
        END;

        j := 0;

        IF ci < cl THEN
            termChar := ' ';
            IF cLine[ci] = '"' THEN
                termChar := '"';
                INC(ci);
            END;

            WHILE (ci < cl) AND (cLine[ci] <> termChar) DO
                IF j < HIGH(FileNames[i]) THEN
                    FileNames[i][j] := cLine[ci];
                    INC(j);
                ELSE
                    usage;
                    RETURN CommandError;
                END;
                INC(ci);
            END;

            IF (ci < cl) AND (cLine[ci] = termChar) THEN
                INC(ci);
            END;
        END;
        FileNames[i][j] := '';
    END;

    IF (FileNames[1][0] = '') OR (FileNames[2][0] = '') THEN
        usage;
        RETURN CommandError;
    END;

    RETURN Diff();
END ParseCommandLine;

VAR
    result      : Status;
BEGIN
    result := ParseCommandLine();
    IF result = Okay THEN
        WriteString("Files are the same");
        WriteLn;
    END;
    HALT(ORD(result));
END diff.
MODULE DeleteOurself;

FROM Environment IMPORT
    GetProgramName;

FROM RunProg IMPORT
    PerformCommand, ExecFlagSet, ExecFlags;

FROM FileFunc IMPORT
    FileSpecString, ConstructFileName,
    File, CreateFile, CloseFile, WriteBlock, WriteChar, EOL;

FROM Strings IMPORT
    Insert, Append;

PROCEDURE DeleteOurself;
(* we create a batch file which loops trying to delete our executable *)
(* file. Then the batch file deletes itself. *)
(* Batch files are unique in that they can delete themselves. *)
(* The batch file is executed with idle priority because it is in a *)
(* polling loop. This stops the batch from consuming major CPU time *)
(* until the delete command succeeds. *)
(* This algorithm works on Win9x and NT, and does not require a reboot *)
(* to delete the file as other methods do. *)

VAR
    exeName	: FileSpecString;
    batName	: FileSpecString;
    stat	: CARDINAL;
    f		: File;

    PROCEDURE writeString(str : ARRAY OF CHAR);
    BEGIN
	WriteBlock(f, str, LENGTH(str));
    END writeString;

    PROCEDURE writeLn;
    BEGIN
	WriteChar(f, EOL);
    END writeLn;
BEGIN
    GetProgramName(exeName);
    ConstructFileName(".BAT", exeName, batName);

    CreateFile(f, batName);

    (* quote the file name in case it contains spaces *)

    Insert('"', 0, exeName);
    Append('"', exeName);

    writeString(":repeat");
    writeLn;

    writeString("del ");
    writeString(exeName);
    writeLn;

    writeString("if exist ");
    writeString(exeName);
    writeString(" goto repeat");
    writeLn;

    (* now the command to have the batch file delete itself *)

    writeString("del %0");
    writeLn;

    CloseFile(f);

    (* create the batch file console window hidden *)

    IF NOT PerformCommand(batName,
			  ExecFlagSet{ExecAsync, ExecIdlePriority, ExecHidden},
			  stat)
    THEN
	(*??? *)
    END;
END DeleteOurself;

BEGIN
    DeleteOurself;
END DeleteOurself.

(***************************************************************************)
(***************************************************************************)
DEFINITION MODULE FileFunc;
(***************************************************************************)
%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END
<*/VALIDVER:PROTECT*>
(*<*/VERSION:PROTECT*>*)
(*  FileFunc does not protect against multiple threads accessing the same File data structure. The PROTECT version tag enables this, however this still will not provide proper functionalitly for most applications since one thread may need to do multiple writes before it is done, another thread can then start reading.  what an application really needs is a mutex semaphore to protect complete actions within their algorithm, not just single procedure calls hence the reason the protect version tag is defaulted off *)
<*/NOPACK*>

FROM SYSTEM IMPORT BYTE, ADDRESS;
FROM SysClock IMPORT DateTime;

%IF PROTECT %THEN
FROM Threads IMPORT CriticalSection;
%END

CONST
    EOL = 36C;

(* This is the character used to separate directory names and file names in a file specification.     *)
    %IF WIN32 %OR FlashTek %OR DOS %OR WIN16 %THEN
        PathSepChar = '\';
    %ELSIF UNIX %THEN
        PathSepChar = '/';
    %ELSE
        fix me;
    %END

TYPE (* these strings have room for the maximum data plus a null character *)
    %IF WIN32 %THEN
        FileSpecString  = ARRAY [0..260] OF CHAR;
        NameString      = ARRAY [0..255] OF CHAR;
    %ELSIF LINUX %OR SUNOS %THEN
        FileSpecString  = ARRAY [0..1023] OF CHAR;
        NameString      = ARRAY [0..255] OF CHAR;
    %ELSIF FlashTek %OR DOS %OR WIN16 %THEN
        (* DOS has a smaller limit than the size of the following string.  network drivers can allow longer paths for servers    *)
        FileSpecString  = ARRAY [0..255] OF CHAR;
        NameString      = ARRAY [0..12] OF CHAR;
    %ELSE
        fix me;
    %END

    FileAttributes =
        (
            ReadOnly,
            Hidden,
            System,
            Archive,

            Compressed,
            Encrypted,
            Temporary,
            Offline,     (* Indicates that the file data has been
                            physically moved to offline storage. *)

            Alias,       (* Unix link  *)
            OwnerRead,   (* "Unix" permissions *)
            OwnerWrite,
            OwnerExec,
            GroupRead,
            GroupWrite,
            GroupExec,
            OtherRead,
            OtherWrite,
            OtherExec,


            NormalFile,  (*regular files *)
            Directory    (*self explanatory. a Directory *)
        );
    FileAttributeSet    = PACKEDSET OF FileAttributes;
(* none of the above attributes are guaranteed to exist on a given underlying file system except NormalFile and Directory.
   On Unix systems the Hidden attribute is set on files with a leading '.' character in the file name. This is the convension for "Hidden" files.
   You cannot set the Hidden attribute on Unix systems as this is a pseudo attribute.
   On Unix systems the ReadOnly attribute is set according to the file permissions and taking into account the file owner and the current user and group ids.
   You cannot set the ReadOnly attribute on Unix systems as this is a pseudo attribute. Use the permissions attributes.
*)
    SearchEntry =
        RECORD            (* returned information for you *)
            size        : CARDINAL32;
            attribute   : FileAttributeSet;
            dt          : DateTime;(*this is local time *)
            %IF WIN32 %OR UNIX %THEN
            dtUTC       : DateTime;(*this is UTC time *)
            %END
            name        : NameString;

            (* fields used for internal implementation *)

            mayHave     : FileAttributeSet;
            mustHave    : FileAttributeSet;
        %IF PROTECT %THEN
            critic      : CriticalSection;
        %END
        %IF WIN32 %THEN
            findHandle  : ADDRESS;
            reserved0   : CARDINAL;
            reserved1   : CARDINAL;
        %ELSIF UNIX %THEN
            findHandle  : ADDRESS;
            pattern     : FileSpecString;
        %ELSIF FlashTek %OR DOS %OR WIN16 %THEN
            reserved    : ARRAY [0..20] OF CHAR;
        %END
        END;

(*
     the following record is used to contain the various components
     of a file specification
     The sizes of individual components are defined by the underlying file system for the device accessed. The sizes declared here are at least as big as necessary, but most likely larger
*)
    FileNameParts =
        RECORD
            %IF WIN32 %THEN
            drive : NameString;
            %ELSIF DOS %OR FlashTek %OR WIN16 %THEN
            drive : ARRAY [0..127] OF CHAR;
            %ELSIF UNIX %THEN
            drive : ARRAY [0..0] OF CHAR;(*N/A*)
            %ELSE
                fix me;
            %END
            path  : FileSpecString;
            name  : NameString;
            extension   : NameString;
        END;
(*
   .drive only has meaning on Miscorosft platforms  this is the device, it is either a logical drive letter or a UNC server name and share.
   .path = this is the path
   .name = the file name  excluding the file extension
   .extension = the file extension, this is everything  after the *last*
       '.' character. On Unix systems this may actually be the full file
       name since the convension there is to use a preceeding '.' to
       mark hidden files and/or directories.
*)
    FileTypes           = (
                           FileTypeUnknown,
                           FileTypeDisk,
                           FileTypeChar,
                           FileTypePipe
                          );
(*
  FileTypeChar is a data stream that cannot be repositioned and is text oriented. Usually this is accessing the console.
  This means input is comming from the keyboard, and output is going to the screen.
  FileTypePipe is a data stream that cannot be repositioned and the data format is undefined.
  FileTypeDisk should be obvious, some sort of floppy,harddisk,etc
*)
    DeviceTypes         = (
                           DeviceUnknown,
                           DeviceFixedDisk,
                           DeviceRemovable,
                           DeviceRamdisk,
                           DeviceRemote
                          );
    AccessModes         = (
                           ReadOnlyDenyNone,
                           ReadOnlyDenyWrite,
                           ReadOnlyDenyAll,
                           ReadWriteDenyNone,
                           ReadWriteDenyWrite,
                           ReadWriteDenyAll,
                           WriteOnlyDenyNone,
                           WriteOnlyDenyAll
                          );
(*
   These modes specify both an access mode and a file sharing mode ReadOnly, ReadWrite and WriteOnly are the access mode for your access to the file.
   DenyNone, DenyWrite, DenyAll are the sharing mode for the file 
   DenyNone will allow everything to have full access to the file
   DenyWrite will allow others to have read access to the file
   DenyAll will allow nothing to access the file
   The most common modes used are ReadOnlyDenyWrite, ReadWriteDenyAll, and ReadWriteDenyNone.

   On Unix systems file open "sharing" does not exist. This module simulates this capability via record locking. There is no way to truely enforce file open sharing on Unix systems.
*)
    FileUseInfo         = (
                           SequentialAccess,
                           RandomAccess,
                           WriteThrough,
                           TemporaryFile
                          );
    FileUseInfoSet      = PACKEDSET OF FileUseInfo;
(*
   these flags can be used to give additional instructions to the operating system about how you will be using a file.
   the operating system can thus possibly optimize the file access given this additional information.
   these are only suggestions and an operating system may not support all or any of the suggestions.
   SequentialAccess = the file is accessed linearly, or at least mostly
                        in this manner. Under Win32 this flag has an
                        interesting effect on file caching. It will
                        cause the file to not be cached in the disk
                        cache except for any read ahead caching
                        the system does. Once you read past a certain
                        point the cached data is removed from the cache
                        which means that the second time you read the
                        file it will not be in the cache.
                        Thus for small/average files that are read
                        often it is best to not use this attribute.
   RandomAccess = the file is accessed in a random manner
   WriteThrough = Data written to the file should be immediately written
                    to the disk. The data can still be cached.
                    This flag only has meaning on operating systems that
                    implement write-back disk caches where the data
                    written will be written to disk at some later point
                    in time, thus allowing the system to optimize
                    access to the disk.
   TemporaryFile = the file is only temporary and will be deleted.
*)
    CommonFileErrors    = (
                           FileErrSuccess,
                           FileErrFileNotFound,
                           FileErrPathNotFound,
                           FileErrNoHandles,
                           FileErrAccessDenied,
                           FileErrInvalidHandle,
                           FileErrNotReady,
                           FileErrWriteProtect,
                           FileErrSharingViolation,
                           FileErrLockViolation,
                           FileErrDiskFull,
                           FileErrBrokenPipe,
                           FileErrInterrupted,
                           FileErrUnknown
                          );
(*
   these are common errors that can occur while accessing a file
   The File record contains an error code but this code is operating system dependent
   use TranslateFileError to convert this code to one of these errors an error code of zero however always means FileErrSuccess
*)
    File =
        RECORD
            status      : CARDINAL;
            count       : CARDINAL;
            bp          : CARDINAL;
            be          : CARDINAL;
            size        : CARDINAL;
            start       : CARDINAL32;
            end         : CARDINAL32;
            buffer      : POINTER TO ARRAY [0..0] OF BYTE;(*any size allowed *)
            handle      : CARDINAL;
            userData    : ADDRESS;
            %IF PROTECT %THEN
            critic      : CriticalSection;
            %END
            peekedChar  : CHAR;
            mode        : AccessModes;
            valid       : BOOLEAN;
            dirty       : BOOLEAN;
            eof         : BOOLEAN;
            buffered    : BOOLEAN;
            canPosition : BOOLEAN;
            peeked      : BOOLEAN;
        END;
(*
   the only user fields in the above File record are
     status          = the error state of the last operation 0 = Success other errors vary by operating system
     count           = used by the read and write procedures
     handle          = the operating system file handle
     eof             = EndOfFile: will be set after a read operation
     userData        = you can use this field for anything you like

     you can access other fields but do so at your own risk. those fields may change in future implementations.
*)

CONST
    InvalidHandle       = MAX(CARDINAL);(*-1 for integers*)
(*
   These constants are used with the mayHave and mustHave search parameters of FindFirst
   Use one of these with mustHave to search for files only, directories only, files and directories
*)

    MustHaveNormalFile  = FileAttributeSet{NormalFile};
    MustHaveDirectory   = FileAttributeSet{Directory};
    MustHaveNothing     = FileAttributeSet{};

    (* use the following in mayHave *)

    AllAttributes       = FileAttributeSet{MIN(FileAttributes).. MAX(FileAttributes)};
    StdAttributes       = AllAttributes - FileAttributeSet{Hidden, System};

(* these will allow the use of the set + operator to compose a search filter expression example: StdAttributes + AddHidden *)

    AddArchive          = FileAttributeSet{Archive};
    AddReadOnly         = FileAttributeSet{ReadOnly};
    AddHidden           = FileAttributeSet{Hidden};
    AddSystem           = FileAttributeSet{System};
    AddCompressed       = FileAttributeSet{Compressed};
    AddTemporary        = FileAttributeSet{Temporary};
    AddEncrypted        = FileAttributeSet{Encrypted};
    AddOffline          = FileAttributeSet{Offline};
    AddAlias            = FileAttributeSet{Alias};
    AddNormalFile       = FileAttributeSet{NormalFile};
    AddDirectory        = FileAttributeSet{Directory};

    UnixPermissions     = FileAttributeSet{OwnerRead..OtherExec};
    UnixExecPerm        = FileAttributeSet{OwnerExec,GroupExec,OtherExec};
    UnixReadPerm        = FileAttributeSet{OwnerRead,GroupRead,OtherRead};
    UnixWritePerm       = FileAttributeSet{OwnerWrite,GroupWrite,OtherWrite};

PROCEDURE OpenFile(VAR OUT f : File; spec : ARRAY OF CHAR; mode : AccessModes); (* open the file specified by spec, with the access mode specified by mode the file must currently exist f.status = 0 signifies success, otherwise it contains the  operating system error code the file position is at the beginning of the file *)
PROCEDURE OpenFileEx(VAR OUT f : File; spec : ARRAY OF CHAR; mode : AccessModes; useInfo : FileUseInfoSet); (* as OpenFile, with additional information in useInfo *)
PROCEDURE CreateFile(VAR OUT f : File; spec : ARRAY OF CHAR); (* create a file with the given file specification the mode of the file is ReadWriteDenyAll if the file already exists, then it is truncated to 0 bytes in size f.status = 0 signifies success, otherwise it contains the operating system error code the file position is at the beginning of the file *)
PROCEDURE CreateFileEx(VAR OUT f : File; spec : ARRAY OF CHAR; useInfo : FileUseInfoSet); (* as CreateFile, with additional information in useInfo *)
PROCEDURE GetTempFileDirectory(VAR OUT spec : ARRAY OF CHAR); (* return the system temportary file directory. *)
PROCEDURE MakeTempFileName(VAR INOUT spec : ARRAY OF CHAR); (*  creates a unique filename in the path given in spec.  if spec = "", then the file is placed in the system temp directory.  returns the resulting full file specification in spec. *)
PROCEDURE CreateTempFile(VAR OUT f : File; VAR INOUT spec : ARRAY OF CHAR); (*  this is implemented as MakeTempFileName(spec);   CreateFileEx(f, spec, FileUseInfoSet{TemporaryFile}); *)
PROCEDURE CreateTempFileEx(VAR OUT f : File; VAR INOUT spec : ARRAY OF CHAR; useInfo : FileUseInfoSet); (*  this is implemented as MakeTempFileName(spec); CreateFileEx(f, spec, useInfo+FileUseInfoSet{TemporaryFile}); *)
PROCEDURE OpenCreateFile(VAR OUT f : File; spec : ARRAY OF CHAR; mode : AccessModes); (* open the file specified by spec, with the access mode specified by mode if the file does not exist it is created  f.status = 0 signifies success, otherwise it contains the  operating system error code *)
PROCEDURE OpenCreateFileEx(VAR OUT f : File; spec : ARRAY OF CHAR; mode : AccessModes;                           useInfo : FileUseInfoSet);
(* as OpenCreateFile, with additional information in useInfo *)
PROCEDURE FakeFileOpen(VAR OUT f : File; handle : CARDINAL; mode : AccessModes); (* initializes the File record with proper inital values handle = the operating system handle used to access the "file"  mode = the access modes  this call always succeeds  *)
PROCEDURE CloseFile(VAR INOUT f : File); (*  closes the specified file if the file was buffered and the buffer is "dirty", then contents  of the buffer are written to disk before closing the file *)
PROCEDURE FileType(VAR INOUT f : File) : FileTypes; (* returns the type of the file for DiskFile you can use the file position and size functions *)
PROCEDURE SetFileBuffer(VAR INOUT f : File; VAR OUT buf : ARRAY OF BYTE); (* attach a buffer to a file excellent for sequentially accessed files.  size of buffer is taken from the size of the ARRAY OF BYTE parameter  One a buffer is attached to a file all read/write calls go through  the file buffer. The disk is only accessed when the buffer is full for  writes or empty for reads.  For example, your code could read one byte at a time from the file but  the disk is accessed in chunks of the size of the buffer.  1-64k are values to try. if you are writing files then larger is better.  this is because a fast HD writes reasonably large blocks in the same time  as smaller ones.  the best rule for a buffer size is to time your application with  some different buffer sizes to see what does best.  NOTE: Do not forget to consider any disk caches the file system may have in testing file access performance. *)
PROCEDURE RemoveFileBuffer(VAR INOUT f : File); (* flushes buffer to disk if necessary, then removes file buffer *)
PROCEDURE FlushBuffers(VAR INOUT f : File; flushOs : BOOLEAN); (* flushes any buffered data to disk  if flushOS = TRUE then the file is flushed out of any  OS buffers and or caches to disk, if the file system supports this  capability. *) 
PROCEDURE ReadBlock(VAR INOUT f : File; buf : ADDRESS; size : CARDINAL); (*  the amount to be read is passed in the size parameter  the data is read into buf  the file record count field contains the actual amount read  the file position is advanced by the actual amount read  f.status = 0 signifies success, otherwise it contains the  operating system error code  *) 
PROCEDURE WriteBlock(VAR INOUT f : File; buf : ADDRESS; size : CARDINAL); (*  the amount to be written is passed in the size parameter  the data is written from buf  the file record count field contains the actual amount written  the file position is advanced by the actual amount written  f.status = 0 signifies success, otherwise it contains the  operating system error code *)
PROCEDURE ReadChar(VAR INOUT f : File) : CHAR; (*  reads a single character  it returns the value EOL for the following character sequences  Carriage Return. CHR(13)  Line Feed. CHR(10)  Carriage Return, Line Feed. CHR(13)CHR(10)  the file position is advanced by the actual amount read  f.status = 0 signifies success, otherwise it contains the  operating system error code *)
PROCEDURE WriteChar(VAR INOUT f : File; ch : CHAR); (* writes a single char  the value of the EOL is system dependent.  for DOS and Windows => Carriage return, line feed pairs.  for Unix => line feed.  the file position is advanced by one character, except if  EOL represents a multi character sequence. in this case the position  is advanced by the number of characters in the sequence.  f.status = 0 signifies success, otherwise it contains the  operating system error code *)
PROCEDURE PeekChar(VAR INOUT f : File) : CHAR; (*  same as ReadChar  except that the file position is not advanced  f.status = 0 signifies success, otherwise it contains the  operating system error code *)
PROCEDURE ReadLine(VAR INOUT f : File; VAR OUT str : ARRAY OF CHAR) : CARDINAL; (*  a convenience call.  this procedure reads a line of text from a file.  the EOL marker is consumed by this read.  if the line is longer than the passed string parameter  then the procedure returns leaving the remainder of the line  to be read on the next read.  the return value is the number of characters in the line. *)
PROCEDURE WriteLine(VAR INOUT f : File; str : ARRAY OF CHAR);
                                                                  (* a convenience call  implemented as 
                                                                      IF str[0] <> '' THEN
                                                                          WriteBlock(f, str, LENGTH(str)*SIZE(CHAR));
                                                                      END;
                                                                      WriteChar(f, EOL);
                                                                  *)
PROCEDURE LockFileRegion(VAR INOUT f : File; start, length : CARDINAL32); (*  gives the process exclusive access to the specified region  of the file in question. You should unlock after the critical file  operations have been completed  multiple locking regions cannot overlap  start = the starting offset in bytes of the region to be locked  length = the length in bytes of the region to be locked  f.status = 0 signifies success, otherwise it contains the  operating system error code *)
PROCEDURE UnlockFileRegion(VAR INOUT f : File; start, length : CARDINAL32); (*  unlocks a previously locked region of the file  start = the starting offset in bytes of the locked region  length = the length in bytes of the region to be unlocked  f.status = 0 signifies success, otherwise it contains the  operating system error code *)
PROCEDURE SetFilePos(VAR INOUT f : File; pos : CARDINAL32); (*  pos is an absolute file position in bytes  position zero is the beginning of the file  f.status = 0 signifies success, otherwise it contains the  operating system error code *)
PROCEDURE GetFilePos(VAR INOUT f : File) : CARDINAL32; (*  returns an absolute position  position zero is the beginning of the file  f.status = 0 signifies success, otherwise it contains the  operating system error code *)
PROCEDURE MoveFilePos(VAR INOUT f : File; pos : INTEGER32); (* moves the file position relative to the current position  position zero is the beginning of the file f.status = 0 signifies success, otherwise it contains the operating system error code *)
PROCEDURE TruncateFile(VAR INOUT f : File); (* truncates the file size to the current file position example    SetFilePos(f, newEnd);    TruncateFile(f);  f.status = 0 signifies success, otherwise it contains the  operating system error code *)
PROCEDURE FileLength(VAR INOUT f : File) : CARDINAL32; (* size of the file in bytes *)
PROCEDURE GetFileSizes(name : ARRAY OF CHAR; VAR actual, alloc : CARDINAL32); (* actual, alloc are the size of the file in bytes actual is the amount of data stored in the file alloc includes system allocation overhead such as sector/cluster granularity *)
PROCEDURE TranslateFileError(f : File) : CommonFileErrors; (* translates the OS dependent .status field for common errors  only a small common subset of errors is translated  if the error does not translate to to one of the errors in CommonFileErrors then FileErrUnknown is returned *)
PROCEDURE GetFileAttr(name : ARRAY OF CHAR; VAR OUT attr : FileAttributeSet) : BOOLEAN; (*  fetch the attributes of the file specified by name  returns true if the operation succeeded *)
PROCEDURE SetFileAttr(name : ARRAY OF CHAR; attr : FileAttributeSet) : BOOLEAN; (* set the attributes of the file specified by name with attr  not all attributes can be set by this call, as this is system  dependent. for example  only the "owner" of a file may be allowed to make this change.  returns true if the operation succeeded *)
PROCEDURE GetFileDateTime(spec : ARRAY OF CHAR; VAR OUT dt : DateTime);
%IF WIN32 %OR UNIX %THEN
PROCEDURE GetFileDateTimeUTC(spec : ARRAY OF CHAR; VAR OUT dt : DateTime);
PROCEDURE GetFileDateTimes(spec : ARRAY OF CHAR; VAR OUT create, access, modify : DateTime; utc : BOOLEAN);
%END
(*
 fetch the date time of the file specified in spec
 the time is local time.
 if the file does not exist, dt.year = 0

 GetFileDateTimeUTC returns UTC time.

 GetFileDateTimes returns the file creation time, last access time and last modification
 time *IF* the file system supports the specified parameter.
 If the file system does not support a given time parameter then the parameter time
 will be the last modification time. utc = TRUE then the time retuned is UTC.
*)

PROCEDURE SetFileDateTime(spec : ARRAY OF CHAR; dt : DateTime) : BOOLEAN;
%IF WIN32 %OR UNIX %THEN
PROCEDURE SetFileDateTimeUTC(spec : ARRAY OF CHAR; dt : DateTime) : BOOLEAN;
PROCEDURE SetFileDateTimes(spec : ARRAY OF CHAR;
                           create, access, modify : DateTime;
                           utc : BOOLEAN) : BOOLEAN;
%END
(*
 set the date time of the file specified in spec.
 the dt parameter is local time.
 sets "modified" time field
 also sets the "accessed" time field if applicable
 the system may not allow you to set the file date time.
 this is a system dependent feature.
 for example
 only the "owner" of a file may be allowed to make this change.

 SetFileDateTimeUTC assumes the dt parameter is UTC time.

 SetFileDateTimes sets the file creation time, last access time and last modification
 time *IF* the file system supports the specified parameter.
 If the file system does not support a given time parameter then the parameter is
 ignored.
 if a given parameter has .year = 0, then that parameter is ignored.
 utc = TRUE the the time parameters are assumed to be UTC times.

*)

PROCEDURE RenameFile(fromFile, toFile : ARRAY OF CHAR) : BOOLEAN; (* change the name of a file you can move a file from one directory to another on the same device with this function. the meaning of a device is somewhat dependent on the underlying file system *)
PROCEDURE DeleteFile(name : ARRAY OF CHAR) : BOOLEAN; (* deletes the named file from the disk returns TRUE if successful *)
PROCEDURE FileExists(name : ARRAY OF CHAR) : BOOLEAN; (*  does the named file exists returns TRUE if successful *)
PROCEDURE CopyFile(source, dest : ARRAY OF CHAR) : BOOLEAN; (* copy a file from source to dest if dest already exists it will be overwritten *)
PROCEDURE SetHandleCount(num : CARDINAL); 
(*
 increases number of file handles available to a process
 The number of file handles specifies how many files can be open
 at any one point in time
 some systems have a limit and some do not.
 this call is then ignored on systems that do not have hard limits.
 if the current limit is greater than the value being set, then this call
 does not reduce the limit.
*)

PROCEDURE GetNextDir(list : ARRAY OF CHAR; sepChars : ARRAY OF CHAR; VAR INOUT i : CARDINAL; VAR OUT item : ARRAY OF CHAR) : BOOLEAN;
(*
 list is a series of strings separated by a a given set of character(s)
 this list is a search path of directories
 sepChars = the character(s) that separate the individual elements
 the procedure starts search list at the position pointed to in "i"
 "i" is incremented past the returned string upon return
 item = the returned string extracted from list
 a PathSepChar characeter is appended to the returned path if this character
 is not already there
 returns TRUE if a value is returned in item, otherwise FALSE
 example of use

    i := 0;
    WHILE GetNextDir(path, i, dir) DO
        ConstructFileName(name, dir, spec);
         do something
    END;
*)

PROCEDURE ParseFileName(pathname : ARRAY OF CHAR; VAR OUT parts : FileNameParts);
(* splits file spec into the FileNameParts record
   .drive only has meaning on Miscorosft platforms
       this is the device, it is either a logical drive letter or
       a UNC server name and share.
   .path = this is the path
   .name = the file name  excluding the file extension
   .extension = the file extension, this is everything  after the *last*
       '.' character. On Unix systems this may actually be the full file
       name since the convension there is to use a preceeding '.' to
       mark hidden files and/or directories.
*)

PROCEDURE ParseFileNameEx(path : ARRAY OF CHAR; VAR OUT parts : FileNameParts; list : ARRAY OF CHAR; sepChars : ARRAY OF CHAR);
(*
 like ParseFileName, but in addition
 an extension is only considered a file extension if it is
 contained within the list of extensions passed in the parameter list
 where each item within the list is separated by one of the characters
 is sepChars
 if the extension is not in the list it is then appended to name field
 this function obviously only makes sense on file systems where
 a filename can contain more than one . character
*)

PROCEDURE AssembleParts(parts : FileNameParts; VAR OUT name : ARRAY OF CHAR);
(* puts the file parts back together into a single string *)

PROCEDURE ConstructFileName(pri, def : ARRAY OF CHAR; VAR OUT res : ARRAY OF CHAR);
(*
 pri = the primary file spec (device/path/name/extension)
 def = the default file spec (device/path/name/extension)
 the above can have all or none of various path components
 anything pri does not have is supplied by def if it has the component
 this function uses ParseFileName to split pri and def into their
 respective components

  ConstructFileName(FileName, '.mod', FileName);
   supplies a default extension. The leading . is necessary
  ConstructFileName(FileName, 'd:\dev\rtl\', FileName);
   supplies a default device and/or path. The trailing PathSepChar is necessary
   to signify that "rtl" is a directory name and not a file name.
*)

PROCEDURE ConstructFileNameEx(pri, def : ARRAY OF CHAR;
                              VAR OUT res : ARRAY OF CHAR;
                              list : ARRAY OF CHAR;
                              sepChars : ARRAY OF CHAR);
(* like ConstructFileName, however uses ParseFileNameEx to split
 the primary and default parts *)

PROCEDURE FindInPathList(fileName, pathList : ARRAY OF CHAR;
                         sepChars : ARRAY OF CHAR;
                         VAR OUT result : ARRAY OF CHAR;
                         searchCurrent : BOOLEAN) : BOOLEAN;
(*
 searches a given path list for a file given in fileName
 sepChars = the character(s) that separate the path elements
 if the function returns TRUE then the fileSpec is returned in result
 if searchCurrent = TRUE then the current directory is search first
 if searchCurrent = FALSE then the current directory is not searched first
*)

PROCEDURE FindInOSPathList(fileName : ARRAY OF CHAR;
                           VAR OUT result : ARRAY OF CHAR) : BOOLEAN;
(*
 searches the Operating system search path, "PATH", for a file
 if TRUE then the fileSpec is returned in result
 the current directory is always searched first
*)

PROCEDURE ExpandFileSpec(VAR INOUT spec : ARRAY OF CHAR);
(*
 if passed a relative file spec, this procedure returns
 a complete unambiguous file spec which includes the device and path
 otherwise the passed file spec is returned unchanged.
*)

PROCEDURE FindFirst(path : ARRAY OF CHAR;
                    mayHave : FileAttributeSet;
                    mustHave : FileAttributeSet;
                    VAR OUT entry : SearchEntry) : BOOLEAN;
(*
 path specifies a device and directory where to search
 wildcards can be and generally are used in path.
 How wildcards are specified is filesystem dependent.
 Generally the '*' character matches any number of characters and a
 '?' character matches any single character.
 if this procedure succeeds(returns TRUE), you must call FindClose when
 you are done searching.
 Example of use
   This searches for all files, excluding file directories.
    IF FindFirst("*", StdAttributes, MustHaveNormalFile, entry) THEN
        REPEAT
            ...
        UNTIL NOT FindNext(entry);
        FindClose(entry);
    END;


  mayHave - returned files will only have attributes within this set,
            however they need not have all of the attributes.
  mustHave - all returned files will have ALL the specified Attribute(s)

  FindFirst combines mustHave into mayHave as a convenience.

  NormalFile is assumed for mayHave if Directory is not present.

  this API will not return the pseudo directories "." and "..", for filesystems and/or
  operating systems that support such pseudo directories. it filters these out.
*)

PROCEDURE FindNext(VAR INOUT entry : SearchEntry) : BOOLEAN; (* find the next file in the search parameters given in FindFirst *)
PROCEDURE FindClose(VAR INOUT entry : SearchEntry); (* terminates a FindFirst, FindNext sequence of operations *)
PROCEDURE MakeDir(name : ARRAY OF CHAR) : BOOLEAN;
(*
 create a directory in the given location.
 name can contain a device and path in the specification
 all directories in the path up to the directory to be created must
 already exist.
 returns TRUE if successfull
*)

PROCEDURE CreateDirTree(fileSpec : ARRAY OF CHAR) : BOOLEAN;
(*
 makes sure every directory within the given path exists
 if it does not, the necessary directories are created
 returns TRUE if successfull
 this procedure accepts file specifications and ignores the filename
 this means that if you pass only a directory path a PatrhSepChar character
 should be at the end of the string.
 examples
 CreateDirTree("\sbm2\mod\FileFile.MOD");
 CreateDirTree("\sbm2\mod\");
*)

PROCEDURE DeleteDir(name : ARRAY OF CHAR) : BOOLEAN; (*  remove a directory returns TRUE if successfull *)
PROCEDURE DirExists(name : ARRAY OF CHAR) : BOOLEAN; (*  does the specified directory exist  returns TRUE if successfull *)
PROCEDURE RenameDir(fromDir, toDir : ARRAY OF CHAR) : BOOLEAN;
(*
 rename a directory
 you can move a file from one directory to another on the same device
 with this function
 the meaning of a device is somewhat dependent on the underlying system
 returns TRUE if successfull
*)

PROCEDURE GetDefaultPath(VAR OUT path : ARRAY OF CHAR) : BOOLEAN;
(*
 gets the current default device and path
 the operating system uses the default path to open files when
 they are given a relative path
 for example if \sbm2\def\ is the default path then
 OpenFile(f, "FileFunc.DEF", ReadOnlyDenyWrite)
  is the same as
 OpenFile(f, "\sbm2\def\FileFunc.DEF", ReadOnlyDenyWrite)
*)

PROCEDURE SetDefaultPath(path : ARRAY OF CHAR) : BOOLEAN; (* sets the current default device and path *)

PROCEDURE GetDeviceFreeSpace(spec : ARRAY OF CHAR) : CARDINAL32;
(*
 spec = file spec of any device, file or directory on the device
 returns the amount of free space on the device.
 the device can be a network share.
 if the device has more free space than MAX(CARDINAL32) then
 MAX(CARDINAL32) is returned
*)

PROCEDURE GetDeviceFreeSpaceEx(spec : ARRAY OF CHAR;
                               VAR OUT allocGranularity : CARDINAL32) : LONGCARD;
(*
 spec = file spec of any device, file or directory on the device
 returns the amount of free space on the device.
 the device can be a network share.
 allocGranularity contains the file allocation granularity of the device
*)

PROCEDURE GetDeviceType(spec : ARRAY OF CHAR) : DeviceTypes;
(*
 spec = file spec of any file or directory on the "device"
 DOS can only determine remote and removable
 Unix can only determine remote
*)

END FileFunc.

(***************************************************************************)
(***************************************************************************)
DEFINITION MODULE TextFileFunc;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

FROM FileFunc IMPORT    File;

TYPE
    SeparatorSet        = PACKEDSET OF CHAR;
VAR
    Separators  : SeparatorSet; (* Default = SeparatorSet{' ',
                                                          FileFunc.EOL,
                                                          ASCII.ht,
                                                          ASCII.vt,
                                                          ASCII.ff};
                                *)

    PadChar     : CHAR;                 (* Default = ' ' *)
    ErrorChar   : CHAR;                 (* Default = '?' *)
    ChopField   : BOOLEAN;              (* Default = FALSE *)

(*
 it is recommended that any file using these functions be buffered
 by using FileFunc.SetFileBuffer. The best size of the buffer can only
 be determined via testing. Buffersizes smaller than 512 do not make
 much sense and sizes greater than 4-8k have diminishing returns
*)

PROCEDURE WriteString(VAR INOUT f : File; str : ARRAY OF CHAR); (*  writes the string, str, to the file f *)
PROCEDURE WriteStringLn(VAR INOUT f : File; str : ARRAY OF CHAR); (* this procedure is implemented as follows        WriteString(f, str);        WriteLn(f); *)
PROCEDURE WriteField(VAR INOUT f : File; str : ARRAY OF CHAR; fieldLen : INTEGER);
(*
 writes the string, str, to the file f
 fieldLen specifies the size of the field the string is written to
 if fieldLen > 0, str is right justified in the field
 if fieldLen < 0, str is left justified in the field
 if fieldLen = 0 then the full string str is always written to the file
 if the LENGTH of str is less than fieldLen then this function will
 use the global variable PadChar to justify the string in the field
 if the LENGTH of str is > fieldLen, and fieldLen <> 0, then the value
 of the Global variable ChopField determines the action taken
 if ChopField = TRUE then the field will be filled with ErrorChar and
    f.status = MAX(CARDINAL)
 if ChopField = FALSE then the string str will be truncated to the size
 of the field
*)

PROCEDURE WriteNumber(VAR INOUT f : File; num : LONGINT; fieldLen : INTEGER);
(*
 the number num is converted to a string and written to the file f
 using the procedure WriteField
 See WriteField for the meaning of fieldLen
 if the numeric conversion fails f.status = MAX(CARDINAL)
*)

PROCEDURE WriteNumberBase(VAR INOUT f : File;
                          num : CARDINAL32;
                          base : CARDINAL;
                          fieldLen : INTEGER);
(*
 the number num is converted to a string in the number base base
 and is written to the file f using the procedure WriteField
 base must be >= 2 and <= 16
 See WriteField for the meaning of fieldLen
 if the numeric conversion fails f.status = MAX(CARDINAL)
*)

PROCEDURE WriteReal(VAR INOUT f : File;
                    num : LONGREAL;
                    sigFigs : CARDINAL;
                    eng : BOOLEAN;
                    fieldLen : INTEGER);
(*
 the real number num is converted to a string in scientific notation
 and written to the file f using the procedure WriteField
 sigFigs = the number of significant digits in the mantissa
 if eng = TRUE the the exponent will always be a multiple of 3 and the
 mantissa may thus be >= 10.0
 See WriteField for the meaning of fieldLen
 if the numeric conversion fails f.status = MAX(CARDINAL)
*)

PROCEDURE WriteRealFixed(VAR INOUT f : File;
                         num : LONGREAL;
                         place : CARDINAL;
                         fieldLen : INTEGER);
(*
 the real number num is converted to a string in decimal notation
 and written to the file f using the procedure WriteField
 place = the number of digits after the decimal place to output
 See WriteField for the meaning of fieldLen
 if the numeric conversion fails f.status = MAX(CARDINAL)
*)

PROCEDURE WriteBoolean(VAR INOUT f : File; bool : BOOLEAN; fieldLen : INTEGER);
(*
 writes a BOOLEAN value to the file f
 if bool = TRUE then a string value of "TRUE" is written
 otherwise "FALSE" is written
 See WriteField for the meaning of fieldLen
*)

PROCEDURE WriteLn(VAR INOUT f : File); (*  writes and end of line character(s) to the file f implemented as FileFunc.WriteChar(f, FileFunc.EOL) *)
PROCEDURE ReadString(VAR INOUT f : File; VAR OUT str : ARRAY OF CHAR); (*  reads from the file f as many characters as will fit into the string str. IF the end of the current line is reached before the string is filled then reading will stop and the string will be null terminated *)
PROCEDURE ReadField(VAR INOUT f : File; VAR OUT str : ARRAY OF CHAR);
(*
 reads from file f into the string str a string deliminated by the
 characters in the global variable Separators. If the string is not
 fully filled it will be null terminated.
 This function skips over separators before attempting to read the field
*)

PROCEDURE ReadNumber(VAR INOUT f : File) : LONGINT;
(*
 read an integer number from the file f by calling ReadField
 to read a field string and then doing a numeric conversion to an
 integer number. if the conversion fails f.status = MAX(CARDINAL)
 if an error occurs a value of 0 is always returned
*)

PROCEDURE ReadNumberValidate(VAR INOUT f : File;
                             min, max : LONGINT;
                             VAR OUT inRange : BOOLEAN) : LONGINT;
(*
 read an integer number from the file f by calling ReadField
 to read a field string and then doing a numeric conversion to an
 integer number. if the conversion fails f.status = MAX(CARDINAL)
 this function also validates the numeric range of the read number
 if an error occurs a value of 0 is always returned
 if the result within the range of min and max, inclusive then
 inRange = TRUE, otherwise inRange = FALSE
 in either case the number value will be returned
*)

PROCEDURE ReadNumberBase(VAR INOUT f : File; base : CARDINAL) : CARDINAL32;
(*
 read an integer number in the number base, base, from the file f by
 calling ReadField to read a field string and then doing a numeric
 conversion to an integer number.
 if the conversion fails f.status = MAX(CARDINAL)
 if an error occurs a value of 0 is always returned
 base must be >= 2 and <= 16
*)

PROCEDURE ReadReal(VAR INOUT f : File) : LONGREAL;
(*
 read a real number from the file f by calling ReadField to read a
 field string and then doing a numeric conversion to a real number
 the real number can be in decimal, scientific or engineering notation
 if the conversion fails f.status = MAX(CARDINAL)
 if an error occurs a value of 0.0 is always returned
*)

PROCEDURE ReadBoolean(VAR INOUT f : File) : BOOLEAN;
(*
 read a BOOLEAN value from the file f by calling ReadField to read a
 field string and then comparing the field string with the value "TRUE"
 If the field string is equal to "TRUE" then TRUE is returned, otherwise
 FALSE is returned
 The field string is compared case insensitively
*)

PROCEDURE ReadLn(VAR INOUT f : File); (* skip all characters in the current line up to and including the end of the line *)
END TextFileFunc.

(* ====================================================================================*)
DEFINITION MODULE RndFile;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

IMPORT IOChan, ChanConsts, SYSTEM;

TYPE
    ChanId      = IOChan.ChanId;
    FlagSet     = ChanConsts.FlagSet;
    OpenResults = ChanConsts.OpenResults;

CONST  (* Accepted singleton values of FlagSet *)
  read  = FlagSet{ChanConsts.readFlag}; (* input operations are requested/available *)
  write = FlagSet{ChanConsts.writeFlag};(* output operations are requested/available *)
  old   = FlagSet{ChanConsts.oldFlag};  (* a file may/must/did exist before the channel is opened *)
  text  = FlagSet{ChanConsts.textFlag}; (* text operations are requested/available *)
  raw   = FlagSet{ChanConsts.rawFlag};  (* raw operations are requested/available *)

PROCEDURE OpenOld(VAR cid : ChanId; name : ARRAY OF CHAR; flags : FlagSet; VAR res : OpenResults);
  (* Attempts to obtain and open a channel connected to a stored random
     access file of the given name. The old flag is implied; without the
     write flag, read is implied; without the text flag, raw is implied.
     If successful, assigns to cid the identity of the opened channel,
     assigns the value opened to res, and sets the read/write position to
     the start of the file. If a channel cannot be opened as required, the
     value of res indicates the reason, and cid identifies the invalid
     channel.
  *)

PROCEDURE OpenClean(VAR cid : ChanId; name : ARRAY OF CHAR; flags : FlagSet; VAR res : OpenResults);
  (* Attempts to obtain and open a channel connected to a stored random
     access file of the given name. The write flag is implied;
     without the text flag, raw is implied.
     If successful, assigns to cid the identity of the opened channel,
     assigns the value opened to res, and truncates the file to zero length.
     If a channel cannot be opened as required, the value of res indicates
     the reason, and cid identifies the invalid channel.
  *)

PROCEDURE IsRndFile(cid : ChanId) : BOOLEAN;   (* Tests if the channel identified by cid is open to a random access file.  *)
PROCEDURE IsRndFileException() : BOOLEAN;    (* Returns TRUE if the current coroutine is in the exceptional execution state because of the raising of a RndFile exception;      otherwise returns FALSE.   *)

CONST
    FilePosSize = 4;
TYPE
    FilePos = ARRAY [1..FilePosSize] OF SYSTEM.LOC;

PROCEDURE StartPos(cid : ChanId) : FilePos;
  (* If the channel identified by cid is not open to a random access file,
     the exception wrongDevice is raised; otherwise returns the position of
     the start of the file.
  *)

PROCEDURE CurrentPos(cid : ChanId) : FilePos;
  (* If the channel identified by cid is not open to a random access file,
     the exception wrongDevice is raised; otherwise returns the position of
     the current read/write position.
  *)

PROCEDURE EndPos(cid : ChanId) : FilePos;
  (* If the channel identified by cid is not open to a random access file,
     the exception wrongDevice is raised; otherwise returns the first
     position after which there have been no writes.
  *)

PROCEDURE NewPos(cid : ChanId;  chunks : INTEGER; chunkSize : CARDINAL; from : FilePos) : FilePos;
  (* If the channel identified by cid is not open to a random access file,
     the exception wrongDevice is raised; otherwise returns the
     position (chunks * chunkSize) relative to the position given by from,
     or raises the exception posRange if the required position cannot be
     represented as a value of type FilePos.
  *)

PROCEDURE SetPos(cid : ChanId; pos : FilePos);
  (* If the channel identified by cid is not open to a random access file,
     the exception wrongDevice is raised; otherwise sets the read/write
     position to the value given by pos.
  *)

PROCEDURE Close(VAR cid : ChanId);
  (* If the channel identified by cid is not open to a random access file,
     the exception wrongDevice is raised; otherwise closes the channel, and
     assigns the value identifying the invalid channel to cid.
  *)

END RndFile.

(* ====================================================================================*)
DEFINITION MODULE SeqFile;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

  (* Rewindable sequential files *)

IMPORT IOChan, ChanConsts;

TYPE
    ChanId      = IOChan.ChanId;
    FlagSet     = ChanConsts.FlagSet;
    OpenResults = ChanConsts.OpenResults;

CONST     (* Accepted singleton values of FlagSet *)
  read  = FlagSet{ChanConsts.readFlag}; (* input operations are requested/available *)
  write = FlagSet{ChanConsts.writeFlag};(* output operations are requested/available *)
  old   = FlagSet{ChanConsts.oldFlag};  (* a file may/must/did exist before the channel is opened *)
  text  = FlagSet{ChanConsts.textFlag}; (* text operations are requested/available *)
  raw   = FlagSet{ChanConsts.rawFlag};  (* raw operations are requested/available *)

PROCEDURE OpenWrite(VAR cid : ChanId;
                    name : ARRAY OF CHAR;
                    flags : FlagSet;
                    VAR res : OpenResults);
  (* Attempts to obtain and open a channel connected to a stored rewindable
     file of the given name. The write flag is implied; without the raw flag,
     text is implied. If successful, assigns to cid the identity of the
     opened channel, assigns the value opened to res, and selects output mode,
     with the write position at the start of the file
     (i.e. the file is of zero length).
     If a channel cannot be opened as required, the value of res indicates
     the reason, and cid identifies the invalid channel.
  *)

PROCEDURE OpenAppend(VAR cid : ChanId;
                     name : ARRAY OF CHAR;
                     flags : FlagSet;
                     VAR res : OpenResults);
  (* Attempts to obtain and open a channel connected to a stored rewindable
     file of the given name.
     The write and old flags are implied; without the raw flag, text is
     implied. If successful, assigns to cid the identity of the opened
     channel, assigns the value opened to res, and selects output mode,
     with the write position corresponding to the length of the file.
     If a channel cannot be opened as required, the value of res indicates
     the reason, and cid identifies the invalid channel.
  *)

PROCEDURE OpenRead(VAR cid : ChanId;
                   name : ARRAY OF CHAR;
                   flags : FlagSet;
                   VAR res : OpenResults);
  (* Attempts to obtain and open a channel connected to a stored rewindable
     file of the given name. The read and old flags are implied; without the
     raw flag, text is implied.If successful, assigns to cid the identity
     of the opened channel, assigns the value opened to res, and selects
     input mode, with the read position corresponding to the start of the
     file. If a channel cannot be opened as required, the value of res
     indicates the reason, and cid identifies the invalid channel.
  *)

PROCEDURE IsSeqFile(cid : ChanId) : BOOLEAN;
  (* Tests if the channel identified by cid is open to a rewindable
     sequential file. *)

PROCEDURE Reread(cid : ChanId);
  (* If the channel identified by cid is not open to a rewindable sequential
     file, the exception wrongDevice is raised; otherwise attempts to set
     the read position to the start of the file, and to select input mode.
     If the operation cannot be performed (perhaps because of insufficient
     permissions) neither input mode nor output mode is selected.
  *)

PROCEDURE Rewrite(cid : ChanId);
  (* If the channel identified by cid is not open to a rewindable sequential
     file, the exception wrongDevice is raised; otherwise, attempts to
     truncate the file to zero length, and to select output mode.
     If the operation cannot be performed (perhaps because of insufficient
     permissions) neither input mode nor output mode is selected.
  *)

PROCEDURE Close(VAR cid : ChanId);
  (* If the channel identified by cid is not open to a rewindable sequential
     file, the exception wrongDevice is raised; otherwise closes the channel,
     and assigns the value identifying the invalid channel to cid.
  *)

END SeqFile.
(* ==================================================================================== *)
DEFINITION MODULE StreamFile;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

  (* Independent sequential data streams *)

IMPORT IOChan, ChanConsts;

TYPE
    ChanId      = IOChan.ChanId;
    FlagSet     = ChanConsts.FlagSet;
    OpenResults = ChanConsts.OpenResults;

  (* Accepted singleton values of FlagSet *)

CONST
  read  = FlagSet{ChanConsts.readFlag}; (* input operations are requested/available *)
  write = FlagSet{ChanConsts.writeFlag};(* output operations are requested/available *)
  old   = FlagSet{ChanConsts.oldFlag};  (* a file may/must/did exist before the channel is opened *)
  text  = FlagSet{ChanConsts.textFlag}; (* text operations are requested/available *)
  raw   = FlagSet{ChanConsts.rawFlag};  (* raw operations are requested/available *)

PROCEDURE Open(VAR cid : ChanId;
               name : ARRAY OF CHAR;
               flags : FlagSet;
               VAR res : OpenResults);
  (* Attempts to obtain and open a channel connected to a sequential
     stream of the given name. The read flag implies old; without the raw
     flag, text is implied. If successful, assigns to cid the identity of
     the opened channel, and assigns the value opened to res. If a channel
     cannot be opened as required, the value of res indicates the reason,
     and cid identifies the invalid channel.   *)

PROCEDURE IsStreamFile(cid : ChanId) : BOOLEAN;
  (* Tests if the channel identified by cid is open to a sequential stream. *)

PROCEDURE Close(VAR cid : ChanId);
  (* If the channel identified by cid is not open to a sequential stream,
     the exception wrongDevice is raised; otherwise closes the channel, and
     assigns the value identifying the invalid channel to cid.   *)

END StreamFile.
(* ==================================================================================== *)
DEFINITION MODULE TextIO;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END


  (* Input and output of character and string types over specified channels.
     The read result is of the type IOConsts.ReadResults.
  *)

IMPORT IOChan;

  (* The following procedures do not read past line marks *)

PROCEDURE ReadChar(cid : IOChan.ChanId; VAR ch : CHAR);
  (* If possible, removes a character from the input stream cid and
     assigns the corresponding value to ch.  The read result is set to
     the value allRight, endOfLine, or endOfInput.
  *)

PROCEDURE ReadRestLine(cid : IOChan.ChanId; VAR s : ARRAY OF CHAR);
  (* Removes any remaining characters from the input stream cid before
     the next line mark, copying to s as many as can be accommodated as
     a string value. The read result is set to the value allRight,
     outOfRange, endOfLine, or endOfInput.  *)

PROCEDURE ReadString(cid : IOChan.ChanId; VAR s : ARRAY OF CHAR);
  (* Removes only those characters from the input stream cid before the
     next line mark that can be accommodated in s as a string value, and
     copies them to s.  The read result is set to the value allRight,
     endOfLine, or endOfInput.  *)

PROCEDURE ReadToken(cid : IOChan.ChanId; VAR s : ARRAY OF CHAR);
  (* Skips leading spaces, and then removes characters from the input
     stream cid before the next space or line mark, copying to s as
     many as can be accommodated as a string value. The read result is
     set to the value allRight, outOfRange, endOfLine, or end OfInput. *)

  (* The following procedure reads past the next line mark *)

PROCEDURE SkipLine(cid : IOChan.ChanId);
  (* Removes successive items from the input stream cid up to and
     including the next line  mark, or until the end of input is reached.
     The read result is set to the value allRight, or endOfInput.  *)

  (* Output procedures *)

PROCEDURE WriteChar(cid : IOChan.ChanId; ch : CHAR);
  (* Writes the value of ch to the output stream cid. *)

PROCEDURE WriteLn(cid : IOChan.ChanId);
  (* Writes a line mark to the output stream cid. *)

PROCEDURE WriteString(cid : IOChan.ChanId; s : ARRAY OF CHAR);
  (* Writes the string value in s to the output stream cid. *)

END TextIO.
(* ====================================================================================*)
DEFINITION MODULE SIOResult;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END


(* Read results for the default input channel *)

IMPORT IOConsts;

TYPE
    ReadResults = IOConsts.ReadResults;

(*
  TYPE
    ReadResults =    (* This type is used to classify the result of an input operation *)
    (
      notKnown,      (* no data read result is set *)
      allRight,      (* data is as expected or as required *)
      outOfRange,    (* data cannot be represented *)
      wrongFormat,  (* data not in expected format *)
      endOfLine,    (* end of line seen before expected data *)
      endOfInput    (* end of input seen before expected data *)
    );
*)

PROCEDURE ReadResult() : ReadResults;

(* Returns the result for the last read operation on the default input
   channel *)

END SIOResult.
(***************************************************************************)
(***************************************************************************)
DEFINITION MODULE SLWholeIO;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

(* Input and output of whole numbers in decimal text form over default
   channels. The read result is of the type IOConsts.ReadResults. *)

(* The text form of a signed whole number is ["+" | "-"], decimal digit, {decimal digit}
   The text form of an unsigned whole number is decimal digit, {decimal digit}
*)

PROCEDURE ReadLongInt(VAR int : LONGINT);
(* Skips leading spaces, and removes any remaining characters from the
   default input channel that form part of a signed whole number.  The
   value of this number is assigned to int. The read result is set to
   the value allRight, outOfRange, wrongFormat, endOfLine, or endOfInput. *)

PROCEDURE WriteLongInt(int : LONGINT; width : CARDINAL);
  (* Writes the value of int to the default output channel in text form,
     in a field of the given minimum width.A width of zero(0) is special
 and means a single space character will always be output before the number *)

PROCEDURE ReadLongCard(VAR card : LONGCARD);
  (* Skips leading spaces, and removes any remaining characters from the
     default input channel that form part of an unsigned whole number.
     The value of this  number is assigned to card.  The read result is
     set to the value allRight, outOfRange, wrongFormat, endOfLine,
     or endOfInput. *)

PROCEDURE WriteLongCard(card : LONGCARD; width : CARDINAL);
  (* Writes the value of card to the default output channel in text form,
     in a field of the given minimum width.A width of zero(0) is special
 and means a single space character will always be output before the number *)

END SLWholeIO.

(* ==================================================================================== *)
DEFINITION MODULE STextIO;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

(* Input and output of character and string types over default channels. The read result is of the type IOConsts.ReadResults. *)
(* The following procedures do not read past line marks *)
PROCEDURE ReadChar(VAR ch : CHAR); (* If possible, removes a character from the default input stream, and assigns the corresponding value to ch.  The read result is set to allRight, endOfLine or endOfInput. *)
PROCEDURE ReadRestLine(VAR s : ARRAY OF CHAR); (* Removes any remaining characters from the default input stream before the next line mark, copying to s as many as can be accommodated as a string value.  The read result is set to the value allRight, outOfRange, endOfLine, or endOfInput. *)
PROCEDURE ReadString(VAR s : ARRAY OF CHAR); (* Removes only those characters from the default input stream before the next line mark that can be accommodated in s as a string value, and copies them to s.  The read result is set to the value allRight, endOfLine, or endOfInput. *)
PROCEDURE ReadToken(VAR s : ARRAY OF CHAR);  (* Skips leading spaces, and then removes characters from the default input stream before the next space or line mark, copying to s as many as can be accommodated as a string value.  The read result is set to the value allRight, outOfRange, endOfLine, or endOfInput. *)

  (* The following procedure reads past the next line mark *)
PROCEDURE SkipLine; (* Removes successive items from the default input stream up to and including the next line mark or until the end of input is reached.   The read result is set to the value allRight, or endOfInput. *)
PROCEDURE WriteChar(ch : CHAR); (* Writes the value of ch to the default output stream. *)
PROCEDURE WriteLn;  (* Writes a line mark to the default output stream. *)
PROCEDURE WriteString(s : ARRAY OF CHAR);  (* Writes the string value of s to the default output stream. *)
END STextIO.

(* ==================================================================================== *)
DEFINITION MODULE LongIO;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

(* Input and output of real numbers in decimal text form over specified channels. The read result is of the type IOConsts.ReadResults. *)

IMPORT IOChan;
  (* The text form of a signed fixed-point real number is ["+" | "-"], decimal digit, {decimal digit}, [".", {decimal digit}]
     The text form of a signed floating-point real number is signed fixed-point real number, "E", ["+" | "-"], decimal digit, {decimal digit}
  *)

PROCEDURE ReadReal(cid : IOChan.ChanId; VAR real : LONGREAL);
(* Skips leading spaces, and removes any remaining characters from cid that form part of a signed fixed or floating point number.  The value of this number is assigned to real.  The read result is set to the value allRight, outOfRange, wrongFormat, endOfLine, or  endOfInput. *)

PROCEDURE WriteFloat(cid : IOChan.ChanId; real : LONGREAL; sigFigs : CARDINAL; width : CARDINAL);
(* Writes the value of real to cid in floating-point text form, with sigFigs significant figures, in a field of the given minimum width. *)
(* if width = 0 then a single space character will always be output before the number. *)

PROCEDURE WriteEng(cid : IOChan.ChanId; real : LONGREAL; sigFigs : CARDINAL; width : CARDINAL);
(* As for WriteFloat, except that the number is scaled with one to three digits in the whole number part, and with an exponent that is a multiple of three. *)
(* if width = 0 then a single space character will always be output before the number. *)

PROCEDURE WriteFixed(cid : IOChan.ChanId; real : LONGREAL; place : INTEGER; width : CARDINAL);
(* Writes the value of real to cid in fixed-point text form, rounded to the given place relative to the decimal point, in a field of the given minimum width. *)
(* if width = 0 then a single space character will always be output before the number. *)

PROCEDURE WriteReal(cid : IOChan.ChanId; real : LONGREAL; width : CARDINAL);
(* Writes the value of real to cid, as WriteFixed if the sign and magnitude can be shown in the given width, or otherwise as WriteFloat.  The number of places or significant digits depends on the given width.  *)
(* if width = 0 then a single space character will always be output before the number. *)
END LongIO.

DEFINITION MODULE LWholeIO;
%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

(* Input and output of whole numbers in decimal text form over specified channels. The read result is of the type IOConsts.ReadResults. *)

IMPORT IOChan;
(* The text form of a signed whole number is ["+" | "-"], decimal digit, {decimal digit}
   The text form of an unsigned whole number is decimal digit, {decimal digit}   *)

PROCEDURE ReadLongInt(cid : IOChan.ChanId; VAR int : LONGINT);
  (* Skips leading spaces, and removes any remaining characters from cid that form part of a signed whole number.  The value of this number is assigned to int.  The read result is set to the value allRight, outOfRange, wrongFormat, endOfLine, or endOfInput. *) 
PROCEDURE WriteLongInt(cid : IOChan.ChanId; int : LONGINT; width : CARDINAL);
  (* Writes the value of int to cid in text form, in a field of the given minimum width. A width of zero(0) is special and means a single space character will always be output before the number *)

PROCEDURE ReadLongCard(cid : IOChan.ChanId; VAR card : LONGCARD);
  (* Skips leading spaces, and removes any remaining characters from cid that form part of an unsigned whole number.  The value of this number is assigned to card.  The read result is set to the value allRight, outOfRange, wrongFormat, endOfLine, or endOfInput. *)

PROCEDURE WriteLongCard(cid : IOChan.ChanId; card : LONGCARD; width : CARDINAL);
  (* Writes the value of card to cid in text form, in a field of the given minimum width.A width of zero(0) is special and means a single space character will always be output before the number *)
END LWholeIO.

(* ====================================================================================*)
DEFINITION MODULE RealIO;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

(* Input and output of real numbers in decimal text form over specified channels. The read result is of the type IOConsts.ReadResults. *)

IMPORT IOChan;
(* The text form of a signed fixed-point real number is ["+" | "-"], decimal digit, {decimal digit}, [".", {decimal digit}]
   The text form of a signed floating-point real number is signed fixed-point real number, "E", ["+" | "-"], decimal digit, {decimal digit}   *)

PROCEDURE ReadReal(cid : IOChan.ChanId; VAR real : REAL);
  (* Skips leading spaces, and removes any remaining characters from cid that form part of a signed fixed or floating point number.  The value of this number is assigned to real.  The read result is set to the value allRight, outOfRange, wrongFormat, endOfLine, or  endOfInput. *)
PROCEDURE WriteFloat(cid : IOChan.ChanId; real : REAL; sigFigs : CARDINAL; width : CARDINAL);
  (* Writes the value of real to cid in floating-point text form, with sigFigs significant figures, in a field of the given minimum width.   *)
  (* if width = 0 then a single space character will always be output before the number. *)
PROCEDURE WriteEng(cid : IOChan.ChanId; real : REAL; sigFigs : CARDINAL; width : CARDINAL);
  (* As for WriteFloat, except that the number is scaled with one to three digits in the whole number part, and with an exponent that is a multiple of three. *)
  (* if width = 0 then a single space character will always be output before the number. *)
PROCEDURE WriteFixed(cid : IOChan.ChanId; real : REAL; place : INTEGER; width : CARDINAL);
  (* Writes the value of real to cid in fixed-point text form, rounded to the given place relative to the decimal point, in a field of the given minimum width. *)
  (* if width = 0 then a single space character will always be output before the number. *)
PROCEDURE WriteReal(cid : IOChan.ChanId; real : REAL; width : CARDINAL);
  (* Writes the value of real to cid, as WriteFixed if the sign and magnitude can be shown in the given width, or otherwise as WriteFloat.  The number of places or significant digits depends on the given width.   *)
  (* if width = 0 then a single space character will always be output before the number. *)
END RealIO.

(* ==================================================================================== *)
DEFINITION MODULE SWholeIO;
%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

(* Input and output of whole numbers in decimal text form over default
   channels. The read result is of the type IOConsts.ReadResults. *)

(* The text form of a signed whole number is
   ["+" | "-"], decimal digit, {decimal digit}

   The text form of an unsigned whole number is
   decimal digit, {decimal digit}
*)

PROCEDURE ReadInt(VAR int : INTEGER);
(* Skips leading spaces, and removes any remaining characters from the
   default input channel that form part of a signed whole number.  The
   value of this number is assigned to int. The read result is set to
   the value allRight, outOfRange, wrongFormat, endOfLine, or endOfInput. *)

PROCEDURE WriteInt(int : INTEGER; width : CARDINAL);
(* Writes the value of int to the default output channel in text form,
 in a field of the given minimum width. A width of zero(0) is special
 and means a single space character will always be output before the number *)

PROCEDURE ReadCard(VAR card : CARDINAL);
  (* Skips leading spaces, and removes any remaining characters from the
     default input channel that form part of an unsigned whole number.
     The value of this  number is assigned to card.  The read result is
     set to the value allRight, outOfRange, wrongFormat, endOfLine,
     or endOfInput. *)

PROCEDURE WriteCard(card : CARDINAL; width : CARDINAL);
(* Writes the value of card to the default output channel in text form,
 in a field of the given minimum width. A width of zero(0) is special
 and means a single space character will always be output before the number *)

END SWholeIO.
(* ==================================================================================== *)
DEFINITION MODULE TermFile;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END
  (* Access to the terminal device *)
  (* Channels opened by this module are connected to a single terminal device; typed characters are distributed between channels according to the sequence of read requests. *)

IMPORT IOChan, ChanConsts;

TYPE
    ChanId      = IOChan.ChanId;
    FlagSet     = ChanConsts.FlagSet;
    OpenResults = ChanConsts.OpenResults;
CONST  (* Accepted singleton values of FlagSet *)
  read  = FlagSet{ChanConsts.readFlag}; (* input operations are requested/available *)
  write = FlagSet{ChanConsts.writeFlag};(* output operations are requested/available *)
  text  = FlagSet{ChanConsts.textFlag}; (* text operations are requested/available *)
  raw   = FlagSet{ChanConsts.rawFlag};  (* raw operations are requested/available *)
  echo  = FlagSet{ChanConsts.echoFlag}; (* echoing by interactive device on reading of characters from input stream requested/applies *)
PROCEDURE Open(VAR cid : ChanId; flags : FlagSet; VAR res : OpenResults);
  (* Attempts to obtain and open a channel connected to the terminal.  Without the raw flag, text is implied.  Without the echo flag, line mode is requested, otherwise single character mode is requested.
     If successful, assigns to cid the identity of the opened channel, and assigns the value opened to res.
     If a channel cannot be opened as required, the value of res indicates the reason, and cid identifies the invalid channel. *)
PROCEDURE IsTermFile(cid : ChanId) : BOOLEAN; (* Tests if the channel identified by cid is open to the terminal. *)
PROCEDURE Close(VAR cid : ChanId);  (* If the channel identified by cid is not open to the terminal, the exception wrongDevice is raised; otherwise closes the channel and assigns the value identifying the invalid channel to cid. *)
END TermFile.
(***************************************************************************)
(***************************************************************************)
DEFINITION MODULE Terminal;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

(* a simple text output *)
(* the size of the display is generally 80x25, but may be different *)

CONST
    (* these character codes are used for some non ASCII characters *)
    (* supported by this terminal module *)

    CursorUp    = CHR(1);
    CursorDown  = CHR(2);
    PageUp      = CHR(3);
    PageDown    = CHR(4);
    CursorLeft  = CHR(5);
    CursorRight = CHR(6);

    Escape      = CHR(27);
    Tab         = CHR(9);
    BackSpace   = CHR(8);
    Bell        = CHR(7);
    Enter       = CHR(13);
    LineFeed    = CHR(10);

PROCEDURE Write(ch : CHAR); (* write a single character to the currsor cursor position *)
PROCEDURE WriteString(str : ARRAY OF CHAR); (* write a string to the cursor position *)
PROCEDURE WriteLn;
                       (* set the cursor X position to 0, far left *)
                       (* and increment the Y positon, down *)
                       (* if the Y position is greater that the terminal window size *)
                       (* then the terminal window data is scrolled and a blank line *)
                       (* is displayed at the bottom of the terminal window *)
                       (* and the Y position of the cursor is at the bottom of the terminal *)
                       (* window *)
PROCEDURE Position(X, Y : CARDINAL); (* set the cursor position *)
PROCEDURE CharAvail() : BOOLEAN; (* is there a character keystroke available for input *)
PROCEDURE Read(VAR OUT ch : CHAR); (* read a character keystroke *)
PROCEDURE ReadChar() : CHAR; (* same as Read, but in function form *)
PROCEDURE Reset; (* clears the screen and places the cursor at 0,0 *)
END Terminal.

(* ==================================================================================== *)
DEFINITION MODULE WholeIO;
(* Input and output of whole numbers in decimal text form over specified channels. The read result is of the type IOConsts.ReadResults.   *)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

IMPORT IOChan;
  (* The text form of a signed whole number is ["+" | "-"], decimal digit, {decimal digit}
     The text form of an unsigned whole number is decimal digit, {decimal digit} *)
PROCEDURE ReadInt(cid : IOChan.ChanId; VAR int : INTEGER);   (* Skips leading spaces, and removes any remaining characters from cid that form part of a signed whole number.  The value of this number is assigned to int.  The read result is set to the value allRight, outOfRange, wrongFormat, endOfLine, or endOfInput. *)
PROCEDURE WriteInt(cid : IOChan.ChanId; int : INTEGER; width : CARDINAL);  (* Writes the value of int to cid in text form, in a field of the given minimum width.  A width of zero(0) is special and means a single space character will always be output before the number *)
PROCEDURE ReadCard(cid : IOChan.ChanId; VAR card : CARDINAL);   (* Skips leading spaces, and removes any remaining characters from cid that form part of an unsigned whole number.  The value of this number is assigned to card.  The read result is set to the value allRight, outOfRange, wrongFormat, endOfLine, or endOfInput. *)
PROCEDURE WriteCard(cid : IOChan.ChanId; card : CARDINAL; width : CARDINAL); (* Writes the value of card to cid in text form, in a field of the given minimum width. A width of zero(0) is special and means a single space character will always be output before the number *)
END WholeIO.


DEFINITION MODULE FIO;
FROM SYSTEM IMPORT BYTE;
IMPORT Str;
CONST
    DiskFull		= 0F0h;

    StandardInput	= 1;
    StandardOutput	= 2;
    ErrorOutput		= 3;
    AuxDevice		= 4;
    PrinterDevice	= 5;

%IF DOS %OR FlashTek %OR WIN16 %THEN
    MaxOpenFiles	= 20;
%ELSE
    MaxOpenFiles	= 100;
%END
    BufferOverhead	= 0;

TYPE
    File		= CARDINAL;
    CHARSET		= Str.CHARSET;
    PathTail		= ARRAY [0..12] OF CHAR;
    FileAttr		= SET OF (
				  readonly,
				  hidden,
				  system,
				  volume,
				  directory,
				  archive
				 );

    <*/PUSH/PACK/NOWARN:A*>
    DirEntry		=
	RECORD
	rsvd		: ARRAY [0..20] OF CARDINAL8;
	attr		: FileAttr;
	time		: CARDINAL16;
	date		: CARDINAL16;
	size		: CARDINAL32;
	name		: PathTail;
	END;
    <*/POP*>

VAR
    RunTimeError	: PROCEDURE(CARDINAL32, CARDINAL, ARRAY OF CHAR);

    IOcheck		: BOOLEAN;
    EOF			: BOOLEAN;
    Separators		: Str.CHARSET;
    OK			: BOOLEAN;
    ChopOff		: BOOLEAN;
    Eng			: BOOLEAN;
    PrefixChar		: CHAR;
    PostfixChar		: CHAR;
PROCEDURE Append(name : ARRAY OF CHAR) : File;
PROCEDURE AssignBuffer(f : File; VAR buf : ARRAY OF BYTE);
PROCEDURE ChDir(name : ARRAY OF CHAR);
PROCEDURE Close(f : File);
PROCEDURE Create(name : ARRAY OF CHAR) : File;
PROCEDURE Erase(name : ARRAY OF CHAR);
PROCEDURE Exists(name : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE Flush(f : File);
PROCEDURE GetCurrentDate() : CARDINAL32;
PROCEDURE GetDir(drive : SHORTCARD; VAR name : ARRAY OF CHAR);
PROCEDURE GetDrive() : SHORTCARD;
PROCEDURE GetFileDate(f : File) : CARDINAL32;
PROCEDURE GetPos(f : File) : CARDINAL32;
PROCEDURE IOresult() : CARDINAL;
PROCEDURE MkDir(name : ARRAY OF CHAR);
PROCEDURE Open(name : ARRAY OF CHAR) : File;
PROCEDURE OpenRead(name : ARRAY OF CHAR) : File;
PROCEDURE RdBin(f : File; VAR buf : ARRAY OF BYTE; amount : CARDINAL) : CARDINAL;
PROCEDURE RdItem(f : File; VAR str : ARRAY OF CHAR);
PROCEDURE RdChar(f : File) : CHAR;
PROCEDURE RdBool(f : File) : BOOLEAN;
PROCEDURE RdShtInt(f : File) : SHORTINT;
PROCEDURE RdInt(f : File) : INTEGER;
PROCEDURE RdLngInt(f : File) : LONGINT;
PROCEDURE RdShtCard(f : File) : SHORTCARD;
PROCEDURE RdCard(f : File) : CARDINAL;
PROCEDURE RdLngCard(f : File) : CARDINAL32;
PROCEDURE RdShtHex(f : File) : SHORTCARD;
PROCEDURE RdHex(f : File) : CARDINAL;
PROCEDURE RdLngHex(f : File) : CARDINAL32;
PROCEDURE RdReal(f : File) : REAL;
PROCEDURE RdLngReal(f : File) : LONGREAL;
PROCEDURE RdStr(f : File; VAR str : ARRAY OF CHAR);
PROCEDURE ReadFirstEntry(path : ARRAY OF CHAR; attr : FileAttr; VAR entry : DirEntry) : BOOLEAN;
PROCEDURE ReadNextEntry(VAR entry : DirEntry) : BOOLEAN;
PROCEDURE Rename(fromName, toName : ARRAY OF CHAR);
PROCEDURE RmDir(name : ARRAY OF CHAR);
PROCEDURE Seek(f : File; pos : CARDINAL32);
PROCEDURE SetDrive(drive : SHORTCARD);
PROCEDURE SetFileDate(f : File; dt : CARDINAL32);
PROCEDURE Size(f : File) : CARDINAL32;
PROCEDURE Truncate(f : File);
PROCEDURE WrBin(f : File; buf : ARRAY OF BYTE; amount : CARDINAL);
PROCEDURE WrCharRep(f : File; ch : CHAR; amount : CARDINAL);
PROCEDURE WrLn(f : File);
PROCEDURE WrChar(f : File; ch : CHAR);
PROCEDURE WrBool(f : File; bool : BOOLEAN; len : INTEGER);
PROCEDURE WrShtInt(f : File; num : SHORTINT; len : INTEGER);
PROCEDURE WrInt(f : File; num : INTEGER; len : INTEGER);
PROCEDURE WrLngInt(f : File; num : LONGINT; len : INTEGER);
PROCEDURE WrShtCard(f : File; num : SHORTCARD; len : INTEGER);
PROCEDURE WrCard(f : File; num : CARDINAL; len : INTEGER);
PROCEDURE WrLngCard(f : File; num : CARDINAL32; len : INTEGER);
PROCEDURE WrShtHex(f : File; num : SHORTCARD; len : INTEGER);
PROCEDURE WrHex(f : File; num : CARDINAL; len : INTEGER);
PROCEDURE WrLngHex(f : File; num : CARDINAL32; len : INTEGER);
PROCEDURE WrReal(f : File; num : REAL; precision : CARDINAL; len : INTEGER);
PROCEDURE WrLngReal(f : File; num : LONGREAL; precision : CARDINAL; len : INTEGER);
PROCEDURE WrFixReal(f : File; num : REAL; precision : CARDINAL; len : INTEGER);
PROCEDURE WrFixLngReal(f : File; num : LONGREAL; precision : CARDINAL; len : INTEGER);
PROCEDURE WrStr(f : File; str : ARRAY OF CHAR);
PROCEDURE WrStrAdj(f : File; str : ARRAY OF CHAR; len : INTEGER);
END FIO.

DEFINITION MODULE FIOR;
TYPE
    ExtStr	= ARRAY [0..2] OF CHAR;
PROCEDURE AddExtension(VAR spec : ARRAY OF CHAR; ext : ARRAY OF CHAR);
PROCEDURE ChangeExtension(VAR spec : ARRAY OF CHAR; ext : ARRAY OF CHAR);
PROCEDURE RemoveExtension(VAR spec : ARRAY OF CHAR);
PROCEDURE ExpandPath(path : ARRAY OF CHAR; VAR fullPath : ARRAY OF CHAR);
PROCEDURE IsExtension(spec : ARRAY OF CHAR; ext : ExtStr) : BOOLEAN;
PROCEDURE MakePath(VAR path : ARRAY OF CHAR; head, tail : ARRAY OF CHAR);
PROCEDURE SplitPath(path : ARRAY OF CHAR; VAR head, tail : ARRAY OF CHAR);
END FIOR.

DEFINITION MODULE IO;
IMPORT Str;
CONST
    MaxRdLength		= 256;
TYPE
    WrStrType		= PROCEDURE(ARRAY OF CHAR);
    RdStrType		= PROCEDURE(VAR ARRAY OF CHAR);
    CHARSET		= Str.CHARSET;
VAR
    RdStrRedirect	: RdStrType;
    WrStrRedirect	: WrStrType;
    InputRedirected	: BOOLEAN;
    OutputRedirected	: BOOLEAN;
    RdLnOnWr		: BOOLEAN;
    Prompt		: BOOLEAN;
    Separators		: CHARSET;
    OK			: BOOLEAN;
    ChopOff		: BOOLEAN;
    Eng			: BOOLEAN;
    PrefixChar		: CHAR;
    SuffixChar		: CHAR;

PROCEDURE RedirectInput(fileName : ARRAY OF CHAR);
PROCEDURE RedirectOutput(fileName : ARRAY OF CHAR);
PROCEDURE RdStr(VAR str : ARRAY OF CHAR);
PROCEDURE EndOfRd(skip : BOOLEAN) : BOOLEAN;
PROCEDURE RdLn;
PROCEDURE RdChar() : CHAR;
PROCEDURE RdBool() : BOOLEAN;
PROCEDURE RdShtInt() : SHORTINT;
PROCEDURE RdInt() : INTEGER;
PROCEDURE RdLngInt() : LONGINT;
PROCEDURE RdShtCard() : SHORTCARD;
PROCEDURE RdCard() : CARDINAL;
PROCEDURE RdLngCard() : CARDINAL32;
PROCEDURE RdShtHex() : SHORTCARD;
PROCEDURE RdHex() : CARDINAL;
PROCEDURE RdLngHex() : CARDINAL32;
PROCEDURE RdReal() : REAL;
PROCEDURE RdLngReal() : LONGREAL;
PROCEDURE RdItem(VAR str : ARRAY OF CHAR);
PROCEDURE WrStr(str : ARRAY OF CHAR);
PROCEDURE WrStrAdj(str : ARRAY OF CHAR; len : INTEGER);
PROCEDURE WrLn;
PROCEDURE WrChar(ch : CHAR);
PROCEDURE WrBool(bool : BOOLEAN; len : INTEGER);
PROCEDURE WrShtInt(num : SHORTINT; len : INTEGER);
PROCEDURE WrInt(num : INTEGER; len : INTEGER);
PROCEDURE WrLngInt(num : LONGINT; len : INTEGER);
PROCEDURE WrShtCard(num : SHORTCARD; len : INTEGER);
PROCEDURE WrCard(num : CARDINAL; len : INTEGER);
PROCEDURE WrLngCard(num : CARDINAL32; len : INTEGER);
PROCEDURE WrShtHex(num : SHORTCARD; len : INTEGER);
PROCEDURE WrHex(num : CARDINAL; len : INTEGER);
PROCEDURE WrLngHex(num : CARDINAL32; len : INTEGER);
PROCEDURE WrReal(num : REAL; precision : CARDINAL; len : INTEGER);
PROCEDURE WrLngReal(num : LONGREAL; precision : CARDINAL; len : INTEGER);
PROCEDURE WrFixReal(num : REAL; precision : CARDINAL; len : INTEGER);
PROCEDURE WrFixLngReal(num : LONGREAL; precision : CARDINAL; len : INTEGER);
PROCEDURE WrCharRep(ch : CHAR; count : CARDINAL);
END IO.


(***************************************************************************)
(***************************************************************************)

DEFINITION MODULE SYSTEMC;

%IF SPARC %AND Bits32 %THEN
<*/PROCESSOR:V8/NOAPPREGS*>
(* limit the registers compiler "helper" procedures can use.  these procedures have no symbol file.  to be compatible with any possible user options we choose the least common denoiminator  *)
%END

FROM SYSTEM IMPORT ADDRESS;

%IF WIN32 %OR OS2 %OR UNIX %THEN
PROCEDURE STACKGROWTH(pages : CARDINAL)
                            %IF IA32 %THEN
                            [ALTERS()];
                            %ELSE
                            ;
                            %END
%END

PROCEDURE MOVE(SOURCE, DEST : ADDRESS; COUNT : CARDINAL)
                                %IF IA32 %THEN
                                [PASS(,,AX), ALTERS(AX)];
                                %ELSE
                                [LeftToRight];
                                %END

PROCEDURE MOVEBYTES(SOURCE : ADDRESS; SRC_LEN : CARDINAL;
                    DEST : ADDRESS; DEST_LEN : CARDINAL)
                                %IF IA32 %THEN
                                [PASS(,DX,,AX), ALTERS(AX,DX)];
                                %ELSE
                                [LeftToRight];
                                %END

PROCEDURE COPYPAR3S(source, dest : ADDRESS; amount : CARDINAL) [LeftToRight];

PROCEDURE COPYOPENPARAMS;

%IF IA32 %AND Bits16 %THEN
PROCEDURE COPYPAR3;

PROCEDURE COPYOPENPARAM;
%END

%IF %NOT IA32 %THEN
(*
PROCEDURE LOADUA_WORDS;
PROCEDURE LOADUA_WORDU;
*)
PROCEDURE LOADUA_DWORDS;
PROCEDURE LOADUA_DWORDU;
PROCEDURE LOADUA_LONG;
PROCEDURE LOADUA_REAL4;
PROCEDURE LOADUA_REAL8;
PROCEDURE LOADUA_COMPLEX4;
PROCEDURE LOADUA_COMPLEX8;
(*
PROCEDURE STOREUA_WORD;
*)
PROCEDURE STOREUA_DWORD;
PROCEDURE STOREUA_LONG;
PROCEDURE STOREUA_REAL4;
PROCEDURE STOREUA_REAL8;
PROCEDURE STOREUA_COMPLEX4;
PROCEDURE STOREUA_COMPLEX8;
PROCEDURE CALLUA;
%END

PROCEDURE LMUL(RIGHT, LEFT : LONGINT) : LONGINT
                            %IF IA32 %THEN
                            [ALTERS(AX, DX)];
                            %ELSE
                            [LeftToRight];
                            %END

PROCEDURE LMULCHECK(RIGHT, LEFT : LONGINT) : LONGINT
                            %IF IA32 %THEN
                            [ALTERS(AX, DX)];
                            %ELSE
                            [LeftToRight];
                            %END

PROCEDURE LDIVIS(RIGHT, LEFT : LONGINT) : LONGINT
                            %IF IA32 %THEN
                            [ALTERS(AX, DX)];
                            %ELSE
                            [LeftToRight];
                            %END

PROCEDURE LDIVIU(RIGHT, LEFT : LONGCARD) : LONGCARD
                            %IF IA32 %THEN
                            [ALTERS(AX, DX)];
                            %ELSE
                            [LeftToRight];
                            %END

PROCEDURE LREMU(RIGHT, LEFT : LONGCARD) : LONGCARD
                            %IF IA32 %THEN
                            [ALTERS(AX, DX)];
                            %ELSE
                            [LeftToRight];
                            %END

PROCEDURE LREMS(RIGHT, LEFT : LONGINT) : LONGINT
                            %IF IA32 %THEN
                            [ALTERS(AX, DX)];
                            %ELSE
                            [LeftToRight];
                            %END

PROCEDURE LDIVS(RIGHT, LEFT : LONGINT) : LONGINT
                            %IF IA32 %THEN
                            [ALTERS(AX, DX)];
                            %ELSE
                            [LeftToRight];
                            %END

PROCEDURE LMODS(RIGHT, LEFT : LONGINT) : LONGINT
                            %IF IA32 %THEN
                            [ALTERS(AX, DX)];
                            %ELSE
                            [LeftToRight];
                            %END

PROCEDURE DIVS(RIGHT, LEFT : INTEGER) : INTEGER
                            %IF IA32 %THEN
                            [ALTERS(AX, DX)];
                            %ELSE
                            [LeftToRight];
                            %END

PROCEDURE MODS(RIGHT, LEFT : INTEGER) : INTEGER
                            %IF IA32 %THEN
                            [ALTERS(AX, DX)];
                            %ELSE
                            [LeftToRight];
                            %END

%IF SPARC %THEN
PROCEDURE FLOAT32(i : INTEGER) : LONGREAL;
PROCEDURE FLOAT64(li : LONGINT) : LONGREAL;
%END

PROCEDURE TTRUNC ["SYSTEMC_TRUNC"] ();
(*
PROCEDURE TROUND ["SYSTEMC_ROUND"] ();
PROCEDURE TINT ["SYSTEMC_INT"] ();
PROCEDURE TFRAC ["SYSTEMC_FRAC"] ();
*)

%IF IA32 %THEN
PROCEDURE MULC;
PROCEDURE CMPC;
%END
PROCEDURE DIVC;

VAR
    CapTable    : ARRAY [MIN(ACHAR)..MAX(ACHAR)] OF ACHAR;

PROCEDURE InitCapTable;

PROCEDURE CAP(ch : ACHAR) : ACHAR
                %IF IA32 %THEN
                [PASS(AX)];
                %ELSE
                ;
                %END

PROCEDURE UCAP(ch : UCHAR) : UCHAR
                %IF IA32 %THEN
                [PASS(AX)];
                %ELSE
                ;
                %END

END SYSTEMC.
(***************************************************************************)
(***************************************************************************)
DEFINITION MODULE StdHandles;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

PROCEDURE HaveStdInput() : BOOLEAN;
PROCEDURE StdInputHandle() : CARDINAL;
PROCEDURE HaveStdOutput() : BOOLEAN;
PROCEDURE StdOutputHandle() : CARDINAL;
PROCEDURE HaveStdError() : BOOLEAN;
PROCEDURE StdErrorHandle() : CARDINAL; (* generally the same as the standard output handle *)
PROCEDURE IsConsole(h : CARDINAL) : BOOLEAN;
(* is the handle refering to a command console *)
(* for input handles this generally means the keyboard *)
(* for output handles this means the display *)
END StdHandles.

DEFINITION MODULE SetExStorageDebugMode;
END SetExStorageDebugMode.

(***************************************************************************)
(***************************************************************************)
DEFINITION MODULE RunProg;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

TYPE
    ExecHandle;
    ExecFlags = (ExecAsync,
                 ExecDetached,
                 ExecMinimized,
                 ExecMaximized,
                 ExecHidden,
                 ExecNormalPriority,
                 ExecIdlePriority,
                 ExecHighPriority);
    ExecFlagSet = SET OF ExecFlags;
CONST
    SyncExec    = ExecFlagSet{};
    AsyncExec   = ExecFlagSet{ExecAsync};

PROCEDURE RunProgram(name, command, defaultPath : ARRAY OF CHAR;
                     flags : ExecFlagSet;
                     VAR OUT status : CARDINAL) : BOOLEAN;
(*
   Run the program given by "name" and passing the command line
   specified by "command".  The exit status of the program
   is returned in status
   defaultPath is the default device and directory for the application.
   if defaultPath = "" then the curreent default path is used.
   this function returns TRUE if the program was executed.
   The program is executed synchronous by default, meaning the program
   being executed must terminate before this call will return.
   status has no meaning unless the program is executed synchronous.

   on Unix systems when ExecAsync is used the executed process is
   orphaned by this call. Use RunProgramEx to not orphan the process.
   the process is orphaned because Unix want's the parent
   to "wait" on the child.

   All ExecFlags are optional behavior if the targeted operating
   system supports that option. If the system does not support an option
   then it is ignored.
   ExecAsync => If this flag is given then RunProgram will return after
                the specified program starts executing.
   ExecDetached => the process will not have standard input/output. All
                   standard output will be ignored. The process will receive
                   an error on standard input reads.
                   The program can create windows if it desires
                   ExecDetached implies ExecAsync
                   The program is run in the background
   ExecMinimized => The application will be informed to open its window
                    in the minimized state.
   ExecMaximized => The application will be informed to open its window
                    in the maximized state.
   ExecHidden    => The application will be informed to open its window hidden.
   Exec...Priority => Normal is assumed if none of these flags are used.
                      determines the process execution priority
*)

PROCEDURE RunProgramEx(name, command, defaultPath : ARRAY OF CHAR;
                       flags : ExecFlagSet;
                       VAR OUT handle : ExecHandle) : BOOLEAN;
(*
   this procedure is always used with ExecAsync
   if this flag is not specified it will return FALSE,
   otherwise this procedure operates just as RunProgram.
   the parameters are as RunProgram.
   the procedure returns in the parameter 'handle'
   a value which you can later use to retrieve the exit status
   of the program.
   when you are done with the program you should call TerminateProgram
   to free up resources allocated internally to track the executed program
   TerminateProgram also terminates the program if it is still running.
*)

PROCEDURE GetProgramExitStatus(handle : ExecHandle) : CARDINAL;
(*
   retrieve the exit value of the program
   if the program has not terminated MAX(CARDINAL) will be returned
*)

PROCEDURE TerminateProgram(VAR INOUT handle : ExecHandle);
(*
   this terminates the program you executed and releases resources
   allocated to track the executed program
   the value of handle is invalid(NIL) after this call
*)

PROCEDURE PerformCommand(com : ARRAY OF CHAR;
                         flags : ExecFlagSet;
                         VAR OUT status : CARDINAL) : BOOLEAN;
(*
   Run the command shell to perform the command, the com parameter.
   status is the exit status of the command shell
   not of a program that it runs
   returns TRUE if the command shell was executed
   status is the return result of the command interpreter.
*)

END RunProg.

(***************************************************************************)
(***************************************************************************)

DEFINITION MODULE RConversions;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

PROCEDURE RealToString(num : LONGREAL;
                       digits : CARDINAL;
                       VAR OUT str : ARRAY OF CHAR;
                       VAR INOUT pos : CARDINAL;
                       VAR OUT done : BOOLEAN);
(* Convert a real number into a string buf starting at position pos. *)
(* pos is left pointing at the next character after the converted number *)
(* done signifies the success of the conversion *)

PROCEDURE RealToStringFixed(num : LONGREAL;
                            digits, before : CARDINAL;
                            VAR OUT str : ARRAY OF CHAR;
                            VAR INOUT pos : CARDINAL;
                            VAR OUT done : BOOLEAN);
(* Convert a real number into a string buf starting at position pos using *)
(* fixed point notation with digits digits and before digits before the *)
(* decimal point *)
(* done signifies the success of the conversion *)

PROCEDURE StringToReal(str : ARRAY OF CHAR;
                       VAR INOUT pos : CARDINAL;
                       VAR OUT num : LONGREAL;
                       VAR OUT done : BOOLEAN);
(* Get a longreal number from a string starting at position pos. *)
(* pos is left pointing to the first character that is not part of *)
(* the number done signifies the success of the conversion *)

END RConversions.

(***************************************************************************)
(***************************************************************************)

DEFINITION MODULE MemUtils;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

<*/NOHIGH*>(* none of these calls care about this, so why pass usused data *)

FROM SYSTEM IMPORT
    LOC, BYTE, WORD, DWORD;

PROCEDURE FillMemBYTE(VAR OUT dest : ARRAY OF LOC;
                      numBytes : CARDINAL;
                      db : BYTE);
(* fill the memory location specified in dest *)
(* BYTE = 8bits *)
(* numBytes is the number of bytes to fill *)
(* db is the byte to use to fill dest *)

PROCEDURE FillMemWORD(VAR OUT dest : ARRAY OF LOC;
                      numWords : CARDINAL;
                      dw : WORD);
(* fill the memory location specified in dest *)
(* WORD = 16bits *)
(* numWords is the number of words to fill *)
(* dw is the word to use to fill dest *)

PROCEDURE FillMemDWORD(VAR OUT dest : ARRAY OF LOC;
                       numDwords : CARDINAL;
                       dd : DWORD);
(* fill the memory location specified in dest *)
(* DWORD = 32bits *)
(* numDwords is the number of dwords to fill *)
(* dd is the dword to use to fill dest *)

PROCEDURE ScanMemBYTE(dest : ARRAY OF LOC;
                      numBytes : CARDINAL;
                      db : BYTE) : CARDINAL;
(* scan the memory location specified in dest *)
(* BYTE = 8bits *)
(* numBytes is the number of bytes at most to scan *)
(* db is the byte to use to scan dest *)
(* the return value will be the first location where the byte db *)
(* was found while scanning. If the first location matches a value of zero *)
(* is returned. If the value was not found then numBytes will be returned *)

PROCEDURE ScanMemNeBYTE(dest : ARRAY OF LOC;
                        numBytes : CARDINAL;
                        db : BYTE) : CARDINAL;
(* like ScanMemBYTE but looks for the first location not equal to db *)

PROCEDURE ScanMemWORD(dest : ARRAY OF LOC;
                      numWords : CARDINAL;
                      dw : WORD) : CARDINAL;
(* scan the memory location specified in dest *)
(* WORD = 16bits *)
(* numWords is the number of words at most to scan *)
(* dw is the word to use to scan dest *)
(* the return value will be the first location where the word dw *)
(* was found while scanning. If the first location matches a value of zero *)
(* is returned. If the value was not found then numWords will be returned *)

PROCEDURE ScanMemNeWORD(dest : ARRAY OF LOC;
                        numWords : CARDINAL;
                        dw : WORD) : CARDINAL;
(* like ScanMemWORD but looks for the first location not equal to dw *)

PROCEDURE ScanMemDWORD(dest : ARRAY OF LOC;
                       numDwords : CARDINAL;
                       dd : DWORD) : CARDINAL;
(* scan the memory location specified in dest *)
(* DWORD = 32bits *)
(* numDwords is the number of dwords at most to scan *)
(* dd is the dword to use to scan dest *)
(* the return value will be the first location where the dword dd *)
(* was found while scanning. If the first location matches a value of zero *)
(* is returned. If the value was not found then numDwords will be returned *)

PROCEDURE ScanMemNeDWORD(dest : ARRAY OF LOC;
                         numDwords : CARDINAL;
                         dd : DWORD) : CARDINAL;
(* like ScanMemDWORD but looks for the first location not equal to dd *)

PROCEDURE MoveMem(VAR OUT dest : ARRAY OF LOC;
                  src : ARRAY OF LOC;
                  numBytes : CARDINAL);
(* this procedure correctly handles overlapping memory regions *)
(* by performing the memory move top down when necessary *)
(* numBytes is the number of bytes to move *)
(* BYTE = 8bits *)

END MemUtils.

(***************************************************************************)
(***************************************************************************)

DEFINITION MODULE FormatString;
FROM SYSTEM IMPORT ADDRESS;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL*>
%END
<*/COPYATTRIBUTES*>

PROCEDURE FormatString(formatStr : ARRAY OF CHAR;
                       VAR OUT destStr : ARRAY OF CHAR) : BOOLEAN
                         [RightToLeft, LEAVES, VARIABLE];

(* destStr can be the same string as formatStr. *)
(* this procedure takes a variable number of parameters *)
(* to accomodate the contents of the format string *)

(* note that when you pass a numeric constant you are *)
(* passing a longint, since in Stony Brook compilers all constants *)
(* are longint size until typed by an assignment or expression. *)
(* there is no formal parameter for a variable parameter to type check the constant to. *)
(* use ORD or INT if you need a CARDINAL or INTEGER sized constant *)
(* passed as one of the variable parameters. *)

(* the following character combinations allow simple entry of some *)
(* control characters into a format string *)
(* control characters are prefixed by a backslash character *)
(* \n = new line
        on Unix systems this is a single linefeed character CHR(10).
        on other systems this outputs two characters CHR(13)CHR(10)
*)
(* \t = horizontal tab *)
(* \v = vertical tab *)
(* \f = form feed *)
(* \x000 = character in hexidecimal form *)
(* if you want a backslash character in the output string then you need *)
(* to use a double backslash character sequence \\ character sequence. *)
(* if an unknown control specifier follows a backslash it is simply output *)
(* as itself, remember that the \ preceeding the char is not output *)

(*
  Format specifications, discussed below, always begin with a percent
  sign (%). If a percent sign is followed by a character that has no
  meaning as a format field, the function immediately returns FALSE,
  unless the next character is also a percent sign. In this case a
  single percent sign is placed into the output string.
  The format-control string is read from left to right. When the first
  format specification (if any) is encountered, it causes the value of
  the first argument after the format-control string to be converted and
  copied to the output string according to the format specification.
  The second format specification causes the second argument to be
  converted and copied, and so on. If there are more arguments than
  format specifications, the extra arguments are ignored. If there are
  not enough arguments for all of the format specifications, the results
  are undefined.

  The function will return FALSE if the output string cannot fully contain
  the results of the formatting.
  An illegal format field will cause a return of FALSE.
  A hex control character that is too large will cause a return of FALSE.
  A field width that is too large will cause a return of FALSE.
  Otherwise the function returns TRUE.

  A format specification has the following form:
    %[-]['][width]type

  Each field is a single character or a number signifying a particular
  format option. The type characters that appear after the last optional
  format field determine whether the associated argument is interpreted
  as a string, or a number. The simplest format specification contains
  only the percent sign and a type character (for example, %s).
  The optional fields control other aspects of the formatting.
  Following are the optional and required fields and their meanings:

  Field         Meaning
  -             Pad the output to the right to fill the field width, thus
                justifying output to the left.
                If this field is omitted, the output is padded to the left,
                thus justifying it to the right.

  '             The single quote character is followed by a character
                which will be used as the padding character if padding
                of the field is necessary. The default padding character
                is a blank space.

  width         A field width is specified by a cardinal constant or
                an asterisk. An asterisk specifies the field width is a
                variable and is the next parameter in the format parameters.
                The parameter type is CARDINAL.

                Width must be <= 256.

                Copy the specified minimum number of characters to the
                output string. The width field is a cardinal and the
                default is zero.

                The width specification never causes a value to be
                truncated; if the number of characters in the output value
                is greater than the specified width, or if the width field
                is not present, all characters of the value are printed.

                Pad characters will be output as necessary to fill the
                field width if the value does not fully occupy the
                specified width.

  type          Output the corresponding argument as a string, or a number.

                This field can be any of the following character sequences:
                The output type specifiers are not case sensitive.

        c       the type is CARDINAL, output is in decimal
        h       the type is CARDINAL, output is in hexadecimal
        i       the type is INTEGER, output is in decimal
        l       the type is LONGINT, output is in decimal
        s       the type is a null terminated ARRAY OF CHAR.
                The terminating null character is mandatory.
*)

PROCEDURE FormatStringEx(formatStr : ARRAY OF CHAR;
                         VAR OUT destStr : ARRAY OF CHAR;
                         args : ADDRESS) : BOOLEAN;
(*
  as FormatString except the base address of the "variable" arguments is
  passed in the args parameter.

  this function can be useful within a procedure that accepts a variable number of
  arguments and still wants to call FormatString with those variable arguments.
  in this case do the following.

  PROCEDURE MyProc(...
  VAR
      addr : ADDRESS;
  BEGIN
      VA_START(addr);
      ...
      ok := FormatStringEx(format, dest, addr);
  END MyProc;
*)
END FormatString.

(***************************************************************************)
(***************************************************************************)

DEFINITION MODULE FormatDT;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

FROM SysClock IMPORT DateTime;

TYPE
    DateFormats         = (MonthDayYear, DayMonthYear, YearMonthDay);
(* the following variables contain the formatting information *)
(* used in converting between strings and the DateTime record *)

VAR
    LeadingDayZero      : BOOLEAN;
    LeadingMonthZero    : BOOLEAN;
    LeadingTimeZero     : BOOLEAN;

    Time24Hour          : BOOLEAN;

    TimeSep             : ARRAY [0..15] OF CHAR;
    DateSep             : ARRAY [0..15] OF CHAR;

    FullYear            : BOOLEAN;

    AmStr               : ARRAY [0..15] OF CHAR;
    PmStr               : ARRAY [0..15] OF CHAR;

    DateFormat          : DateFormats;

PROCEDURE GetSystemFormatInfo;
(* this procedure retrieves the formatting information from the system *)
(* and stores it in the above variables *)
(* This procedure is called by the module initialization code. *)
(* It is here in case you need to reload the system information later *)

PROCEDURE DateTimeToString(dt : DateTime;
                           VAR OUT date : ARRAY OF CHAR;
                           VAR OUT time : ARRAY OF CHAR);
(* this function converts the DateTime to string format using *)
(* the current formatting information *)

PROCEDURE StringToDateTime(dateStr : ARRAY OF CHAR;
                           timeStr : ARRAY OF CHAR;
                           VAR OUT dt : DateTime) : BOOLEAN;
(* the function converts the strings to a DateTime record using the *)
(* current formatting information *)

END FormatDT.
(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1992-2002                             *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)


(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1994-2002                             *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)
DEFINITION MODULE ExStrings;
(* this module adds additional functionality to the ISO Strings module. *)
(* ISO does not allow the Strings module to be extended, hence the *)
(* existence of this module. *)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END
<*/COPYATTRIBUTES*>

IMPORT Strings;

TYPE
    CompareResults      = Strings.CompareResults;

(* case insensitive versions of ISO Strings functions *)

PROCEDURE CompareI(stringVal1, stringVal2 : ARRAY OF CHAR)
                                    : CompareResults [Invariant];

PROCEDURE EqualI(stringVal1, stringVal2 : ARRAY OF CHAR) : BOOLEAN [Invariant];

PROCEDURE FindNextI(pattern, stringToSearch : ARRAY OF CHAR;
                    startIndex : CARDINAL;
                    VAR OUT patternFound : BOOLEAN;
                    VAR OUT posOfPattern : CARDINAL);

PROCEDURE FindPrevI(pattern, stringToSearch : ARRAY OF CHAR;
                    startIndex : CARDINAL;
                    VAR OUT patternFound : BOOLEAN;
                    VAR OUT posOfPattern : CARDINAL);

PROCEDURE FindDiffI(stringVal1, stringVal2 : ARRAY OF CHAR;
                    VAR OUT differenceFound : BOOLEAN;
                    VAR OUT posOfDifference : CARDINAL);

(* Misc other usefull stuff *)
(* follows ISO parameter convensions *)

PROCEDURE AssignNullTerm(source : ARRAY OF CHAR; VAR OUT destination : ARRAY OF CHAR);
(* copies source to destination.
   the destination will always be null terminated.
*)

PROCEDURE NullTerminate(VAR str : ARRAY OF CHAR);
(* this will make sure the string is null terminated by placing *)
(* a null character in the high bound of the string *)
(* harmless if the string is already null terminated, and will truncate *)
(* the last character if it is not null terminated *)

PROCEDURE Lowercase(VAR INOUT stringVar : ARRAY OF CHAR);
(* the reverse of Strings.Capitalize *)

PROCEDURE AnsiToUnicode(strA : ARRAY OF ACHAR; VAR OUT strU : ARRAY OF UCHAR);
(* convert an Ansi(8-bit) string to a Unicode string *)

PROCEDURE UnicodeToAnsi(strU : ARRAY OF UCHAR;
                        VAR OUT strA : ARRAY OF ACHAR;
                        replaceChar : ACHAR);
(* convert an Unicode string to a Ansi(8-bit) string
   some Unicode characters may be "lost" and replaced with the
   replaceChar character.
   for example converting Kanji to Ansi will not work.
*)

PROCEDURE Utf8Length(strU : ARRAY OF UCHAR) : CARDINAL;
(*
  returns the number of character ACHAR characters needed to translate the UCHAR
  unicode string to UTF-8 format.
  the length returned does not include a null terminator character byte.
*)

PROCEDURE LengthUtf8(strA : ARRAY OF ACHAR) : CARDINAL;
(*
   return the length in characters, not bytes, of a UTF-8 sequence.
   Using LENGTH or Strings.Length will return the number of byte characters.
*)

PROCEDURE IsValidUtf8(strA : ARRAY OF ACHAR) : BOOLEAN;
(*
  returns true if the character sequence is a valid UTF-8 sequence.

  what this procedure is checking for are "over long" character encodings and
  truncated characters at the end of a string.
  UTF-8 encoding allows only the shortest possible encoding to exist in a
  valid UTF-8 character string.
*)

PROCEDURE UnicodeToUtf8(strU : ARRAY OF UCHAR; VAR OUT strA : ARRAY OF ACHAR);
(*
  convert a two byte Unicode character to a multibyte UTF-8 sequence.
  the ACHAR character string will be 1-3x the number of UCHAR characters.
  so a 3x ACHAR string will *always* be able to accept a conversion of
  a UCHAR character string.
*)

PROCEDURE Utf8ToUnicode(strA : ARRAY OF ACHAR;
                        VAR OUT strU : ARRAY OF UCHAR;
                        replaceChar : UCHAR);
(*
  convert a multibyte UTF-8 sequence to a two byte unicode character array.
  if the UTF-8 sequence contains a character that cannot be contained within
  a UCHAR unicode character (> 65535), then replaceChar will be inserted into
  the destination string for the unsupported character.
*)

PROCEDURE Utf8ToAnsi(utf8 : ARRAY OF ACHAR;
                     VAR OUT strA : ARRAY OF ACHAR;
                     replaceChar : ACHAR);
(*
  convert a UTF-8 sequence to an ACHAR character sequence.
  for characters > MAX(ACHAR) then replaceChar is inserted for the
  out of range character.

  you can pass the same string to the utf8 and strA parameters.
*)

PROCEDURE FindAndReplace(find, replace : ARRAY OF CHAR;
                         VAR INOUT str : ARRAY OF CHAR) : BOOLEAN;
(*
  find the string find in the string str and if found then replace
  the string find in str with replace.
  the string comparison is case sensitive.
  returns TRUE if find was found and a replace occurred, otherwise false.
*)

PROCEDURE FindAndReplaceI(find, replace : ARRAY OF CHAR;
                          VAR INOUT str : ARRAY OF CHAR) : BOOLEAN;
(*
  find the string find in the string str and if found then replace
  the string find in str with replace.
  the string comparison is NOT case sensitive.
  returns TRUE if find was found and a replace occurred, otherwise false.
*)

PROCEDURE AppendWithLengths(source : ARRAY OF CHAR;
                            srcLen : CARDINAL;
                            VAR INOUT destination : ARRAY OF CHAR;
                            destLen : CARDINAL) : CARDINAL;
(* source is appended to destination *)
(* this is a very specialied Append procedure that can be used *)
(* where you are appending many different strings to a single string *)
(* this function will be faster than using Append since it is your job *)
(* to keep track of the string lengths *)
(* the result is the length of the result which is placed in destination *)

PROCEDURE AppendChar(ch : CHAR; VAR INOUT str : ARRAY OF CHAR);
(* appends the character, ch, to the end of the string str *)
(* if there is no space left in the string nothing happens *)

PROCEDURE AppendCharCond(ch : CHAR; VAR INOUT str : ARRAY OF CHAR);
(* same as AppendChar, except it will not append the character *)
(* if the character already exists at the end of the string *)

PROCEDURE AppendNum(num : CARDINAL; VAR INOUT str : ARRAY OF CHAR);
(* append a decimal number to the end of the string *)
(* the number may be truncated if not enough space exists in the string *)

PROCEDURE AppendHex(num, digits : CARDINAL; VAR INOUT str : ARRAY OF CHAR);
(* append a hex number with at most digits characters *)
(* to the end of the string *)
(* the number may be truncated if not enough space exists in the string *)

(* the following procedure are used for parsing a string *)
(* with a set of characters that are separators of individual items *)
(* within the main string *)
(* individual items should not be greater than 128 characters *)

PROCEDURE GetNextItem(list : ARRAY OF CHAR;
                      VAR INOUT i : CARDINAL;
                      VAR OUT item : ARRAY OF CHAR;
                      sep : ARRAY OF CHAR) : BOOLEAN;
(* list = the main string contains the various items *)
(* i = the index position to start scanning list for next item *)
(*     upon return i will have been advanced beyond the item returned *)
(* item = the item extracted from the list *)
(* sep = characters that are considered as separators, *)
(* separating the individual items within the list *)
(* example of use *)
(*
    i := 0;
    WHILE GetNextItem(list, i, item, ";,") DO
        (* do something *)
    END;
*)

PROCEDURE InList(item, list : ARRAY OF CHAR; sep : ARRAY OF CHAR) : BOOLEAN;
(* item = the item to scan for *)
(* list = the list if items *)
(* sep = a string contains characters that are considered as separators *)
(* separating the items within the list *)
(* returns TRUE is item is in list *)

PROCEDURE AddItem(item : ARRAY OF CHAR;
                  VAR INOUT list : ARRAY OF CHAR;
                  ch : CHAR);
(* add the item to the list using the character ch *)
(* as the separator character *)

PROCEDURE RemoveItem(item : ARRAY OF CHAR;
                     VAR INOUT list : ARRAY OF CHAR;
                     sep : ARRAY OF CHAR);
(* removes an item from the list if it exists in the list *)
(* item = the item to remove *)
(* list = the list if items *)
(* sep = a string contains characters that are considered as separators *)
(* separating the items within the list *)

END ExStrings.

(***************************************************************************)
(***************************************************************************)
(*
    This module is a superset of the ISO defined Storage module.
    The ISO Storage module is implemented with calls to this module.
    ISO does not allow Storage to be extended, hence the existence of
    the module.

    The module maintains a free list of blocks that are available for
    allocation. When there is not a big enough block to satisfy the
    allocation request, the heap then goes to its source of memory,
    usually the operating system, for a new block of memory. It would be silly
    to request 50 bytes from the source so the heap allocates chunks from
    the source and then splits these chunks down as allocation requests are made.

    To minimize waste of memory (fragmentation) you may want to change the chunk size
    to a multiple of some size.
    The default chunk size is 64k. (32k for 16-bit DOS)
    The heap manager does have some overhead per block of memory allocated.
    You must take this into account when you set multiples of block sizes.
    This overhead size is BlockOverhead, a value exported from this module.

    A heap has two options to handle allocations larger than the chunk size.
    1. Allocate the memory and add it to the internal heap memory list.
    2. Allocate memory directly from the memory source, and deallocate the
            memory directly back to the memory source on deallocation.

    See the SetChunkSize APIs for further information.


    -----

    Multiple heaps.
    This module allows multiple heaps. A heap is a list of memory blocks
    that are available for allocation. You can think of each heap as a
    "different" storage module.
    All operations in the storage module operate on the current heap, or
    the "Ex" operations operate on the heap parameter passed.

    To create a new heap use AllocHeap. You can then use this heap
    handle with the various "Ex" APIs or use it with UseHeap or PushHeap
    to set the heap as the current heap.

    This module always initializes a default heap. So you need not
    bother with this if you do not need multiple heaps.
*)
DEFINITION MODULE ExStorage;

<*/NOPACK*>

<*/VALIDVERSION:ALIGN8*>
%IF %NOT Bits16 %THEN
    %IF %NOT IA32 %THEN
        <*/VERSION:ALIGN8*>
    %END
%END

FROM SYSTEM IMPORT
    ADDRESS, CAST;

TYPE
    StorageExceptions   =
                          (
                           (* ISO defined exceptions *)
                           nilDeallocation,
                           pointerToUnallocatedStorage,
                           wrongStorageToUnallocate,

                           (* Stony Brook extended exceptions *)

                           outOfStorage,
                           tooManyFreeBlocks,
                           deallocateToWrongHeap,
                           memoryOverwrite,
                           heapStackOverflow,
                           heapStackUnderflow,
                           heapCorrupt
                          );

    AllocStrategy       = (FirstFit, BestFit);
    CombineStrategy     = (NormalCombine, FullCombine, NoCombine);
    SplitStrategy       = (SplitTopDown, SplitBottomUp);

    HeapErrorCodes      = (ReturnNIL, DoException, TryAgain);
    HeapErrorProc       = PROCEDURE((*amount:*)CARDINAL) : HeapErrorCodes;

    MemorySourceAlloc   = PROCEDURE((*amount:*)CARDINAL,
                                    (*userData:*)ADDRESS) : ADDRESS(*memory addr*);
    MemorySourceDealloc = PROCEDURE((*addr:*)ADDRESS,
                                    (*amount:*)CARDINAL,
                                    (*userData:*)ADDRESS);
    MemorySourceAvail   = PROCEDURE((*userData:*)ADDRESS) : CARDINAL32;

CONST
%IF ALIGN8 %THEN
    BlockOverhead       = 8;
%ELSE
    BlockOverhead       = SIZE(CARDINAL);
%END
(* BlockOverhead is also the alignment which all allocated memory returns *)

    HeapErrorNIL        = CAST(HeapErrorProc, 1);
    HeapErrorException  = CAST(HeapErrorProc, 2);
    (*
      you can use these to set the heap error handler to an
      internal procedure that simply returns the specificed result code.
    *)

TYPE
    HeapInfoPointer;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

PROCEDURE ALLOCATE(VAR OUT addr : ADDRESS; amount : CARDINAL);
PROCEDURE AllocateEx(VAR OUT addr : ADDRESS;
                     amount : CARDINAL;
                     heap : HeapInfoPointer);
(*
 allocate memory from the current heap
 addr = the address of the memory block to deallocate
 amount = the size of the memory block in bytes
 on return addr will contain the address of the memory block or
 a value of NIL if there was not enough memory available to
 satisfy the allocation request. This behaviour can be modified by
 installing a new HeapErrorProc.
 This call can fail if SetHeapMax or FreezeHeap are used to limit the
 size of the heap and no block large enough exists in the heap for
 the allocation.
 HeapErrorProc is always called when not enough memory is available
 to satisfy the request. The HeapErrorProc can return one of three
 possible actions for the heap manager to take.
 HeapErrorCodes       = (ReturnNIL, DoException, TryAgain);
 ReturnNIL does just that. This is the default.
 DoException will have ALLOCATE raise an outOfStorage exception
 TryAgain will have the system try to allocate the requested amount again
*)

PROCEDURE DEALLOCATE(VAR INOUT addr : ADDRESS; amount : CARDINAL);
PROCEDURE DeallocateEx(VAR INOUT addr : ADDRESS;
                       amount : CARDINAL;
                       heap : HeapInfoPointer);
(*
 deallocate memory to the current heap
 addr = the address of the memory block to deallocate
 amount = the size of the memory block in bytes
 On return of this procedure addr will contain the value NIL.
 If NIL is passed to addr then a nilDeallocation exception is raised
 If the heap is in debug mode the following actions are also performed.
 The size of the decallocation is checked to make sure it agrees with
 the size the block was allocated. A wrongStorageToUnallocate exception
 is raised if the size is not correct
 If the memory is not allocated memory, such as deallocating twice,
 a pointerToUnallocatedStorage exception is raised.
 A check for memory overwrite is done and a memoryOverwrite exception is
 raised if one is found.
 A check is made to make sure the memory block was allocated from the
 current heap. A deallocateToWrongHeap exception is raised if the memory
 did not come from the current heap.
*)

PROCEDURE IsStorageException() : BOOLEAN;
(* Return TRUE if the current exception came from this module *)

PROCEDURE StorageException() : StorageExceptions;
(*
 If IsStorageException() = TRUE, then this function returns the
 specific exception that was raised
*)

PROCEDURE ReALLOCATE(VAR INOUT addr : ADDRESS; amount : CARDINAL);
PROCEDURE ReallocateEx(VAR INOUT addr : ADDRESS;
                       amount : CARDINAL;
                       heap : HeapInfoPointer);
(*
 a convienence call
 allocates a memory block of size amount,
 copies the old memory block to the new memory block
 and then deallocates the old memory block.
 addr can be NIL for this call. in this case it simply
 acts like a call to allocate.
*)

PROCEDURE AllocateAligned(VAR OUT addr, alignedAddr : ADDRESS;
                          amount, align : CARDINAL);
PROCEDURE AllocateAlignedEx(VAR OUT addr, alignedAddr : ADDRESS;
                            amount, align : CARDINAL;
                            heap : HeapInfoPointer);
(*
 as ALLOCATE except...
 allocate a memory block and return an address aligned on an even
 multiple address of amount align
 addr = the returned memory block allocated. use this address when
          you deallocate the memory. also use amount+align for the
          amount of memory to deallocate
 alignedAddr = the aligned memory address. use this address for your
                 pointer.
 amount = the amount of memory to allocate.
 align = the alignment multiple.
*)

PROCEDURE Available(amount : CARDINAL) : BOOLEAN;
PROCEDURE AvailableEx(amount : CARDINAL; heap : HeapInfoPointer) : BOOLEAN;
(*
 can a block of the specified size be allocated from the current heap
 TRUE is returned if the amount is available.
 This call can fail if SetHeapMax or FreezeHeap are used to limit the
 size of the heap and no block large enough exists in the heap for
 the allocation.
*)

PROCEDURE MaxAvailable() : CARDINAL;
PROCEDURE MaxAvailableEx(heap : HeapInfoPointer) : CARDINAL;
(*
 largest single continuous block available to be allocated.
 if the heap is not frozen the memory source will be checked for the
 largest block available.
 SetHeapMax can also limit this value.
*)

PROCEDURE MemAvailable() : CARDINAL32;
PROCEDURE MemAvailableEx(heap : HeapInfoPointer) : CARDINAL32;
(*
 total memory in the heap free list, and available from the memory source,
 if the heap has not been frozen. SetHeapMax can also limit this value.
*)

PROCEDURE MemoryInUse() : CARDINAL32;
PROCEDURE MemoryInUseEx(heap : HeapInfoPointer) : CARDINAL32;
(*
 amount of memory currently allocated in the heap
 this value includes any overhead needed by the heap manager

 IF (heap = NIL) THEN
     the value returned is the sum of MemoryInUse for all
     currently active heaps.
*)

PROCEDURE MaxMemoryUsed() : CARDINAL32;
PROCEDURE MaxMemoryUsedEx(heap : HeapInfoPointer) : CARDINAL32;
(*
 the largest amount of memory ever allocated in the heap
 this value includes any overhead needed by the heap manager.

 IF (heap = NIL) THEN
     the value returned is the sum of MaxMemoryUsed for all
     currently active heaps.
*)

PROCEDURE ResetMaxMemoryUsed;
PROCEDURE ResetMaxMemoryUsedEx(heap : HeapInfoPointer);
(*
  resets the internal counter for the maximum amount of memory used
  to zero.

 IF (heap = NIL) THEN
     all currently active heaps will have their counter reset.
*)

PROCEDURE HeapMemory() : CARDINAL32;
PROCEDURE HeapMemoryEx(heap : HeapInfoPointer) : CARDINAL32;
(*
 amount of memory the heap currently owns
 this takes into account heap granularity and overhead.

 IF (heap = NIL) THEN
     the value returned is the sum of HeapMemory for all
     currently active heaps.
*)

PROCEDURE FreezeHeap(yes : BOOLEAN);
PROCEDURE FreezeHeapEx(yes : BOOLEAN; heap : HeapInfoPointer);
(*
 freeze the current heap to it present size.
 no more allocations will be made from the memory source.
*)

PROCEDURE CombineHeap;
PROCEDURE CombineHeapEx(heap : HeapInfoPointer);
(*
 make a pass through the entire free list attempting to combine
 all blocks that can be combined
*)

PROCEDURE FreeHeap;
PROCEDURE FreeHeapEx(heap : HeapInfoPointer);
(* return all memory blocks back to the memory source. *)

PROCEDURE ClearHeap;
PROCEDURE ClearHeapEx(heap : HeapInfoPointer);
(*
 an instant DEALLOCATE everything that is currently allocated in the heap
 while not returning memory to the memory source.
*)

PROCEDURE SetMemorySource(alloc : MemorySourceAlloc;
                          dealloc : MemorySourceDealloc;
                          avail : MemorySourceAvail;
                          userData : ADDRESS);
PROCEDURE SetMemorySourceEx(alloc : MemorySourceAlloc;
                            dealloc : MemorySourceDealloc;
                            avail : MemorySourceAvail;
                            userData : ADDRESS;
                            heap : HeapInfoPointer);
(*
 a heaps memory source defaults to the operating system.
 with this function you can redirect these allocations to another source of memory.

 userData = arbitrary data which will be passed to your callback procedures.
 for MemorySourceAlloc, NIL should be returned to indicate failure.
*)

PROCEDURE SetHeapError(err : HeapErrorProc);
PROCEDURE SetHeapErrorEx(err : HeapErrorProc; heap : HeapInfoPointer);
(*
 The HeapErrorProc is called when ALLOCATE cannot satisfy the allocation
 request. This allows you to perform some action(s) if possible and gain
 the memory to satisfy the ALLOCATE request
 The HeapErrorProc returns a value to indicate what the heap manager
 should do
 HeapErrorCodes = (ReturnNIL, DoException, TryAgain);
 ReturnNIL does just that
 DoException will have ALLOCATE raise an outOfStorage exception
 TryAgain will have the system try to allocate the requested amount again
*)

PROCEDURE GetHeapError() : HeapErrorProc;
PROCEDURE GetHeapErrorEx(heap : HeapInfoPointer) : HeapErrorProc;
(* return the current heap error procedure *)

PROCEDURE GetHeapMax() : CARDINAL32;
PROCEDURE GetHeapMaxEx(heap : HeapInfoPointer) : CARDINAL32;
(* get maximum amount of memory a heap can contain *)

PROCEDURE SetHeapMax(max : CARDINAL32);
PROCEDURE SetHeapMaxEx(max : CARDINAL32; heap : HeapInfoPointer);
(* set maximum amount of memory a heap can contain *)

PROCEDURE GetChunkSize() : CARDINAL;
PROCEDURE GetChunkSizeEx(heap : HeapInfoPointer) : CARDINAL;
(*
 get the block size allocated from the source of memory for the heap
 when the heap needs more memory to satisfy an ALLOCATE request
*)

PROCEDURE SetChunkSize(max : CARDINAL; direct : BOOLEAN);
PROCEDURE SetChunkSizeEx(max : CARDINAL; direct : BOOLEAN; heap : HeapInfoPointer);
(*
 set the block size allocated from the source of memory for the heap
 when the heap needs more memory to satisfy an ALLOCATE request.
 if direct = FALSE then all allocation requests will become a part of the memory
     freelist managed by the heap. the memory will remain a part of the heap
     until the heap is freed.
 if direct = TRUE then allocation requests larger than the chunk size will
     be allocated directly from the memory source, and when deallocated it will
     be deallocated back to the memory source. the memory allocation will never
     be placed into the heap memory freelist. this can help reduce memory fragmentation
     but direct allocations are slower than allocations from the
     internal memory freelist.
*)

PROCEDURE GetMinAllocSize() : CARDINAL;
PROCEDURE GetMinAllocSizeEx(heap : HeapInfoPointer) : CARDINAL;
(* get the minimum block size that can be allocated *)

PROCEDURE SetMinAllocSize(min : CARDINAL);
PROCEDURE SetMinAllocSizeEx(min : CARDINAL; heap : HeapInfoPointer);
(*
 set the minimum block size that can be allocated
 usefull when using SetCombine(NoCombine) to get a uniform block size
 without playing with your data structure definitions and/or the amount
 value passed to ALLOCATE.
*)

PROCEDURE GetDebug() : BOOLEAN;
PROCEDURE GetDebugEx(heap : HeapInfoPointer) : BOOLEAN;
(* get the heap debug state *)

PROCEDURE SetDebug(debug : BOOLEAN);
PROCEDURE SetDebugEx(debug : BOOLEAN; heap : HeapInfoPointer);
(*
 debug = FALSE is the default
 it debug = TRUE then the heap is checked for consistency and
 fills all blocks with NIL before allocation and deallocation
 it can also detect many memory overwrite situations.
 it can also help detect memory leaks.
 Setting the debug mode can only be done when the heap is empty,
 otherwise this call has no effect.
 You can use the SetExStorageDebugMode module to easily set the debug mode
 to TRUE for the default heap.
 Just import the module as the first module imported in your main program.
 This will set the debug mode for the default heap. This works even if the
 initialization code in one or more modules allocates memory because it would be
 the first module initialization code called that uses the ExStorage module.
*)

PROCEDURE ScanForMemoryOverwrites;
PROCEDURE ScanForMemoryOverwritesEx(heap : HeapInfoPointer);
(*
 If SetDebug(TRUE) then you can call this procedure to scan all blocks
 deallocated and allocated to look for memory overwrites
 If one is found then a memoryOverwrite exception will be raised
 IF SetDebug(FALSE) then this call returns immediately without performing
 any checks
*)

PROCEDURE ScanForMemoryOverwritesOnApiCalls(yes : BOOLEAN);
PROCEDURE ScanForMemoryOverwritesOnApiCallsEx(yes : BOOLEAN;
                                              heap : HeapInfoPointer);
(*
 if SetDebug(TRUE) and (yes = TRUE) then all calls to
 ALLOCATE, DEALLOCATE, Available
 will first scan for memory overwrites before performing their
 normal action(s)
 if SetDebug(TRUE) and (yes = FALSE) then memory overwrites are only
 checked in the DEALLOCATE procedure and then only the deallocated block
 is checked.
*)

TYPE
    CheckLeakCallbackProc = PROCEDURE((*allocId*)CARDINAL32, (*size*) CARDINAL);
    StopLeakCallbackProc = PROCEDURE(VAR INOUT (*allocId*)CARDINAL32);
     (*allocId = a unique number identifying a specific allocation *)

PROCEDURE CheckForMemoryLeaks(callback : CheckLeakCallbackProc);
PROCEDURE CheckForMemoryLeaksEx(callback : CheckLeakCallbackProc; heap : HeapInfoPointer);
(*
 if SetDebug(TRUE) then call this function when you believe you have
 deallocated all memory in your application. The callback procedure
 will be called for each memory block that has not been deallocated
*)

PROCEDURE SetMemoryStopLeakCallback(callback : StopLeakCallbackProc;
                                    allocId : CARDINAL32);
PROCEDURE SetMemoryStopLeakCallbackEx(callback : StopLeakCallbackProc;
                                      allocId : CARDINAL32;
                                      heap : HeapInfoPointer);
(*
    if SetDebug(TRUE) then
    once you have detected one or more memory leaks via CheckForMemoryLeaks,
    and you can precisely repeat the execution of your program,
    you can use this call to have a procedure of yours called when the memory
    block with the given allocId is allocated.
    You can set a breakpoint in this procedure to stop when one of your leaked
    memory blocks is allocated. You can now debug your code to determine why the
    memory allocation leaked.
    You can assign a value to allocId to look for another memory leak. The allocId
    you assign should be higher than the current one.
*)

PROCEDURE GetCombine() : CombineStrategy;
PROCEDURE GetCombineEx(heap : HeapInfoPointer) : CombineStrategy;
(* get the heap combine state *)

PROCEDURE SetCombine(comb : CombineStrategy);
PROCEDURE SetCombineEx(comb : CombineStrategy; heap : HeapInfoPointer);
(*
 NormalCombine = the current heap block will be fully combined where
                 where possible before checking its suitability for
                 allocation.
                 This gives best performance, while still reducing
                 the fragmentation of heap memory
                 This is the default value
 FullCombine   = All the free blocks in the heap will be combined where
                 possible before doing any allocation
                 If you are having problems with heap fragmentation with
                 NormalCombine, then this option will help.
                 How much help cannot be determined.
                 This will slow down allocations, more so in FirstFit
                 than in BestFit strategy
 NoCombine     = No heap block combining will be done. This will slow
                 down heap allocation unless your blocks are all the same
                 size. See SetMinAllocSize for more info
*)

PROCEDURE GetStrategy() : AllocStrategy;
PROCEDURE GetStrategyEx(heap : HeapInfoPointer) : AllocStrategy;
(* get the current allocation strategy *)

PROCEDURE SetStrategy(s : AllocStrategy);
PROCEDURE SetStrategyEx(s : AllocStrategy; heap : HeapInfoPointer);
(*
 there are two allocation strategies available
 FirstFit = default and fastest by far, the first block that is greater
            than or equal to the requested allocation will be used
            This is the default value
 BestFit =  the block that best fits the requested allocation will
            be used. The entire free list will be searched until an
            exact match is found. If not found then the next block size
            >= the requested size will be used
*)

PROCEDURE SetSplitStrategy(split : SplitStrategy);
PROCEDURE SetSplitStrategyEx(split : SplitStrategy;
                             heap : HeapInfoPointer);
(*
 there are two block splitting strategies
 SplitTopDown = the default and the fastest mechanism.
 depending on how data structures such as lists are created
 a one of the strategies may cause the structures to be arranged such
 that processor memory cache is used much more efficiently and therefore
 increase execution performance.
 for best effect you will generally have to use multiple heaps, one
 per structure, to force linear adjacent memory allocation.
*)

PROCEDURE SetThreadSafe(yes : BOOLEAN);
PROCEDURE SetThreadSafeEx(yes : BOOLEAN; heap : HeapInfoPointer);
(*
  if yes = TRUE then the heap is thread safe. meaning multiple threads
  can allocate from the heap and not corrupt the heap.
  being thread safe incurs a small overhead.

  single threaded code can safely turn off thread protection.

  multi-threaded code can turn off thread safety if the application controls
  heap access such that only a single thread is allowed to access the heap
  at any point in time.

  thread safe, yes = TRUE, is the default when a heap is initialized.
*)

PROCEDURE AllocHeap() : HeapInfoPointer;
PROCEDURE AllocHeapEx(defaultError : HeapErrorCodes) : HeapInfoPointer;
(*
 returns a handle to a heap if successfull. otherwise returns NIL.
 defaultError can be ReturnNIL or DoException
*)

PROCEDURE DeallocHeap(heap : HeapInfoPointer);
(* releases a previously allocated heap.
   all heap memory is released (FreeHeap) before the heap is deallocated.
*)

PROCEDURE GetHeap() : HeapInfoPointer;
(* return the current heap pointer *)

PROCEDURE GetDefaultHeap() : HeapInfoPointer;
(* return the default heap pointer *)

PROCEDURE UseHeap(heap : HeapInfoPointer) : HeapInfoPointer;
(* set the current heap, and return the previous heap *)

PROCEDURE PushHeap(heap : HeapInfoPointer);
(*
 push the previous heap onto an internal stack and set the passed heap
 as the current heap.
 other threads will be blocked from AllocHeap, DeallocHeap,
 UseHeap, PushHeap, PopHeap, ClearHeapStack until PopHeap is called.
*)

PROCEDURE PopHeap;
(* set the current heap to the last heap pushed onto the stack *)

PROCEDURE ClearHeapStack;
(*
 clear all heaps off of the internal stack
 can be usefull in exception handlers to do some clean up
*)

PROCEDURE LockHeap(heap : HeapInfoPointer);
(*
 this procedure "locks" the heap such that only the current thread
 can access the heap.
 this may be called recursively. you must call Unlock once for each
 call to lock.
*)

PROCEDURE UnlockHeap(heap : HeapInfoPointer);
(* this call reverses a previous LockHeap call. *)

PROCEDURE AllocSystemMemory(VAR OUT addr : ADDRESS; amount : CARDINAL);
PROCEDURE DeallocSystemMemory(VAR INOUT addr : ADDRESS; amount : CARDINAL);
(*
  this calls are not an integral part of this modules functions.
  they are simply here to provide a convenient and portable way
  of directly allocating operating system memory.

  for alloc, addr = NIL if the call fails.
*)

END ExStorage.
(***************************************************************************)
(***************************************************************************)

DEFINITION MODULE Environment;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

PROCEDURE GetSymbol(name : ARRAY OF CHAR;
                    VAR OUT result : ARRAY OF CHAR) : BOOLEAN;
(* Get the value of an enviroment symbol.  name is the name of the symbol
   to get, result is the returned definition, function value is TRUE if the
   symbol was found.
   name should not be longer than 128 characters.
   returns FALSE if the symbol is not found and the value in result will
   be unchanged.
   returns TRUE if the symbol was found and the entire contents of the
   symbol fit in the output variable result.
   if the symbol was found and result is not large enough FALSE is returned
   and the value in result will be the truncated value of the symbol.
*)

PROCEDURE GetCommandLine(VAR OUT commandLine : ARRAY OF CHAR);
(* Get the command line with which the program was run. *)

PROCEDURE GetProgramName(VAR OUT name : ARRAY OF CHAR);
(* Get the name of the currently running program.
   under DOS, DOS extended, Win16, Win32 this will be a fully qualified
   path and name of the running executable program.
*)
(* On Linux 2.2 and later kernels a fully qualified path is returned. *)
(* On other Unix systems this value does not have any real meaning
   other than the name of the program executed.
*)

END Environment.
(***************************************************************************)
(***************************************************************************)

DEFINITION MODULE Conversions;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

PROCEDURE StringToInt(str : ARRAY OF CHAR;
                      VAR INOUT pos : CARDINAL;
                      VAR OUT num : INTEGER;
                      VAR OUT done : BOOLEAN);
(* Get an integer number from a string starting at position pos. *)
(* pos is left pointing at the first character that is not part of the *)
(* number. done signifies the success of the conversion *)
(* Skips any leading spaces. *)

PROCEDURE StrToInt(buf : ARRAY OF CHAR; VAR OUT num : INTEGER) : BOOLEAN;
(* Convert an integer number from a string  *)
(* Skips any leading spaces. *)

PROCEDURE IntToString(num : INTEGER;
                      size : CARDINAL;
                      VAR OUT str : ARRAY OF CHAR;
                      VAR INOUT pos : CARDINAL;
                      VAR OUT done : BOOLEAN);
(* Convert an integer number into a string starting at position *)
(* pos.  pos is left pointing to the character following the number *)
(* done signifies the success of the conversion *)

PROCEDURE IntToStr(num : INTEGER; VAR OUT str : ARRAY OF CHAR) : BOOLEAN;
(* Convert an integer number to a string  *)

PROCEDURE StringToCard(str : ARRAY OF CHAR;
                       VAR INOUT pos : CARDINAL;
                       VAR OUT num : CARDINAL;
                       VAR OUT done : BOOLEAN);
(* Get a cardinal number from a string starting at position pos. *)
(* pos is left pointing at the first character that is not part of the *)
(* number *)
(* done signifies the success of the conversion *)
(* Skips any leading spaces. *)

PROCEDURE StrToCard(buf : ARRAY OF CHAR; VAR OUT num : CARDINAL) : BOOLEAN;
(* Convert a string in buf to a cardinal *)
(* Skips any leading spaces. *)

PROCEDURE CardToString(num : CARDINAL;
                       size : CARDINAL;
                       VAR OUT str : ARRAY OF CHAR;
                       VAR INOUT pos : CARDINAL;
                       VAR OUT done : BOOLEAN);
(* Convert a cardinal number into the string starting at position *)
(* pos.  pos is left pointing to the character following the number *)
(* done signifies the success of the conversion *)

PROCEDURE CardToStr(num : CARDINAL; VAR OUT str : ARRAY OF CHAR) : BOOLEAN;
(* Convert a cardinal to a string *)

PROCEDURE StrBaseToCard(str : ARRAY OF CHAR;
                        base : CARDINAL;
                        VAR OUT num : CARDINAL32) : BOOLEAN;
(* convert a string to a cardinal32 using the number base specified in base *)
(* (base >= 2) AND (base <= 16) *)
(* Skips any leading spaces. *)

PROCEDURE CardBaseToStr(num : CARDINAL32;
                        base : CARDINAL;
                        VAR OUT str : ARRAY OF CHAR) : BOOLEAN;
(* convert a cardinal32 to a string using the number base specified in base *)
(* (base >= 2) AND (base <= 16) *)

PROCEDURE StringToLong(str : ARRAY OF CHAR;
                       VAR INOUT pos : CARDINAL;
                       VAR OUT num : LONGINT;
                       VAR OUT done : BOOLEAN);
(* Get an longint number from a string buf starting at position pos. *)
(* pos is left pointing at the first character that is not part of the *)
(* number *)
(* done signifies the success of the conversion *)
(* Skips any leading spaces. *)

PROCEDURE StrToLong(buf : ARRAY OF CHAR; VAR OUT num : LONGINT) : BOOLEAN;
(* Convert a longint number from a string  *)
(* Skips any leading spaces. *)

PROCEDURE LongToString(num : LONGINT;
                       size : CARDINAL;
                       VAR OUT str : ARRAY OF CHAR;
                       VAR INOUT pos : CARDINAL;
                       VAR OUT done : BOOLEAN);
(* Convert a longint number into the string starting at position *)
(* pos.  pos is left pointing to the character following the number *)
(* done signifies the success of the conversion *)

PROCEDURE LongToStr(num : LONGINT; VAR OUT str : ARRAY OF CHAR) : BOOLEAN;
(* Convert a longint to a string *)

PROCEDURE StrBaseToLong(str : ARRAY OF CHAR;
                        base : CARDINAL;
                        VAR OUT num : LONGCARD) : BOOLEAN;
(* convert a string to a longcard using the number base specified in base *)
(* (base >= 2) AND (base <= 16) *)
(* Skips any leading spaces. *)

PROCEDURE LongBaseToStr(num : LONGCARD;
                        base : CARDINAL;
                        VAR OUT str : ARRAY OF CHAR) : BOOLEAN;
(* convert a longcard to a string using the number base specified in base *)
(* (base >= 2) AND (base <= 16) *)

END Conversions.

(***************************************************************************)
(***************************************************************************)

DEFINITION MODULE BitVectors;
(* bit vectors are similar to Modula-2 SETs, however they are dynamically *)
(* sized *)

<*/VALIDVERSION:PROTECT*>
%IF WIN32 %OR UNIX %THEN
<*/VERSION:PROTECT*>
%END
(* make sure this version tag is set the same in the DEF and MOD *)

FROM ExStorage IMPORT
    HeapInfoPointer;

CONST
    BitVectorBits       = SIZE(CARDINAL)*8;

TYPE
    BitVectorElement    = PACKEDSET OF [0..BitVectorBits-1];

    (* this is defined in the DEF only to support the inline macro procedures
       FastSetBit and FastClearBit.
       your should ignore this and use the provided APIs.
    *)
    BitVectorRecord =
        RECORD
        %IF PROTECT %THEN
        lock            : CARDINAL;
        pad             : ARRAY [1..32] OF CARDINAL8;
        (* separate the lock and the data by a cache line *)
        %END
        lowBit          : CARDINAL;
        highBit         : CARDINAL;
        numElements     : CARDINAL;
        heap            : HeapInfoPointer;
        bits            : ARRAY [0..0] OF BitVectorElement;
        (* the above array is allocated to its appropriate size *)
        (* depending on the range of the BitVector *)
        END;
    BitVector           = POINTER TO BitVectorRecord;

CONST
    EmptyElement        = BitVectorElement{};
    FullElement         = BitVectorElement{0..BitVectorBits-1};

PROCEDURE NewVector(VAR OUT v : BitVector; lowBit, highBit : CARDINAL);
(* allocate a new bit vector with a lower bound of lowBit and upper bound *)
(* of highBit. *)
(* v = NIL if the operation does not succeed *)
(* a bit outside the allocated range of a bit vector is considered clear, *)
(* meaning the bit is not set, and obviously never can be set *)
(* the bits in the new vector default to clear *)

PROCEDURE DisposeVector(VAR INOUT v : BitVector);
(* deallocate a previously allocated bit vector *)
(* v = NIL after this procedure *)

PROCEDURE ReallocVector(VAR INOUT v : BitVector; newHighBit : CARDINAL);
(* change the upper bound of the previously allocated bit vector v *)
(* to the new bound in newHighBit. the lower bound is unchanged *)
(* the value v will change as a result of this call *)
(* if the high bound is increased then the new bits will default to clear *)

PROCEDURE SetBit(b : CARDINAL; v : BitVector);
(* set the bit value in b in the bit vector v *)
(* if b is outside the valid range of v it is ignored and this procedure *)
(* performs no action *)

PROCEDURE ClearBit(b : CARDINAL; v : BitVector);
(* clear the bit value in b in the bit vector v *)
(* if b is outside the valid range of v it is ignored and this procedure *)
(* performs no action *)

PROCEDURE FastSetBit(b : CARDINAL; v : BitVector); MACRO;
(* as SetBit, except this gets generated inline.
   it is not thread safe and it does not range check the set bit.
*)
BEGIN
    b := b - v^.lowBit;
    INCL(v^.bits[b / BitVectorBits], b REM BitVectorBits);
END FastSetBit;

PROCEDURE FastClearBit(b : CARDINAL; v : BitVector); MACRO;
(* as ClearBit, except this gets generated inline.
   it is not thread safe and it does not range check the set bit.
*)
BEGIN
    b := b - v^.lowBit;
    EXCL(v^.bits[b / BitVectorBits], b REM BitVectorBits);
END FastClearBit;

PROCEDURE SetBits(bottom, top : CARDINAL; v : BitVector);
(* set the range of bits from bottom..top in the bit vector v *)
(* if any bit is outside the valid range of v it is ignored *)
(* any bit within the valid range of v will be set *)

PROCEDURE ClearBits(bottom, top : CARDINAL; v : BitVector);
(* clear the range of bits from bottom..top in the bit vector v *)
(* if any bit is outside the valid range of v it is ignored *)
(* any bit within the valid range of v will be cleared *)

PROCEDURE BitIsSet(b : CARDINAL; v : BitVector) : BOOLEAN;
(* returns TRUE if the bit value b is set in the bit vector v, *)
(* otherwise FALSE is returned *)
(* if the bit value b is outside the range of v then FALSE is returned *)

PROCEDURE AnyBitSet(bottom, top : CARDINAL; v : BitVector) : BOOLEAN;
(* returns TRUE if any bit in the range bottom..top is set *)
(* in the bit vector v, otherwise FALSE *)

PROCEDURE AnyBitClear(bottom, top : CARDINAL; v : BitVector) : BOOLEAN;
(* returns TRUE if any bit in the range bottom..top is clear *)
(* in the bit vector v, otherwise FALSE *)
(* if any bit from bottom..top is outside the range of v *)
(* then TRUE is returned since these bits are defined as always clear *)

PROCEDURE FindSetBits(startBit, numBits : CARDINAL;
                      v : BitVector;
                      VAR OUT bottom : CARDINAL) : BOOLEAN;
(* this scans the BitVector for a group of set bits *)
(* the search begins at the bit specified by startBit. *)
(* returns TRUE if a group of bits was found and then bottom contains *)
(* the first bit position in the found group. *)

PROCEDURE FindClearBits(startBit, numBits : CARDINAL;
                        v : BitVector;
                        VAR OUT bottom : CARDINAL) : BOOLEAN;
(* as FindSetBits, except looks for clear bits *)

PROCEDURE Empty(v : BitVector) : BOOLEAN;
(* returns TRUE if all bits in the bit vector v are clear *)

PROCEDURE And(v1, v2 : BitVector);
(* perform a boolean "and" operation on the two bit vectors *)
(* v2 is the destination of this operation *)
(* v2 := v2 "and" v1 *)
(* if v1 is smaller than v2 then these bits are assumed clear for this *)
(* "and" operation *)
(* if v1 is larger than v2 the extra bits are ignored *)
(* maximum performance comes when two bit vectors have the same lower bound *)

PROCEDURE Or(v1, v2 : BitVector);
(* perform a boolean "or" operation on the two bit vectors *)
(* v2 is the destination of this operation *)
(* v2 := v2 "or" v1 *)
(* if v1 is smaller than v2 then these bits are assumed clear for this *)
(* "or" operation *)
(* if v1 is larger than v2 the extra bits are ignored *)
(* maximum performance comes when two bit vectors have the same lower bound *)

PROCEDURE Minus(v1, v2 : BitVector);
(* remove any bit values set in bit vector v1 from bit vector v2 *)
(* v2 is the destination of this operation *)
(* v2 := v2 "-" v1 *)
(* if v1 is smaller than v2 then these bits are assumed clear for this *)
(* operation *)
(* if v1 is larger than v2 the extra bits are ignored *)
(* maximum performance comes when two bit vectors have the same lower bound *)

PROCEDURE BitsInCommon(v1, v2 : BitVector) : BOOLEAN;
(* returns TRUE if any bit value in the two bit vectors *)
(* is set in both bit vectors, otherwise FALSE is returned *)
(* maximum performance comes when two bit vectors have the same lower bound *)

PROCEDURE Equal(v1, v2 : BitVector) : BOOLEAN;
(* returns TRUE if the two bit vectors contain the same set and clear bits *)
(* otherwise FALSE is returned *)
(* maximum performance comes when two bit vectors have the same lower bound *)

PROCEDURE Copy(v1, v2 : BitVector);
(* copy the bits in bit vector v1 into bit vector v2 *)
(* if v1 is smaller than v2 then these bits are cleared in v2 *)
(* if v1 is larger than v2 then these extra bits are ignored *)
(* maximum performance comes when two bit vectors have the same lower bound *)

PROCEDURE Duplicate(v1 : BitVector; VAR OUT v2 : BitVector);
(* allocate a new bit vector in v2 with the same range a bit vector v1 *)
(* and copy the bits from v1 into v2 *)

PROCEDURE Zap(val : BitVectorElement; v : BitVector);
(* assign all bit vector storage elements in v with the value val *)
(* this procedure is usefull to assign all clear or set bits in a bit vector *)
(* using the constants EmptyElement or FullElement *)

END BitVectors.

(***************************************************************************)
(***************************************************************************)

DEFINITION MODULE ASCII;
CONST
    nul = CHR(0);     soh = CHR(1);    stx = CHR(2);    etx = CHR(3);
    eot = CHR(4);     enq = CHR(5);    ack = CHR(6);    bel = CHR(7);
    bs  = CHR(8);     ht  = CHR(9);    lf  = CHR(10);   vt  = CHR(11);
    ff  = CHR(12);    cr  = CHR(13);   so  = CHR(14);   si  = CHR(15);
    dle = CHR(16);    dc1 = CHR(17);   dc2 = CHR(18);   dc3 = CHR(19);
    dc4 = CHR(20);    nak = CHR(21);   syn = CHR(22);   etb = CHR(23);
    can = CHR(24);    em  = CHR(25);   sub = CHR(26);   esc = CHR(27);
    fs  = CHR(28);    gs  = CHR(29);   rs  = CHR(30);   us  = CHR(31);
    space = CHR(32);  del = CHR(127);
END ASCII.

(* ==================================================================================== *)
DEFINITION MODULE WholeStr;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

  (* Whole-number/string conversions *)

IMPORT
    ConvTypes;

TYPE
    ConvResults = ConvTypes.ConvResults;
    (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

(* the string form of a signed whole number is
     ["+" | "-"], decimal digit, {decimal digit}
*)

PROCEDURE StrToInt(str : ARRAY OF CHAR; VAR int : INTEGER; VAR res : ConvResults); (* Ignores any leading spaces in str. If the subsequent characters in str are in the format of a signed whole number, assigns a corresponding value to int. Assigns a value indicating the format of str to res.  *)
PROCEDURE IntToStr(int : INTEGER; VAR str : ARRAY OF CHAR);   (* Converts the value of int to string form and copies the possibly truncated result to str. *) (* the string form of an unsigned whole number is decimal digit, {decimal digit} *)
PROCEDURE StrToCard(str : ARRAY OF CHAR; VAR card : CARDINAL; VAR res : ConvResults); (* Ignores any leading spaces in str. If the subsequent characters in str are in the format of an unsigned whole number, assigns a corresponding value to card. Assigns a value indicating the format of str to res.  *)
PROCEDURE CardToStr(card : CARDINAL; VAR str : ARRAY OF CHAR);   (* Converts the value of card to string form and copies the possibly truncated result to str. *)
END WholeStr.

(* ==================================================================================== *)

DEFINITION MODULE CharClass;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

  (* Classification of values of the type CHAR *)
PROCEDURE IsNumeric(ch : CHAR) : BOOLEAN;   (* Returns TRUE if and only if ch is classified as a numeric character *)
PROCEDURE IsLetter(ch : CHAR) : BOOLEAN;   (* Returns TRUE if and only if ch is classified as a letter *)
PROCEDURE IsUpper(ch : CHAR) : BOOLEAN;   (* Returns TRUE if and only if ch is classified as an upper case letter *)
PROCEDURE IsLower(ch : CHAR) : BOOLEAN;   (* Returns TRUE if and only if ch is classified as a lower case letter *)
PROCEDURE IsControl(ch: CHAR) : BOOLEAN;   (* Returns TRUE if and only if ch represents a control function *)
PROCEDURE IsWhiteSpace(ch : CHAR): BOOLEAN;   (* Returns TRUE if and only if ch represents a space character or a format effector *)
END CharClass.

(* ==================================================================================== *)

DEFINITION MODULE LongConv;

(* Low-level LONGREAL/string conversions *)

IMPORT
    ConvTypes;

TYPE
    ConvResults = ConvTypes.ConvResults; (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

(* the string form of a signed fixed-point real number is ["+" | "-"], decimal digit, {decimal digit}, [".", {decimal digit}] *)
(* the string form of a signed floating-point real number is signed fixed-point real number, "E", ["+" | "-"], decimal digit, {decimal digit} *)

PROCEDURE ScanReal(inputCh : CHAR;
                   VAR chClass : ConvTypes.ScanClass;
                   VAR nextState : ConvTypes.ScanState);
(* Represents the start state of a finite state scanner for real
   numbers - assigns class of inputCh to chClass and a procedure
   representing the next state to nextState.
*)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

PROCEDURE FormatReal(str : ARRAY OF CHAR) : ConvResults;
(* Returns the format of the string value for conversion to REAL *)

PROCEDURE ValueReal(str : ARRAY OF CHAR) : LONGREAL;
(* Returns the value corresponding to the real number string
   value str if str is well-formed; otherwise raises the RealConv exception.
*)

PROCEDURE LengthFloatReal(real : LONGREAL; sigFigs : CARDINAL) : CARDINAL;
(* Returns the number of characters in the floating-point
   string representation of real with sigFigs significant figures
*)

PROCEDURE LengthEngReal(real : LONGREAL; sigFigs : CARDINAL) : CARDINAL;
(* Returns the number of characters in the floating-point engineering
   string representation of real with sigFigs significant figures
*)

PROCEDURE LengthFixedReal(real : LONGREAL; place : INTEGER) : CARDINAL;
(* Returns the number of characters in the fixed-point
   string representation of real rounded to the given place relative to
   the decimal point
*)

PROCEDURE IsRConvException() : BOOLEAN;
(* Returns TRUE if the current coroutine is in the exceptional execution
   state because of the raising of an exception in a routine from this
   module; otherwise returns FALSE
*)

END LongConv.

(* ==================================================================================== *)

DEFINITION MODULE LongStr;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

  (* LONGREAL/string conversions *)

IMPORT ConvTypes;

TYPE
    ConvResults = ConvTypes.ConvResults;
                  (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

(* the string form of a signed fixed-point real number is
     ["+" | "-"], decimal digit, {decimal digit}, [".", {decimal digit}]
*)

(* the string form of a signed floating-point real number is
   signed fixed-point real number,
   "E",
   ["+" | "-"], decimal digit, {decimal digit}
*)

PROCEDURE StrToReal(str : ARRAY OF CHAR;
                    VAR real : LONGREAL;
                    VAR res : ConvResults);
  (* Ignores any leading spaces in str.
     If the subsequent characters in str are in the format of a signed real
     number, assigns a corresponding value to real.
     Assigns a value indicating the format of str to res.
  *)

PROCEDURE RealToFloat(real : LONGREAL;
                      sigFigs : CARDINAL;
                      VAR str : ARRAY OF CHAR);
  (* Converts the value of real to floating-point string form, with sigFigs
     significant figures, and copies the possibly truncated result to str.
  *)

PROCEDURE RealToEng(real : LONGREAL;
                    sigFigs : CARDINAL;
                    VAR str : ARRAY OF CHAR);
  (* Converts the value of real to floating-point string form, with sigFigs
     significant figures, and copies the possibly truncated result to str.
     The number is scaled with one to three digits in the whole number part
     and with an exponent that is a multiple of three. *)

PROCEDURE RealToFixed(real : LONGREAL;
                      place : INTEGER;
                      VAR str : ARRAY OF CHAR);
  (* Converts the value of real to fixed-point string form, rounded to the
     given place relative to the decimal point, and copies the possibly
     truncated result to str. *)
(* if place is negative then the decimal point is suppressed and only *)
(* the whole part of the number will be output *)

PROCEDURE RealToStr(real : LONGREAL; VAR str : ARRAY OF CHAR);
  (* Converts the value of real as RealToFixed if the sign and magnitude
     can be shown within the capacity of str, or otherwise as RealToFloat,
     and copies the possibly truncated result to str. The number of places
     or significant digits depend on the capacity of str. *)

END LongStr.

(***************************************************************************)
(***************************************************************************)

(***************************************************************************)
(***************************************************************************)
DEFINITION MODULE LWholeStr;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

  (* Whole-number/string conversions *)

IMPORT
    ConvTypes;

TYPE
    ConvResults = ConvTypes.ConvResults;
    (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

(* the string form of a signed whole number is
     ["+" | "-"], decimal digit, {decimal digit}
*)

PROCEDURE StrToLongInt(str : ARRAY OF CHAR;
                       VAR int : LONGINT;
                       VAR res : ConvResults);
  (* Ignores any leading spaces in str. If the subsequent characters in
     str are in the format of a signed whole number, assigns a corresponding
     value to int. Assigns a value indicating the format of str to res.  *)

PROCEDURE LongIntToStr(int : LONGINT; VAR str : ARRAY OF CHAR);
  (* Converts the value of int to string form and copies the possibly
     truncated result to str. *)

(* the string form of an unsigned whole number is
     decimal digit, {decimal digit} *)

PROCEDURE StrToLongCard(str : ARRAY OF CHAR;
                        VAR card : LONGCARD;
                        VAR res : ConvResults);
  (* Ignores any leading spaces in str. If the subsequent characters in
     str are in the format of an unsigned whole number, assigns a
     corresponding value to card. Assigns a value indicating the format
     of str to res.  *)

PROCEDURE LongCardToStr(card : LONGCARD; VAR str : ARRAY OF CHAR);
  (* Converts the value of card to string form and copies the possibly
     truncated result to str. *)

END LWholeStr.

(* ==================================================================================== *)
DEFINITION MODULE ProgramArgs;

(* access to program arguments *)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

IMPORT IOChan;

TYPE
    ChanId      = IOChan.ChanId;

PROCEDURE ArgChan() : ChanId;
(* returns the value that identifies a channel for reading program arguments *)

PROCEDURE IsArgPresent() : BOOLEAN;
(* tests if there is a current argument to read from; If not,
   read <= IOChan.CurrentFlags() will be FALSE, and attempting to read
   from the argument channel will raise the exception notAvailable
*)

PROCEDURE NextArg();
(* if there is another argument, causes subsequent input from the
   argument device to come from the start of the next argument. Otherwise
   there is no argument to read from, and a call to IsArgPresent will
   return FALSE
*)

END ProgramArgs.

(* ==================================================================================== *)

DEFINITION MODULE IOConsts;


(* Types and constants for input/output modules *)

TYPE
    (* This type is used to classify the result of an input operation *)
    ReadResults =
    (
     notKnown,          (* no data read result is set *)
     allRight,          (* data is as expected or as required *)
     outOfRange,        (* data cannot be represented *)
     wrongFormat,       (* data not in expected format *)
     endOfLine,         (* end of line seen before expected data *)
     endOfInput         (* end of input seen before expected data *)
    );

END IOConsts.
(* ==================================================================================== *)
DEFINITION MODULE RealConv;
(* Low-level REAL/string conversions *)

IMPORT
    ConvTypes;

TYPE
    ConvResults = ConvTypes.ConvResults;
                (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

(* the string form of a signed fixed-point real number is
     ["+" | "-"], decimal digit, {decimal digit}, [".", {decimal digit}]
*)

(* the string form of a signed floating-point real number is
   signed fixed-point real number,
   "E",
   ["+" | "-"], decimal digit, {decimal digit}
*)

PROCEDURE ScanReal(inputCh : CHAR;
                   VAR chClass : ConvTypes.ScanClass;
                   VAR nextState : ConvTypes.ScanState);
(* Represents the start state of a finite state scanner for real
   numbers - assigns class of inputCh to chClass and a procedure
   representing the next state to nextState.
*)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

PROCEDURE FormatReal(str : ARRAY OF CHAR) : ConvResults;
(* Returns the format of the string value for conversion to REAL *)

PROCEDURE ValueReal(str : ARRAY OF CHAR) : REAL;
(* Returns the value corresponding to the real number string
   value str if str is well-formed; otherwise raises the RealConv exception.
*)

PROCEDURE LengthFloatReal(real : REAL; sigFigs : CARDINAL) : CARDINAL;
(* Returns the number of characters in the floating-point
   string representation of real with sigFigs significant figures
*)

PROCEDURE LengthEngReal(real : REAL; sigFigs : CARDINAL) : CARDINAL;
(* Returns the number of characters in the floating-point engineering
   string representation of real with sigFigs significant figures
*)

PROCEDURE LengthFixedReal(real : REAL; place : INTEGER) : CARDINAL;
(* Returns the number of characters in the fixed-point
   string representation of real rounded to the given place relative to
   the decimal point
*)

PROCEDURE IsRConvException() : BOOLEAN;
(* Returns TRUE if the current coroutine is in the exceptional execution
   state because of the raising of an exception in a routine from this
   module; otherwise returns FALSE
*)

END RealConv.

(* ==================================================================================== *)

DEFINITION MODULE RealStr;

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

  (* REAL/string conversions *)

IMPORT ConvTypes;

TYPE
    ConvResults = ConvTypes.ConvResults;
                  (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

(* the string form of a signed fixed-point real number is
     ["+" | "-"], decimal digit, {decimal digit}, [".", {decimal digit}]
*)

(* the string form of a signed floating-point real number is
   signed fixed-point real number,
   "E",
   ["+" | "-"], decimal digit, {decimal digit}
*)

PROCEDURE StrToReal(str : ARRAY OF CHAR;
                    VAR real : REAL;
                    VAR res : ConvResults);
  (* Ignores any leading spaces in str.
     If the subsequent characters in str are in the format of a signed real
     number, assigns a corresponding value to real.
     Assigns a value indicating the format of str to res.
  *)

PROCEDURE RealToFloat(real : REAL;
                      sigFigs : CARDINAL;
                      VAR str : ARRAY OF CHAR);
  (* Converts the value of real to floating-point string form, with sigFigs
     significant figures, and copies the possibly truncated result to str.
  *)

PROCEDURE RealToEng(real : REAL;
                    sigFigs : CARDINAL;
                    VAR str : ARRAY OF CHAR);
  (* Converts the value of real to floating-point string form, with sigFigs
     significant figures, and copies the possibly truncated result to str.
     The number is scaled with one to three digits in the whole number part
     and with an exponent that is a multiple of three. *)

PROCEDURE RealToFixed(real : REAL;
                      place : INTEGER;
                      VAR str : ARRAY OF CHAR);
  (* Converts the value of real to fixed-point string form, rounded to the
     given place relative to the decimal point, and copies the possibly
     truncated result to str. *)
(* if place is negative then the decimal point is suppressed and only *)
(* the whole part of the number will be output *)

PROCEDURE RealToStr(real : REAL; VAR str : ARRAY OF CHAR);
  (* Converts the value of real as RealToFixed if the sign and magnitude
     can be shown within the capacity of str, or otherwise as RealToFloat,
     and copies the possibly truncated result to str. The number of places
     or significant digits depend on the capacity of str. *)

END RealStr.

(* ====================================================================================*)
DEFINITION MODULE Storage;
%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

(* Facilities for dynamically allocating and deallocating storage *)

IMPORT SYSTEM;
TYPE
    StorageExceptions   =
                          (
                           nilDeallocation,
                           pointerToUnallocatedStorage,
                           wrongStorageToUnallocate
                          );

PROCEDURE ALLOCATE(VAR addr : SYSTEM.ADDRESS; amount : CARDINAL);
(* Allocates storage for a variable of size amount and assigns the
   address of this variable to addr. If there is insufficient unallocated
   storage to do this, the value NIL is assigned to addr.
*)

PROCEDURE DEALLOCATE(VAR addr : SYSTEM.ADDRESS; amount : CARDINAL);
(* Deallocates the amount locations allocated by ALLOCATE for the storage
   of the variable addressed by addr and assigns the value NIL to addr
*)

PROCEDURE StorageException() : StorageExceptions;
(* Returns TRUE if the current coroutine is in the exceptional execution
   state because of the raising of an exception from StorageExceptions;
   otherwise returns FALSE.
*)

PROCEDURE IsStorageException() : BOOLEAN;
(* IF the current coroutine is in the exceptional execution state because
   of the raising of an exception from StorageExceptions, returns the
   corresponding enumeration value, and otherwise raises an exception.
*)
END Storage.


(* ==================================================================================== *)

DEFINITION MODULE Strings;

<*/VALIDVER:ASM*>
%IF Bits16 %THEN
<*/VERSION:ASM*>
%END

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL*>
%END
<*/COPYATTRIBUTES*>

TYPE
    String1 = ARRAY [0..0] OF CHAR;

%IF ASM %AND Bits16 %THEN
    PROCEDURE Length(stringVal : ARRAY OF CHAR) : CARDINAL
                    [PASS(CX, ES:BX), ALTERS(AX,BX,CX,DX,ES), Invariant];
%ELSE
    PROCEDURE Length(stringVal : ARRAY OF CHAR) : CARDINAL [Invariant];
%END

(* the following seven procedures construct a string value, and attempt *)
(* to assign it to a variable parameter. The all have the property that *)
(* if the length of the constructed string value exceeds the capacity *)
(* of the variable parameter, a truncated value is assigned, while *)
(* if the length of the constructed string value is less than the capacity *)
(* of the variable parameter, a string terminator is appended before *)
(* assignment is performed. *)

PROCEDURE Assign(source : ARRAY OF CHAR; VAR OUT destination : ARRAY OF CHAR);
(* copies source to destination *)

PROCEDURE Extract(source : ARRAY OF CHAR;
                  startIndex, numberToExtract : CARDINAL;
                  VAR OUT destination : ARRAY OF CHAR);
(* copies at most numberToExtract characters from source to destination, *)
(* starting at position startIndex in source *)

PROCEDURE Delete(VAR INOUT stringVar : ARRAY OF CHAR;
                 startIndex, numberToDelete: CARDINAL);
(* deletes at most numberToDelete characters from stringVar, starting at *)
(* position startIndex *)

PROCEDURE Insert(source : ARRAY OF CHAR;
                 startIndex : CARDINAL;
                 VAR INOUT destination : ARRAY OF CHAR);
(* inserts source into destination at position startIndex *)

PROCEDURE Replace(source : ARRAY OF CHAR;
                  startIndex : CARDINAL;
                  VAR INOUT destination : ARRAY OF CHAR);
(* copies source into destination, starting at position startIndex. *)
(* Copying stops when all of source has been copied, or when the last *)
(* character of the string in destination has been replaced. *)

PROCEDURE Append(source : ARRAY OF CHAR; VAR INOUT destination : ARRAY OF CHAR);
(* appends source to destination *)

PROCEDURE Concat(source1, source2 : ARRAY OF CHAR;
                 VAR OUT destination : ARRAY OF CHAR);
(* concatenates source2 to source1 and copies the result into destination *)

(* the following predicates provide for pre-testing of the *)
(* operation-completion conditions for the procedures above. *)

PROCEDURE CanAssignAll(sourceLength : CARDINAL;
                       VAR OUT destination : ARRAY OF CHAR) : BOOLEAN;
(* retuns TRUE if a number of characters, indicated by sourceLength, *)
(* will fit into destination; otherwise returns FALSE *)

PROCEDURE CanExtractAll(sourceLength, startIndex, numberToExtract : CARDINAL;
                        VAR OUT destination : ARRAY OF CHAR) : BOOLEAN;
(* returns TRUE if there are numberToExtract characters starting at *)
(* startIndex and within the sourceLength of some string, and if the *)
(* capacity of destination is sufficient to hold numberToExtract characters; *)
(* otherwise returns FALSE *)

PROCEDURE CanDeleteAll(stringLength,
                       startIndex,
                       numberToDelete : CARDINAL) : BOOLEAN;
(* returns TRUE if there are numberToDelete characters starting at *)
(* startIndex and within the stringLength of some string; *)
(* otherwise returns FALSE *)

PROCEDURE CanInsertAll(sourceLength, startIndex : CARDINAL;
                       VAR INOUT destination : ARRAY OF CHAR) : BOOLEAN;
(* returns TRUE if there is room for insertion of sourceLength *)
(* characters from some string into destination starting at startIndex; *)
(* otherwise returns FALSE *)

PROCEDURE CanReplaceAll(sourceLength, startIndex : CARDINAL;
                        VAR INOUT destination : ARRAY OF CHAR) : BOOLEAN;
(* returns TRUE if there is room for the replacement of sourecLength *)
(* characters in destination starting at startIndex; *)
(* otherwise returns FALSE *)

PROCEDURE CanAppendAll(sourceLength : CARDINAL;
                       VAR INOUT destination : ARRAY OF CHAR) : BOOLEAN;
(* returns TRUE if there is sufficient room in destination to append *)
(* a string of length sourceLength to the string in destination; *)
(* otherwise returns FALSE *)

PROCEDURE CanConcatAll(source1Length, source2Length : CARDINAL;
                       VAR OUT destination: ARRAY OF CHAR) : BOOLEAN;
(* returns TRUE if there is sufficient room in destination for two strings *)
(* of length source1Length and source2Length; otherwise returns FALSE *)

TYPE
    CompareResults = (less, equal, greater);

%IF ASM %AND Bits16 %THEN

PROCEDURE Compare(stringVal1, stringVal2 : ARRAY OF CHAR) : CompareResults
    [PASS(CX, ES:DI, DX, BX:SI), ALTERS(AX,BX,CX,DX,SI,DI,ES), Invariant];

PROCEDURE Equal(stringVal1, stringVal2 : ARRAY OF CHAR) : BOOLEAN
    [PASS(CX, ES:DI, DX, BX:SI), ALTERS(AX,BX,CX,DX,SI,DI,ES), Invariant];

%ELSE

PROCEDURE Compare(stringVal1, stringVal2 : ARRAY OF CHAR)
                                        : CompareResults [Invariant];
(* returns less, equal or greater accordinly if stringVal1 is lexically *)
(* less than, equal to, or greater than stringVal2 *)

PROCEDURE Equal(stringVal1, stringVal2 : ARRAY OF CHAR)
                                        : BOOLEAN [Invariant];
(* returns Compare(stringVal1, stringVal2) = equal *)

%END

PROCEDURE FindNext(pattern, stringToSearch : ARRAY OF CHAR;
                   startIndex : CARDINAL;
                   VAR OUT patternFound : BOOLEAN;
                   VAR OUT posOfPattern : CARDINAL);
(* looks forward for the next occurance of pattern in stringToSearch, *)
(* starting the search at position startIndex. *)
(* If startIndex < LENGTH(stringToSearch) and pattern is found, patternFound *)
(* is returned as TRUE, and posOfPattern contains the start position in *)
(* stringToSearch of pattern. Otherwise patternFound is returned as FALSE, *)
(* and posOfPattern is unchanged. *)

PROCEDURE FindPrev(pattern, stringToSearch : ARRAY OF CHAR;
                   startIndex : CARDINAL;
                   VAR OUT patternFound : BOOLEAN;
                   VAR OUT posOfPattern : CARDINAL);
(* looks backward for the previous occurence of pattern in stringToSearch *)
(* and returns the position of the first character of the pattern if found. *)
(* The search for the pattern begins at startIndex. If pattern is found, *)
(* patternFound is returned as TRUE, and posOfPattern contains the start *)
(* position in stringToSearch of pattern in the range [0..startIndex]. *)
(* otherwise patternFound is returned FALSE, and posOfPattern is unchanged. *)

PROCEDURE FindDiff(stringVal1, stringVal2 : ARRAY OF CHAR;
                   VAR OUT differenceFound : BOOLEAN;
                   VAR OUT posOfDifference : CARDINAL);
(* compares the string values in stringVal1 and stringVal2 for differences. *)
(* If they are equal, differenceFound is returned as FALSE, and TRUE *)
(* otherwise. If differenceFound is TRUE, posOfDifference is set to the *)
(* position of the first difference; otherwise posOfDifference is unchanged. *)

PROCEDURE Capitalize(VAR INOUT stringVar : ARRAY OF CHAR);
(* applies the function CAP to each character of the string in stringVar *)

END Strings.


DEFINITION MODULE WholeConv;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs  1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman
=========================================== *)

(* Low-level whole-number.string conversions *)

IMPORT
    ConvTypes;

TYPE
    ConvResults = ConvTypes.ConvResults;
                (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

PROCEDURE ScanInt(inputCh : CHAR;
                  VAR chClass : ConvTypes.ScanClass;
                  VAR nextState : ConvTypes.ScanState);
(* Represents the start state of a finite state scanner for signed whole
   numbers - assigns class of inputCh to chClass and a procedure
   representing the next state to nextState.
*)

PROCEDURE ScanCard(inputCh : CHAR;
                   VAR chClass : ConvTypes.ScanClass;
                   VAR nextState : ConvTypes.ScanState);
(* Represents the start state of a finite state scanner for signed whole
   numbers - assigns class of inputCh to chClass and a procedure
   representing the next state to nextState.
*)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

PROCEDURE FormatInt(str : ARRAY OF CHAR) : ConvResults;
(* Returns the format of the string value for conversion to INTEGER *)

PROCEDURE ValueInt(str : ARRAY OF CHAR) : INTEGER;
(* Returns the value corresponding to the signed whole number string
   value str if str is well-formed; otherwise raises the WholeConv exception.
*)

PROCEDURE LengthInt(int : INTEGER) : CARDINAL;
(* Returns the number of characters in the string representation of int *)

PROCEDURE FormatCard(str : ARRAY OF CHAR) : ConvResults;
(* Returns the format of the string value for conversion to CARDINAL *)

PROCEDURE ValueCard(str : ARRAY OF CHAR) : CARDINAL;
(* Returns the value corresponding to the signed whole number string
   value str if str is well-formed; otherwise raises the WholeConv exception.
*)

PROCEDURE LengthCard(card : CARDINAL) : CARDINAL;
(* Returns the number of characters in the string representation of card *)

PROCEDURE IsWholeConvException() : BOOLEAN;
(* Returns TRUE if the current coroutine is in the exceptional execution
   state because of the raising of an exception in a routine from this
   module; otherwise returns FALSE
*)

END WholeConv.

DEFINITION MODULE Str;

IMPORT Strings;

TYPE
    CHARSET	= PACKEDSET OF CHAR;
    PosLen =
	RECORD
        Pos	: CARDINAL;
	Len	: CARDINAL;
	END;


CONST
    Caps	= Strings.Capitalize;
    Length	= Strings.Length;
    Delete	= Strings.Delete;
(*
PROCEDURE Caps(VAR str : ARRAY OF CHAR);
PROCEDURE Length(str : ARRAY OF CHAR) : CARDINAL;
PROCEDURE Delete(VAR str : ARRAY OF CHAR; pos, len : CARDINAL);
*)

PROCEDURE Lows(VAR str : ARRAY OF CHAR);

PROCEDURE Compare(s1, s2 : ARRAY OF CHAR) : INTEGER;

PROCEDURE Concat(VAR dest : ARRAY OF CHAR;
		 str1 : ARRAY OF CHAR;
		 str2 : ARRAY OF CHAR);

PROCEDURE Append(VAR dest : ARRAY OF CHAR; str : ARRAY OF CHAR);

PROCEDURE Copy(VAR dest : ARRAY OF CHAR; str : ARRAY OF CHAR);

PROCEDURE Slice(VAR dest : ARRAY OF CHAR;
		str : ARRAY OF CHAR;
		pos, len : CARDINAL);

PROCEDURE Pos(str, subStr : ARRAY OF CHAR) : CARDINAL;

PROCEDURE NextPos(str, subStr : ARRAY OF CHAR; pos : CARDINAL) : CARDINAL;

PROCEDURE CharPos(str : ARRAY OF CHAR; ch : CHAR) : CARDINAL;

PROCEDURE RCharPos(str : ARRAY OF CHAR; ch : CHAR) : CARDINAL;

PROCEDURE Item(VAR dest : ARRAY OF CHAR;
	       str : ARRAY OF CHAR;
	       sep : CHARSET;
	       n : CARDINAL);

PROCEDURE ItemS(VAR dest : ARRAY OF CHAR;
		str : ARRAY OF CHAR;
		sep : ARRAY OF CHAR;
		n : CARDINAL);

PROCEDURE Prepend(VAR dest : ARRAY OF CHAR; str : ARRAY OF CHAR);

PROCEDURE Insert(VAR dest : ARRAY OF CHAR;
		str : ARRAY OF CHAR;
		pos : CARDINAL);

PROCEDURE Subst(VAR dest : ARRAY OF CHAR;
		src : ARRAY OF CHAR;
		new : ARRAY OF CHAR);

PROCEDURE Match(src, pattern : ARRAY OF CHAR) : BOOLEAN;

PROCEDURE FindSubStr(src, pattern : ARRAY OF CHAR;
		     VAR posList : ARRAY OF PosLen) : BOOLEAN;


PROCEDURE IntToStr(num : LONGINT;
		   VAR str : ARRAY OF CHAR;
		   base : CARDINAL;
		   VAR ok : BOOLEAN);

PROCEDURE CardToStr(num : CARDINAL32;
		    VAR str : ARRAY OF CHAR;
		    base : CARDINAL;
                    VAR ok : BOOLEAN);

PROCEDURE RealToStr(num : LONGREAL;
                    precision : CARDINAL;
		    eng : BOOLEAN;
		    VAR dest : ARRAY OF CHAR;
		    VAR ok : BOOLEAN);

PROCEDURE FixRealToStr(num : LONGREAL;
                       precision : CARDINAL;
		       VAR str : ARRAY OF CHAR;
		       VAR ok : BOOLEAN);

PROCEDURE StrToInt(str : ARRAY OF CHAR;
		   base : CARDINAL;
		   VAR ok : BOOLEAN) : LONGINT;

PROCEDURE StrToCard(str : ARRAY OF CHAR;
		    base : CARDINAL;
                    VAR ok : BOOLEAN) : CARDINAL32;

PROCEDURE StrToReal(str : ARRAY OF CHAR; VAR ok : BOOLEAN ) : LONGREAL;

PROCEDURE StrToC(src : ARRAY OF CHAR; VAR dest : ARRAY OF CHAR) : BOOLEAN;

PROCEDURE StrToPas(src : ARRAY OF CHAR; VAR dest : ARRAY OF CHAR) : BOOLEAN;

END Str.

DEFINITION MODULE Lib;

FROM SYSTEM IMPORT
    ADDRESS, BYTE, WORD;

%IF DOS %OR FlashTek %THEN
FROM SYSTEM IMPORT
    REGISTERS;
%END

VAR
    RunTimeError        : PROCEDURE(CARDINAL32, CARDINAL, ARRAY OF CHAR);

PROCEDURE AddAddr(a : ADDRESS; incr : CARDINAL) : ADDRESS;

PROCEDURE SubAddr(a : ADDRESS; incr : CARDINAL) : ADDRESS;

PROCEDURE IncAddr(VAR a : ADDRESS; incr : CARDINAL);

PROCEDURE DecAddr(VAR a : ADDRESS; incr : CARDINAL);

PROCEDURE Compare(src, dest : ADDRESS; len : CARDINAL) : CARDINAL;

TYPE
    CpuKind     =
        (
         cpu_Unknown,
         cpu_V20,
         cpu_V30,
         cpu_8088,
         cpu_8086,
         cpu_80188,
         cpu_80186,
         cpu_80286,
         cpu_80386,
         cpu_80486,
         cpu_Pentium
        );
    FpuKind     =
        (
         fpu_none,
         fpu_8087,
         fpu_80287,
         fpu_80387
        );
    CpuRec      =
        RECORD
            cpu : CpuKind;
            fpu : FpuKind;
        END;

PROCEDURE CpuId(VAR id : CpuRec);


PROCEDURE Delay(amount : CARDINAL);

%IF DOS %OR FlashTek %THEN
PROCEDURE Dos(VAR R : REGISTERS);
%END

TYPE
    ExecEnvPtr  = POINTER TO ARRAY [0..0] OF ADDRESS;

PROCEDURE Exec(command, params : ARRAY OF CHAR; env : ExecEnvPtr) : CARDINAL;

PROCEDURE ExecCmd(command : ARRAY OF CHAR) : CARDINAL;

PROCEDURE EnvironmentFind(name : ARRAY OF CHAR;
                          VAR result : ARRAY OF CHAR);

PROCEDURE Fill(dest : ADDRESS; count : CARDINAL; db : BYTE);

TYPE
    DayType     = (
                   Sunday,
                   Monday,
                   Tuesday,
                   Wednesday,
                   Thursday,
                   Friday,
                   Saturday);

PROCEDURE GetDate(VAR year, month, day : CARDINAL;
                  VAR dayOfWeek : DayType);

PROCEDURE GetTime(VAR hrs, mins, secs, hsecs : CARDINAL);

PROCEDURE SetDate(year, month, day : CARDINAL; dayOfWeek : DayType);

PROCEDURE SetTime(hrs, mins, secs, hsecs : CARDINAL);

PROCEDURE HashString(str : ARRAY OF CHAR; range : CARDINAL) : CARDINAL;

%IF DOS %OR FlashTek %THEN
PROCEDURE Intr(VAR R : REGISTERS; intNum : CARDINAL);
%END

PROCEDURE Move(src, dest : ADDRESS; count : CARDINAL);

PROCEDURE ParamCount() : CARDINAL;

PROCEDURE ParamStr(VAR str : ARRAY OF CHAR; n : CARDINAL);

TYPE
    CompareProc = PROCEDURE(CARDINAL, CARDINAL) : BOOLEAN;
    SwapProc    = PROCEDURE(CARDINAL, CARDINAL);

PROCEDURE QSort(numItems : CARDINAL;
                less : CompareProc;
                swap : SwapProc);

PROCEDURE HSort(numItems : CARDINAL;
                less : CompareProc;
                swap : SwapProc);

PROCEDURE RAND() : REAL;

PROCEDURE RANDOM(range : CARDINAL) : CARDINAL;

PROCEDURE RANDOMIZE;

PROCEDURE ScanL(dest : ADDRESS; count : CARDINAL; db : BYTE) : CARDINAL;

PROCEDURE ScanNeL(dest : ADDRESS; count : CARDINAL; db : BYTE) : CARDINAL;

PROCEDURE ScanNeR(dest : ADDRESS; count : CARDINAL; db : BYTE) : CARDINAL;

PROCEDURE ScanR(dest : ADDRESS; count : CARDINAL; db : BYTE) : CARDINAL;

PROCEDURE SetReturnCode(code : CARDINAL);

PROCEDURE Terminate(p : PROC; VAR old : PROC);

PROCEDURE WordFill(dest : ADDRESS; cound : CARDINAL; dw : WORD);

PROCEDURE WordMove(src, dest : ADDRESS; count : CARDINAL);

END Lib.
DEFINITION MODULE MATHLIB;

IMPORT LongMath;

CONST
    M_E		= 2.718281828459045240;      (* e *)
    M_Log2E	= 1.442695040888963410;      (* log2 of e *)
    M_Log10E	= 0.434294481903251828;      (* log10 of e *)
    M_Ln2	= 0.693147180559945309;      (* ln of 2.0 *)
    M_Ln10	= 2.302585092994045680;      (* ln of 10.0 *)
    M_Pi	= 3.141592653589793240;      (* pi *)
    M_PiBy2	= 1.570796326794896620;      (* pi / 2.0 *)
    M_PiBy4	= 0.785398163397448310;      (* pi / 4.0 *)
    M_1ByPy	= 0.318309886183790672;      (* 1.0 / pi *)
    M_2ByPy	= 0.636619772367581343;      (* 2.0 / pi *)
    M_1BySqrtPi	= 0.564189583547756287;      (* 1.0 / sqrt(pi) *)
    M_2BySqrtPi	= 1.128379167095512570;      (* 2.0 / sqrt(pi) *)
    M_Sqrt2	= 1.414213562373095050;      (* sqrt(2.0) *)
    M_Sqrt2By2	= 0.707106781186547524;      (* sqrt(2.0) / 2.0 *)

CONST
    Sin    = LongMath.sin;
    Cos    = LongMath.cos;
    Tan    = LongMath.tan;
    ASin   = LongMath.arcsin;
    ACos   = LongMath.arccos;
    ATan   = LongMath.arctan;
    Sqrt   = LongMath.sqrt;
    Exp    = LongMath.exp;
    Log    = LongMath.ln;
    Pow    = LongMath.power;
(*
PROCEDURE Sin(num : LONGREAL) : LONGREAL;
PROCEDURE Cos(num : LONGREAL) : LONGREAL;
PROCEDURE Tan(num : LONGREAL) : LONGREAL;
PROCEDURE ASin(num : LONGREAL) : LONGREAL;
PROCEDURE ACos(num : LONGREAL) : LONGREAL;
PROCEDURE ATan(num : LONGREAL) : LONGREAL;
PROCEDURE Sqrt(num : LONGREAL) : LONGREAL;
PROCEDURE Exp(num : LONGREAL) : LONGREAL;
PROCEDURE Log(num : LONGREAL) : LONGREAL;
PROCEDURE Pow(X, Y : LONGREAL) : LONGREAL;
*)

PROCEDURE SinH(num : LONGREAL) : LONGREAL;

PROCEDURE CosH(num : LONGREAL) : LONGREAL;

PROCEDURE TanH(num : LONGREAL) : LONGREAL;

PROCEDURE ATan2(X, Y : LONGREAL) : LONGREAL;

PROCEDURE Log10(num : LONGREAL) : LONGREAL;

PROCEDURE Mod(X, Y : LONGREAL) : LONGREAL;

PROCEDURE Rexp(VAR i : INTEGER; num : LONGREAL) : LONGREAL;

END MATHLIB.

DEFINITION MODULE SysClock;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs  1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman

=========================================== *)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

(* Facilities for accessing a system clock that
   records the date and time of day
*)

<*/NOPACK*>

CONST
    maxSecondParts      = 999;(*implementation dependent value*)

TYPE
    Month       = [1..12];
    Day         = [1..31];
    Hour        = [0..23];
    Min         = [0..59];
    Sec         = [0..59];
    Fraction    = [0..maxSecondParts];
    UTCDiff     = [-780..720];

    DateTime    =
        RECORD
        year            : CARDINAL;
        month           : Month;
        day             : Day;
        hour            : Hour;
        minute          : Min;
        second          : Sec;
        fractions       : Fraction; (* parts of a second *)
        zone            : UTCDiff;  (* Time zone differential factor
                                       which is the number of minutes
                                       to add to local time to obtain
                                       UTC. *)
        summerTimeFlag  : BOOLEAN;  (* interpretation depends on local
                                       usage *)
        END;

(* NOTE: the zone and summerTimeFlag fields are only supported on those *)
(* operating systems that can provide this information *)
(* On Win32 and Posix compliant Unix they are supported *)
(* summerTimeFlag can means daylight savings time or not *)

PROCEDURE CanGetClock() : BOOLEAN;
(* Returns TRUE if a system clock can be read; FALSE otherwise *)

PROCEDURE CanSetClock() : BOOLEAN;
(* Returns TRUE if a system clock can be set; FALSE otherwise *)

PROCEDURE IsValidDateTime(userData : DateTime) : BOOLEAN;
(* Returns TRUE if the value of userData represents a valid date and time;
   FALSE otherwise
*)

PROCEDURE GetClock(VAR userData : DateTime);
(* If possible, assigns system date and time of day to userData *)

PROCEDURE SetClock(userData : DateTime);
(* If possible, sets the system clock to the values of userData *)

END SysClock.

DEFINITION MODULE LongIO;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs  1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman
=========================================== *)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END


  (* Input and output of real numbers in decimal text form over specified
channels. The read result is of the type IOConsts.ReadResults. *)

IMPORT IOChan;

  (* The text form of a signed fixed-point real number is
       ["+" | "-"], decimal digit, {decimal digit},
       [".", {decimal digit}]

     The text form of a signed floating-point real number is
       signed fixed-point real number,
       "E", ["+" | "-"], decimal digit, {decimal digit}
  *)

PROCEDURE ReadReal(cid : IOChan.ChanId; VAR real : LONGREAL);
  (* Skips leading spaces, and removes any remaining characters from cid
     that form part of a signed fixed or floating point number.
     The value of this number is assigned to real.
     The read result is set to the value allRight, outOfRange, wrongFormat,
     endOfLine, or  endOfInput. *)

PROCEDURE WriteFloat(cid : IOChan.ChanId;
                     real : LONGREAL;
                     sigFigs : CARDINAL;
                     width : CARDINAL);
  (* Writes the value of real to cid in floating-point text form,
     with sigFigs significant figures, in a field of the given minimum width.
  *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

PROCEDURE WriteEng(cid : IOChan.ChanId;
                   real : LONGREAL;
                   sigFigs : CARDINAL;
                   width : CARDINAL);
  (* As for WriteFloat, except that the number is scaled with one to three
     digits in the whole number part, and with an exponent that is a
     multiple of three. *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

PROCEDURE WriteFixed(cid : IOChan.ChanId;
                     real : LONGREAL;
                     place : INTEGER;
                     width : CARDINAL);
  (* Writes the value of real to cid in fixed-point text form, rounded to
     the given place relative to the decimal point, in a field of the given
     minimum width. *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

PROCEDURE WriteReal(cid : IOChan.ChanId;
                    real : LONGREAL;
                    width : CARDINAL);
  (* Writes the value of real to cid, as WriteFixed if the sign and
     magnitude can be shown in the given width, or otherwise as WriteFloat.
     The number of places or significant digits depends on the given width.
  *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

END LongIO.

DEFINITION MODULE LongMath;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs  1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman

===========================================*)

CONST
    pi          = 3.141592653589793238462;
    expi        = 2.718281828459045235360;

%IF InlineFpp %THEN
PROCEDURE sqrt(x : LONGREAL) : LONGREAL [FppPrim, Invariant];
%ELSE
PROCEDURE sqrt(x : LONGREAL) : LONGREAL [Invariant];
%END

%IF InlineFpp %AND IA32 %THEN

PROCEDURE exp(x : LONGREAL) : LONGREAL [FppPrim, Invariant];

PROCEDURE ln(x : LONGREAL) : LONGREAL [FppPrim, Invariant];

(* these functions compute values in radians *)

PROCEDURE sin(x : LONGREAL) : LONGREAL [FppPrim, Invariant];

PROCEDURE cos(x : LONGREAL) : LONGREAL [FppPrim, Invariant];

PROCEDURE tan(x : LONGREAL) : LONGREAL [FppPrim, Invariant];

PROCEDURE arctan(x : LONGREAL) : LONGREAL [FppPrim, Invariant];

%ELSE

PROCEDURE exp(x : LONGREAL) : LONGREAL [Invariant];

PROCEDURE ln(x : LONGREAL) : LONGREAL [Invariant];

(* these functions compute values in radians *)

PROCEDURE sin(x : LONGREAL) : LONGREAL [Invariant];

PROCEDURE cos(x : LONGREAL) : LONGREAL [Invariant];

PROCEDURE tan(x : LONGREAL) : LONGREAL [Invariant];

PROCEDURE arctan(x : LONGREAL) : LONGREAL [Invariant];

%END

PROCEDURE arcsin(x : LONGREAL) : LONGREAL [Invariant];

PROCEDURE arccos(x : LONGREAL) : LONGREAL [Invariant];

PROCEDURE power(base, exponent : LONGREAL) : LONGREAL [Invariant];
(* base must be > 0.0 *)
(* exponent may have any value *)
(* this function is functionally identical to (exp(exponent * ln(base))) *)

PROCEDURE round(x : LONGREAL) : INTEGER [Invariant];

PROCEDURE IsRMathException() : BOOLEAN;

END LongMath.

DEFINITION MODULE LowLong;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs  1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman
=========================================== *)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

(* Access to underlying properties of the type LONGREAL *)

CONST
    radix       = 2;    (* number base used to represent real numbers *)
    places      = 64;   (* radix places used to store number *)
    expoMin     = -1022;(* powers of radix *)
    expoMax     = 1023; (* powers of radix *)
    large       = MAX(LONGREAL);
    small       = 2.23E-308;(*normalized*)
    IEEE        = TRUE; (* IEEE 754, 854 floating point standard *)
    ISO         = FALSE;(* ISO/IEC 10967-1(LIA-1) standard *)
    rounds      = TRUE; (* after each mathematical operation *)
    gUnderflow  = TRUE; (* TRUE of there can exist numbers 0 > num < small *)
                        (* gradual underflow *)
    exception   = FALSE;(* exception is raised for out of range numbers *)
                        (* after an operation *)
    %IF IA32 %THEN
    extend      = TRUE; (* computations are performed at a higher precision *)
                        (* than the stored precision *)
    %ELSE
    extend      = FALSE;
    %END
    nModes      = 1;

TYPE
    Modes       = PACKEDSET OF [0..nModes-1];

PROCEDURE exponent(x : LONGREAL) : INTEGER;
(* returns the exponent value of x *)
(* in radix number base *)

PROCEDURE fraction(x : LONGREAL) : LONGREAL;
(* returns the significand (or significant part) of x *)
(* in radix number base *)

PROCEDURE sign(x : LONGREAL) : LONGREAL;
(* returns the signum of x *)

PROCEDURE succ(x : LONGREAL) : LONGREAL;
(* returns the next value of the type LONGREAL greater than x *)

PROCEDURE ulp(x : LONGREAL) : LONGREAL;
(* returns the value of a unit in the last place of x *)

PROCEDURE pred(x : LONGREAL) : LONGREAL;
(* returns the previous value of the type LONGREAL less than x *)

PROCEDURE intpart(x : LONGREAL) : LONGREAL;
(* returns the integer parts of x *)
(* in radix number base *)

PROCEDURE fractpart(x : LONGREAL) : LONGREAL;
(* returns the fractional parts of x *)

PROCEDURE scale(x : LONGREAL; n : INTEGER) : LONGREAL;
(* returns the value of (x * radix ** n) *)
(* in radix number base *)

PROCEDURE trunc(x : LONGREAL; n : INTEGER) : LONGREAL;
(* returns the value of the first n places of x *)
(* in radix number base *)

PROCEDURE round(x : LONGREAL; n : INTEGER) : LONGREAL;
(* returns the value of x rounded to the first n places *)
(* in radix number base *)

PROCEDURE synthesize(expart : INTEGER; frapart : LONGREAL) : LONGREAL;
(* returns a value of the type LONGREAL constructed from the given
   expart and frapart
*)

PROCEDURE setMode(m : Modes);
(* sets status flags approiate to the underlying implementation of the
   type LONGREAL
*)

PROCEDURE currentMode() : Modes;
(* returns the current status flags in the form set by setMode *)

PROCEDURE IsLowException() : BOOLEAN;
(* returns TRUE if the current coroutine is in the exception state
   because of the raising of an exception in a routine from this module;
   otherwise returns FALSE
*)

END LowLong.

DEFINITION MODULE LowReal;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs  1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman
=========================================== *)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

(* Access to underlying properties of the type REAL *)

CONST
    radix       = 2;    (* number base used to represent real numbers *)
    places      = 32;   (* radix places used to store number *)
    expoMin     = -126; (* powers of radix *)
    expoMax     = 127;  (* powers of radix *)
    large       = MAX(REAL);
    small       = 1.18E-38;(*normalized*)
    IEEE        = TRUE; (* IEEE 754, 854 floating point standard *)
    ISO         = FALSE;(* ISO/IEC 10967-1(LIA-1) standard *)
    rounds      = TRUE; (* after each mathematical operation *)
    gUnderflow  = TRUE; (* TRUE of there can exist numbers 0 > num < small *)
                        (* gradual underflow *)
    exception   = FALSE;(* exception is raised for out of range numbers *)
                        (* after an operation *)
    extend      = TRUE; (* computations are performed at a higher precision *)
                        (* than the stored precision *)
    nModes      = 1;

TYPE
    Modes       = PACKEDSET OF [0..nModes-1];

PROCEDURE exponent(x : REAL) : INTEGER;
(* returns the exponent value of x *)
(* in radix number base *)

PROCEDURE fraction(x : REAL) : REAL;
(* returns the significand (or significant part) of x *)
(* in radix number base *)

PROCEDURE sign(x : REAL) : REAL;
(* returns the signum of x *)

PROCEDURE succ(x : REAL) : REAL;
(* returns the next value of the type REAL greater than x *)

PROCEDURE ulp(x : REAL) : REAL;
(* returns the value of a unit in the last place of x *)

PROCEDURE pred(x : REAL) : REAL;
(* returns the previous value of the type REAL less than x *)

PROCEDURE intpart(x : REAL) : REAL;
(* returns the integer parts of x *)
(* in radix number base *)

PROCEDURE fractpart(x : REAL) : REAL;
(* returns the fractional parts of x *)
(* in radix number base *)

PROCEDURE scale(x : REAL; n : INTEGER) : REAL;
(* returns the value of (x * radix ** n) *)

PROCEDURE trunc(x : REAL; n : INTEGER) : REAL;
(* returns the value of the first n places of x *)
(* in radix number base *)

PROCEDURE round(x : REAL; n : INTEGER) : REAL;
(* returns the value of x rounded to the first n places *)
(* in radix number base *)

PROCEDURE synthesize(expart : INTEGER; frapart : REAL) : REAL;
(* returns a value of the type REAL constructed from the given
   expart and frapart
*)

PROCEDURE setMode(m : Modes);
(* sets status flags approiate to the underlying implementation of the
   type REAL
*)

PROCEDURE currentMode() : Modes;
(* returns the current status flags in the form set by setMode *)

PROCEDURE IsLowException() : BOOLEAN;
(* returns TRUE if the current coroutine is in the exception state
   because of the raising of an exception in a routine from this module;
   otherwise returns FALSE
*)

END LowReal.

DEFINITION MODULE RealMath;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs  1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman

===========================================*)

CONST
    pi          = 3.141592653589793238462;
    expi        = 2.718281828459045235360;

%IF InlineFpp %THEN
PROCEDURE sqrt(x : REAL) : REAL [FppPrim, Invariant];
%ELSE
PROCEDURE sqrt(x : REAL) : REAL [Invariant];
%END

%IF InlineFpp %AND IA32 %THEN

PROCEDURE exp(x : REAL) : REAL [FppPrim, Invariant];

PROCEDURE ln(x : REAL) : REAL [FppPrim, Invariant];

(* these functions compute values in radians *)

PROCEDURE sin(x : REAL) : REAL [FppPrim, Invariant];

PROCEDURE cos(x : REAL) : REAL [FppPrim, Invariant];

PROCEDURE tan(x : REAL) : REAL [FppPrim, Invariant];

PROCEDURE arctan(x : REAL) : REAL [FppPrim, Invariant];

%ELSE

PROCEDURE exp(x : REAL) : REAL [Invariant];

PROCEDURE ln(x : REAL) : REAL [Invariant];

(* these functions compute values in radians *)

PROCEDURE sin(x : REAL) : REAL [Invariant];

PROCEDURE cos(x : REAL) : REAL [Invariant];

PROCEDURE tan(x : REAL) : REAL [Invariant];

PROCEDURE arctan(x : REAL) : REAL [Invariant];

%END

PROCEDURE arcsin(x : REAL) : REAL [Invariant];

PROCEDURE arccos(x : REAL) : REAL [Invariant];

PROCEDURE power(base, exponent : REAL) : REAL [Invariant];
(* base must be > 0.0 *)
(* exponent may have any value *)
(* this function is functionally identical to (exp(exponent * ln(base))) *)

PROCEDURE round(x : REAL) : INTEGER [Invariant];

PROCEDURE IsRMathException() : BOOLEAN;

END RealMath.

(***************************************************************************)
(***************************************************************************)


(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1992-2002                             *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)
DEFINITION MODULE DlgShell;
(* This module provides an encapsulation of the interface to
   dialog boxes. This module is independent of the underlying
   operating system.
   This module also attempts to provide some automatic and simpler mechanisms
   for dealing with dialog boxes and their controls.
*)

(* about threads
   Win32 - you may use the GUI features in a fully multi threaded manner.

   Gtk - Only one thread, the main thread, may use the GUI features.
*)

<*/NOPACK*>
%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

FROM SYSTEM IMPORT
    ADDRESS, CAST, DWORD;

FROM WinShell IMPORT
    Window, COORDINATE;
IMPORT WinShell;

CONST
    CurrentAsParent     = CAST(Window, 1);
    (* Use this to specify the current dialog
      as the parent of the new dialog
      this is only used when one dialog creates another dialog. *)

VAR
    DlgError            : CARDINAL; (* operating system specific value *)

TYPE
    (* various types of dialog controls supported by this module *)
    ControlType = (
                   DialogTitle,
                   StaticText,
                   StaticTextAttrib,
                   CheckBox,
                   RadioGroup,
                   LineEdit,
                   NumberEdit,
                   IncDec,
                   MultiLineEdit,
                   EditTextFile,
                   ListBox,
                   ColumnListBox,
                   DropDownList,
                   ComboBox,
                   ColorDropDownList,
                   PushButton,
                   Timer,
                   UserData
                  );
(*

    ======= ControlType =======

    Most fields set the initial value of the control as well as holding
    the return value.

    StaticText  = The text to display in the field. Can be NIL on init.
                  Win32 - static text
                  Gtk - GtkLabel

    StaticTextAttrib    = The text to display in the field. Can be NIL.
                  Win32 - static text
                  Gtk - GtkLabel inside a GtkEventBox.
                          You should place a label inside and event box for this
                          control. A GtkLabel does not control its background color
                          so you need the EventBox to be able to set the background
                          color. If an event box is not the "parent" of this label,
                          then the background color will not be set but the foreground
                          and font attributes will still work.

        sta_fore = the foreground color to display the text in.
        sta_back = the background color to display the text in.
        sta_font = the font to used to display the text in. (Can be NIL)

    CheckBox
                  Win32 - check box
                  Gtk - GtkCheckButton

        on      = The state of the checkbox (checked is TRUE).
                  On entry sets box state and upon return contains the box state.

    RadioGroup
                  Win32 - radio button
                  Gtk - GtkRadioButton

        r_first = The id of the first radio button in the button group.
        r_last  = The id of the last radio button in the button group.
                  All items in the group must have consecutive id numbers
                  from first to last.

                  On entry id contains the initial item to check in the
                  radio group.
                  On return id contains the item in the group that is
                  currently checked.
                  This value is zero based from the first item in the group

    LineEdit
                  Win32 - edit
                  Gtk - GtkEntry

        le_text = Pointer to a null terminated string which holds the
                  edit field contents. Can be NIL. In this case
                  you will need to use the GetText procedure to fetch the
                  text from the control.
                  On entry the edit field is initialized with the text in
                  this string, and upon return the user entered text is
                  contained within this string.
        le_max  = The maximum number of characters allowed in the edit field.
                  The le_text buffer, if present, should be one character bigger
                  than the maximum allowable character count. This allows for
                  a null terminator.

    MultiLineEdit
                  Win32 - edit with multi line option
                  Gtk - GtkText

        mle_text = Pointer to a null terminated string which holds the
                   edit field contents. Can be NIL. To enter/retrieve text
                   you can use the supplied line read/write APIs.
                   If not NIL, on entry the edit field is initialized with the
                   text from this string.
        mle_max = The maximum number of characters allowed in the edit field.
                  mle_max can be zero which means that the edit file has not limit
                  other than that implied by the system.
                  The mle_text buffer, if present, should be one character bigger
                  than the maximum allowable character count. This allows for
                  a null terminator.

                  IF (mle_max <> 0) AND (mle_text <> NIL) THEN
                  mle_text will contain the value of the edit field upon return.
                  The buffer should be one character bigger than the maximum to
                  allow for a null terminator character.

    EditTextFile
        etf_name = Pointer to a NULL terminated string which holds the
                   file name of the file to be edited.
                   the file will be saved when the dialog is closed if the user alters
                   the file in any way. if the dialog is "canceled" then
                   the file will not be saved.
                   This control is compatible with the MultiLineEdit control.

    ListBox
                A list box that allows only a single item selected.
                  Win32 - list box, single selection
                  Gtk - GtkCList (1 column), browse/single selection

        lb_text
                = Pointer to an array of null terminated strings terminated
                  by a null, meaning the end of the string has a double null.
                  See the ConvertToNulls and ConvertFromNulls procedures in
                  this module for a simple method maintaining such strings.
        lb_selStr
                = Pointer to a string to hold the result as well as the
                  initial selection. This value can be NIL if you want to
                  set and receive the selection by index. The strings are
                  not case sensitive.
                  On termination this string has the users selection if it
                  does not have NIL.
                  selStr MUST be big enough to hold any string in the
                  list box.
        lb_selIndex
                = if selStr is NIL on entry, this has the initial selection
                  index. On termination this always has the users selection
                  by index regardless of if selStr <> NIL.
                  For sorted, this is the index of the order data was
                  added to the list box, not how it was displayed.
                  The index is zero based, and MAX(CARDINAL) signifies no
                  selection.

    ColumnListBox
                A list box that allows only a single item selected.
                The list box has 2 or more columns. The only way to initialize
                the list is to use API calls. You can do this in the dialog
                "init" message.
                  Win32 - ListView in report mode, single selection
                  Gtk - GtkCList, browse/single selection

        clb_columns = The number of columns, 2 or more

        clb_columnInfo =
                = Pointer to and array of CARDINAL values with the column
                  widths in screen pixels. Must have clb_columns number of
                  elements.
                  The first element is for column zero, and so on...

                  width = the column width in pixels. Can be zero if you are
                          going to set the column size via APIs
                  align = The alignment of the text in the column.
                  header = the header text. Can be NIL, which means the
                           header, if shown, with not have a title.
        clb_selStr
                = Pointer to a string to hold the result.
                  This value can be NIL if you want to receive the selection
                  by index.
                  On termination this string has the users selection if it
                  does not contain NIL.
                  selStr MUST be big enough to hold any string in the
                  list box.
                  selStr contains the text of all columns separated by null characters.
        clb_selIndex
                = On termination this always has the users selection.
                  The index is zero based, and MAX(CARDINAL) signifies no
                  selection.

    DropDownList
                This is an expandable list box that shows the selected item and the
                user can press a button to display the full list of items
                available to be selected.
                  Win32 - combo box with drop down list attribute
                  Gtk - GtkOptionMenu, or GtkCombo(not editable)
                        OptionMenu is the ideal widget but if you have a large
                        number of items in the list then OptionMenu does not work
                        well, if at all. In these cases use a GtkCombo with the
                        edit field marked as not editable.

        ddl_text = Pointer to an array of null terminated strings terminated
                  by a null, meaning the end of the string has a double null.
        ddl_selIndex
                = this has the initial selection index.
                  On termination this always has the users selection.
                  The index is zero based, and MAX(CARDINAL) signifies no
                  selection.

    ColorDropDownList
                    this control displays a selection of colors for the user to
                    choose from.

                  Win32 - combo box with drop down list attribute
                  Gtk - GtkOptionMenu

        cddl_colorData = pointer to an array of color values
        cddl_colorCount = number of items in the color array
        cddl_selIndex
                = this has the initial selection index.
                  On termination this always has the users selection.
                  The index is zero based, and MAX(CARDINAL) signifies no
                  selection.

    ComboBox
                  Win32 - ComboBox (simple or drop down)
                  Gtk - GtkCombo

        cb_text = Pointer to an array of null terminated strings terminated
                  by a null, meaning the end of the string has a double null.
        cb_max  = Maximum number of characters that edit portion will accept.
                  The cb_text buffer, if present, should be one character bigger
                  than the maximum allowable character count. This allows for
                  a null terminator.
        cb_selStr
                = Pointer to a string to hold the result as well as the
                  initial selection. The strings are not case sensitive.
                  On termination this string has the users selection.

    PushButton
                  Win32 - push button
                  Gtk - GtkButton

        buttonType = the type of button
                        CloseButton - the dialog is closed and data validation
                                          occurs.
                        CancelButton - the dialog is closed and data validation
                                          does not occur.
                        HelpButton - the Pressed notification is sent and data
                                          validation does not occur.
                        NotifyButton - the Pressed notification is sent and data
                                          validation occurs.
                        NotifyButtonNV - the Pressed notification is sent and data
                                          validation does not occur.

        returnValue = for CloseButton and CancelButton
                        the value to be returned by the dialog.

    UserData    = allows you to have some data attached to a dialog box
                  for access by the notify procedure

    Timer
                = the notify procedure will be called when the timerInterval
                  for this time has elapsed.

        id = A unique number to identify the timer. This number should be
             different for all possible timers in your program. This
             includes WinShell window timers.
        timerInterval = the timer interval in milliseconds. A value of
                        zero means the timer is not activated.

    IncDec
                = this control has up and down arrows to allow the user to
                  increment and decrement a numeric field.
                  Win32 - UpDown with autobuddy on an edit control
                  Gtk - GtkSpinButton

        incDec_Val = the numeric value.
        incDec_Min = the minimum value of the valid number range.
        incDec_Max = the maximum value of the valid number range.

    NumberEdit
                  Win32 - edit
                  Gtk - GtkEntry

        number_Val =  the initial and return value
        number_Min = the minimum value of the valid number range.
        number_Max = the maximum value of the valid number range.
        number_Hex = the number will be displayed in hexadecimal format
                     the user will be allowed to enter a number in hex
                     or decimal format
        number_msg = the string id number of the message displayed when
                     an invalid or out of range number is entered.
                     if 0, then a default message is displayed.
*)

    NotifyType   = (
                    Init, (* only dialogs *)
                    Destroy, (* only dialogs *)
                    ValueChanged, (* all that accept user input *)
                    LoseFocus, (* all *)
                    GainFocus, (* all *)
                    Validate, (* all that accept user input *)
                    SelectionChanged, (* all ListBoxes, DropDownLists, ComboBox *)
                    DoubleClicked, (* all ListBoxes *)
                    Pressed,  (* NotifyButton,
                                 CheckBox,
                                 RadioGroup *)
                    TimerElapsed, (* Timer *)
                    DialogModified, (* only dialogs *)
                    PageActivate,    (* only tabbed dialogs *)
                    PageDeactivate,  (* only tabbed dialogs *)
                    PageCancel,       (* only tabbed dialogs *)
                    ContextHelp(* all *)
                   );

(*
    ======= NotifyType =======

    Init
        The dialog is Initing and about to be displayed.

    Destroy
        The dialog is terminated. Do not access anything. Use this to
        free any memory or resources you may have allocated for the dialog.

    ValueChanged
        The text in a control has been changed.

    LoseFocus
        Input focus has been lost.

    GainFocus
        Input focus is now on the specified control.

    Validate
        The user is/has moved the input focus from one control to another.
        You can use this notification of validate the input of the current control.
        You can fail the validation and the input focus will be remain on
        the current control.

    SelectionChanged
        The selected item in a control has been changed.

    DoubleClicked
        An item in a control was double clicked.

    Pressed
        The button was pressed.

    TimerElapsed
        Self explanatory

    DialogModified
        Lets you know that the current dialog has been modified in some way.
        Very useful with tabbed dialogs. For tabbed dialogs each page will
        receive this message if something on that page has been altered.
        The dialog as a whole is considered altered if any single page has
        been altered.

    PageActivate
        For tabbed dialogs. Notifies you that the page is being activated.

    PageDeactivate
        For tabbed dialogs. Notifies you that the page is being deactivated.
        If you return ContinueDialog from this message the page will be
        allowed to deactivate. If you return DisallowPageDeactivate the
        page will remain the active page. For example you may want to
        validate some entry fields and disable switching/closing the current
        page until proper data has been entered.

    PageCancel
        For tabbed dialogs. The user has pressed the "cancel" button.
        All pages will receive this message when a tabbed dialog is being
        canceled. This will allow you to perform any necessary processing
        to satisfy "cancelling" the users modifications.

    ContextHelp
        Sent when context help was selected for the control but the control
        helpId value was 0.
*)

    PushButtonType = (
                      CloseButton,
                      CancelButton,
                      HelpButton,
                      NotifyButton,
                      NotifyButtonNV
                     );

    NotifyResult = (
                    ContinueDialog, (* means continue normally *)
                    TerminateDialog,(* the dialog is closed *)
                                    (* data fields will be validated *)
                                    (* this is considered a successfull *)
                                    (* dialog exit return *)
                    CancelDialog,(* the dialog is closed *)
                                 (* data fields will NOT be validated.
                                    this is considered a failed return.
                                 *)
                    DisallowPageDeactivate, (* use with tabbed dialogs *)
                    FailedValidation(*used with the Validate notify message*)
                   );

    NotifyProc  = PROCEDURE(
                            NotifyType, (* what happened *)
                            VAR INOUT CARDINAL
                                            (* on entry identifies the control
                                               associated with this notification.
                                               MAX(CARDINAL) signifies the
                                               entire dialog as the "control".

                                               See SetControlIdMode for a full
                                               description of how controls are
                                               identified.

                                               If you return TerminateDialog or
                                               CancelDialog,
                                               then assign the value you want the
                                               dialog call to return to this
                                               parameter. This only has
                                               meaning for modal dialogs.
                                            *)
                           ) : NotifyResult;

    DialogPositions     = (
                           NormalPosition, (* dialog resource position *)
                           CenterOnParent, (* center on parent window *)
                           CenterOnScreen  (* center on physical screen *)
                          );

    ColorValue  = WinShell.ColorValue;
    FontInfo    = WinShell.FontInfo;

    FontInfoPointer = POINTER TO FontInfo;

    StringData  = POINTER TO ARRAY [0..0] OF CHAR;

    TextAlignment = (AlignLeft, AlignCenter, AlignRight);

    ColumnInfo =
        RECORD
        width   : CARDINAL;
        align   : TextAlignment;
        header  : StringData;
        END;

    CONTROL     =
        RECORD
        id              : CARDINAL; (* the control identifier number *)
                                    (* For RadioGroup and Timer
                                       See the description of the control *)
                                    (* For DialogTitle and UserData this field
                                       has no meaning so just set it to zero *)
        helpId          : CARDINAL; (* context help id.
                                       this is the id number of a string resource entry.
                                       Use 0 for no help. In this case the Contexthelp
                                       notification is sent.

                                       On Win32 the standard dialog box context help
                                       mechanism is used. Your resource should have this
                                       dialog attribute.

                                       On Gtk no such mechanism exists so this module
                                       simulates it.

                                       For normal dialogs you should define a button
                                       with an id of 911 in the dialog. this module
                                       will treat that button as the initiator of the
                                       context help sequence. This button should NOT
                                       be listed in the control array. This module will
                                       replace the button label with a '?' icon.

                                       Tabbed dialogs simply look at the various controls
                                       in the dialog tabs and if any one of them has
                                       a non zero help id number then a context help
                                       button is added to the dialog. You do not need,
                                       and should not have, a 911 button defined
                                       in the dialog resource(s).

                                       As a convenience on these controls

                                       RadioGroup,
                                       LineEdit, MultiLineEdit, NumberEdit,
                                       ListBox, ColumnListBox
                                       ComboBox, DropDownList, ColorDropDownList

                                       the id number 1 less than the control(s) id
                                       is assumed to be a label/frame for the control,
                                       *unless* a specific control exists with that
                                       id number in the control array.
                                       This "label" will also get the help text
                                       of the control if the user asks for context
                                       help on this item.
                                       *)

        CASE ct : ControlType OF
        PushButton:
            buttonType          : PushButtonType;
            returnValue         : CARDINAL;
        |
        RadioGroup:
            r_first             : CARDINAL;
            r_last              : CARDINAL;
        |
        CheckBox:
            on                  : BOOLEAN;
        |
        LineEdit:
            le_text             : StringData;
            le_max              : CARDINAL;
        |
        MultiLineEdit:
            mle_text            : StringData;
            mle_max             : CARDINAL;
        |
        EditTextFile:
            etf_name            : StringData;
            etf_altered         : BOOLEAN;
        |
        StaticText:
            st_text             : StringData;
        |
        StaticTextAttrib:
            sta_text            : StringData;
            sta_fore            : ColorValue;
            sta_back            : ColorValue;
            sta_font            : FontInfoPointer;
        |
        ListBox:
            lb_text             : StringData;
            lb_selStr           : StringData;
            lb_selIndex         : CARDINAL;
        |
        ColumnListBox:
            clb_columns         : CARDINAL;
            clb_columnInfo      : POINTER TO ARRAY [0..0] OF ColumnInfo;
            clb_selStr          : StringData;
            clb_selIndex        : CARDINAL;
        |
        DropDownList:
            ddl_text            : StringData;
            ddl_selIndex        : CARDINAL;
        |
        ColorDropDownList:
            cddl_colorData      : POINTER TO ARRAY [0..0] OF ColorValue;
            cddl_colorCount     : CARDINAL;
            cddl_selIndex       : CARDINAL;
            cddl_palette        : WinShell.PaletteHandle;
        |
        ComboBox:
            cb_text             : StringData;
            cb_selStr           : StringData;
            cb_max              : CARDINAL;
        |
        IncDec:
            incDec_Val          : INTEGER;
            incDec_Min          : INTEGER;
            incDec_Max          : INTEGER;
        |
        NumberEdit:
            number_Val          : INTEGER;
            number_Min          : INTEGER;
            number_Max          : INTEGER;
            number_Msg          : CARDINAL;
            number_Hex          : BOOLEAN;
        |
        Timer:
            timerInterval       : CARDINAL;
        |
        DialogTitle:
            dlgTitle            : StringData;
        |
        UserData:
            userData            : ADDRESS;
        ELSE
        END;
    END;

    ControlsPointer     = POINTER TO ARRAY [0..0] OF CONTROL;
    PAGE =
        RECORD
        controls        : ControlsPointer;
        numControls     : CARDINAL;
        notify          : NotifyProc;
        name            : StringData;(*dialog resource*)
        title           : StringData;(*tab text, NIL to use the dialog resource
                                       title.
                                     *)
        END;

    DialogSizes = (NormalDialog, LargeDialog, ExtraLargeDialog);
    (* Win32
       this changes the size of the font used in a dialog. on Win32 this effectively
       makes the controls and thus the dialog larger. rememeber that dialog sizes are
       based on dialog units, which are based on the font used for a dialog.
       Large = +2 points, ExtraLarge = +4 points
       if the dialog resource used an 8pt font then, Large=10, ExtraLarge=12.

       GTK
       currently ignored.
    *)

    ControlIdModes = (ControlSubscript, ControlId);

VAR
    DialogSize  : DialogSizes;

PROCEDURE GetDialogParent() : Window;
(* a utility function to return the current foreground window, or
   the current modal dialog for use as a parent for a dialog.
   If the current foreground window is NIL then the value
   of WinShell.MainWindow is used.
*)

PROCEDURE SetControlIdMode(mode : ControlIdModes);
(*
  set how this module identifies individual controls.
  ControlIdSubscript
      Controls are identiifed by their control array subscript position, zero based.
      This is the original DlgShell mode and is the default mode at startup.
  ControlId
      Controls are identified by their id value.
      RadioGroups are identified by the id number, r_first.
      If you are using symbolic constants for your control ids then this
      mode is probably preferable.
*)

PROCEDURE CallDialog(parent : Window;
                     name : ARRAY OF CHAR;
                     VAR INOUT ctrls : ARRAY OF CONTROL;
                     notify : NotifyProc;
                     position : DialogPositions) : CARDINAL;
(*
   opens a modal dialog.
   The dialog is a named resource and the name is specified in the name parameter.

       Gtk - The dialog window should not have the visible attribute. This
             module will show the dialog once the controls and dialog are
             fully initialized.

   parent = the parent window of the dialog.
   ctrls = the controls in the dialog. This need not be all of the controls
           in the dialog resource but those controls that you need to
           perform some processing action with. For example a dialog may
           have many static text controls and if you have no need to change
           the text of these controls you need NOT specify them in the
           controls array.
           How controls are identified in the Notify procedure and in the API calls
           of this module depends on the control id mode.
           See SetControlIdMode.
   notify = the call back procedure. Pass NIL_NOTIFY if you have no
            need for a call back procedure. This is quite common.
            You generally only need a notification procedure if you need to
            validate data or perform other processing. You do not need
            a notification procedure to initialize the controls with
            information or to retrieve the information the user has entered.
            Mechanisms are in place to handle this without a call back
            notification procedure. However many times it is easier to fill
            a list box without generating the data structure to automatically
            fill the list and in this case you would "initialize" the
            list with NIL and then use API calls to add items to the list.
            Multi line edit controls are also probably easier to deal with
            using API calls rather than the control data structures. These
            are two examples of choices you will need to make in developing
            your dialog boxes.
   position = Allows you to specify where on the screen the dialog is displayed.
*)

PROCEDURE ModelessDialog(parent : Window;
                         name : ARRAY OF CHAR;
                         VAR INOUT ctrls : ARRAY OF CONTROL;
                         notify : NotifyProc;
                         position : DialogPositions) : CARDINAL;
(*
   opens a modeless dialog. The dialog is a named resource and the name
   is specified in the name parameter.
   The return value identifies the dialog for use in the various
   API calls provided in this module. Many times you may not need to save
   this value since while processing a notify message you are the current
   dialog, and if the modeless dialog terminates itself then you do not need
   the value to close the dialog.
   See CallDialog
*)

PROCEDURE CallTabbedDialog(parent : Window;
                           title : ARRAY OF CHAR;
                           VAR INOUT pages : ARRAY OF PAGE;
                           position : DialogPositions) : CARDINAL;
(*
   opens a modal "tabbed" dialog.
   Win32 - A property sheet is created.
   Gtk - a Window with a notebook widget is created.

   title = the dialog title. Null terminated
   pages = the list of "sub dialogs"/pages/tabs.

    controls = this is the same as the ARRAY OF CONTROL parameter
               in CallDialogByName.
    numControls = the number of controls in the controls array.
    notify = Same as the notify parameter in CallDialogByName
    name  = specifies the name of the dialog resource for this
            page of the tabbed dialog.
    title = the text of the tab. NIL if you want ot use the dialog resource
            title (the caption text of the source).

    Win32.
        Dialog resources should be marked with the PropertySheet and Child
        attributes.
    Gtk
        Dialog resources should be windows without the visible attribute.
        The container in the dialog must be named "mainbox". It does not
        matter what type of container it is. This module extracts the
        container from the dialog window and places it into the notebook
        page(s).

    You can use the same notify procedure for all pages in the dialog.
    If this is the case you may need to inquire about the current page.

   See CallDialog
*)

(*  --------------------------------------------------------------------*)
(*  --------------------------------------------------------------------*)
(*  --------------------------------------------------------------------*)

(*
   most of the following API procedures have two versions of the same
   procedure. One procedure explicitly takes the dialog number and the
   other assumes the current dialog.

   When you receive a notify message your dialog is the current dialog and you
   can use those API procedures assuming the current dialog.
   This is true for modal and modeless dialogs.

   To access a modeless dialog, outside of a notification you will need to use
   the dialog number APIs.

   For modal dialogs you NEVER know what the dialog number is unless you
   call GetDialogNumber() while you are the current dialog, and why bother
   doing such a thing.
*)

PROCEDURE ShowDialog(dlgNum : CARDINAL; yes : BOOLEAN);
(*
   If yes = TRUE then the dialog will be visible, otherwise the dialog
   will be invisible. This makes no sense for modal dialogs.
*)

PROCEDURE CloseDialog(dlgNum : CARDINAL; cancel : BOOLEAN);
(*
   close the dialog specified by dlgNum. Only use this with modeless dialogs
   remember that a dialog can terminate itself by simply returning
   TerminateDialog or CancelDialog from its notify procedure
*)

PROCEDURE GetDialogNumber() : CARDINAL;
(*   get the dialog number for the current dialog
*)

PROCEDURE GetActivePage() : CARDINAL;
(*
   For tabbed dialogs only
   get the currently active page number for the currently active dialog
   page numbers are zero based.
*)

PROCEDURE SetActivePage(page : CARDINAL);
(*
   For tabbed dialogs only
   set the active page of the current dialog
*)

PROCEDURE GetUserDataDlg(dlgNum : CARDINAL) : ADDRESS;
PROCEDURE GetUserData() : ADDRESS;
(*
   dlgNum specifies the dialog
   get the user data attached to the dialog.
   for tabbed dialogs operates on the current page only
*)

PROCEDURE PositionDialogDlg(dlgNum : CARDINAL; pos : DialogPositions);
PROCEDURE PositionDialog(pos : DialogPositions);
(*
   dlgNum specifies the dialog
   reposition the dialog on the screen using the pos parameter
*)

PROCEDURE GetDialogSizeDlg(dlgNum : CARDINAL; VAR OUT x, y : COORDINATE);
PROCEDURE GetDialogSize(VAR OUT x, y : COORDINATE);
(*
   dlgNum specifies the dialog
   get the size of the dialog in screen pixels
   x = width, y = height
*)

PROCEDURE GetDefaultButtonDlg(dlgNum : CARDINAL) : CARDINAL;
PROCEDURE GetDefaultButton() : CARDINAL;
(*
   dlgNum specifies the dialog
   get the button control that is the current default button
*)

PROCEDURE SetDefaultButtonDlg(dlgNum : CARDINAL; control : CARDINAL);
PROCEDURE SetDefaultButton(control : CARDINAL);
(*
   dlgNum specifies the dialog
   set the default button to the control.
*)

PROCEDURE SetPaintDlg(dlgNum : CARDINAL; control : CARDINAL; on : BOOLEAN);
PROCEDURE SetPaint(control : CARDINAL; on : BOOLEAN);
(*
   dlgNum specifies the dialog
   If on = TRUE then the control will repaint itself
   when necessary, otherwise it will not repaint itself until paint is
   turned on for this control. An example of using this would be loading
   a listbox control. It is senseless to have a list box repaint itself
   after each item you add until you have added all items to the list box.
*)

PROCEDURE SetEnableDlg(dlgNum : CARDINAL;
                       control : CARDINAL;
                       enabled : BOOLEAN);
PROCEDURE SetEnable(control : CARDINAL; enabled : BOOLEAN);
(*
   dlgNum specifies the dialog
   If enabled = TRUE the control will be enabled thus
   allowing the user to interact with the control, otherwise the control
   will be disabled or "grayed out"
   If this is used on a RadioGroup all radio buttons in the group will be
   disabled.
*)

PROCEDURE SetEnableRangeDlg(dlgNum : CARDINAL;
                            first, last : CARDINAL;
                            enabled : BOOLEAN);
PROCEDURE SetEnableRange(first, last : CARDINAL; enabled : BOOLEAN);
(*
  as SetEnable, except all controls from first..last are acted upon
*)

PROCEDURE SetEnableRadioDlg(dlgNum : CARDINAL;
                            control, item : CARDINAL;
                            enabled : BOOLEAN);
PROCEDURE SetEnableRadio(control, item : CARDINAL; enabled : BOOLEAN);
(*
   dlgNum specifies the dialog
   If enabled = TRUE the radio group i'th item identified
   by item will be enabled thus allowing the user to interact with the control,
   otherwise the item will be disabled or "grayed out"
*)

PROCEDURE SetVisibleDlg(dlgNum : CARDINAL;
                        control : CARDINAL;
                        visible : BOOLEAN);
PROCEDURE SetVisible(control : CARDINAL; visible : BOOLEAN);
(*
   dlgNum specifies the dialog
   If visible = TRUE the control will be visible thus
   allowing the user to interact with the control, otherwise the control
   will not be visible and thus not available to the user
   If this is used on a RadioGroup all radio buttons in the group will be
   invisible.
*)

PROCEDURE SetVisibleRadioDlg(dlgNum : CARDINAL;
                             control, item : CARDINAL;
                             visible : BOOLEAN);
PROCEDURE SetVisibleRadio(control, item : CARDINAL; visible : BOOLEAN);
(*
   dlgNum specifies the dialog
   If visible = TRUE the radio group i'th item identified by item will be visible thus
   allowing the user to interact with the control,
   otherwise the item will be invisible.
*)

PROCEDURE SetColorAndFontDlg(dlgNum : CARDINAL;
                      control : CARDINAL;
                      fore, back : ColorValue;
                      font : FontInfoPointer);
PROCEDURE SetColorAndFont(control : CARDINAL;
                          fore, back : ColorValue;
                          font : FontInfoPointer);
(*
   dlgNum specifies the dialog
   set the color and font of the control.
   font can be NIL if you do not want to set the font.

   currently can only be used with StaticTextAttrib controls
*)

PROCEDURE SetInputFocusToDlg(dlgNum : CARDINAL; control : CARDINAL);
PROCEDURE SetInputFocusTo(control : CARDINAL);
(*
   dlgNum specifies the dialog
   set the keyboard input focus to the specified control.
*)

PROCEDURE GetInputFocusControlDlg(dlgNum : CARDINAL) : CARDINAL;
PROCEDURE GetInputFocusControl() : CARDINAL;
(*
  return the control that currently has the input focus.
*)

PROCEDURE SetupStringMatchDlg(dlgNum : CARDINAL;
                              control : CARDINAL;
                              startPos : CARDINAL;
                              column : CARDINAL);
PROCEDURE SetupStringMatch(control : CARDINAL;
                           startPos : CARDINAL;
                           column : CARDINAL);
(*
   For ListBox, ColumnListBox.
   this sets up the ability of the list box to perform a full text
   search. The list box will automatically select the first item in the
   list that matches the text entered. When the spacebar is pressed the
   match string is reset and cleared.

   startPos = the string character position to start the comparison.
   column = if ColumnListBox, the column to compare.
*)

PROCEDURE ClearMatchBufferDlg(dlgNum : CARDINAL; control : CARDINAL);
PROCEDURE ClearMatchBuffer(control : CARDINAL);
(*
   clear the match buffer. This is the keystrokes that the user may have
   entered during ASCII matching. You could use this after reloading a list box
   with new data, so the match is not in the middle of some previous match search.
*)

PROCEDURE SetCheckBoxDlg(dlgNum : CARDINAL; control : CARDINAL; on : BOOLEAN);
PROCEDURE SetCheckBox(control : CARDINAL; on : BOOLEAN);
(*
   dlgNum specifies the dialog
   set the check box state of the check box control.
   on = TRUE = the check box will be "checked"
*)

PROCEDURE GetCheckBoxDlg(dlgNum : CARDINAL; control : CARDINAL) : BOOLEAN;
PROCEDURE GetCheckBox(control : CARDINAL) : BOOLEAN;
(*
   dlgNum specifies the dialog
   get the check box state of the check box control.
   returns TRUE when the check box is "checked"
*)

PROCEDURE SetRadioGroupDlg(dlgNum : CARDINAL;
                           control, item : CARDINAL);
PROCEDURE SetRadioGroup(control, item : CARDINAL);
(*
   dlgNum specifies the dialog
   set the selected/checked radio group item identified by item in the
   radio group control.
   The item will become the checked radio group item. If another item in the
   group is currently checked, it will be unchecked in favor of the new item
*)

PROCEDURE GetRadioGroupDlg(dlgNum : CARDINAL; control : CARDINAL) : CARDINAL;
PROCEDURE GetRadioGroup(control : CARDINAL) : CARDINAL;
(*
   dlgNum specifies the dialog
   get the checked item in the radio group.
*)

PROCEDURE SetRadioTextDlg(dlgNum : CARDINAL;
                          control, item : CARDINAL;
                          text : ARRAY OF CHAR);
PROCEDURE SetRadioText(control, item : CARDINAL; text : ARRAY OF CHAR);
(*
   dlgNum specifies the dialog
   set the text of a radio group item identified by item with the
   new text in the parameter text (null terminated).
*)

PROCEDURE GetRadioTextDlg(dlgNum : CARDINAL;
                          control, item : CARDINAL;
                          VAR OUT text : ARRAY OF CHAR);
PROCEDURE GetRadioText(control, item : CARDINAL; VAR OUT text : ARRAY OF CHAR);
(*
   dlgNum specifies the dialog
   get the text of a radio group item identified by item
   return the text in the text parameter
*)

PROCEDURE SetTimerIntervalDlg(dlgNum : CARDINAL;
                              control : CARDINAL;
                              time : CARDINAL);
PROCEDURE SetTimerInterval(control : CARDINAL; time : CARDINAL);
(*
   dlgNum specifies the dialog
   set the interval of the timer notifications in time. time is specified
   in milliseconds. The interval notifications are only approximate.
   If a value of zero is passed for the interval, the timer is disabled and
   you will receive no further timer notifications until the timer is again
   activated
*)

PROCEDURE SetTextDlg(dlgNum : CARDINAL;
                     control : CARDINAL;
                     text : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE SetText(control : CARDINAL; text : ARRAY OF CHAR) : BOOLEAN;
(*
   dlgNum specifies the dialog
   set the text of the control.
   the text parameter must be null terminated.
   the following controls have a special meaning for SetText
   RadioGroup use SetRadioText
   ListBox the effect is to select the list box item that matches the text parameter.
   ColumnListBox, the same effect as ListBox, the match is done to column 0.

   for TermButton, NotifyButton, CheckBox you can apply an accelerator
   in the label text. the underscore character '_' signifies that the
   following chracter should be an accelerator key for the button.

   returns TRUE is successful
*)

PROCEDURE GetTextDlg(dlgNum : CARDINAL;
                     control : CARDINAL;
                     VAR OUT text : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE GetText(control : CARDINAL; VAR OUT text : ARRAY OF CHAR) : BOOLEAN;
(*
   dlgNum specifies the dialog
   get the text of the control.
   RadioGroup use GetRadioText
   ListBox the effect is to fetch the text of the selected item in the list box.
   ColumnListBox as ListBox. Column 0 is used.
   returns TRUE is successful
*)

PROCEDURE SetNumericValueDlg(dlgNum : CARDINAL;
                             control : CARDINAL;
                             value : INTEGER) : BOOLEAN;
PROCEDURE SetNumericValue(control : CARDINAL; value : INTEGER) : BOOLEAN;
(* see the text of the control to the string representation of
   the passed numeric value.
   Any control that displays text can use this call.
   Also sets IncDec controls.
*)

PROCEDURE GetIncDecValueDlg(dlgNum : CARDINAL;
                            control : CARDINAL) : INTEGER;
PROCEDURE GetIncDecValue(control : CARDINAL) : INTEGER;
(*
   dlgNum specifies the dialog
   get the numeric value of the IncDec control.
   if the control is not an IncDec control MIN(INTEGER) is returned.
*)

PROCEDURE SetTextSelectionDlg(dlgNum : CARDINAL;
                              control : CARDINAL;
                              startPos, endPos : CARDINAL) : BOOLEAN;
PROCEDURE SetTextSelection(control : CARDINAL;
                           startPos, endPos : CARDINAL) : BOOLEAN;
(*
   dlgNum specifies the dialog
   set the text selection in a LineEdit, MultiLineEdit or ComboBox control.
   startPos and endPos are zero based and specify the starting and
   ending character position to the selection.
   use MAX(CARDINAL) for endPos to select all text from startPos
   to the end of the buffer.
*)

PROCEDURE ClearTextSelectionDlg(dlgNum : CARDINAL; control : CARDINAL);
PROCEDURE ClearTextSelection(control : CARDINAL);
(*
   dlgNum specifies the dialog
   clear any text section in a LineEdit, MultiLineEdit or ComboBox control.
*)

PROCEDURE GetItemCountDlg(dlgNum : CARDINAL; control : CARDINAL) : CARDINAL;
PROCEDURE GetItemCount(control : CARDINAL) : CARDINAL;
(*
   dlgNum specifies the dialog
   For all ListBox(s) and DropDownList(s) and ComboBox(s)
   returns the number of items in the list
   this result can be zero
*)

PROCEDURE GetSelectedDlg(dlgNum : CARDINAL; control : CARDINAL) : CARDINAL;
PROCEDURE GetSelected(control : CARDINAL) : CARDINAL;
(*
   dlgNum specifies the dialog
   For all ListBox(s), DropDownList(s) and ComboBox(s)
   returns the number of the selected item in the list.
   MAX(CARDINAL) signifies no selection.
*)

PROCEDURE SetSelectedDlg(dlgNum : CARDINAL;
                         control : CARDINAL;
                         sel : CARDINAL) : BOOLEAN;
PROCEDURE SetSelected(control : CARDINAL; sel : CARDINAL) : BOOLEAN;
(*
   dlgNum specifies the dialog
   For all ListBox(s), DropDownList(s), ComboBox(s)
   set the selected item in the control.
   MAX(CARDINAL) signifies no selection.
   returns TRUE if successful
*)

PROCEDURE AppendItemDlg(dlgNum : CARDINAL;
                        control : CARDINAL;
                        str : ARRAY OF CHAR) : INTEGER;
PROCEDURE AppendItem(control : CARDINAL; str : ARRAY OF CHAR) : INTEGER;
(*
   dlgNum specifies the dialog
   For ListBox, DropDownList and ComboBox
   add a new item at the end of the list of items in the control.
   returns the item number if successful, otherwise -1
   NOTE: If the control is an operating system sorted control then
   you do not know where in the list (ordinal position) the item exists
   after you add or delete another item. See SetItemData
*)

PROCEDURE ChangeItemDlg(dlgNum : CARDINAL;
                        control : CARDINAL;
                        item : CARDINAL;
                        str : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE ChangeItem(control : CARDINAL;
                     item : CARDINAL;
                     str : ARRAY OF CHAR) : BOOLEAN;
(*
   dlgNum specifies the dialog
   For ListBox, DropDownList and ComboBox
   change the text of a specific item in the list identified by item
   str must be null terminated
   returns TRUE if successful
*)

PROCEDURE RemoveItemDlg(dlgNum : CARDINAL; control : CARDINAL; item : CARDINAL);
PROCEDURE RemoveItem(control : CARDINAL; item : CARDINAL);
(*
   dlgNum specifies the dialog
   For ListBox, DropDownList, and ComboBox
   remove a specific item in the list identified by item
   items after this one in the list will of course be identified differently
   after this call
*)

PROCEDURE RemoveAllItemsDlg(dlgNum : CARDINAL; control : CARDINAL);
PROCEDURE RemoveAllItems(control : CARDINAL);
(*
   dlgNum specifies the dialog
   For all ListBox(s), DropDownList(s) and ComboBox(s)
   remove all items in the list leaving an empty list
*)

PROCEDURE SetItemDataDlg(dlgNum : CARDINAL;
                         control : CARDINAL;
                         item : CARDINAL;
                         data : DWORD);
PROCEDURE SetItemData(control : CARDINAL; item : CARDINAL; data : DWORD);
(*
   dlgNum specifies the dialog
   item identifies an already existing list item
   For all ListBox, ColumnListBox.
   You can attach a specific piece of data to each list item
   you might use this to identify a list item which you will need
   if the control is sorted
*)

PROCEDURE GetItemDataDlg(dlgNum : CARDINAL;
                         control : CARDINAL;
                         item : CARDINAL;
                         VAR OUT data : DWORD);
PROCEDURE GetItemData(control : CARDINAL; item : CARDINAL; VAR OUT data : DWORD);
(*
   dlgNum specifies the dialog
   item identifies an already existing list item
   For all ListBox, ColumnListBox
   get the user data associated with the list item
*)

PROCEDURE AppendItemColumnsDlg(dlgNum : CARDINAL;
                               control : CARDINAL;
                               strs : ARRAY OF StringData) : INTEGER;
PROCEDURE AppendItemColumns(control : CARDINAL;
                            strs : ARRAY OF StringData) : INTEGER;
(*
   dlgNum specifies the dialog
   For ColumnListBox
   add a new list item at the end of the list
   strs must have the same number of elements are there are columns in
   the control.

   returns the item number if successful, otherwise -1
*)

PROCEDURE SetColumnTextDlg(dlgNum : CARDINAL;
                           control : CARDINAL;
                           item : CARDINAL;
                           column : CARDINAL;
                           text : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE SetColumnText(control : CARDINAL;
                        item : CARDINAL;
                        column : CARDINAL;
                        text : ARRAY OF CHAR) : BOOLEAN;
(*
   For ColumnListBox
   dlgNum specifies the dialog
   set the text of the specified column of the control.
   the text parameter must be null terminated.
   item is the item in the list. (returned by AppendItem)
   column is the column number to set the text
   returns TRUE is successful
*)

PROCEDURE GetColumnWidthDlg(dlgNum : CARDINAL;
                            control : CARDINAL;
                            column : CARDINAL) : CARDINAL;
PROCEDURE GetColumnWidth(control : CARDINAL; column : CARDINAL) : CARDINAL;
(*
  For ColumnListBox
  return the current width, in pixels, of the specified column
*)

PROCEDURE GetOptimalColumnWidthDlg(dlgNum : CARDINAL;
                                   control : CARDINAL;
                                   column : CARDINAL) : CARDINAL;
PROCEDURE GetOptimalColumnWidth(control : CARDINAL;
                                column : CARDINAL) : CARDINAL;
(*
  For ColumnListBox
  return the optimal width, in pixels, of the specified column.
  the optimial width is usch that the column width is enough to display
  the longest string in the column. The column header, if any, is also
  considered in the computation.
*)

PROCEDURE SetColumnWidthDlg(dlgNum : CARDINAL;
                            control : CARDINAL;
                            column : CARDINAL;
                            width : CARDINAL);
PROCEDURE SetColumnWidth(control : CARDINAL;
                         column : CARDINAL;
                         width : CARDINAL);
(*
  For ColumnListBox
  set the width, in pixels, for the specified column
*)

PROCEDURE SetColumnWidthOptimalDlg(dlgNum : CARDINAL;
                                   control : CARDINAL;
                                   column : INTEGER);
PROCEDURE SetColumnWidthOptimal(control : CARDINAL; column : INTEGER);
(*
  For ColumnListBox
  set the column width to the optimal width for the specified column.
  the optimial width is such that the column width is enough to display
  the longest string in the column. The column header, if any, is also
  considered in the computation.

  if column < 0 then call columns in the list are adjusted.
*)

PROCEDURE MleGetCharCountDlg(dlgNum : CARDINAL; control : CARDINAL) : CARDINAL;
PROCEDURE MleGetCharCount(control : CARDINAL) : CARDINAL;
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   get the number of characters contained in the edit control. This includes
   any carriage returns, line feed pairs
   the lines in the edit control text are delimited by these characters
*)

PROCEDURE MleAppendDlg(dlgNum : CARDINAL;
                       control : CARDINAL;
                       text : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE MleAppend(control : CARDINAL; text : ARRAY OF CHAR) : BOOLEAN;
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   append text to the end of the text in the edit control
   text must be null terminated
   RETURNs TRUE is successful
*)

PROCEDURE MleAppendLineDlg(dlgNum : CARDINAL;
                           control : CARDINAL;
                           text : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE MleAppendLine(control : CARDINAL; text : ARRAY OF CHAR) : BOOLEAN;
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   like MlAppendDlg but also appends a line terminator in addition
   to the text
   text must be null terminated
   RETURNs TRUE is successful
*)

PROCEDURE MleGetLineCountDlg(dlgNum : CARDINAL; control : CARDINAL) : CARDINAL;
PROCEDURE MleGetLineCount(control : CARDINAL) : CARDINAL;
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   get the count of the number of lines of text in the edit control
*)

PROCEDURE MleGetLineLengthDlg(dlgNum : CARDINAL;
                              control : CARDINAL;
                              line : CARDINAL) : CARDINAL;
PROCEDURE MleGetLineLength(control : CARDINAL; line : CARDINAL) : CARDINAL;
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   get the length of the line identified by line.
   line is 1 based.
   a line can have a zero length
*)

PROCEDURE MleGetLineDlg(dlgNum : CARDINAL;
                        control : CARDINAL;
                        line : CARDINAL;
                        VAR OUT text : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE MleGetLine(control : CARDINAL;
                     line : CARDINAL;
                     VAR OUT text : ARRAY OF CHAR) : BOOLEAN;
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   fetch the text of the line identified by line into text
   line is 1 based.
   returns TRUE if successful
*)

PROCEDURE MleRemoveLineDlg(dlgNum : CARDINAL;
                           control : CARDINAL;
                           line : CARDINAL);
PROCEDURE MleRemoveLine(control : CARDINAL; line : CARDINAL);
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   delete all of the text and line terminator of the line
   identified by line.
   line is 1 based.
*)

PROCEDURE MleAppendToLineDlg(dlgNum : CARDINAL;
                             control : CARDINAL;
                             line : CARDINAL;
                             text : ARRAY OF CHAR);
PROCEDURE MleAppendToLine(control : CARDINAL;
                          line : CARDINAL;
                          text : ARRAY OF CHAR);
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   append the text in text to the end of the line identified by line.
   line is 1 based.
*)

PROCEDURE MlePositionToBottomDlg(dlgNum : CARDINAL; control : CARDINAL);
PROCEDURE MlePositionToBottom(control : CARDINAL);
(*
   dlgNum specifies the dialog
   For MultiLineEdit controls
   position the text caret location to be visible at the bottom of the
   edit control.
*)

PROCEDURE SaveTextFileDlg(dlgNum : CARDINAL; control : CARDINAL);
PROCEDURE SaveTextFile(control : CARDINAL);
(*
  For ExitTextFile
  Save the text file to disk
*)

PROCEDURE NIL_NOTIFY(n : NotifyType; VAR INOUT item : CARDINAL) : NotifyResult;
(*   dummy notify procedure *)

(*
   The following two procedures are useful for maintaining lists of items
   for DropDownLists, combo boxes and list boxes.
   You use a special character to separate
   the list items from each other and before assigning the string to
   the dialog control call ConvertToNulls to change the special character
   to a null character. As long as the string parameter passed is already
   null terminated you then have a proper "list" to assigning to list boxes
   a combo boxes for automatic initialization by DlgShell
   ConvertFromNulls can revert your string back its previous state if
   this is necessary.
*)

PROCEDURE ConvertToNulls(ch : CHAR; VAR INOUT str : ARRAY OF CHAR);

PROCEDURE ConvertFromNulls(ch : CHAR; VAR INOUT str : ARRAY OF CHAR);

PROCEDURE GetNthString(list : ARRAY OF CHAR;
                       listSep : CHAR;
                       VAR OUT str : ARRAY OF CHAR;
                       n : CARDINAL);
(*
   use this procedure to fetch the i'th string from the list
   list = the list of items
   sep = the character that separates the list items
   str = the returned string. Will be "" if not i'th item does not exist
   n = the item to fetch
   items are numbered starting at zero
*)

PROCEDURE GetNthFromList(list : ARRAY OF CHAR;
                         listSep : CHAR;
                         str : ARRAY OF CHAR;
                         VAR OUT n : CARDINAL);
(*
   use this procedure to find the number position of the item in the list
   items are numbered starting at zero
   list = the list of items
   sep = the character that separates the list items
   str = the string to match in list. The match is not case sensitive
   n = the returned item number. MAX(CARDINAL) = not found
*)

PROCEDURE GetDlgWindowDlg(dlgNum : CARDINAL) : ADDRESS;
PROCEDURE GetDlgWindow() : ADDRESS;
(*
   dlgNum specifies the dialog
   returns the dialog box operating system specific window handle
*)

END DlgShell.
(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1992-2002                             *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)

(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1992-2002                             *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)
DEFINITION MODULE WinShell;
(*
  This module provides an encapsulation of the underlying operating system
  interface for handling windows and messages.
  no operating system types, constants or procedures are exported from
  this module. therefore any code that uses this module will not change
  when ported to another system. Only the implementation of this module
  need be ported.
  This module does not try to create a "high level" interface.
  It mostly maps itself directly to the underlying system. However there
  is some functionality not typically provided by a single system API call
  This module does not attempt to map the entire underlying system.
  Features are added to this module on an as needed basis. In other words,
  why write the code if it has no immediate use.
  The messaging structure is very clean via the use of a variant record.
*)

(* about resources.
   See also, SetResourceFile API call in this module.

   Resource names are not case sensitive.

   Win32 - normal Windows resources are used.

           An accelerator table resource needs to have the same name
           as the menu resource it is associated with.

           Additional "bitmap" resource types are supported in addition to the
           Windows native bitmap format. !!! not yet implemented !!!
           JPEG, PNG and TIFF formats are supported.
           When loading a bitmap from the resource file this module first looks
           for a native bitmap resource of the given name, and if this is not found
           then looks for JPEG, PNG and TIFF resources in that order.
           JPEG resources are identified by the "JPEG" resource type.
           PNG resources are identified by the "PNG" resource type.
           TIFF resources are identified by the "TIFF" resource type.

   Gtk - The concept of resources does not exist in the Unix toolkit
         world, and Gtk is no exception.
         We use a combination of various files to get the same effect.

       Dialogs - Glade XML files.
           For further information consult DlgShell.

       ---------------------------------------------------------------
       Menu's and accelerators. Glade XML files.
           Create a window in glade, mark the window as NOT visible.
           The name of the window is the name of your menu resource.
           Put your menubar into this window. The menu bar name must be named
           "menubar". The accelerators you define in the menubar will be used.

           For accelerators not tied to a menu item you create a menu in
           your menubar named "hiddenaccel" and put your accelerators
           on menu items within this menu. This menu will be hidden by
           this module.

           Popup menus are glade popup menu resources.

       ---------------------------------------------------------------
       String table - Proprietary format used by this module.
           This file format is the one that the Win32 resource editor uses
           to export/import string tables to stand alone files.

           Format.
           IdNumber = "...

           IdNumber = the string id number
           '=' the equal character.
           '"' the double quote character.
           The string is all data after the '"' character to the end of
           the line.

           Carrage return, line feed, tab, and backspace characters are
               in "escape" notation. These characters are converted to binary
               format when the string is loaded.
           \r = Carriage return = CHR(13). ignored on Unix systems.
           \n = line feed (new line) = CHR(10)
           \t = tab = CHR(9)
           \b = backspace = CHR(8)
           \\ = \ backslash character.

        ---------------------------------------------------------------
        Bitmaps - Proprietary format used by this module.
            This is a text file that describes the resource name
            and the associated bitmap file to load. Therefore each
            bitmap resource is an individual file. The bitmap file names
            can be relative file names that are relative to the bitmap
            resource file.

            Format
            ResourceName = FileName
            where ResoruceName and FileName must be enclosed in double quote
            characters.
            Only one resource description entry per line.

            Example
            "Splash" = "pixmaps/splash.png"

            Assuming the resource file is in directory "/opt/MyCompany",
            then the full path of the example bitmap file is
            "/opt/MyCompany/pixmaps/splash.png"

            Bitmap resource files can be any graphics file format supported
            by the Gdk Pixbuf library.
            This includes
                BMP, JPEG, PNG, TIFF.
                XPM, GIF, ICO.
*)

(* about threads
   Win32 - you may use the GUI features in a fully multi threaded manner.

   Gtk - Only one thread, the main thread, may use the GUI features.

   In all systems you can have any thread safely use the LoadString API.

   In all systems you can have a background thread send or post a message
   to a window. For send, the background thread will wait until the message is
   received and processed by the UI thread before returning from the
   send message call.
*)

<*/NOPACK*>
%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

FROM SYSTEM IMPORT
    ADDRESS;

TYPE
    Window;
    Drawable;
    DrawContext;

    WindowTypes         = (TopLevel, MdiChild, MdiFrame);

    MdiTabPosition      = (MdiTabTop, MdiTabBottom, MdiTabLeft, MdiTabRight);

    WinShellMsg         = (
                           WSM_CREATE,
                           WSM_GAINFOCUS,
                           WSM_LOSEFOCUS,
                           WSM_ACTIVATEAPP,
                           WSM_DEACTIVATEAPP,
                           WSM_MOUSE,
                           WSM_KEY,
                           WSM_CLOSE,
                           WSM_PAINT,
                           WSM_SIZE,
                           WSM_POSITIONCHANGED,
                           WSM_SCROLL,
                           WSM_MENU,
                           WSM_MENUSELECT,
                           WSM_MENUSTART,
                           WSM_MENUEND,
                           WSM_MDIACTIVE,
                           WSM_TIMER,
                           WSM_USER
                          );

(******************** Message Definitions ************************************
    WSM_CREATE          this window is being created

    WSM_GAINFOCUS       this window has gained the input focus

    WSM_LOSEFOCUS       this window has lost the input focus

    WSM_ACTIVATEAPP     the application is now the foreground application the
                        user is using.

    WSM_DEACTIVATEAPP   the application is no longer the foreground application the
                        user is using.

    WSM_MDIACTIVE     this MdiChild window is the foreground MdiChild window in
                      the childs parent frame window.

    WSM_MOUSE           this window received a mouse event
        m_pos = Window Coordinates of click
        m_button = Which button the event is for
        m_event = the type of event
        m_state = the state of various other keys at the time of the mouse event
        m_wheel = the mouse wheel movement. positive is forward towards the front
                of the mouse. This value is scroll increments.
                1 = one scroll increment

    WSM_KEY             this window received keyboard input
        k_ch = character keystroke if not special
        k_state = various extended keys when not a normal ASCII character
        k_special = the various special keys. If NOTSPECIAL then
                  ch contains the ANSI character
        k_count = The key repeat count. Normally 1.

    WSM_CLOSE           this window hasbeen or may be closed
        closeMode =  the close "mode"
                CM_REQUEST = you are being asked if you will close the window
                    RETURN OkayToClose
                        you will then later get a TWM_CLOSE with a mode of
                        CM_DICTATE
                    RETURN NotOkayToClose
                        at which point no further close action will take place
                        and the window will remain open.
                CM_DICTATE = you *ARE* closing
                        the return value is ignored in this case

    WSM_PAINT   a region of this window needs to be repainted.
                the text caret, if any, is automatically hidden and
                restored around this message.
        paintRect = rectangle of region that needs to be painted
        paintDraw = a drawable available to use for painting

    WSM_SIZE            the window *HAS* been resized
        sizeType = The type of sizing operation
        width = the new width
        height = the new height

    WSM_POSITIONCHANGED         the window has been moved on screen
        windowPos       = The window position

    WSM_SCROLL          the window has been scrolled
        dir = indicates direction to scroll
        class = the amount to scroll
        absOffs = absolute scroll position within the scroll range

    WSM_STARTMENU       the user has opened a menu
        you should use this to check/uncheck, activate/disable any menu items
        as necessary here. You do not know which menu was opened so you
        should just do all menus in the menu hierarchy of the window.

    WSM_MENU            a menu item has been selected
        menuId = the menu resource id number for the menu item

    WSM_MENUSELECT      a menu is highlighted
        menuId = the menu resource id number for the menu item
                 Typically this is used if a program has a status line
                 and you want to display simple single line help
                 descriptions of each menu item.

    WSM_ENDMENU         the user has exited the menu system
        If you were using MENUSELECT to display quick help you can use this
        to restore the status line to its proper state.

    WSM_TIMER           the specified timer duration has elapsed
        timerId = identifies which timer has elapsed

    WSM_USER
        userId = user defined value to identify the user message type
        userData =  if not used should be NIL
                    otherwise generally used to
                    pass a pointer to some data

*****************************************************************************)

    ResponseType        = (
                           USER_HANDLE, (* you handled the message *)
                           DEFAULT_HANDLE, (* use default message processing *)
                           OkayToClose,(* see WSM_CLOSE *)
                           NotOkayToClose(* see WSM_CLOSE *)
                          );

    WinAttr             = (
                           WA_SYSMENU, (* has system menu in caption *)
                           WA_MINIMIZEBOX,(* has minimize button in caption *)
                           WA_MAXIMIZEBOX,(* has maximize button in caption *)
                           WA_TITLE,(* has a caption title bar *)
                           WA_RESIZABLE,(* can be sized by the user *)
                           WA_HSCROLL,(* has/can have horizontal scroll bar *)
                           WA_VSCROLL,(* has/can have vertical scroll bar *)
                           WA_HSCROLLTRACK,(* receive scroll messages while
                                               the user is dragging the
                                               scroll bar thumb *)
                           WA_VSCROLLTRACK,(* receive scroll messages while
                                               the user is dragging the
                                               scroll bar thumb *)
                           WA_STATUSLINE,(* has a status line *)
                                         (* only frame windows can have this *)
                                         (* in the current implementation *)
                           WA_VISIBLE(* window is visible *)
                          );
    WinAttrSet          = SET OF WinAttr;

    CloseModes          = (CM_REQUEST, CM_DICTATE);(* see WSM_CLOSE *)

    ScrollDirection     = (DIR_UP, DIR_DOWN, DIR_LEFT, DIR_RIGHT); (* obvious *)

    ScrollClass         = (
                           SCROLL_LINE,(* scroll by lines *)
                           SCROLL_PAGE,(* scroll by pages *)
                           SCROLL_EXTREME,(* position to the extreme edges of the
                                      scroll range. ScrollDirection
                                      determines which edge is scrolled to *)
                           SCROLL_ABSOLUTE(* set to absolute scroll position within
                                      the scroll range *)
                          );

    SizeType    = (
                   SizeNormal,(* window no minimize or maximized *)
                   SizeMinimized,(* window is minimized *)
                   SizeMaximized(* window is maximized *)
                  );

    SpecialKeys = (
                   KEY_NOTSPECIAL,(* normal character *)
                   KEY_PAGEUP, KEY_PAGEDOWN, KEY_INSERT, KEY_DELETE, KEY_HOME, KEY_END,
                   KEY_MENU(*not all keyboards have this*),
                   KEY_RIGHTARROW, KEY_LEFTARROW, KEY_UPARROW, KEY_DOWNARROW,
                   KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6,
                   KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11, KEY_F12
                  );

    KeyStateType = (
                    KS_CONTROL,
                    KS_ALT,
                    KS_SHIFT
                   );
    KeyStateSet  = SET OF KeyStateType;

    SystemColors = (
                    SC_WINDOW_BACKGROUND,
                    SC_TEXT,
                    SC_HIGHLIGHT,
                    SC_HIGHLIGHTTEXT,
                    SC_GRAYTEXT,
                    SC_BUTTON_FACE
                   );

CONST
    (* some usefull predefined window attributes *)

    NormalWindow        = WinAttrSet{WA_VISIBLE,
                                     WA_TITLE,
                                     WA_RESIZABLE,
                                     WA_SYSMENU,
                                     WA_MINIMIZEBOX,
                                     WA_MAXIMIZEBOX
                                    };
    NormalMdiChildWindow= NormalWindow;(* because a MdiChild can be converted to TopLevel *)

    AddVScrollBar       = WinAttrSet{WA_VSCROLL};
    AddHScrollBar       = WinAttrSet{WA_HSCROLL};
    AddScrollBars       = AddVScrollBar + AddHScrollBar;
    AddScrollTrack      = WinAttrSet{WA_HSCROLLTRACK, WA_VSCROLLTRACK};
    AddStatusLine       = WinAttrSet{WA_STATUSLINE};

TYPE
    MouseButton         = (LeftButton, MiddleButton, RightButton, NoButton);
    MouseEventType      = (ButtonDown, ButtonUp,
                           ButtonDouble, ButtonTriple,
                           MouseMove, MouseWheel);
                           (* ButtonDouble and ButtonTriple are "software"
                              mouse events. You always receive the hardware
                              mouse Down and Up events.
                              You always receive an Up for every Down.
                              You will never receive an Up without a preceeding
                              Down.
                              ButtonTriple may not be portable.
                              MouseWheel may not be portable.
                            *)

    MouseStateType      = (
                           MS_SHIFT,(* shift key was down *)
                           MS_CONTROL,(* control key was down *)
                           MS_ALT,(*alt key was down*)
                           MS_LEFTBUTTON,(* is pressed *)
                           MS_RIGHTBUTTON,(* is pressed *)
                           MS_MIDDLEBUTTON(* is pressed *)
                          );
    MouseStateSet       = SET OF MouseStateType;

    COORDINATE  = INTEGER;

    wsPOINT =
        RECORD
        x        : COORDINATE;
        y        : COORDINATE;
        END;

    wsRECT =
        RECORD
        x1, y1   : COORDINATE;(*upper left*)
        x2, y2   : COORDINATE;(*lower right*)
        END;

    ColorValue          = CARDINAL32;(*00BBGGRRh*)(*red in LSB*)

    ClipboardFormat     = (CLIPBOARD_ASCII, CLIPBOARD_UNICODE);

    HelpCommand         = (
                           HelpTopic,(* open help to a specific topic *)
                           HelpContents(*Win32 only, open help in table of contents *)
                          );

    MenuHandle;(* magic cookie *)
    BitmapHandle;(* magic cookie *)
    PaletteHandle;(* magic cookie *)
    FontHandle;(* magic cookie *)
    PrintDriverInfo;(* magic cookie *)

    FontWeights         = (FwLight, FwNormal, FwDemiBold, FwBold, FwHeavy);

    CharacterSets       = (
                           LATIN1_CHARSET,(*ansi, iso*)
                           LATIN2_CHARSET,(*east europe*)
                           SYMBOL_CHARSET,
                           ASCII_CHARSET,
                           DEFAULT_CHARSET
                          );
    FontInfo            =
        RECORD
        height          : INTEGER;(* positive = points,
                                     negative = pixels*)
        italic          : BOOLEAN;
        fixedPitch      : BOOLEAN;(* if TRUE then only fixed pitch *)
                                  (* if FALSE then any pitch *)
        weight          : FontWeights;
        charSet         : CharacterSets;
        name            : ARRAY [0..63] OF CHAR;
        END;

    TextMetrics         =
        RECORD
        ascent          : CARDINAL;(*maximum ascent*)
        descent         : CARDINAL;(*maximum descent*)
        height          : CARDINAL;(*the maximum height of the font*)
                                   (*this is max ascent + max decent *)
        aveCharWidth    : CARDINAL;(*average character width.
                                     for fixed pitch fonts this is the
                                     character width. *)
        externalLeading : CARDINAL;(*extra spacing not in font,
                                     but specified by the font designer *)
        END;

    TextDrawOrigin      = (
                           OriginBaseLeft,
                           OriginTopLeft,
                           OriginBaseCenter,
                           OriginTopCenter
                          );
                          (*
                             BaseLeft = the x origin is the left side of the
                                            first character.
                                        the y origin is on the font
                                            baseline.
                             TopLeft = the x origin is the left side of the
                                            first character.
                                       the y origin is at the top of the
                                       font. The is basically above the
                                       baseline by the ascender amount of
                                       the string.
                             BaseCenter = the x origin is the middle of
                                          the string in device pixels.
                                        the y origin is on the font
                                            baseline.
                             TopCenter = the x origin is the middle of
                                          the string in device pixels.
                                       the y origin is at the top of the
                                       font. The is basically above the
                                       baseline by the ascender amount of
                                       the string.
                          *)

    JoinStyles       = (JoinBevel, JoinMiter, JoinRound);
    EndCaps          = (
                        EndCapFlat,
                        EndCapSquare,(* the line entends beyond the line end
                                        points by have the line width.*)
                        EndCapRound(* the line will extend beyond the line
                                      end points to draw the rounded end. *)
                       );

    DrawContextValues   =
        RECORD
        foreground              : ColorValue;
        background              : ColorValue;
        font                    : FontHandle;
        textExtraSpacing        : INTEGER;
        textOrigin              : TextDrawOrigin;
        lineWidth               : CARDINAL;
        joinStyle               : JoinStyles;
        endCap                  : EndCaps;
        END;

CONST
    DrawContextDefaults =
                DrawContextValues{0,(*foreground (black) *)
                                  0FFFFFFh,(*background (white) *)
                                  NIL,(*font*)
                                  0,(*extra spacing*)
                                  OriginTopLeft,
                                  1,(*line width*)
                                  JoinBevel,
                                  EndCapFlat
                                 };

TYPE
    DrawTextOptions     = (DT_CLIPPED, DT_OPAQUE);
    DrawTextOptionSet   = SET OF DrawTextOptions;

CONST
    DrawTextOpaque      = DrawTextOptionSet{DT_OPAQUE};
    DrawTextClipped     = DrawTextOptionSet{DT_CLIPPED};

TYPE
    CursorTypes         = (
                           LeftArrowCursor,(* arrow pointing left, default *)
                           RightArrowCursor,(* arrow pointing right *)
                           WaitCursor,(* an hourglass or similar *)
                           TextCursor,(* standard text cursor *)
                           CrossHairCursor(*just like it sounds*)
                          );

    CaretTypes          = ((* text cursor shape *)
                           CtVerticalBar,
                           CtHorizontalBar,
                           CtHalfBlock,
                           CtFullBlock
                          );


    DisplayModes        = (
                           DisplayNormal, (* will activate window *)
                                          (* make it visible *)
                                          (* reverses minimized or maximized *)
                           DisplayVisible,(* makes window visible *)
                                          (* will not activate window *)
                           DisplayHidden,(* hides window *)
                                         (* active window changes *)
                           DisplayMinimized,(* minimizes window *)
                                            (* does not change active window *)
                           DisplayMaximized(* will activate window *)
                                           (* maximizes window *)
                          ) BIG;

    Beeps               = (NormalBeep, QuestionBeep, WarningBeep, ErrorBeep);

    ScrollRange         = INTEGER32;

    WindowDisplayInfo =
        RECORD
        x       : COORDINATE;(* upper left corner *)
        y       : COORDINATE;(* upper left corner *)
        width   : COORDINATE;
        height  : COORDINATE;
        mode    : DisplayModes;
        END;

    ScreenMetrics =
        RECORD
        xSize   : CARDINAL;(* width is pixels *)
        ySize   : CARDINAL;(* height in pixels *)
        colors  : CARDINAL;(* number of simultaneous color supported *)
        END;

    MessageRec          = RECORD
        CASE msg : WinShellMsg OF
        WSM_GAINFOCUS, WSM_LOSEFOCUS,
        WSM_MENUSTART, WSM_MENUEND,
        WSM_ACTIVATEAPP, WSM_DEACTIVATEAPP,
        WSM_MDIACTIVE:
            (* no data fields for these *)
        |
        WSM_CREATE:
            createParam : ADDRESS;
        |
        WSM_MOUSE:
            m_pos       : wsPOINT;
            m_wheel     : INTEGER;
            m_button    : MouseButton;
            m_event     : MouseEventType;
            m_state     : MouseStateSet;
        |
        WSM_KEY:
            k_count     : CARDINAL;
            k_special   : SpecialKeys;
            k_state     : KeyStateSet;
            k_ch        : CHAR;
        |
        WSM_CLOSE:
            closeMode   : CloseModes;
        |
        WSM_PAINT:
            paintRect   : wsRECT;
            paintDraw   : Drawable;
        |
        WSM_SIZE:
            sizeType    : SizeType;
            width       : COORDINATE;
            height      : COORDINATE;
        |
        WSM_POSITIONCHANGED:
            windowPos   : wsPOINT;
        |
        WSM_SCROLL:
            scrollDir   : ScrollDirection;
            scrollClass : ScrollClass;
            scrollPos   : ScrollRange;
        |
        WSM_MENUSELECT,
        WSM_MENU:
            menuId      : CARDINAL;
        |
        WSM_TIMER:
            timerId     : CARDINAL;
        |
        WSM_USER:
            userId      : CARDINAL;
            userData    : ADDRESS;
        END;
    END;

CONST
    TOOLBAR_SEPARATOR                   = MAX(CARDINAL);

TYPE
    StdToolbarBitmaps =
    ((* standard built-in bitmaps for toolbars *)
     TB_BMP_CUT,
     TB_BMP_COPY,
     TB_BMP_PASTE,
     TB_BMP_UNDO,
     TB_BMP_REDO,
     TB_BMP_DELETE,
     TB_BMP_FILENEW,
     TB_BMP_FILEOPEN,
     TB_BMP_FILESAVE,
     TB_BMP_PROPERTIES,
     TB_BMP_HELP,
     TB_BMP_FIND,
     TB_BMP_REPLACE,
     TB_BMP_PRINT
    );

    ToolbarButtonTypes  = (TbPushButton, TbToggleButton);

    ToolbarButtonInfo =
        RECORD
        image           : ADDRESS;(* non user field, for internal WinShell use.
                                     Win32 -> bitmap,  GTK -> GtkPixmap.
                                     should be inited to NIL
                                  *)
        actionId        : CARDINAL;(* menu id number *)
        textId          : CARDINAL;(* button label string resource id number *)
        helpId          : CARDINAL;(* tooltip string resource id number *)
        type            : ToolbarButtonTypes;
        CASE stdButton : BOOLEAN OF
        FALSE:
            bmpResName  : ARRAY [0..31] OF CHAR;(*bitmap resource name *)
        |
        TRUE:
            stdName     : StdToolbarBitmaps;
        END;
        END;

    WindowProcedure     = PROCEDURE(Window, MessageRec) : ResponseType;

    WindowNotification = (
                          WindowMinimized,
                          WindowMaximized,
                          WindowSized,
                          WindowMoved,
                          WindowClosed
                         );

    WindowNotifyProcedure = PROCEDURE((*w : *)Window,
                                      (*notify :*)WindowNotification,
                                      (*data : *)ADDRESS);
    (* this is the format of a window notification procedure.
       w = the window in question
       notify = the action that occured
       data = user data.
    *)

    HostSystem  = (
                   Windows,(* Windows95, Windows98, Windows ME,
                              Win32s, WindowsCE *)
                   WindowsNT,(* Windows NT/2000/XP *)
                   GTK
                  );

VAR
    MainWindow          : Window;
    (* this value is initialied with the first TopLevel or MdiFrame
       window created. You may assign your own value to this.
       This value is used by DlgShell.GetDialogParent().
    *)

    StartupDisplayMode  : DisplayModes;(* the display mode the user
                                          requested the application be started
                                          in *)

    Host                : HostSystem;
    HostMajorVersion    : CARDINAL;(* Win32s = 3
                                      Windows95, Windows98 = 4
                                      Windows ME = ? 4
                                      WindowsCE = ?
                                      WindowsNT = 3, 4
                                      Windows2000/XP = 5
                                      *)
    HostMinorVersion    : CARDINAL;(* Win32s = 10 for 3.10
                                      Windows95 = 0 for 4.0
                                      Windows98 = 10 for 4.10
                                      WindowsME = ?
                                      WindowsCE = ?
                                      WindowsNT = 50 for 3.50
                                                  51 for 3.51
                                                  00 for 4.00
                                      Windows2000 = 00
                                      WindowsXP =
                                      *)

    UnicodeSupported    : BOOLEAN;

    ScreenInfo          : ScreenMetrics;

PROCEDURE SetResourceFile(name : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE GetResourceFile(VAR OUT name : ARRAY OF CHAR);
(* for Win32 name = "" means the resources are in the executable,
  otherwise it is some DLL and a .dll extension is provided if not
  supplied.

  for Gtk it specifies the base path and name for various resource files.
  the various resource files are identified by file extension.
  .xml file contains menus, dialogs and accelerators
  .str file contains a string table
  .img file contains bitmaps
*)

TYPE
    IdleResults         = (ContinueIdle, SuspendIdle, TerminateIdle);
    IdleProcType        = PROCEDURE((*userdata*)ADDRESS,
                                    (*count*)CARDINAL) : IdleResults;
                        (* count is the number of times the idle procedure.
                           has been called in the current idle cycle.
                           userdata is arbitrary user data
                           *)

PROCEDURE AddIdleProcedure(idle : IdleProcType; data : ADDRESS) : CARDINAL;
(* add an idle procedure to the system.
   the return value identifies the idle procedure for removal.
   a return value of zero indicates failure.
   the idle procedure will be called when no messages are pending for the
   input thread.
   the idle procedure will be repeatedly called while no messages are being
   received and the idle procedure returns ContinueIdle.
   if it returns SuspendIdle then it will not be called until the next idle
   cycle. an idle cycle is the idle period between receiving messages.
   if it returns TerminateIdle the idle handler is removed from the system.
*)

PROCEDURE RemoveIdleProcedure(id : CARDINAL);
(* remove a previously installed idle procedure *)

PROCEDURE DispatchMessages() : CARDINAL;
(* any thread that has windows must have a message dispatch loop.
   a dispatch loop just loops forever sending messages to the appropriate
   window in the thread. A window is attached to a specific thread. this
   thread is the thread the window was created in. A thread will only
   receive messages for windows created within itself.
   this is why each thread that creates windows needs a dispatch procedure
   call.
   message boxes and modal dialogs do not count as "windows" for this
   definition since they create their own temporary message dispatch loop.
   this procedure contains a message dispatch loop. This procedure never
   returns until the message loop is terminated.
   A message dispatch loop is terminated with a call to
   TerminateDispatchMessages. The return value from this procedure is
   the value passed to TerminateDispatchMessages.

   you can create your own temporary dispatch loops in a thread that
   already has a dispatch loop. Remember that TerminateDispatchMessages
   only terminates the most recent call to DispatchMessages.
*)

PROCEDURE CheckMessages() : BOOLEAN;
(* many times you perform tasks that will take a reasonable amount of time
   so that the user interface will not become unresponsive you can call
   this procedure to dispatch any messages that are already sitting
   in the message queue. If no messages are available this procedure
   returns.
   If this function returns TRUE it means that the message loop has received
   a "quit" message and the dispatch loop will be terminated.
*)

PROCEDURE WaitForAMessage();
(* this procedure does not return until there is at least one message
   waiting in the current threads message queue.
*)

PROCEDURE TerminateDispatchMessages(code : CARDINAL);
(* this procedure terminates a previous call to DispatchMessages
   code = an arbitrary value that DispatchMessages will return as
   its function result. You can use it as a result code
*)

PROCEDURE CreateWindow(windowType : WindowTypes;
                       parent : Window;
                       name : ARRAY OF CHAR;
                       menu : ARRAY OF CHAR;
                       icon : ARRAY OF CHAR;
                       wndProc : WindowProcedure;
                       attribs : WinAttrSet;
                       x, y : COORDINATE;
                       width, height : COORDINATE;
                       createParam : ADDRESS) : Window;
(* create a new window
   parent = the parent window of this window. Can be NIL.
            An owned is destroyed, CM_DICTATE, when its parent
            is destroyed.

            For Win32 owned windows are always displayed above
            the parent window. Owned windows are minimized when
            when the parent is minimized.

            For Gtk the parent is the window that is the leader
            in a window manager "group" of windows. Just what this means
            is dependent on the specific window manager in use.

            For MdiChild windows parent must be an MdiFrame window.

   name = the caption text of the window. if the window does not have a
          caption then this parameter is ignored. On MdiChild windows
          the caption is the window selection tab.

   menu = the menu for the window. Can be "", which means no menu.

   icon = the icon associated with this window. Can be "".
           For Win32 you should have both 16x16 and 32x32 icons in the icon
           set.
           For Gtk this parameter currently is ignored.

   wndProc = the window procedure

   attribs = the window attributes for the window

   x, y = the initial screen coordinates for the window to be displayed
          if a parameters is -1 then the operating system will choose
          a default location. these coordinates are relative to the
          origin to the screen

   width, height = the initial size of the window when created.
                   if a parameter is -1 the operating system will
                   choose a default size

   createParam = an arbitrary value you can use to pass information
                 to the window procedure of the window. this value is
                 passed in the WSM_CREATE message.

   For MdiChild windows Ctrl+Tab, Ctrl+Shift+Tab are accelerator keys to
   cycle through the various MdiChild windows.

   returns the window handle if success full, otherwise NIL
*)

PROCEDURE SetMdiTabPosition(w : Window; tabPos : MdiTabPosition);
(* set the position of the MDI child tabs.
   w must be an MDI frame window.
   the default tab position is MdiTabBottom.

   Win32
       Windows seems to have issues with changing from various tab positions.
       Changing between top and bottom works. Changing left/right to/from top/bottom
       does not work.
*)

PROCEDURE CycleActiveMdiChild(w : Window; direction : INTEGER);
(*
  w can be an MdiChild or MdiFrame window.
  if direction > 0 then the next MdiChild becomes the active child window.
  if direction < 0 then the previous MdiChild becomes the active child window.
*)

PROCEDURE ConvertMdiChildToTopLevel(w : Window);
(* convert the MdiChild window to a TopLevel window.
   if the frame window has a toolbar and/or statusline the new
   toplevel window will create copies of these for itself.
*)

PROCEDURE AddWindowNotify(w : Window;
                          proc : WindowNotifyProcedure;
                          data : ADDRESS) : BOOLEAN;
(* the passed procedure "proc" will be called when the window "w"
   has one of the notify actions occur.
   "data" is aribtrary data you can have passed to the close procedure.
   you can have multiple notify procedures attached to a window.
   returns TRUE if the notify procedure was added.
*)

PROCEDURE CloseWindow(w : Window; mode : CloseModes) : BOOLEAN;
(* close an existing window.
   mode = CM_REQUEST you are requesting that the window close.
          for example this can give a window a change to prompt for saving any
          unsaved changes and possibly aborting the close.
   mode = CM_DICTATE the window *WILL* be closed
   returns TRUE if the window is closing
*)

PROCEDURE CloseAllChildren(parent : Window; mode : CloseModes) : BOOLEAN;
(* the effect here is to call CloseWindow with the given close mode
   for all child windows of the given window.
   returns TRUE if all child windows were closed
*)

PROCEDURE DisplayMdiChildNumber(w : Window; yes : BOOLEAN);
(*
  w must be an MdiFrame window.
  yes = TRUE means that the Mdi child titles will be prefixed with a number 0-9.
        This corresponds to the position of the child in the frame window.
        This can be used in conjunction with the GetIthMdiChild API call.
        The 10th child and beyond will not have a number.
*)

PROCEDURE SetBackgroundAutoErase(w : Window; color : ColorValue);
(* this will have the window automatically erase any region that
   needs to be painted with a background color before any paint
   message is sent.
*)

PROCEDURE IsWindow(w : Window) : BOOLEAN;
(* is the window handle passed in w a valid window handle
   for example a window might have been closed and a copy of the window
   handle an application had stored somewhere may no longer be valid
   retuns TRUE if the window handle is valid
*)

PROCEDURE GetWindowType(w : Window) : WindowTypes;
(* return the window type for the specified window *)

PROCEDURE GetWindowParent(w : Window) : Window;
(* return the parent window *)

PROCEDURE GetIthMdiChild(w : Window; num : CARDINAL) : Window;
(* return the ith child in the list of child windows.
   the first child is number 0.
   child windows are ordered by the order of creation.
   hidden child windows are not considered by this procedure.
*)

PROCEDURE GetActiveMdiChild(w : Window) : Window;
(*
  w = an MDI frame window.
  the return value is the child window that is on top of all the
  other MDI child windows.
*)

PROCEDURE SetActiveMdiChild(w : Window);
(*
  w must be an MDI child window.
  set w to be the active MDI child window. this is the child that
  is on top of all the other MDI child windows.
*)

PROCEDURE SetMdiChildPosition(w : Window; index : CARDINAL);
(*
  set the position of the window in the child window selection tabs.
  0 = the "first" tab.
*)

PROCEDURE SetDisplayMode(w : Window; mode : DisplayModes);
(* set the display mode for the window identified by w *)

PROCEDURE GetDisplayMode(w : Window) : DisplayModes;
(* get the display mode for the window identified by w *)

PROCEDURE SetWindowEnable(w : Window; enabled : BOOLEAN);
(* enable/disable the window identified by w
   if enabled = TRUE then the window will be enabled, otherwise the window
   will be disabled
   A disabled window cannot receive any user interaction
*)

PROCEDURE IsMinimized(w : Window) : BOOLEAN;
(* retuns TRUE if the window identified by w is currently minimized *)

PROCEDURE IsMaximized(w : Window) : BOOLEAN;
(* retuns TRUE if the window identified by w is currently maximized *)

PROCEDURE ClientAreaIsClipped(w : Window) : BOOLEAN;
(* returns TRUE if the client area of the window identified by w is
   currently clipped by some other window.
   By clipped we mean that the entire client area is not visible.
*)

PROCEDURE GetForegroundWindow() : Window;
(* get the current window with input focus.
   if the focused window is not a window managed by this module
   the returned value will be NIL
*)

PROCEDURE SetForegroundWindow(w : Window);
(* makes the window the foreground window
  also makes the window have the keyboard input focus.

   depending on the underlying system this function may FAIL if the thread
   associated with the window is not the current foreground thread.
*)

PROCEDURE RepaintRect(w : Window; rect : wsRECT);
(* force the rectangle in rect to be repainted in the window identified by w *)
(* the repaint is queued, and not drawn immediately *)

PROCEDURE UpdateWindow(w : Window);
(* force any pending repaint messsages to be sent before this call returns *)

PROCEDURE GetClientSize(w : Window; VAR OUT width, height : COORDINATE);
(* get the size of the windows client area in screen coordinates *)

PROCEDURE SetClientSize(w : Window; width, height : COORDINATE);
(* set the size of the windows client area in screen coordinates
   the actual size of the window will likely be larger due to a caption,
   border, menus, scroll bars and other goodies
*)

PROCEDURE SetMinClientSize(w : Window; width, height : COORDINATE);
(* limit the window to a certain minimum client area size
   this does not effect the windows ability to be minimized.
*)

PROCEDURE SetMaxClientSize(w : Window; width, height : COORDINATE);
(* limit the window to a certain maximum client area size
   Such a window should probably not be capable of being maximized
*)

PROCEDURE SetWindowGrains(w : Window; width, height : COORDINATE);
(* use this procedure to limit the possible window sizes to values
   such that the client area will be an even multiple of width and height.

   this setting has no effect on a maximized, or minimized window.

   Gtk - not implemented
   Window managers have a geometry hints option but when I used this the
   Window manager(s)/X/Gtk freak out and strange things happen.
   Manual implemenation also had other wierd side effects.
*)

PROCEDURE GetWindowSize(w : Window; VAR OUT width, height : COORDINATE);
(* get the size of the window area in screen coordinates
   this includes the client area and all the other goodies.

   Gtk
       On X the border and caption title are not a part of a user window.
       they are the domain of the window manager.
*)

PROCEDURE SetWindowSize(w : Window; width, height : COORDINATE);
(* set the size of the window area in screen coordinates
   this includes the client area and all the other goodies.

   Gtk
       On X the border and caption title are not a part of a user window.
       they are the domain of the window manager.
*)

PROCEDURE GetWindowPos(w : Window; VAR OUT x, y : COORDINATE);
(* get the screen coordinates of the upper left corner of the window

   Gtk
       X and/or window managers have issues with this. The position retrieved
       seems to be interpreted differently than a when setting a window position.
*)

PROCEDURE SetWindowPos(w : Window; x, y : COORDINATE);
(* set the screen coordinates of the upper left corner of the window.

   Gtk
       X and/or window managers have issues with this. The position retrieved
       seems to be interpreted differently than a when setting a window position.
*)

PROCEDURE GetWindowDisplayInfo(w : Window; VAR OUT info : WindowDisplayInfo);
(* get the size a position information for the window
   this is useful for remembering the size and position of a window
   across multiple execution sessions
   if info.mode = SizeMinimized or SizeMaximized then the size and
   position information is the size and position information for the window
   when it is not minimized or maximized.

   Gtk
       X and/or window managers have issues with this. The position retrieved
       seems to be interpreted differently than a when setting a window position.
       On X the border and caption title are not a part of a user window.
       they are the domain of the window manager.
*)

PROCEDURE SetWindowDisplayInfo(w : Window; info : WindowDisplayInfo);
(* set the size and position information for the window.

   Gtk
       X and/or window managers have issues with this. The position retrieved
       seems to be interpreted differently than a when setting a window position.
       On X the border and caption title are not a part of a user window.
       they are the domain of the window manager.
*)

PROCEDURE CascadeWindow(cascadeThis, onThis : Window);
(* this positions the window 'cascadeThis' just below and to the right of the
   caption of the window 'onThis'.
   the window size is not altered
*)

PROCEDURE SetWindowTitle(w : Window; title : ARRAY OF CHAR);
(* set the caption text for the window
   if the window does not have a caption then nothing happens
   title must be null terminated.
*)

PROCEDURE SetWindowData(w : Window;
                        index : CARDINAL;
                        data : ADDRESS) : BOOLEAN;
PROCEDURE SetWindowDataNum(w : Window;
                           index : CARDINAL;
                           data : CARDINAL) : BOOLEAN;
(* this procedure will place the store the data in "data"
   into the window storage array position specified by index.
   index positions are from 0..31
   returns TRUE if successful
*)

PROCEDURE GetWindowData(w : Window;
                        index : CARDINAL) : ADDRESS;
PROCEDURE GetWindowDataNum(w : Window;
                           index : CARDINAL) : CARDINAL;
(* returns the data from the window storage array from the location
   index positions are from 0..31
   specified by index.
*)

PROCEDURE SetWindowIsBusy(w : Window; busy : BOOLEAN);
(* set the window to a "busy" state
   for each call with busy = TRUE, you must have a corresponding call
   with busy = FALSE to remove the busy state.
   this call changes the mouse cursor of the window to "busy" cursor
   generally an hourglass cursor.
   when the window reverts back to not busy, whatever the mouse cursor
   was before the window was busy is restored.
   generally you use this call when your user interface thread is performing
   a task that might take a while so you give the user some feedback
   with this call
*)

PROCEDURE RedirectMessage(w : Window; msg : MessageRec);
(* this call simply passes the message to the window specified.
   the window should be of the same thread as the window that received
   the message originally. Everything should work if not, but unforseen problems
   may occur.
*)

PROCEDURE SendUserMessage(w : Window;
                          userId : CARDINAL; userData : ADDRESS);
PROCEDURE PostUserMessage(w : Window;
                          userId : CARDINAL; userData : ADDRESS);
(* send a user message to a window
   the window receiving the message can be associated with any thread and
   need not be associated with the current thread.
   userId = arbitrary number
   userData = arbitrary data
   SendUserMessage waits for the message to be received and processed before returning.

   PostUserMessage send the message and return immediately.
   when using PostUserMessage you should not pass the address of local data
   in the item userData since it is not known when the other window
   will process the message and when the procedure that calls this API
   procedure ends the local data is invalidated.
   global variables, constants, and allocated memory can be safe to use
   for the userData item. "can be" because you can use safe memory in an
   unsafe manner.
*)

PROCEDURE IsUserMessageWaiting(w : Window;
                               userIdLow, userIdHigh : CARDINAL) : BOOLEAN;
(* returns TRUE if a user message within the range of userLow..userHigh
   is currently waiting in the message queue of the current thread
*)

PROCEDURE ClientToScreen(w : Window; VAR INOUT pt : wsPOINT);
(* convert client coordinates, in pt, of the given window to screen
   relative coordinates
*)

PROCEDURE ScreenToClient(w : Window; VAR INOUT pt : wsPOINT);
(* convert screen coordinates, in pt, to client relative coordinates for
   the given window. The returned coordinates can be negative.
*)

PROCEDURE GetCursorPos(w : Window; VAR OUT pt : wsPOINT);
(* get the screen coordinate position of the mouse cursor
   relative to the specified window client area
*)

PROCEDURE CreateStatusLine(w : Window; fmt : ARRAY OF INTEGER) : BOOLEAN;
(* add a status line to a window that does not have a status line.
   see SetStatusFormat for the meaning of the fmt parameter.
   returns TRUE if successfull.
   FALSE is returned if the window already has a status line, or
   some other error occurred.
*)

PROCEDURE RemoveStatusLine(w : Window);
(* if the window has a status line then remove the status line
   from the window
*)

PROCEDURE SetStatusFormat(w : Window; fmt : ARRAY OF INTEGER);
(* set the format of the status line
   each element in the fmt array defines a status line field.
   the numeric value in the field defines the number characters
   in size the field should be. The average character width is used to
   determine this size in screen coordinates.
   The last field can contain the value -1 which means
   the field will go all the way to the right side of the window.
   As a convenience if a MdiChild window is passed as the window
   parameter, the write will affect the parent window (MdiFrame).
*)

PROCEDURE WriteStatusField(w : Window;
                           field : CARDINAL;
                           text : ARRAY OF CHAR);
(* write the text given in txt to the field identified by field
   in the status line for the window w
   if the window does not have a status line nothing happens
   txt must be null terminated. if txt is too long for the defined size
   of the field the text will be clipped.
   As a convenience if a MdiChild window is passed as the window
   parameter, the write will affect the parent window (MdiFrame).
*)

PROCEDURE LoadToolbarBitmaps(VAR INOUT buttons : ARRAY OF ToolbarButtonInfo;
                             transparent : ColorValue) : BOOLEAN;
(* load the bitmaps for the toolbar buttons from the resource file.
   For standard bitmaps the stdButton = TRUE and stdName = the button.
   otherwise, the bitmap resource names are taken from bmpResName field.
   This call will not load a bitmap unless the image field is NIL,
   and the bmpResName field is <> "".

   transparent is the color in the bitmap that is to be "transparent", having the
   same color as the button background.
   The loaded bitmaps will be altered to make this so.
   if the transparent color does not exist in a bitmap then the bitmap is loaded
   unaltered without error.

   returns TRUE if successful, which means ALL bitmaps were loaded.
*)

PROCEDURE UnloadToolbarBitmaps(VAR INOUT buttons : ARRAY OF ToolbarButtonInfo);
(* unload the bitmaps for the toolbar buttons.
   if a button does not have a bitmap currently loaded that button is
   skipped.
*)

PROCEDURE CreateToolbar(w : Window;
                        buttons : ARRAY OF ToolbarButtonInfo;
                        hasText : BOOLEAN;
                        hasHelp : BOOLEAN;
                        canCustomize : BOOLEAN) : BOOLEAN;
(* create a toolbar for the given window.
   buttons = the buttons of the toolbar. this is ALL possible buttons.
             button bitmaps should be 24x24.
             this call does not use the bmpResId field of the button
             info record.
             the bitmap field must be initialized with the handle
             of your bitmap, or the value of a standard bitmap.
             Use SYSTEM.MAKEADR to create an address with the
             standard bitmap ordinal. MAKEADR(ORD(TB_BMP_CUT))
             You can use LoadToolbarBitmaps to load your bitmaps
             or you can load them via other means.
   hasText = TRUE the buttons will display text labels if available.
             FALSE only the bitmaps will be displayed.
   hasHelp = TRUE the buttons will display tooltip help popups if available
             FALSE the buttons will not display tooltips
   canCustomize = TRUE the toolbar will allow the user to customize the
                  buttons displayed and the order they are displayed.
                  You should fetch this information and save it so you can
                  remember the user preferred toolbar settings.
*)

PROCEDURE DestroyToolbar(w : Window);
(* destroy the toolbar for the window if it has one *)

PROCEDURE SetToolbarButtons(w : Window; fmt : ARRAY OF CARDINAL);
(* set which buttons from the list of available buttons will be
   displayed. The HIGH bound of the passed array determines the
   number of toolbar buttons.
   the numeric value if each array element specifies the ordinal index
   into the list of available buttons passed to CreateToolbar.
   if the window does not have a toolbar nothing happens
*)

PROCEDURE GetToolbarButtons(w : Window; VAR OUT fmt : ARRAY OF CARDINAL) : CARDINAL;
(* get the current buttons displayed and their layout.
   the returned value is number of buttons returned into the parameter
   fmt. you should  make sure fmt is big enough to hold all possible
   buttons so you will not lose information. the maximum number of buttons
   is known from the CreateToolbar procedure call.
   the numeric value if each array element specifies the ordinal index
   into the list of available buttons passed to CreateToolbar.
   if the window does not have a toolbar nothing happens.

   Win32
       the system toolbar control supports toolbar customization by the user
       with no interaction necessary on our part.
       the user customizes a toolbar by double clicking on an empty area in the tool
       bar. Windows displays a customization dialog the user interacts with.
   GTK
       no user customization is currently implemented.
*)

PROCEDURE IsToolbarButtonDown(w : Window; index : CARDINAL) : BOOLEAN;
(* is the button identified by index currenly in the down position.
   this call is only valid for TbToggle buttons
   a button must be shown before it can be toggled.
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if the button is shown and checked in the toolbar
*)

PROCEDURE IsToolbarButtonEnabled(w : Window; index : CARDINAL) : BOOLEAN;
(* is the button identified by index currently enabled
   returns TRUE means the button is active an can be pressed
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if the button is enabled in the toolbar
*)

PROCEDURE IsToolbarButtonShown(w : Window; index : CARDINAL) : BOOLEAN;
(* is the button identified by index currently shown
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if the button is shown in the toolbar
*)

PROCEDURE ToggleToolbarButton(w : Window;
                             index : CARDINAL;
                             down : BOOLEAN) : BOOLEAN;
(* set the toggled state of the button identified by index
   this call is only valid for TbToggle buttons
   down = TRUE means the button should be in the down position.
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if successful
*)

PROCEDURE EnableToolbarButton(w : Window;
                              index : CARDINAL;
                              enable : BOOLEAN) : BOOLEAN;
(* set the enabled state of the button identified by index
   enable = TRUE means the button should be enabled
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if successful
*)

PROCEDURE ShowToolbarButton(w : Window;
                            index : CARDINAL;
                            show : BOOLEAN) : BOOLEAN;
(* set the shown state of the button identified by index
   show = TRUE means the button should be shown
   index is the ordinal index into the button list array passed
   to CreateToolbar
*)

PROCEDURE CaretOn(w : Window);
(* turn the display of a text caret ON in the window.
   if the window is the input focus window then the caret will be
   displayed otherwise the caret is not displayed
*)

PROCEDURE CaretOff(w : Window);
(* turn the display of a text caret OFF in the window *)

PROCEDURE HideCaret(w : Window);
(* this call is not normally necessary.
   the caret must not be displayed when you paint to maintain a proper display.
   BeginPaint, and PAINT messages automatically hide/show the caret.
   this call is only necessary when using non transient window drawables,
   since in these cases you may not be using BeginPaint.
   HideCaret maintain a hide count therefore you must call ShowCaret
   once for each call to HideCaret.
*)

PROCEDURE ShowCaret(w : Window);
(* see HideCaret *)

PROCEDURE MoveCaretTo(w : Window; x, y : INTEGER);
(*
   move the text caret to a specific location
   the coordinates are client area relative
   the window need not have the caret turned on for this function
   to operate. the coordinates will be remembered
*)

PROCEDURE GetCaretPos(w : Window; VAR OUT x, y : COORDINATE);
(* fetch the current text caret position *)

PROCEDURE SetCaretType(w : Window; ct : CaretTypes; width, height : CARDINAL);
(* set the type and size of the caret for this window
   ct = the shape of the caret
   width, height = the width and height in screen coordinates of the caret
   the window need not have the caret turned on for this function
   to operate. the information will be remembered
*)

PROCEDURE SetScrollBarRange(w : Window;
                            which : WinAttr;
                            min : ScrollRange;
                            max : ScrollRange;
                            pageSize : ScrollRange);
(* set the range information for the given scroll bar in the given window
   which = which scroll bar
   min = the lower limit of the scroll bar range
   max = the upper limit of the scroll bar range
         if min = max then the scroll bar is remove or disabled
   pageSize = the size of a "page" in scroll bar range units.
   for example in a text file
    the range might be (min = 1) (max = 534) and (pageSize = 10)
    in this case the lower limit is always line number 1.
    the upper limit is the number of lines in the text file.
    pageSize is the most likely the size of the window in lines or one or two
        lines less than this.
    scroll bar ranges are whatever you what them to be
*)

PROCEDURE SetScrollBarRanges(w : Window;
                             minX : ScrollRange;
                             maxX : ScrollRange;
                             pageX : ScrollRange;
                             minY : ScrollRange;
                             maxY : ScrollRange;
                             pageY : ScrollRange);
(* like SetScrollBarRange except that you are setting the range for
   both the horizontal, X, and vertical, Y, scroll bars.
   See SetScrollBarRange
*)

PROCEDURE SetScrollBarPos(w : Window;
                          which : WinAttr;
                          pos : ScrollRange);
(* set the position of the scroll bar thumb
   which = which scroll bar
   pos = the position. (pos >= minRange) AND (pos <= maxRange)
*)

PROCEDURE GetScrollBarPos(w : Window;
                          which : WinAttr) : ScrollRange;
(* get the position of the scroll bar thumb
   which = which scroll bar
*)

PROCEDURE SetScrollDisableWhenNone(w : Window; yesH, yesV : BOOLEAN);
(* this procedure controls whether a scroll bar disappears or becomes
   disabled when the window is large enough to display the entire
   "document" and thus a scroll bar is not necessary.
   this sets the policy for both scroll bars, but each scroll bar
   acts independently regarding its own state.
   yes = TRUE means the scroll bar(s) will disable
         FALSE means the scroll bar(s) will disappear
   yesH = horizontal, yesV = vertical
   default = FALSE
*)

PROCEDURE SetWindowIcon(w : Window; icon : ARRAY OF CHAR) : BOOLEAN;
(*
   set the icon associated with the window
   the resource can have many icon formats and the most appropriate
   icon will be chosen depending on how the icon is going to
   be used by the system. generally 32x32 and a 16x16 16color icons should
   be provided at a minimum in the icon resource.

   Gtk
       not currently implemented.
*)

PROCEDURE SetWindowCursor(w : Window; typ : CursorTypes);
(* set the cursor type displayed when the mouse cursor is within the
   confines of the windows client area.
*)

PROCEDURE SetWindowMenu(w : Window;
                        menu : ARRAY OF CHAR) : BOOLEAN;
(* set/change the menu for the given window.
   menu = the menu resource. Can be "", which means no menu.
*)

PROCEDURE GetWindowMenu(w : Window) : MenuHandle;
(* get the menu handle for menu currently associated with the window
   the return value can be NIL if the window has no menu
*)

PROCEDURE SetMenuItemEnable(w : Window; id : CARDINAL; enabled : BOOLEAN);
(* set whether a menu item identified by id is enabled
   enabled = TRUE the menu item is enabled
             FLASE the menu item is disabled
*)

PROCEDURE GetMenuItemEnable(w : Window; id : CARDINAL) : BOOLEAN;
(* get whether a menu item identified by id is enabled
   returns = TRUE the menu item is enabled
             FLASE the menu item is disabled
*)

PROCEDURE SetMenuItemCheck(w : Window; id : CARDINAL; checked : BOOLEAN);
(* set whether a menu item identified by id has a check mark displayed
   in the menu
   checked = TRUE a check mark will be displayed
             FLASE no check mark will be displayed
*)

PROCEDURE GetMenuItemCheck(w : Window; id : CARDINAL) : BOOLEAN;
(* get the checked state a menu item identified by id
   returns = TRUE a check mark is displayed
             FLASE no check mark is displayed
*)

PROCEDURE SetMenuItemRadioCheck(w : Window;
                                first, last, set : CARDINAL);
(* similar to check menu item, however this identifies a group of
   menu items of which one is checked and the others are unchecked.

   first..last is the range of menu items in the radio group.
   set is the menu item in the group to be "checked".
*)

PROCEDURE GetMenuItemRadioCheck(w : Window; first, last : CARDINAL) : CARDINAL;
(* get the checked menu item in a radio menu item group
   returns 0 if some error occurs, or none are checked.
*)

PROCEDURE LoadMenu(w : Window;
                   menu : ARRAY OF CHAR;
                   popup : BOOLEAN) : MenuHandle;
(* load a menu resource identified by menu.
   the menu is associated with the identified window.
   the return value will be NIL if the resource does not exist
   or there was an error loading the resource.

   popup = TRUE if the menu being loaded is a popup menu.
           For Win32 the menu resource is loaded and the first menu
           is returned.
           For Gtk a popup menu resource is loaded.
*)

PROCEDURE DestroyMenu(VAR INOUT menuH : MenuHandle);
(* destroy a previously loaded menu resource *)

PROCEDURE GetSubMenu(menuH : MenuHandle; subMenu : CARDINAL) : MenuHandle;
(*
   get the menu handle of a sub menu within a menu
   can return NIL of the sub menu does not exist or there was an error
   the sub menu is identified by position in the menu, zero being first.

   for example if the menu bar shows
   File Edit Search

   Edit is ordinal position 1 in the main menu.
   You can continue on though the menu hierarchy if any hierarchy exists
   to get a menu handle for any menu within the hierarchy.
*)

PROCEDURE AppendMenuItemStr(w : Window;
                            menuH : MenuHandle;
                            str : ARRAY OF CHAR;
                            id : CARDINAL) : BOOLEAN;
(* append a new menu item to the menu identified by menuH
   str = the text of the menu. must be null terminated
   id = the id number used to identify the menu item.
   you can "underscore" a character in the menu for keyboard activation
   by preceeding the desired character with an underscore character ('_').
   returns TRUE is successfull
*)

PROCEDURE AppendMenuItemSeparator(w : Window; menuH : MenuHandle) : BOOLEAN;
(* append a new menu item to the menu identified by menuH
   the menu item appended is a menu separator
   this is usually a thin line drawn across the menu
   returns TRUE is successfull
*)

PROCEDURE DeleteMenuItemPosition(menuH : MenuHandle;
                                 pos : CARDINAL) : BOOLEAN;
(* remove a menu item from the menu identified by menuH
   pos = the ordinal position of the menu item starting at zero for the
         first item in the menu
*)

PROCEDURE PopupMenu(w : Window;
                    menu : ARRAY OF CHAR;
                    button : MouseButton;
                    x, y : COORDINATE);
(* display a popup menu at client coordinates x, y.
   the menu is identified the parameter menu.
   button = the button used to "open" the popup menu and thus when this
            button is released the menu will close.

   This call is modal, meaning the call does not return until the popup
   menu is closed.

   For Win32 the menu resource is loaded and the first menu is used.
   For Gtk a popup menu resource is used.
*)

PROCEDURE PopupMenuHandle(w : Window;
                          menu : MenuHandle;
                          button : MouseButton;
                          x, y : COORDINATE);
(* like PopupMenu except that the menu is identified by a MenuHandle.
   this allows you to modify the menu resource before displaying the menu
   See PopupMenu

   This call is modal, meaning the call does not return until the popup
   menu is closed.
*)

PROCEDURE LoadString(idNum : CARDINAL; VAR OUT str : ARRAY OF CHAR);
(*
  Load a string from the string resource file.
  the string is identified by idNum.
  str = "" if not successfull.
*)

PROCEDURE CreatePalette(colors : ARRAY OF ColorValue) : PaletteHandle;
(* create a color palette
   some screen displays are limited in the number of colors they
   can simultaneously display. this means that the color range is larger
   than the number of colors that can be displayed.
   what we are talking about here are 256 and 16(yuck) color displays.
   the number of colors in the palette is determined by the HIGH bound
   of the passed array
   the return value is the handle used for the palette.
   NIL is returned if the function did not succeed, or if display does
   not use palettes (16, 24 and 32 bit color modes).
*)

PROCEDURE DestroyPalette(VAR INOUT palette : PaletteHandle);
(* dispose of a previously created color palette
   no window should be using this palette or an error is likely to occur
   at some later point of execution
*)

PROCEDURE SetWindowPalette(w : Window; pal : PaletteHandle);
(* set a specific window to use a given color palette
   the window will set the palette into the system whenever necessary
   when the window is not the foreground window the colors displayed
   may not match those in the color palette depending on various factors
   in the system
*)

PROCEDURE OpenClipboard(w : Window) : BOOLEAN;
(* open the system clipboard and give ownership to the specified window
   returns TRUE is successful
   only a foreground window should make such a request, and then only
   on behalf of a users request

   Gtk
       on X systems the "clipboard" can be many different things and some programs
       may only support one type of "clipboard". X calls these "selections".
       This module defines its own selection, and also tries to use other selections
       to try and be compatible with as many programs as possible.
*)

PROCEDURE CloseClipboard(w : Window);
(* close and release ownership of the clipboard. *)

PROCEDURE EmptyClipboard(w : Window) : BOOLEAN;
(* empty all contents of the clipboard
   if the window does not own the clipboard the call will fail
   returns TRUE if the operation is successfull
*)

PROCEDURE ClipboardFormatAvailable(fmt : ClipboardFormat) : BOOLEAN;
(* returns TRUE if data of the given clipboard format is available
   in the clipboard.
   returns TRUE if the format is available, otherwise FALSE if the
   clipboard is empty or some other data type is available.
   all text formats are automatically converted to other text formats
   on demand. Therefore if you put ASCII into the clipboard you can
   retrieve Unicode from the clipboard.
*)

PROCEDURE AllocClipboardMemory(size : CARDINAL) : ADDRESS;
(* allocate and lock system memory suitable for placing in the clipboard
   size = the amount of memory in bytes
   if NIL is returned the call failed, otherwise a valid address is returned.

   Win32
       the operating system will deallocate this memory for you since you
       cannot know how long the data will exist in the clipboard.
   Gtk
       Data put into the clipboard is only available to other programs as long
       as your process is running.
*)

PROCEDURE UnlockClipboardMemory(data : ADDRESS);
(* unlock locked clipboard memory.
   memory must be unlocked before placed into the clipboard.
   clipboard memory received must be unlocked after it is used.
*)

PROCEDURE SetClipboard(fmt : ClipboardFormat;
                       data : ADDRESS;
                       amount : CARDINAL) : BOOLEAN;
(* place data, identified by data, into the clipboard
   the format of the data is given in fmt parameter
   the data MUST be unlocked before setting into the clipboard.
   the memory is automatically freed by the system.
   returns TRUE if successfull *)

PROCEDURE GetClipboard(fmt : ClipboardFormat) : ADDRESS;
(* get clipboard data of the given format.
   returns NIL if the format was not available or the clip board was empty.
   otherwise a valid address is returned and the data is locked.
   you MUST unlock the data when you are done reading the data.
   all text formats are automatically converted to other text formats
   on demand. Therefore if you put ASCII into the clipboard you can
   retrieve Unicode from the clipboard.
   text formats are returned null terminated.
*)

PROCEDURE SetTimer(w : Window; timerId : CARDINAL; interval : CARDINAL);
(* create/reset a timer associated with the specified window
   timerId = a unique number to identify the timer.
   interval = the amount of time in milliseconds between WSM_TIMER messages
              this interval is only an approximate time
   calling SetTimer with the same timerId as a previous call but with
   a different interval has the effect of resetting the interval from
   the previous value to the new value *)

PROCEDURE KillTimer(w : Window; timerId : CARDINAL);
(* dispose of a previously created timer
   timerId = the identification number of an existing timer *)

PROCEDURE Beep(beep : Beeps);
(* make a sound on the computer.
   beep = various sound signatures. what these sounds sound like is defined
          by the user on their machine
*)

PROCEDURE PointInRect(x, y : COORDINATE; rect : wsRECT) : BOOLEAN;

PROCEDURE IntersectRect(r1, r2 : wsRECT; VAR OUT r3 : wsRECT) : BOOLEAN;

PROCEDURE RectOverlap(r1, r2 : wsRECT) : BOOLEAN;

PROCEDURE UnionRect(r1, r2 : wsRECT; VAR OUT r3 : wsRECT);

PROCEDURE OffsetRect(x, y : COORDINATE; VAR INOUT rect : wsRECT);

PROCEDURE RgbToColorValue(red, green, blue : CARDINAL8) : ColorValue;
(* take the separate red, green and blue color components and
   create a composite color value
*)

PROCEDURE ColorValueToRgb(colorVal : ColorValue;
                          VAR OUT red, green, blue : CARDINAL8);
(* break a compositie color value into its various components *)

PROCEDURE GetSystemColor(sysColor : SystemColors) : ColorValue;
(* return a color value for the system color *)

PROCEDURE LoadFont(font : FontInfo) : FontHandle;
(* load the font as specified by the parameter font *)
(* returns a valid font handle if successfull, otherwise NIL *)

PROCEDURE DeleteFont(font : FontHandle);
(* remove a previously loaded font *)

PROCEDURE GetTextMetrics(font : FontHandle; VAR OUT metrics : TextMetrics);
(* retrieve information about the font specified in the font parameter *)

PROCEDURE LoadBitmap(name : ARRAY OF CHAR; shared : BOOLEAN) : BitmapHandle;
(*
  Load a bitmap from resource.

  IF shared = TRUE, loaded bitmaps will be cached and on subsequent
  loads the bitmap handle of the first load will be returned.

  You should call DeleteBitmap when you are done using the bitmap.
  If shared = TRUE then the bitmap will not be freed until
  DeleteBitmap is called once for each active Load.
*)

PROCEDURE LoadBitmapFromFile(name : ARRAY OF CHAR) : BitmapHandle;
(*
  as LoadBitmap except the image is loaded from a stand alone file.
*)

PROCEDURE CreateBitmap(w : Window; width, height : CARDINAL) : BitmapHandle;
(*
  create a bitmap compatible with the window.
  The bitmap can be used with any Drawable that it is compatible with,
  meaning the color depth.
*)

PROCEDURE GetBitmapSize(bmp : BitmapHandle; VAR OUT width, height : CARDINAL);
(*
   return the width and height of the specified bitmap.
   returns 0 if bmp is not a valid bitmap handle.
*)

PROCEDURE ExtractBitmap(bmp : BitmapHandle;
                        x, y : COORDINATE;
                        width, height : CARDINAL) : BitmapHandle;
(*
    this function creates a new bitmap from a portion of another
    bitmap.
    This can be usefull with buttons for toolbars. Since these are
    small bitmaps and there are usually many buttons, it can be
    nice to edit all off the buttons in one larger bitmap.
    This function can be used to extract the individual bitmaps
    from the large bitmap button array.
*)

PROCEDURE DeleteBitmap(bmp : BitmapHandle);
(* delete a previously loaded/created bitmap.
  For shared bitmaps the bitmap will not be freed until
  DeleteBitmap is called once for each active Load.
*)

PROCEDURE CreateDrawContext(w : Window;
                            dcValues : DrawContextValues) : DrawContext;
(* create a new DrawContext. the context will be compatigble with
   the passed Window, w. You can use the context with other windows
   as long as the windows use the same color depth.
   If you wish to associate a Palette with a window you should do so
   before using this call, so the DrawContext, will note the change.

   Normally it is not possible to have windows with differing color
   depths. However different windows may have different palettes.
   Palettes are only used for <= 256 color displays.
*)

PROCEDURE DestroyDrawContext(VAR INOUT dc : DrawContext);
(* dispose of a previously created DrawContext.
   The context must not be selected into any Drawable.
*)

PROCEDURE SetDrawContextValues(dc : DrawContext;
                               dcValues : DrawContextValues);
(* set the values associated with the DrawContext. *)

PROCEDURE GetDrawContextValues(dc : DrawContext; VAR OUT dcValues : DrawContextValues);
(* get the values associated with the DrawContext. *)

PROCEDURE SetForegroundColor(dc : DrawContext; color : ColorValue);
(* set the foreground color used for painting *)

PROCEDURE SetBackgroundColor(dc : DrawContext; color : ColorValue);
(* set the background color used for painting *)

PROCEDURE SetFont(dc : DrawContext; font : FontHandle);
(* set the font as the font used for painting text *)

PROCEDURE SetTextExtraSpacing(dc : DrawContext; extra : INTEGER);
(* this alters the normal character spacing of the text written
   a positive value adds space (pixels) between each character drawn
   a negative value removes space.
*)

PROCEDURE SetTextDrawOrigin(dc : DrawContext; origin : TextDrawOrigin);
(*
  Sets the text origin of text drawing operations.
  See the comments at the TextDrawOrigin type declaration.
*)

PROCEDURE SetLineWidth(dc : DrawContext; width : CARDINAL);
(* set the line width *)

PROCEDURE SetLineAttributes(dc : DrawContext;
                            join : JoinStyles;
                            endCap : EndCaps;
                            width : CARDINAL);
(* set all line attributes *)

PROCEDURE BeginPaint(w : Window; dc : DrawContext) : Drawable;
(* use this to obtain a Drawable for the specific window.
   the DrawContext, dc, is selected into the returned Drawable.
   when you are finished painting you must call EndPaint which releases
   any system resources allocated by this call.

   this call will automatically hide the text caret if active.

   when you receive a PAINT message you can use the Drawable passed
   in the paint message, therefore you do not need this call in that
   circumstance, however you will need to select a DrawContext into
   the paint Drawable.
*)

PROCEDURE EndPaint(w : Window);
(* call this when you are done painting to a window.
  this call is the book end to the BeginPaint call.
  The Drawable returned by the BeginPaint call is invalid after this call.
  Any DrawContext selected into the Drawable is automatically deselected.
  This call will show the text caret if the window has an active caret.
*)

PROCEDURE CreateOffscreenDrawable(w : Window;
                                  width, height : CARDINAL;
                                  context : DrawContext) : Drawable;
(* create a Drawable where all draw operations are drawing into
   a offscreen bitmap.  The Drawable is compatible with the given window.

   The size of the Drawable is width and height. If width or height are
   zero then the Drawable size for that dimension is set to the current size
   of the client area of the Window.

   Normally it is not possible to have windows with differing color
   depths. However different windows may have different palettes.
   Palettes are only used for <= 256 color displays.
*)

PROCEDURE CreateBitmapDrawable(bmp : BitmapHandle;
                               context : DrawContext) : Drawable;
(* create a Drawable where all draw operations are drawing into the specified bitmap.

   Use this to draw a bitmap onto another drawable, or to draw into
   the bitmap itself.
   The size of this drawable is the size of the bitmap.
*)

PROCEDURE ChangeDrawableBitmap(draw : Drawable; bmp : BitmapHandle);
(*
  changes the bitmap associated with the existing bitmap drawable.
  if the drawable is not a bitmap drawable then this procedure
  takes no action.
*)

PROCEDURE DestroyDrawable(draw : Drawable);
(*
  Delete a previously created Drawable.
  Do not use this call with a Drawable returned by BeginPaint or the Drawable
  passed in the WSM_PAINT message.
*)

PROCEDURE SelectDrawContext(draw : Drawable; context : DrawContext);
(* associate the DrawContext with the Drawable, draw.
   any previously selected DrawContext is deselected.
*)

PROCEDURE GetTextWidth(draw : Drawable;
                       text : ARRAY OF CHAR;
                       length : CARDINAL) : CARDINAL;
(* this calls returns the width of the text in pixels when drawn.
   the number of characters measured is length.
   if length = 0 the the number of characters measured is LENGTH(text)
   the font currently selected for drawing is used for the measurement.
   The SetTextExtraSpacing API procedure affects this call.
*)

PROCEDURE DrawText(draw : Drawable;
                   x, y : COORDINATE;
                   text : ARRAY OF CHAR;
                   length : CARDINAL);
(* draw text at the coordinates x, y
 length = the number of characters drawn
 if length = 0 then the number of characters draw is LENGTH(text)
 the text is drawn in the foreground color.
 the text is drawn transparently over the background.
*)

PROCEDURE DrawTextRect(draw : Drawable;
                       x, y : COORDINATE;
                       text : ARRAY OF CHAR;
                       length : CARDINAL;
                       rect : wsRECT;
                       flags : DrawTextOptionSet);
(* draw text at the coordinates x, y
   length = the number of characters drawn
   if length = 0 then the number of characters drawn is LENGTH(text).
   the text is drawn in the foreground color.
   the rectangle specifies the rectangle that is used for clipping and/or filling.
   flags specifies options for drawing.
*)

PROCEDURE DrawLine(draw : Drawable;
                   x1, y1, x2, y2 : COORDINATE);
(* draw a line from x1,y1 to x2,y2 in the current foreground color
   and line attributes.
*)

PROCEDURE DrawLines(draw : Drawable; points : ARRAY OF wsPOINT);
(* draw a series of connected lines starting at the first point
   and ending at the last point.
   the line is drawn in the current foreground color, and line attributes.
*)

PROCEDURE DrawRectangle(draw : Drawable;
                        x, y : COORDINATE;
                        width, height : CARDINAL;
                        filled : BOOLEAN);
(* draw the rectangle with the foreground color.
   if filled = FALSE  then the rectangle outline is drawn with
   the current line attributes.
   example x=0,y=0,width=20,height=20
   the coordinates of the drawn rectangle are
   upper left (0, 0), and lower right (19, 19)
*)

PROCEDURE EraseRectangle(draw : Drawable;
                         x, y : COORDINATE;
                         width, height : CARDINAL);
(* as DrawRectangle, except the rectangle is filled with the background color.
*)

PROCEDURE DrawPie(draw : Drawable;
                  x, y : COORDINATE;
                  radius : CARDINAL;
                  startAngle, sliceWidth : REAL;
                  filled : BOOLEAN);
(* draw a pie slice within in the foreground color.
   x, y define the center of the circle the pie slice is a part of.
   radius is the radius of the circle.
   startAngle and width define the size of the pie slice.
   a startAngle value of zero begins at the 3 o'clock position and increasing
   values go in the counter clockwise direction.
   the angle values are specified in degrees.
   width is the number of degrees of the pie slice and must be <= 360.0.
   if filled = FALSE then the pie outline is drawn with
   the current line attributes.
*)

PROCEDURE CopyDrawableArea(destDraw : Drawable;
                           destX, destY : COORDINATE;
                           srcDraw : Drawable;
                           srcX, srcY,
                           width, height : COORDINATE);
(* this call copies a reqion from one drawable to another.
   you may use the same drawable for both the source and destination.

   The for a window, it should not be clipped,
   otherwise you may be copying other windows.
   See the ClientAreaIsClipped API call.
   The UpdateWindow API call can be useful before issuing this call with Window
   drawables as the source.
*)

PROCEDURE InitHtmlHelp;
(*
   On Win32 this initializes support for using the HtmlHelp API.
   On Gtk this call does nothing.
*)

PROCEDURE DisplayHelp(w : Window;
                      command : HelpCommand;
                      helpFile : ARRAY OF CHAR;
                      helpIndex : CARDINAL) : BOOLEAN;
(* call the operating system help program
   helpFile = the file specification of the help file to be opened
   helpIndex = help topic number within the given help file
   command = what you want the help program to do
       HelpTopic        open help to a specific topic.
       HelpContents     open help in table of contents (Win32 only)
                        helpIndex is ignored in this case


   Win32.
   All features are available.
   On Windows you can use WinHelp or HTML help. WinHelp is used unless
   InitHtmlHelp is called.

   GTK+
   command and helpIndex are ignored.
   helpFile is assumed to be an HTML file and an HTML browser is executed for
   the specified file.
*)

PROCEDURE BooBox(a : ARRAY OF CHAR);
(* just a quick and dirty way to display a simple message box
   can be used for diagnostic messages *)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

(* functions that export native operating system values
   these functions are not part of the WinShell API
   they are here to allow "special" actions to be performed when necessary
   and to allow someone to provide additional operating system
   encapsulation in a separate module from this one *)

PROCEDURE GetWindowHandle(w : Window) : ADDRESS;
(* get the operating system handle for window specified *)

PROCEDURE GetClientHandle(w : Window) : ADDRESS;
(* get the operating system handle for the client window
   of the specified window. *)

PROCEDURE GetDrawableHandle(draw : Drawable) : ADDRESS;
(* for Win32 - return the HDC handle associated with the drawable.
   for GTK - return the GDK drawable handle
*)

%IF WIN32 %THEN
PROCEDURE SetModelessDialog(wnd : ADDRESS; add : BOOLEAN) : BOOLEAN;
(* This procedure is here to support DlgShell in Win32
   wnd = the operating system window handle of the modeless dialog
   add = TRUE then you are adding a new dialog to the message loop
         FALSE then you are remove a dialog from the message loop
   returns TRUE if successful
*)
%END

END WinShell.
(*
* Copyright (c) 1985-2000, Microsoft Corp. All rights reserved.             *
*)
(* Conversion from Microsoft WIN32 SDK C source to Modula-2 source *)
(* Copyright (c) 1995-2000, Stony Brook Software. All rights reserved. *)

DEFINITION MODULE WINUSER;

FROM SYSTEM IMPORT
    CAST;
IMPORT SYSTEM;

FROM WIN32 IMPORT
    HANDLE, PVOID, DWORD, HWND, UINT, WPARAM, LPARAM, LRESULT, BOOL, HDC,
    LPCWSTR, LPCSTR, LPWSTR, LPSTR, LPTSTR, POINT, HKL, HDESK, HWINSTA,
    LPSECURITY_ATTRIBUTES,
    PSECURITY_INFORMATION, PSECURITY_DESCRIPTOR, HINSTANCE, HICON, HCURSOR,
    HBRUSH, RECT, WORD, LONG, LPVOID, ATOM, HMENU, WCHAR, SHORT, PBYTE,
    HACCEL, HBITMAP, HRGN,
    WINT, COLORREF, HHOOK, LPATOM, HTASK, HGLOBAL, BYTE;

FROM WINGDI IMPORT
    LOGFONTA, LOGFONTW, DEVMODEA, DEVMODEW;

%IF WIN5 %THEN
FROM WIN32 IMPORT
    HMONITOR, HMODULE, HWINEVENTHOOK;
FROM WINGDI IMPORT
    CCHDEVICENAME, DISPLAY_DEVICEA, DISPLAY_DEVICEW;
%END

<*/CALLS:WIN32SYSTEM*>
<*/NOHIGH*>
<*/ALIGN:8/NOPACK*>

CONST
    WINVER               = 0030Ah;

TYPE
    HDWP                 = HANDLE;

    MENUTEMPLATEA        = BYTE;
    MENUTEMPLATEW        = BYTE;
    LPMENUTEMPLATEA      = PVOID;
    LPMENUTEMPLATEW      = PVOID;
    %IF UNICODE %THEN
    MENUTEMPLATE         = MENUTEMPLATEW;
    LPMENUTEMPLATE       = LPMENUTEMPLATEW;
    %ELSE
    LPMENUTEMPLATE       = LPMENUTEMPLATEA;
    MENUTEMPLATE         = MENUTEMPLATEA;
    %END

    WNDPROC              = PROCEDURE(HWND,
                                     UINT,
                                     WPARAM,
                                     LPARAM) : LRESULT [EXPORT];

    DLGPROC              = PROCEDURE(HWND,
                                     UINT,
                                     WPARAM,
                                     LPARAM) : BOOL [EXPORT];

    TIMERPROC            = PROCEDURE(HWND,
                                     UINT,
                                     UINT,
                                     DWORD) [EXPORT];

    GRAYSTRINGPROC       = PROCEDURE(HDC,
                                     LPARAM,
                                     INTEGER) : BOOL [EXPORT];

    WNDENUMPROC          = PROCEDURE(HWND,
                                     LPARAM) : BOOL [EXPORT];

    HOOKPROC             = PROCEDURE(INTEGER,
                                     WPARAM,
                                     LPARAM) : LRESULT [EXPORT];

    SENDASYNCPROC        = PROCEDURE(HWND,
                                     UINT,
                                     DWORD,
                                     LRESULT) [EXPORT];

    PROPENUMPROCA        = PROCEDURE(HWND,
                                     ARRAY OF ACHAR,
                                     HANDLE) : BOOL [EXPORT];

    PROPENUMPROCW        = PROCEDURE(HWND,
                                     ARRAY OF UCHAR,
                                     HANDLE) : BOOL [EXPORT];

    PROPENUMPROCEXA      = PROCEDURE(HWND,
                                     VAR ARRAY OF ACHAR,
                                     HANDLE,
                                     DWORD) : BOOL [EXPORT];

    PROPENUMPROCEXW      = PROCEDURE(HWND,
                                     VAR ARRAY OF UCHAR,
                                     HANDLE,
                                     DWORD) : BOOL [EXPORT];

    EDITWORDBREAKPROCA   = PROCEDURE(VAR ARRAY OF ACHAR,
                                     INTEGER,
                                     INTEGER,
                                     INTEGER) : INTEGER [EXPORT];

    EDITWORDBREAKPROCW   = PROCEDURE(VAR ARRAY OF UCHAR,
                                     INTEGER,
                                     INTEGER,
                                     INTEGER) : INTEGER [EXPORT];
    %IF UNICODE %THEN
    EDITWORDBREAKPROC    = EDITWORDBREAKPROCW;
    %ELSE
    EDITWORDBREAKPROC    = EDITWORDBREAKPROCA;
    %END

    NAMEENUMPROCA        = PROCEDURE(ARRAY OF ACHAR, LPARAM) : BOOL [EXPORT];
    WINSTAENUMPROCA      = NAMEENUMPROCA;
    DESKTOPENUMPROCA     = NAMEENUMPROCA;

    NAMEENUMPROCW        = PROCEDURE(ARRAY OF UCHAR, LPARAM) : BOOL [EXPORT];
    WINSTAENUMPROCW      = NAMEENUMPROCW;
    DESKTOPENUMPROCW     = NAMEENUMPROCW;
%IF UNICODE %THEN
    NAMEENUMPROC         = NAMEENUMPROCW;
    WINSTAENUMPROC       = WINSTAENUMPROCW;
    DESKTOPENUMPROC      = DESKTOPENUMPROCW;
%ELSE
    NAMEENUMPROC         = NAMEENUMPROCA;
    WINSTAENUMPROC       = WINSTAENUMPROCA;
    DESKTOPENUMPROC      = DESKTOPENUMPROCA;
%END

    DRAWSTATEPROC        = PROCEDURE(HDC,
                                     LPARAM,
                                     WPARAM,
                                     WINT,
                                     WINT) : BOOL [EXPORT];(*95*)

    %IF UNICODE %THEN
    PROPENUMPROC         = PROPENUMPROCW;
    PROPENUMPROCEX       = PROPENUMPROCEXW;
    %ELSE
    PROPENUMPROC         = PROPENUMPROCA;
    PROPENUMPROCEX       = PROPENUMPROCEXA;
    %END

PROCEDURE MAKEINTRESOURCEA(i : INTEGER) : LPSTR;

PROCEDURE MAKEINTRESOURCEW(i : INTEGER) : LPWSTR;

PROCEDURE MAKEINTRESOURCE(i : INTEGER) : LPTSTR;

CONST
    RT_CURSOR           = CAST(LPTSTR,1);
    RT_BITMAP           = CAST(LPTSTR,2);
    RT_ICON             = CAST(LPTSTR,3);
    RT_MENU             = CAST(LPTSTR,4);
    RT_DIALOG           = CAST(LPTSTR,5);
    RT_STRING           = CAST(LPTSTR,6);
    RT_FONTDIR          = CAST(LPTSTR,7);
    RT_FONT             = CAST(LPTSTR,8);
    RT_ACCELERATOR      = CAST(LPTSTR,9);
    RT_RCDATA           = CAST(LPTSTR,10);
    RT_MESSAGETABLE     = CAST(LPTSTR,11);

    DIFFERENCE          = 11;
    RT_GROUP_CURSOR     = CAST(LPTSTR, 1 + DIFFERENCE);
    RT_GROUP_ICON       = CAST(LPTSTR, 3 + DIFFERENCE);

    RT_VERSION          = CAST(LPTSTR,16);
    RT_DLGINCLUDE       = CAST(LPTSTR,17);
    RT_PLUGPLAY         = CAST(LPTSTR,19);
    RT_VXD              = CAST(LPTSTR,20);
    RT_ANICURSOR    = CAST(LPTSTR, 21);
    RT_ANIICON      = CAST(LPTSTR, 22);
    RT_HTML         = CAST(LPTSTR, 23);


PROCEDURE wvsprintfA(VAR a : ARRAY OF ACHAR;
                     b : ARRAY OF ACHAR;
                     c : LPVOID) : INTEGER;

PROCEDURE wvsprintfW(VAR a : ARRAY OF UCHAR;
                     b : ARRAY OF UCHAR;
                     c : LPVOID) : INTEGER;

%IF UNICODE %THEN
PROCEDURE wvsprintf = wvsprintfW;
%ELSE
PROCEDURE wvsprintf = wvsprintfA;
%END

PROCEDURE wsprintfA(VAR a : ARRAY OF ACHAR;
                    b : ARRAY OF ACHAR) : INTEGER [VARIABLE, msCdecl];

PROCEDURE wsprintfW(VAR a : ARRAY OF UCHAR;
                    b : ARRAY OF UCHAR) : INTEGER [VARIABLE, msCdecl];

%IF UNICODE %THEN
PROCEDURE wsprintf = wsprintfW;
%ELSE
PROCEDURE wsprintf = wsprintfA;
%END

CONST
    SB_HORZ              = 0;
    SB_VERT              = 1;
    SB_CTL               = 2;
    SB_BOTH              = 3;
    SB_LINEUP            = 0;
    SB_LINELEFT          = 0;
    SB_LINEDOWN          = 1;
    SB_LINERIGHT         = 1;
    SB_PAGEUP            = 2;
    SB_PAGELEFT          = 2;
    SB_PAGEDOWN          = 3;
    SB_PAGERIGHT         = 3;
    SB_THUMBPOSITION     = 4;
    SB_THUMBTRACK        = 5;
    SB_TOP               = 6;
    SB_LEFT              = 6;
    SB_BOTTOM            = 7;
    SB_RIGHT             = 7;
    SB_ENDSCROLL         = 8;

    SW_HIDE              = 0;
    SW_SHOWNORMAL        = 1;
    SW_NORMAL            = 1;
    SW_SHOWMINIMIZED     = 2;
    SW_SHOWMAXIMIZED     = 3;
    SW_MAXIMIZE          = 3;
    SW_SHOWNOACTIVATE    = 4;
    SW_SHOW              = 5;
    SW_MINIMIZE          = 6;
    SW_SHOWMINNOACTIVE   = 7;
    SW_SHOWNA            = 8;
    SW_RESTORE           = 9;
    SW_SHOWDEFAULT       = 10;
    SW_FORCEMINIMIZE     = 11;
    SW_MAX               = 11;

    HIDE_WINDOW          = 0;

    SHOW_OPENWINDOW      = 1;
    SHOW_ICONWINDOW      = 2;
    SHOW_FULLSCREEN      = 3;
    SHOW_OPENNOACTIVATE  = 4;

    SW_PARENTCLOSING     = 1;
    SW_OTHERZOOM         = 2;
    SW_PARENTOPENING     = 3;
    SW_OTHERUNZOOM       = 4;

%IF WIN5 %THEN
(*
 * AnimateWindow() Commands
 *)
    AW_HOR_POSITIVE             = 00000001h;
    AW_HOR_NEGATIVE             = 00000002h;
    AW_VER_POSITIVE             = 00000004h;
    AW_VER_NEGATIVE             = 00000008h;
    AW_CENTER                   = 00000010h;
    AW_HIDE                     = 00010000h;
    AW_ACTIVATE                 = 00020000h;
    AW_SLIDE                    = 00040000h;
    AW_BLEND                    = 00080000h;
%END

    KF_EXTENDED          = 00100h;
    KF_DLGMODE           = 00800h;
    KF_MENUMODE          = 01000h;
    KF_ALTDOWN           = 02000h;
    KF_REPEAT            = 04000h;
    KF_UP                = 08000h;

    VK_LBUTTON           = 001h;
    VK_RBUTTON           = 002h;
    VK_CANCEL            = 003h;
    VK_MBUTTON           = 004h;
    VK_BACK              = 008h;
    VK_TAB               = 009h;
    VK_CLEAR             = 00Ch;
    VK_RETURN            = 00Dh;
    VK_SHIFT             = 010h;
    VK_CONTROL           = 011h;
    VK_MENU              = 012h;
    VK_PAUSE             = 013h;
    VK_CAPITAL           = 014h;
    VK_KANA           = 15h;
    VK_HANGEUL        = 15h;  (* old name - should be here for compatibility *)
    VK_HANGUL         = 15h;
    VK_JUNJA          = 17h;
    VK_FINAL          = 18h;
    VK_HANJA          = 19h;
    VK_KANJI          = 19h;
    VK_ESCAPE            = 01Bh;
    VK_CONVERT        = 1Ch;
    VK_NONCONVERT     = 1Dh;
    VK_ACCEPT         = 1Eh;
    VK_MODECHANGE     = 1Fh;
    VK_SPACE             = 020h;
    VK_PRIOR             = 021h;
    VK_NEXT              = 022h;
    VK_END               = 023h;
    VK_HOME              = 024h;
    VK_LEFT              = 025h;
    VK_UP                = 026h;
    VK_RIGHT             = 027h;
    VK_DOWN              = 028h;
    VK_SELECT            = 029h;
    VK_PRINT             = 02Ah;
    VK_EXECUTE           = 02Bh;
    VK_SNAPSHOT          = 02Ch;
    VK_INSERT            = 02Dh;
    VK_DELETE            = 02Eh;
    VK_HELP              = 02Fh;

    VK_LWIN              = 05Bh;
    VK_RWIN              = 05Ch;
    VK_APPS              = 05Dh;

    VK_NUMPAD0           = 060h;
    VK_NUMPAD1           = 061h;
    VK_NUMPAD2           = 062h;
    VK_NUMPAD3           = 063h;
    VK_NUMPAD4           = 064h;
    VK_NUMPAD5           = 065h;
    VK_NUMPAD6           = 066h;
    VK_NUMPAD7           = 067h;
    VK_NUMPAD8           = 068h;
    VK_NUMPAD9           = 069h;
    VK_MULTIPLY          = 06Ah;
    VK_ADD               = 06Bh;
    VK_SEPARATOR         = 06Ch;
    VK_SUBTRACT          = 06Dh;
    VK_DECIMAL           = 06Eh;
    VK_DIVIDE            = 06Fh;
    VK_F1                = 070h;
    VK_F2                = 071h;
    VK_F3                = 072h;
    VK_F4                = 073h;
    VK_F5                = 074h;
    VK_F6                = 075h;
    VK_F7                = 076h;
    VK_F8                = 077h;
    VK_F9                = 078h;
    VK_F10               = 079h;
    VK_F11               = 07Ah;
    VK_F12               = 07Bh;
    VK_F13               = 07Ch;
    VK_F14               = 07Dh;
    VK_F15               = 07Eh;
    VK_F16               = 07Fh;
    VK_F17               = 080h;
    VK_F18               = 081h;
    VK_F19               = 082h;
    VK_F20               = 083h;
    VK_F21               = 084h;
    VK_F22               = 085h;
    VK_F23               = 086h;
    VK_F24               = 087h;
    VK_NUMLOCK           = 090h;
    VK_SCROLL            = 091h;
    VK_LSHIFT            = 0A0h;
    VK_RSHIFT            = 0A1h;
    VK_LCONTROL          = 0A2h;
    VK_RCONTROL          = 0A3h;
    VK_LMENU             = 0A4h;
    VK_RMENU             = 0A5h;

    VK_PROCESSKEY        = 0E5h;(*95*)

    VK_ATTN              = 0F6h;
    VK_CRSEL             = 0F7h;
    VK_EXSEL             = 0F8h;
    VK_EREOF             = 0F9h;
    VK_PLAY              = 0FAh;
    VK_ZOOM              = 0FBh;
    VK_NONAME            = 0FCh;
    VK_PA1               = 0FDh;
    VK_OEM_CLEAR         = 0FEh;

    WH_MIN               = ( - 1 ) ;
    WH_MSGFILTER         = ( - 1 ) ;
    WH_JOURNALRECORD     = 0;
    WH_JOURNALPLAYBACK   = 1;
    WH_KEYBOARD          = 2;
    WH_GETMESSAGE        = 3;
    WH_CALLWNDPROC       = 4;
    WH_CBT               = 5;
    WH_SYSMSGFILTER      = 6;
    WH_MOUSE             = 7;
    WH_HARDWARE          = 8;
    WH_DEBUG             = 9;
    WH_SHELL             = 10;
    WH_FOREGROUNDIDLE    = 11;


%IF WIN4 %THEN
    WH_CALLWNDPROCRET    = 12;
    WH_KEYBOARD_LL     =13;(*NT only*)
    WH_MOUSE_LL        =14;(*NT only*)
    WH_MAX               = 14;
%ELSE
    WH_MAX               = 11;
%END

    WH_MINHOOK           = WH_MIN;
    WH_MAXHOOK           = WH_MAX;


    HC_ACTION            = 0;
    HC_GETNEXT           = 1;
    HC_SKIP              = 2;
    HC_NOREMOVE          = 3;
    HC_NOREM             = HC_NOREMOVE;(*95*)
    HC_SYSMODALON        = 4;
    HC_SYSMODALOFF       = 5;

    HCBT_MOVESIZE        = 0;
    HCBT_MINMAX          = 1;
    HCBT_QS              = 2;
    HCBT_CREATEWND       = 3;
    HCBT_DESTROYWND      = 4;
    HCBT_ACTIVATE        = 5;
    HCBT_CLICKSKIPPED    = 6;
    HCBT_KEYSKIPPED      = 7;
    HCBT_SYSCOMMAND      = 8;
    HCBT_SETFOCUS        = 9;

TYPE
    CREATESTRUCTA        = RECORD
        lpCreateParams       : LPVOID;
        hInstance            : HINSTANCE;
        hMenu                : HMENU;
        hwndParent           : HWND;
        cy                   : INTEGER;
        cx                   : INTEGER;
        y                    : INTEGER;
        x                    : INTEGER;
        style                : LONG;
        lpszName             : LPCSTR;
        lpszClass            : LPCSTR;
        dwExStyle            : DWORD;
    END;
    LPCREATESTRUCTA      = POINTER TO CREATESTRUCTA;

    CREATESTRUCTW        = RECORD
        lpCreateParams       : LPVOID;
        hInstance            : HINSTANCE;
        hMenu                : HMENU;
        hwndParent           : HWND;
        cy                   : INTEGER;
        cx                   : INTEGER;
        y                    : INTEGER;
        x                    : INTEGER;
        style                : LONG;
        lpszName             : LPCWSTR;
        lpszClass            : LPCWSTR;
        dwExStyle            : DWORD;
    END;
    LPCREATESTRUCTW      = POINTER TO CREATESTRUCTW;

    %IF UNICODE %THEN
    CREATESTRUCT = CREATESTRUCTW;
    LPCREATESTRUCT = LPCREATESTRUCTW;
    %ELSE
    CREATESTRUCT = CREATESTRUCTA;
    LPCREATESTRUCT = LPCREATESTRUCTA;
    %END

    CBT_CREATEWNDA = RECORD
          lpcs           : POINTER TO CREATESTRUCTA;
          hwndInsertAfter: HWND;
    END;
    LPCBT_CREATEWNDA     = POINTER TO CBT_CREATEWNDA;

    CBT_CREATEWNDW = RECORD
          lpcs           : POINTER TO CREATESTRUCTW;
          hwndInsertAfter: HWND;
    END;
    LPCBT_CREATEWNDW     = POINTER TO CBT_CREATEWNDW;

    %IF UNICODE %THEN
    CBT_CREATEWND        = CBT_CREATEWNDW;
    LPCBT_CREATEWND      = LPCBT_CREATEWNDW;
    %ELSE
    CBT_CREATEWND        = CBT_CREATEWNDA;
    LPCBT_CREATEWND      = LPCBT_CREATEWNDA;
    %END

    CBTACTIVATESTRUCT = RECORD
          fMouse         : BOOL;
          hWndActive     : HWND;
    END;
    LPCBTACTIVATESTRUCT  = POINTER TO CBTACTIVATESTRUCT;

CONST
    MSGF_DIALOGBOX       = 0;
    MSGF_MESSAGEBOX      = 1;
    MSGF_MENU            = 2;
    MSGF_MOVE            = 3;
    MSGF_SIZE            = 4;
    MSGF_SCROLLBAR       = 5;
    MSGF_NEXTWINDOW      = 6;
    MSGF_MAINLOOP        = 8;
    MSGF_MAX             = 8;
    MSGF_USER            = 4096;

    HSHELL_WINDOWCREATED        = 1;
    HSHELL_WINDOWDESTROYED      = 2;
    HSHELL_ACTIVATESHELLWINDOW  = 3;

    HSHELL_WINDOWACTIVATED      = 4;
    HSHELL_GETMINRECT           = 5;
    HSHELL_REDRAW               = 6;
    HSHELL_TASKMAN              = 7;
    HSHELL_LANGUAGE             = 8;

%IF WIN5 %THEN
    HSHELL_ACCESSIBILITYSTATE   = 11;(*NT only*)
       ACCESS_STICKYKEYS            =00001h;(*NT only*)
       ACCESS_FILTERKEYS            =00002h;(*NT only*)
       ACCESS_MOUSEKEYS             =00003h;(*NT only*)
%END


TYPE
    EVENTMSG = RECORD
          message        : UINT;
          paramL         : UINT;
          paramH         : UINT;
          time           : DWORD;
          hwnd           : HWND;
    END;
    PEVENTMSGMSG         = POINTER TO EVENTMSG;
    LPEVENTMSGMSG        = PEVENTMSGMSG;

    PEVENTMSG            = POINTER TO EVENTMSG;
    LPEVENTMSG           = PEVENTMSG;

    CWPSTRUCT = RECORD
          lParam         : LPARAM;
          wParam         : WPARAM;
          message        : DWORD;
          hwnd           : HWND;
    END;
    PCWPSTRUCT           = POINTER TO CWPSTRUCT;
    LPCWPSTRUCT          = PCWPSTRUCT;

    CWPRETSTRUCT = RECORD
        lResult         : LRESULT;
        lParam          : LPARAM;
        wParam          : WPARAM;
        message         : UINT;
        hwnd            : HWND;
    END;
    PCWPRETSTRUCT  = POINTER TO CWPRETSTRUCT;
    LPCWPRETSTRUCT = PCWPRETSTRUCT;

(*
 * Low level hook flags
 *)
CONST
    (*NT only*)
    LLKHF_EXTENDED       = 00000001h;
    LLKHF_INJECTED       = 00000010h;
    LLKHF_ALTDOWN        = 00000020h;
    LLKHF_UP             = 00000080h;

    LLMHF_INJECTED       = 00000001h;

TYPE
(*
 * Structure used by WH_KEYBOARD_LL
 *)
     (*NT only*)
    KBDLLHOOKSTRUCT = RECORD
    vkCode              : DWORD;
    scanCode            : DWORD;
    flags               : DWORD;
    time                : DWORD;
    dwExtraInfo         : DWORD;
    END;
    PKBDLLHOOKSTRUCT = POINTER TO KBDLLHOOKSTRUCT;
    LPKBDLLHOOKSTRUCT = PKBDLLHOOKSTRUCT;

(*
 * Structure used by WH_MOUSE_LL
 *)
     (*NT only*)
    MSLLHOOKSTRUCT = RECORD
    pt          : POINT;
    mouseData   : DWORD;
    flags       : DWORD;
    time        : DWORD;
    dwExtraInfo : DWORD;
    END;
    PMSLLHOOKSTRUCT = POINTER TO MSLLHOOKSTRUCT;
    LPMSLLHOOKSTRUCT = PMSLLHOOKSTRUCT;

    DEBUGHOOKINFO = RECORD
          idThread              : DWORD;
          idThreadInstaller     : DWORD;
          lParam                : LPARAM;
          wParam                : WPARAM;
          code                  : INTEGER;
    END;
    PDEBUGHOOKINFO       = POINTER TO DEBUGHOOKINFO;
    LPDEBUGHOOKINFO      = PDEBUGHOOKINFO;

    MOUSEHOOKSTRUCT = RECORD
          pt             : POINT;
          hwnd           : HWND;
          wHitTestCode   : UINT;
          dwExtraInfo    : DWORD;
    END;
    PMOUSEHOOKSTRUCT     = POINTER TO MOUSEHOOKSTRUCT;
    LPMOUSEHOOKSTRUCT    = PMOUSEHOOKSTRUCT;

    HARDWAREHOOKSTRUCT = RECORD
        hwnd    : HWND;
        message : UINT;
        wParam  : WPARAM;
        lParam  : LPARAM;
    END;
    PHARDWAREHOOKSTRUCT  = POINTER TO HARDWAREHOOKSTRUCT;
    LPHARDWAREHOOKSTRUCT = PHARDWAREHOOKSTRUCT;

CONST
    HKL_PREV             = 0;
    HKL_NEXT             = 1;
    KLF_ACTIVATE         = 000000001h;
    KLF_SUBSTITUTE_OK    = 000000002h;
    KLF_UNLOADPREVIOUS   = 000000004h;
    KLF_REORDER          = 000000008h;
    KLF_REPLACELANG      = 000000010h;
    KLF_NOTELLSHELL      = 000000080h;
    KLF_SETFORPROCESS    = 000000100h;
    KL_NAMELENGTH        = 9;

PROCEDURE LoadKeyboardLayoutA(pwszKLID : ARRAY OF ACHAR;
                              Flags : UINT) : HKL;

PROCEDURE LoadKeyboardLayoutW(pwszKLID : ARRAY OF UCHAR;
                              Flags : UINT) : HKL;

%IF UNICODE %THEN
PROCEDURE LoadKeyboardLayout = LoadKeyboardLayoutW;
%ELSE
PROCEDURE LoadKeyboardLayout = LoadKeyboardLayoutA;
%END

PROCEDURE ActivateKeyboardLayout(hkl : HKL;
                                 Flags : UINT) : BOOL;

PROCEDURE ToUnicodeEx(  wVirtKey : UINT;
                        wScanCode : UINT;
                        lpKeyState : PBYTE;
                        VAR pwszBuff : ARRAY OF UCHAR;
                        cchBuff : WINT;
                        wFlags : UINT;
                        dwhkl : HKL) : WINT;

PROCEDURE UnloadKeyboardLayout(hkl : HKL) : BOOL;

PROCEDURE GetKeyboardLayoutNameA(VAR pwszKLID : ARRAY OF ACHAR) : BOOL;

PROCEDURE GetKeyboardLayoutNameW(VAR pwszKLID : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetKeyboardLayoutName = GetKeyboardLayoutNameW;
%ELSE
PROCEDURE GetKeyboardLayoutName = GetKeyboardLayoutNameA;
%END



PROCEDURE GetKeyboardLayoutList(nBuff : WINT; VAR lpList : HKL) : WINT;

PROCEDURE GetKeyboardLayout(dwLayout : DWORD) : HKL;

%IF WIN5 %THEN
TYPE
    MOUSEMOVEPOINT = RECORD
    x           : WINT;
    y           : WINT;
    time        : DWORD;
    dwExtraInfo : DWORD;
    END;
    PMOUSEMOVEPOINT  = POINTER TO MOUSEMOVEPOINT;
    LPMOUSEMOVEPOINT = PMOUSEMOVEPOINT;

(*
 * Values for resolution parameter of GetMouseMovePoints
 *)
CONST
    GMMP_USE_DISPLAY_POINTS   =1;
    GMMP_USE_DRIVER_POINTS    =2;

PROCEDURE GetMouseMovePoints(cbSize : UINT;
                             VAR lpp : MOUSEMOVEPOINT;
                             VAR lpptBuf : ARRAY OF MOUSEMOVEPOINT;
                             nBufPoints : WINT;
                             resolution : DWORD) : WINT;

%END

CONST
    DESKTOP_READOBJECTS         = 00001h;
    DESKTOP_CREATEWINDOW        = 00002h;
    DESKTOP_CREATEMENU          = 00004h;
    DESKTOP_HOOKCONTROL         = 00008h;
    DESKTOP_JOURNALRECORD       = 00010h;
    DESKTOP_JOURNALPLAYBACK     = 00020h;
    DESKTOP_ENUMERATE           = 00040h;
    DESKTOP_WRITEOBJECTS        = 00080h;
    DESKTOP_SWITCHDESKTOP       = 00100h;

    DF_ALLOWOTHERACCOUNTHOOK    = 1;

PROCEDURE CreateDesktopA(lpszDesktop : ARRAY OF ACHAR;
                         lpszDevice : ARRAY OF ACHAR;
                         pDevmode : DEVMODEA;
                         dwFlags : DWORD;
                         dwDesiredAccess : DWORD;
                         lpsa : LPSECURITY_ATTRIBUTES) : HDESK;

PROCEDURE CreateDesktopW(lpszDesktop : ARRAY OF UCHAR;
                         lpszDevice : ARRAY OF UCHAR;
                         pDevmode : DEVMODEW;
                         dwFlags : DWORD;
                         dwDesiredAccess : DWORD;
                         lpsa : LPSECURITY_ATTRIBUTES) : HDESK;
%IF UNICODE %THEN
PROCEDURE CreateDesktop = CreateDesktopW;
%ELSE
PROCEDURE CreateDesktop = CreateDesktopA;
%END

PROCEDURE OpenDesktopA(lpszDesktop : ARRAY OF ACHAR;
                       dwFlags : DWORD;
                       fInherit : BOOL;
                       dwDesiredAccess : DWORD) : HDESK;

PROCEDURE OpenDesktopW(lpszDesktop : ARRAY OF UCHAR;
                       dwFlags : DWORD;
                       fInherit : BOOL;
                       dwDesiredAccess : DWORD) : HDESK;

%IF UNICODE %THEN
PROCEDURE OpenDesktop = OpenDesktopW;
%ELSE
PROCEDURE OpenDesktop = OpenDesktopA;
%END

PROCEDURE OpenInputDesktop(dwFlags : DWORD;
                           fInherit : BOOL;
                           dwDesiredAccess : DWORD) : HDESK;

PROCEDURE EnumDesktopsA(hwinsta : HWINSTA;
                        lpEnumFunc : DESKTOPENUMPROCA;
                        lParam : LPARAM) : BOOL;

PROCEDURE EnumDesktopsW(hwinsta : HWINSTA;
                        lpEnumFunc : DESKTOPENUMPROCW;
                        lParam : LPARAM) : BOOL;

%IF UNICODE %THEN
PROCEDURE EnumDesktops = EnumDesktopsW;
%ELSE
PROCEDURE EnumDesktops = EnumDesktopsA;
%END

PROCEDURE EnumDesktopWindows(hDesktop : HDESK;
                             lpfn : WNDENUMPROC;
                             lParam : LPARAM) : BOOL;

PROCEDURE SwitchDesktop(hDesktop : HDESK) : BOOL;

PROCEDURE SetThreadDesktop(hDesktop : HDESK) : BOOL;

PROCEDURE CloseDesktop(hDesktop : HDESK) : BOOL;

PROCEDURE GetThreadDesktop(a : DWORD) : HDESK;

CONST
    WINSTA_ENUMDESKTOPS  = 00001h;
    WINSTA_READATTRIBUTES= 00002h;
    WINSTA_ACCESSCLIPBOARD= 00004h;
    WINSTA_CREATEDESKTOP = 00008h;
    WINSTA_WRITEATTRIBUTES= 00010h;
    WINSTA_ACCESSGLOBALATOMS= 00020h;
    WINSTA_EXITWINDOWS   = 00040h;
    WINSTA_ENUMERATE     = 00100h;
    WINSTA_READSCREEN    = 00200h;
    WSF_VISIBLE          = 1;

PROCEDURE CreateWindowStationA(lpwinsta : ARRAY OF ACHAR;
                               dwReserved : DWORD;
                               dwDesiredAccess : DWORD;
                               lpsa : LPSECURITY_ATTRIBUTES) : HWINSTA;

PROCEDURE CreateWindowStationW(lpwinsta : ARRAY OF UCHAR;
                               dwReserved : DWORD;
                               dwDesiredAccess : DWORD;
                               lpsa : LPSECURITY_ATTRIBUTES) : HWINSTA;

%IF UNICODE %THEN
PROCEDURE CreateWindowStation = CreateWindowStationW;
%ELSE
PROCEDURE CreateWindowStation = CreateWindowStationA;
%END

PROCEDURE OpenWindowStationA(lpszWinSta : ARRAY OF ACHAR;
                             fInherit : BOOL;
                             dwDesiredAccess : DWORD) : HWINSTA;

PROCEDURE OpenWindowStationW(lpszWinSta : ARRAY OF UCHAR;
                             fInherit : BOOL;
                             dwDesiredAccess : DWORD) : HWINSTA;

%IF UNICODE %THEN
PROCEDURE OpenWindowStation = OpenWindowStationW;
%ELSE
PROCEDURE OpenWindowStation = OpenWindowStationA;
%END
PROCEDURE EnumWindowStationsW(lpEnumFunc : WINSTAENUMPROCW;
                              lParam : LPARAM) : BOOL;

PROCEDURE EnumWindowStationsA(lpEnumFunc : WINSTAENUMPROCA;
                              lParam : LPARAM) : BOOL;
%IF UNICODE %THEN
PROCEDURE EnumWindowStations = EnumWindowStationsW;
%ELSE
PROCEDURE EnumWindowStations = EnumWindowStationsA;
%END

PROCEDURE CloseWindowStation(hWinSta : HWINSTA) : BOOL;

PROCEDURE SetProcessWindowStation(hWinSta : HWINSTA) : BOOL;

PROCEDURE GetProcessWindowStation() : HWINSTA;

PROCEDURE SetUserObjectSecurity(hObj : HANDLE;
                                pSIRequested : PSECURITY_INFORMATION;
                                pSID : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE GetUserObjectSecurity(hObj : HANDLE;
                                pSIRequested : PSECURITY_INFORMATION;
                                pSID : PSECURITY_DESCRIPTOR;
                                nLength : DWORD;
                                VAR lpnLengthNeeded : DWORD) : BOOL;

CONST
    UOI_FLAGS            = 1;
    UOI_NAME             = 2;
    UOI_TYPE             = 3;
    UOI_USER_SID    = 4;

TYPE
    USEROBJECTFLAGS = RECORD
        fInherit        : BOOL;
        fReserved       : BOOL;
        dwFlags         : DWORD;
    END;
    PUSEROBJECTFLAGS    = POINTER TO USEROBJECTFLAGS;

PROCEDURE GetUserObjectInformationA(hObj : HANDLE;
                                    nIndex : WINT;
                                    pvInfo : PVOID;
                                    nLength : DWORD;
                                    VAR lpnLengthNeeded : DWORD) : BOOL;

PROCEDURE GetUserObjectInformationW(hObj : HANDLE;
                                    nIndex : WINT;
                                    pvInfo : PVOID;
                                    nLength : DWORD;
                                    VAR lpnLengthNeeded : DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE GetUserObjectInformation = GetUserObjectInformationW;
%ELSE
PROCEDURE GetUserObjectInformation = GetUserObjectInformationA;
%END

PROCEDURE SetUserObjectInformationA(hObj : HANDLE;
                                    nIndex : WINT;
                                    pvInfo : PVOID;
                                    nLength : DWORD) : BOOL;

PROCEDURE SetUserObjectInformationW(hObj : HANDLE;
                                    nIndex : WINT;
                                    pvInfo : PVOID;
                                    nLength : DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE SetUserObjectInformation = SetUserObjectInformationW;
%ELSE
PROCEDURE SetUserObjectInformation = SetUserObjectInformationA;
%END

TYPE
    WNDCLASSA = RECORD
          style          : UINT;
          lpfnWndProc    : WNDPROC;
          cbClsExtra     : INTEGER;
          cbWndExtra     : INTEGER;
          hInstance      : HINSTANCE;
          hIcon          : HICON;
          hCursor        : HCURSOR;
          hbrBackground  : HBRUSH;
          lpszMenuName   : LPCSTR;
          lpszClassName  : LPCSTR;
    END;
    PWNDCLASSA           = POINTER TO WNDCLASSA;
    LPWNDCLASSA          = PWNDCLASSA;

    WNDCLASSW = RECORD
          style          : UINT;
          lpfnWndProc    : WNDPROC;
          cbClsExtra     : INTEGER;
          cbWndExtra     : INTEGER;
          hInstance      : HINSTANCE;
          hIcon          : HICON;
          hCursor        : HCURSOR;
          hbrBackground  : HBRUSH;
          lpszMenuName   : LPCWSTR;
          lpszClassName  : LPCWSTR;
    END;
    PWNDCLASSW           = POINTER TO WNDCLASSW;
    LPWNDCLASSW          = PWNDCLASSW;

    %IF UNICODE %THEN
    WNDCLASS             = WNDCLASSW;
    PWNDCLASS            = PWNDCLASSW;
    %ELSE
    WNDCLASS             = WNDCLASSA;
    PWNDCLASS            = PWNDCLASSA;
    %END
    LPWNDCLASS           = PWNDCLASS;

    MSG = RECORD
          hwnd           : HWND;
          message        : UINT;
          wParam         : WPARAM;
          lParam         : LPARAM;
          time           : DWORD;
          pt             : POINT;
    END;
    PMSG                 = POINTER TO MSG;
    LPMSG                = PMSG;


CONST
    GWL_WNDPROC          = - 4;
    GWL_HINSTANCE        = - 6;
    GWL_HWNDPARENT       = - 8;
    GWL_STYLE            = - 16;
    GWL_EXSTYLE          = - 20;
    GWL_USERDATA         = - 21;
    GWL_ID               = - 12;
    GCL_MENUNAME         = - 8;
    GCL_HBRBACKGROUND    = - 10;
    GCL_HCURSOR          = - 12;
    GCL_HICON            = - 14;
    GCL_HMODULE          = - 16;
    GCL_CBWNDEXTRA       = - 18;
    GCL_CBCLSEXTRA       = - 20;
    GCL_WNDPROC          = - 24;
    GCL_STYLE            = - 26;
    GCW_ATOM             = - 32;

    GCL_HICONSM          = - 34;(*95*)

    WM_NULL              = 00000h;
    WM_CREATE            = 00001h;
    WM_DESTROY           = 00002h;
    WM_MOVE              = 00003h;
    WM_SIZE              = 00005h;
    WM_ACTIVATE          = 00006h;
    WA_INACTIVE          = 0;
    WA_ACTIVE            = 1;
    WA_CLICKACTIVE       = 2;
    WM_SETFOCUS          = 00007h;
    WM_KILLFOCUS         = 00008h;
    WM_ENABLE            = 0000Ah;
    WM_SETREDRAW         = 0000Bh;
    WM_SETTEXT           = 0000Ch;
    WM_GETTEXT           = 0000Dh;
    WM_GETTEXTLENGTH     = 0000Eh;
    WM_PAINT             = 0000Fh;
    WM_CLOSE             = 00010h;
    WM_QUERYENDSESSION   = 00011h;
    WM_QUIT              = 00012h;
    WM_QUERYOPEN         = 00013h;
    WM_ERASEBKGND        = 00014h;
    WM_SYSCOLORCHANGE    = 00015h;
    WM_ENDSESSION        = 00016h;
    WM_SHOWWINDOW        = 00018h;
    WM_WININICHANGE      = 0001Ah;

    WM_SETTINGCHANGE     = WM_WININICHANGE;(*95*)

    WM_DEVMODECHANGE     = 0001Bh;
    WM_ACTIVATEAPP       = 0001Ch;
    WM_FONTCHANGE        = 0001Dh;
    WM_TIMECHANGE        = 0001Eh;
    WM_CANCELMODE        = 0001Fh;
    WM_SETCURSOR         = 00020h;
    WM_MOUSEACTIVATE     = 00021h;
    WM_CHILDACTIVATE     = 00022h;
    WM_QUEUESYNC         = 00023h;
    WM_GETMINMAXINFO     = 00024h;

TYPE
    MINMAXINFO = RECORD
          ptReserved     : POINT;
          ptMaxSize      : POINT;
          ptMaxPosition  : POINT;
          ptMinTrackSize : POINT;
          ptMaxTrackSize : POINT;
    END;
    PMINMAXINFO          = POINTER TO MINMAXINFO;
    LPMINMAXINFO         = PMINMAXINFO;

CONST
    WM_PAINTICON         = 00026h;
    WM_ICONERASEBKGND    = 00027h;
    WM_NEXTDLGCTL        = 00028h;
    WM_SPOOLERSTATUS     = 0002Ah;
    WM_DRAWITEM          = 0002Bh;
    WM_MEASUREITEM       = 0002Ch;
    WM_DELETEITEM        = 0002Dh;
    WM_VKEYTOITEM        = 0002Eh;
    WM_CHARTOITEM        = 0002Fh;
    WM_SETFONT           = 00030h;
    WM_GETFONT           = 00031h;
    WM_SETHOTKEY         = 00032h;
    WM_GETHOTKEY         = 00033h;
    WM_QUERYDRAGICON     = 00037h;
    WM_COMPAREITEM       = 00039h;
    %IF WIN5 %THEN
    WM_GETOBJECT                    = 003Dh;
    %END
    WM_COMPACTING        = 00041h;
    WM_OTHERWINDOWCREATED= 00042h;
    WM_OTHERWINDOWDESTROYED= 00043h;
    WM_COMMNOTIFY        = 00044h;
    WM_WINDOWPOSCHANGING = 00046h;
    WM_WINDOWPOSCHANGED  = 00047h;
    WM_POWER             = 00048h;
    PWR_OK               = 1;
    PWR_FAIL             = ( - 1 ) ;
    PWR_SUSPENDREQUEST   = 1;
    PWR_SUSPENDRESUME    = 2;
    PWR_CRITICALRESUME   = 3;
    WM_COPYDATA          = 0004Ah;
    WM_CANCELJOURNAL     = 0004Bh;

TYPE
    COPYDATASTRUCT = RECORD
          dwData         : DWORD;
          cbData         : DWORD;
          lpData         : PVOID;
    END;
    PCOPYDATASTRUCT      = POINTER TO COPYDATASTRUCT;


CONST

    WM_NOTIFY                       = 004Eh;
    WM_INPUTLANGCHANGEREQUEST       = 0050h;
    WM_INPUTLANGCHANGE              = 0051h;
    WM_TCARD                        = 0052h;
    WM_HELP                         = 0053h;
    WM_USERCHANGED                  = 0054h;
    WM_NOTIFYFORMAT                 = 0055h;

    NFR_ANSI                             = 1;
    NFR_UNICODE                          = 2;
    NF_QUERY                             = 3;
    NF_REQUERY                           = 4;

    WM_CONTEXTMENU                  = 007Bh;
    WM_STYLECHANGING                = 007Ch;
    WM_STYLECHANGED                 = 007Dh;
    WM_DISPLAYCHANGE                = 007Eh;
    WM_GETICON                      = 007Fh;
    WM_SETICON                      = 0080h;


    WM_NCCREATE          = 00081h;
    WM_NCDESTROY         = 00082h;
    WM_NCCALCSIZE        = 00083h;
    WM_NCHITTEST         = 00084h;
    WM_NCPAINT           = 00085h;
    WM_NCACTIVATE        = 00086h;
    WM_GETDLGCODE        = 00087h;
    WM_SYNCPAINT         = 00088h;
    WM_NCMOUSEMOVE       = 000A0h;
    WM_NCLBUTTONDOWN     = 000A1h;
    WM_NCLBUTTONUP       = 000A2h;
    WM_NCLBUTTONDBLCLK   = 000A3h;
    WM_NCRBUTTONDOWN     = 000A4h;
    WM_NCRBUTTONUP       = 000A5h;
    WM_NCRBUTTONDBLCLK   = 000A6h;
    WM_NCMBUTTONDOWN     = 000A7h;
    WM_NCMBUTTONUP       = 000A8h;
    WM_NCMBUTTONDBLCLK   = 000A9h;
    WM_KEYFIRST          = 00100h;
    WM_KEYDOWN           = 00100h;
    WM_KEYUP             = 00101h;
    WM_CHAR              = 00102h;
    WM_DEADCHAR          = 00103h;
    WM_SYSKEYDOWN        = 00104h;
    WM_SYSKEYUP          = 00105h;
    WM_SYSCHAR           = 00106h;
    WM_SYSDEADCHAR       = 00107h;
    WM_KEYLAST           = 00108h;


    WM_IME_STARTCOMPOSITION         = 010Dh;
    WM_IME_ENDCOMPOSITION           = 010Eh;
    WM_IME_COMPOSITION              = 010Fh;
    WM_IME_KEYLAST                  = 010Fh;


    WM_INITDIALOG        = 00110h;
    WM_COMMAND           = 00111h;
    WM_SYSCOMMAND        = 00112h;
    WM_TIMER             = 00113h;
    WM_HSCROLL           = 00114h;
    WM_VSCROLL           = 00115h;
    WM_INITMENU          = 00116h;
    WM_INITMENUPOPUP     = 00117h;
    WM_MENUSELECT        = 0011Fh;
    WM_MENUCHAR          = 00120h;
    WM_ENTERIDLE         = 00121h;
    %IF WIN5 %THEN
    WM_MENURBUTTONUP     = 00122h;
    WM_MENUDRAG          = 00123h;
    WM_MENUGETOBJECT     = 00124h;
    WM_UNINITMENUPOPUP   = 00125h;
    WM_MENUCOMMAND       = 00126h;
    %END
    WM_CTLCOLORMSGBOX    = 00132h;
    WM_CTLCOLOREDIT      = 00133h;
    WM_CTLCOLORLISTBOX   = 00134h;
    WM_CTLCOLORBTN       = 00135h;
    WM_CTLCOLORDLG       = 00136h;
    WM_CTLCOLORSCROLLBAR = 00137h;
    WM_CTLCOLORSTATIC    = 00138h;
    WM_MOUSEFIRST        = 00200h;
    WM_MOUSEMOVE         = 00200h;
    WM_LBUTTONDOWN       = 00201h;
    WM_LBUTTONUP         = 00202h;
    WM_LBUTTONDBLCLK     = 00203h;
    WM_RBUTTONDOWN       = 00204h;
    WM_RBUTTONUP         = 00205h;
    WM_RBUTTONDBLCLK     = 00206h;
    WM_MBUTTONDOWN       = 00207h;
    WM_MBUTTONUP         = 00208h;
    WM_MBUTTONDBLCLK     = 00209h;
    WM_MOUSEWHEEL        = 0020Ah;
    WM_MOUSELAST         = 0020Ah;

    WHEEL_DELTA          = 120;   (* Value for rolling one detent *)
    WHEEL_PAGESCROLL     = MAX(UINT); (* Scroll one page *)

    WM_PARENTNOTIFY      = 00210h;
    MENULOOP_WINDOW      = 0;
    MENULOOP_POPUP       = 1;
    WM_ENTERMENULOOP     = 00211h;
    WM_EXITMENULOOP      = 00212h;


    WM_NEXTMENU          = 00213h;

TYPE
    MDINEXTMENU = RECORD
        hmenuIn         : HMENU;
        hmenuNext       : HMENU;
        hwndNext        : HWND;
    END;
    PMDINEXTMENU        = POINTER TO MDINEXTMENU;
    LPMDINEXTMENU       = PMDINEXTMENU;

CONST
    WM_SIZING                       = 0214h;
    WM_CAPTURECHANGED               = 0215h;
    WM_MOVING                       = 0216h;
    WM_POWERBROADCAST               = 0218h;

    PBT_APMQUERYSUSPEND             = 0000h;
    PBT_APMQUERYSTANDBY             = 0001h;

    PBT_APMQUERYSUSPENDFAILED       = 0002h;
    PBT_APMQUERYSTANDBYFAILED       = 0003h;

    PBT_APMSUSPEND                  = 0004h;
    PBT_APMSTANDBY                  = 0005h;

    PBT_APMRESUMECRITICAL           = 0006h;
    PBT_APMRESUMESUSPEND            = 0007h;
    PBT_APMRESUMESTANDBY            = 0008h;

    PBTF_APMRESUMEFROMFAILURE       = 00000001h;

    PBT_APMBATTERYLOW               = 0009h;
    PBT_APMPOWERSTATUSCHANGE        = 000Ah;

    PBT_APMOEMEVENT                 = 000Bh;
    PBT_APMRESUMEAUTOMATIC          = 0012h;

    WM_DEVICECHANGE                 = 0219h;

    WM_IME_SETCONTEXT               = 0281h;
    WM_IME_NOTIFY                   = 0282h;
    WM_IME_CONTROL                  = 0283h;
    WM_IME_COMPOSITIONFULL          = 0284h;
    WM_IME_SELECT                   = 0285h;
    WM_IME_CHAR                     = 0286h;
%IF WIN5 %THEN
    WM_IME_REQUEST                  = 0288h;
%END
    WM_IME_KEYDOWN                  = 0290h;
    WM_IME_KEYUP                    = 0291h;


    WM_MDICREATE         = 00220h;
    WM_MDIDESTROY        = 00221h;
    WM_MDIACTIVATE       = 00222h;
    WM_MDIRESTORE        = 00223h;
    WM_MDINEXT           = 00224h;
    WM_MDIMAXIMIZE       = 00225h;
    WM_MDITILE           = 00226h;
    WM_MDICASCADE        = 00227h;
    WM_MDIICONARRANGE    = 00228h;
    WM_MDIGETACTIVE      = 00229h;
    WM_MDISETMENU        = 00230h;
    WM_ENTERSIZEMOVE     = 00231h;
    WM_EXITSIZEMOVE      = 00232h;
    WM_DROPFILES         = 00233h;
    WM_MDIREFRESHMENU    = 00234h;
    WM_CUT               = 00300h;
    WM_COPY              = 00301h;
    WM_PASTE             = 00302h;
    WM_CLEAR             = 00303h;
    WM_UNDO              = 00304h;
    WM_RENDERFORMAT      = 00305h;
    WM_RENDERALLFORMATS  = 00306h;
    WM_DESTROYCLIPBOARD  = 00307h;
    WM_DRAWCLIPBOARD     = 00308h;
    WM_PAINTCLIPBOARD    = 00309h;
    WM_VSCROLLCLIPBOARD  = 0030Ah;
    WM_SIZECLIPBOARD     = 0030Bh;
    WM_ASKCBFORMATNAME   = 0030Ch;
    WM_CHANGECBCHAIN     = 0030Dh;
    WM_HSCROLLCLIPBOARD  = 0030Eh;
    WM_QUERYNEWPALETTE   = 0030Fh;
    WM_PALETTEISCHANGING = 00310h;
    WM_PALETTECHANGED    = 00311h;
    WM_HOTKEY            = 00312h;

    WM_PRINT             = 00317h;
    WM_PRINTCLIENT       = 00318h;

    WM_HANDHELDFIRST     = 00358h;
    WM_HANDHELDLAST      = 0035Fh;

    WM_AFXFIRST          = 00360h;
    WM_AFXLAST           = 0037Fh;

    WM_PENWINFIRST       = 00380h;
    WM_PENWINLAST        = 0038Fh;

    WM_APP               = 08000h;(*95*)

    WM_USER              = 00400h;


    WMSZ_LEFT           = 1;
    WMSZ_RIGHT          = 2;
    WMSZ_TOP            = 3;
    WMSZ_TOPLEFT        = 4;
    WMSZ_TOPRIGHT       = 5;
    WMSZ_BOTTOM         = 6;
    WMSZ_BOTTOMLEFT     = 7;
    WMSZ_BOTTOMRIGHT    = 8;


    ST_BEGINSWP          = 0;
    ST_ENDSWP            = 1;
    HTERROR              = -2;
    HTTRANSPARENT        = -1;
    HTNOWHERE            = 0;
    HTCLIENT             = 1;
    HTCAPTION            = 2;
    HTSYSMENU            = 3;
    HTGROWBOX            = 4;
    HTSIZE               = HTGROWBOX;(*95*)
    HTMENU               = 5;
    HTHSCROLL            = 6;
    HTVSCROLL            = 7;
    HTMINBUTTON          = 8;
    HTMAXBUTTON          = 9;
    HTLEFT               = 10;
    HTRIGHT              = 11;
    HTTOP                = 12;
    HTTOPLEFT            = 13;
    HTTOPRIGHT           = 14;
    HTBOTTOM             = 15;
    HTBOTTOMLEFT         = 16;
    HTBOTTOMRIGHT        = 17;
    HTBORDER             = 18;

    HTREDUCE             = HTMINBUTTON;
    HTZOOM               = HTMAXBUTTON;
    HTSIZEFIRST          = HTLEFT;
    HTSIZELAST           = HTBOTTOMRIGHT;
    HTOBJECT             = 19;
    HTCLOSE              = 20;
    HTHELP               = 21;


    SMTO_NORMAL          = 00000h;
    SMTO_BLOCK           = 00001h;
    SMTO_ABORTIFHUNG     = 00002h;
%IF WIN5 %THEN
    SMTO_NOTIMEOUTIFNOTHUNG = 00008h;
%END

    MA_ACTIVATE          = 1;
    MA_ACTIVATEANDEAT    = 2;
    MA_NOACTIVATE        = 3;
    MA_NOACTIVATEANDEAT  = 4;

(*
 * WM_SETICON / WM_GETICON Type Codes
 *)
    ICON_SMALL          =0;
    ICON_BIG            =1;

PROCEDURE RegisterWindowMessageA(lpString : ARRAY OF ACHAR) : UINT;

PROCEDURE RegisterWindowMessageW(lpString : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE RegisterWindowMessage = RegisterWindowMessageW;
%ELSE
PROCEDURE RegisterWindowMessage = RegisterWindowMessageA;
%END

CONST
    SIZE_RESTORED        = 0;
    SIZE_MINIMIZED       = 1;
    SIZE_MAXIMIZED       = 2;
    SIZE_MAXSHOW         = 3;
    SIZE_MAXHIDE         = 4;
    SIZENORMAL           = SIZE_RESTORED;
    SIZEICONIC           = SIZE_MINIMIZED;
    SIZEFULLSCREEN       = SIZE_MAXIMIZED;
    SIZEZOOMSHOW         = SIZE_MAXSHOW;
    SIZEZOOMHIDE         = SIZE_MAXHIDE;


TYPE
    WINDOWPOS = RECORD
          hwnd           : HWND;
          hwndInsertAfter: HWND;
          x              : INTEGER;
          y              : INTEGER;
          cx             : INTEGER;
          cy             : INTEGER;
          flags          : UINT;
    END;
    PWINDOWPOS           = POINTER TO WINDOWPOS;
    LPWINDOWPOS          = PWINDOWPOS;


    NCCALCSIZE_PARAMS = RECORD
          rgrc           : ARRAY [0..3 - 1] OF RECT;
          lppos          : PWINDOWPOS;
    END;
    LPNCCALCSIZE_PARAMS  = POINTER TO NCCALCSIZE_PARAMS;

CONST
    WVR_ALIGNTOP         = 00010h;
    WVR_ALIGNLEFT        = 00020h;
    WVR_ALIGNBOTTOM      = 00040h;
    WVR_ALIGNRIGHT       = 00080h;
    WVR_HREDRAW          = 00100h;
    WVR_VREDRAW          = 00200h;
    WVR_REDRAW           = ( WVR_HREDRAW BOR WVR_VREDRAW ) ;
    WVR_VALIDRECTS       = 00400h;

    MK_LBUTTON           = 00001h;
    MK_RBUTTON           = 00002h;
    MK_SHIFT             = 00004h;
    MK_CONTROL           = 00008h;
    MK_MBUTTON           = 00010h;

    TME_HOVER       =000000001h;
    TME_LEAVE       =000000002h;
    TME_QUERY       =040000000h;
    TME_CANCEL      =080000000h;


    HOVER_DEFAULT   =0FFFFFFFFh;

TYPE
    TRACKMOUSEEVENT = RECORD
    cbSize : DWORD;
    dwFlags : DWORD;
    hwndTrack : HWND;
    dwHoverTime : DWORD;
    END;
    LPTRACKMOUSEEVENT = TRACKMOUSEEVENT;


PROCEDURE TrackMouseEvent(VAR lpEventTrack : TRACKMOUSEEVENT) : BOOL;

CONST
    WS_OVERLAPPED        = 000000000h;
    WS_POPUP             = 080000000h;
    WS_CHILD             = 040000000h;
    WS_MINIMIZE          = 020000000h;
    WS_VISIBLE           = 010000000h;
    WS_DISABLED          = 008000000h;
    WS_CLIPSIBLINGS      = 004000000h;
    WS_CLIPCHILDREN      = 002000000h;
    WS_MAXIMIZE          = 001000000h;
    WS_CAPTION           = 000C00000h;
    WS_BORDER            = 000800000h;
    WS_DLGFRAME          = 000400000h;
    WS_VSCROLL           = 000200000h;
    WS_HSCROLL           = 000100000h;
    WS_SYSMENU           = 000080000h;
    WS_THICKFRAME        = 000040000h;
    WS_GROUP             = 000020000h;
    WS_TABSTOP           = 000010000h;
    WS_MINIMIZEBOX       = 000020000h;
    WS_MAXIMIZEBOX       = 000010000h;
    WS_TILED             = WS_OVERLAPPED;
    WS_ICONIC            = WS_MINIMIZE;
    WS_SIZEBOX           = WS_THICKFRAME;

    WS_OVERLAPPEDWINDOW  =   WS_OVERLAPPED BOR
                             WS_CAPTION BOR
                             WS_SYSMENU BOR
                             WS_THICKFRAME BOR
                             WS_MINIMIZEBOX BOR
                             WS_MAXIMIZEBOX;

    WS_POPUPWINDOW       = WS_POPUP BOR WS_BORDER BOR WS_SYSMENU;

    WS_TILEDWINDOW       = WS_OVERLAPPEDWINDOW;

    WS_CHILDWINDOW       = WS_CHILD;

    WS_EX_DLGMODALFRAME  = 000000001h;
    WS_EX_NOPARENTNOTIFY = 000000004h;
    WS_EX_TOPMOST        = 000000008h;
    WS_EX_ACCEPTFILES    = 000000010h;
    WS_EX_TRANSPARENT    = 000000020h;


    WS_EX_MDICHILD          = 00000040h;
    WS_EX_TOOLWINDOW        = 00000080h;
    WS_EX_WINDOWEDGE        = 00000100h;
    WS_EX_CLIENTEDGE        = 00000200h;
    WS_EX_CONTEXTHELP       = 00000400h;

    WS_EX_RIGHT             = 00001000h;
    WS_EX_LEFT              = 00000000h;
    WS_EX_RTLREADING        = 00002000h;
    WS_EX_LTRREADING        = 00000000h;
    WS_EX_LEFTSCROLLBAR     = 00004000h;
    WS_EX_RIGHTSCROLLBAR    = 00000000h;

    WS_EX_CONTROLPARENT     = 00010000h;
    WS_EX_STATICEDGE        = 00020000h;
    WS_EX_APPWINDOW         = 00040000h;

    WS_EX_OVERLAPPEDWINDOW  = (WS_EX_WINDOWEDGE BOR WS_EX_CLIENTEDGE);
    WS_EX_PALETTEWINDOW     = (WS_EX_WINDOWEDGE BOR
                               WS_EX_TOOLWINDOW BOR
                               WS_EX_TOPMOST);


    CS_VREDRAW           = 00001h;
    CS_HREDRAW           = 00002h;
    CS_KEYCVTWINDOW      = 00004h;
    CS_DBLCLKS           = 00008h;
    CS_OWNDC             = 00020h;
    CS_CLASSDC           = 00040h;
    CS_PARENTDC          = 00080h;
    CS_NOKEYCVT          = 00100h;
    CS_NOCLOSE           = 00200h;
    CS_SAVEBITS          = 00800h;
    CS_BYTEALIGNCLIENT   = 01000h;
    CS_BYTEALIGNWINDOW   = 02000h;
    CS_GLOBALCLASS       = 04000h;


    CS_IME              = 00010000h;

    PRF_CHECKVISIBLE    = 00000001h;
    PRF_NONCLIENT       = 00000002h;
    PRF_CLIENT          = 00000004h;
    PRF_ERASEBKGND      = 00000008h;
    PRF_CHILDREN        = 00000010h;
    PRF_OWNED           = 00000020h;

    BDR_RAISEDOUTER = 0001h;
    BDR_SUNKENOUTER = 0002h;
    BDR_RAISEDINNER = 0004h;
    BDR_SUNKENINNER = 0008h;

    BDR_OUTER       = 0003h;
    BDR_INNER       = 000ch;
    BDR_RAISED      = 0005h;
    BDR_SUNKEN      = 000ah;

    EDGE_RAISED     = (BDR_RAISEDOUTER BOR BDR_RAISEDINNER);
    EDGE_SUNKEN     = (BDR_SUNKENOUTER BOR BDR_SUNKENINNER);
    EDGE_ETCHED     = (BDR_SUNKENOUTER BOR BDR_RAISEDINNER);
    EDGE_BUMP       = (BDR_RAISEDOUTER BOR BDR_SUNKENINNER);

    BF_LEFT         = 0001h;
    BF_TOP          = 0002h;
    BF_RIGHT        = 0004h;
    BF_BOTTOM       = 0008h;

    BF_TOPLEFT      = (BF_TOP BOR BF_LEFT);
    BF_TOPRIGHT     = (BF_TOP BOR BF_RIGHT);
    BF_BOTTOMLEFT   = (BF_BOTTOM BOR BF_LEFT);
    BF_BOTTOMRIGHT  = (BF_BOTTOM BOR BF_RIGHT);
    BF_RECT         = (BF_LEFT BOR BF_TOP BOR BF_RIGHT BOR BF_BOTTOM);

    BF_DIAGONAL     = 0010h;

    BF_DIAGONAL_ENDTOPRIGHT     = (BF_DIAGONAL BOR BF_TOP BOR BF_RIGHT);
    BF_DIAGONAL_ENDTOPLEFT      = (BF_DIAGONAL BOR BF_TOP BOR BF_LEFT);
    BF_DIAGONAL_ENDBOTTOMLEFT   = (BF_DIAGONAL BOR BF_BOTTOM BOR BF_LEFT);
    BF_DIAGONAL_ENDBOTTOMRIGHT  = (BF_DIAGONAL BOR BF_BOTTOM BOR BF_RIGHT);

    BF_MIDDLE       = 0800h;
    BF_SOFT         = 1000h;
    BF_ADJUST       = 2000h;
    BF_FLAT         = 4000h;
    BF_MONO         = 8000h;

PROCEDURE DrawEdge(hdc: HDC;
                   qrc: RECT;
                   edge: UINT;
                   grfFlags: UINT) : BOOL;

CONST
    DFC_CAPTION             = 1;
    DFC_MENU                = 2;
    DFC_SCROLL              = 3;
    DFC_BUTTON              = 4;
%IF WIN5 %THEN
    DFC_POPUPMENU           = 5;
%END

    DFCS_CAPTIONCLOSE       = 0000h;
    DFCS_CAPTIONMIN         = 0001h;
    DFCS_CAPTIONMAX         = 0002h;
    DFCS_CAPTIONRESTORE     = 0003h;
    DFCS_CAPTIONHELP        = 0004h;

    DFCS_MENUARROW          = 0000h;
    DFCS_MENUCHECK          = 0001h;
    DFCS_MENUBULLET         = 0002h;
    DFCS_MENUARROWRIGHT     = 0004h;

    DFCS_SCROLLUP           = 0000h;
    DFCS_SCROLLDOWN         = 0001h;
    DFCS_SCROLLLEFT         = 0002h;
    DFCS_SCROLLRIGHT        = 0003h;
    DFCS_SCROLLCOMBOBOX     = 0005h;
    DFCS_SCROLLSIZEGRIP     = 0008h;
    DFCS_SCROLLSIZEGRIPRIGHT = 0010h;

    DFCS_BUTTONCHECK        = 0000h;
    DFCS_BUTTONRADIOIMAGE   = 0001h;
    DFCS_BUTTONRADIOMASK    = 0002h;
    DFCS_BUTTONRADIO        = 0004h;
    DFCS_BUTTON3STATE       = 0008h;
    DFCS_BUTTONPUSH         = 0010h;

    DFCS_INACTIVE           = 0100h;
    DFCS_PUSHED             = 0200h;
    DFCS_CHECKED            = 0400h;
    DFCS_ADJUSTRECT         = 2000h;
    DFCS_FLAT               = 4000h;
    DFCS_MONO               = 8000h;

%IF WIN5 %THEN
    DFCS_TRANSPARENT        =00800h;
    DFCS_HOT                =01000h;
%END

PROCEDURE DrawFrameControl(a: HDC; b: RECT; c: UINT; d: UINT) : BOOL;

CONST
    DC_ACTIVE           = 0001h;
    DC_SMALLCAP         = 0002h;
    DC_ICON             = 0004h;
    DC_TEXT             = 0008h;
    DC_INBUTTON         = 0010h;
%IF WIN5 %THEN
    DC_GRADIENT         = 0020h;
%END
    (*??
    DC_CAPTION          = (DC_ICON BOR DC_TEXT BOR DC_BUTTONS);
    DC_NC               = (DC_CAPTION BOR DC_FRAME);
    *)

PROCEDURE DrawCaption(a: HWND; b: HDC; c: RECT; d: UINT) : BOOL;

CONST
    IDANI_OPEN          = 1;
    IDANI_CLOSE         = 2;
    IDANI_CAPTION       = 3;

PROCEDURE DrawAnimatedRects(hwnd : HWND;
                            idAni : WINT;
                            lprcFrom : RECT;
                            lprcTo : RECT) : BOOL;


CONST
    CF_TEXT              = 1;
    CF_BITMAP            = 2;
    CF_METAFILEPICT      = 3;
    CF_SYLK              = 4;
    CF_DIF               = 5;
    CF_TIFF              = 6;
    CF_OEMTEXT           = 7;
    CF_DIB               = 8;
    CF_PALETTE           = 9;
    CF_PENDATA           = 10;
    CF_RIFF              = 11;
    CF_WAVE              = 12;
    CF_UNICODETEXT       = 13;
    CF_ENHMETAFILE       = 14;

    CF_HDROP             = 15;
    CF_LOCALE            = 16;
    CF_MAX               = 17;

    CF_OWNERDISPLAY      = 00080h;
    CF_DSPTEXT           = 00081h;
    CF_DSPBITMAP         = 00082h;
    CF_DSPMETAFILEPICT   = 00083h;
    CF_DSPENHMETAFILE    = 0008Eh;

    CF_PRIVATEFIRST      = 00200h;
    CF_PRIVATELAST       = 002FFh;
    CF_GDIOBJFIRST       = 00300h;
    CF_GDIOBJLAST        = 003FFh;

    FVIRTKEY             = 001h;(*95*)
    FNOINVERT            = 002h;
    FSHIFT               = 004h;
    FCONTROL             = 008h;
    FALT                 = 010h;

TYPE
    ACCEL = RECORD
          fVirt          : BYTE;
          key            : WORD;
          cmd            : WORD;
    END;
    LPACCEL              = POINTER TO ACCEL;

    PAINTSTRUCT = RECORD
          hdc            : HDC;
          fErase         : BOOL;
          rcPaint        : RECT;
          fRestore       : BOOL;
          fIncUpdate     : BOOL;
          rgbReserved    : ARRAY [0..32 - 1] OF BYTE;
    END;
    PPAINTSTRUCT         = POINTER TO PAINTSTRUCT;
    LPPAINTSTRUCT        = PPAINTSTRUCT;


TYPE
    WINDOWPLACEMENT = RECORD
          length         : UINT;
          flags          : UINT;
          showCmd        : UINT;
          ptMinPosition  : POINT;
          ptMaxPosition  : POINT;
          rcNormalPosition: RECT;
    END;
    PWINDOWPLACEMENT     = POINTER TO WINDOWPLACEMENT;
    LPWINDOWPLACEMENT    = PWINDOWPLACEMENT;

CONST
    WPF_SETMINPOSITION   = 00001h;
    WPF_RESTORETOMAXIMIZED= 00002h;

TYPE
    NMHDR = RECORD
        hwndFrom        : HWND;
        idFrom          : UINT;
        code            : UINT;
    END;
    LPNMHDR = POINTER TO NMHDR;

    STYLESTRUCT = RECORD
        styleOld        : DWORD;
        styleNew        : DWORD;
    END;
    LPSTYLESTRUCT       = POINTER TO STYLESTRUCT;

CONST
    ODT_MENU             = 1;
    ODT_LISTBOX          = 2;
    ODT_COMBOBOX         = 3;
    ODT_BUTTON           = 4;
    ODT_STATIC           = 5;(*95*)

    ODA_DRAWENTIRE       = 00001h;
    ODA_SELECT           = 00002h;
    ODA_FOCUS            = 00004h;
    ODS_SELECTED         = 00001h;
    ODS_GRAYED           = 00002h;
    ODS_DISABLED         = 00004h;
    ODS_CHECKED          = 00008h;
    ODS_FOCUS            = 00010h;

    ODS_DEFAULT          = 00020h;
    ODS_COMBOBOXEDIT     = 01000h;
%IF WIN5 %THEN
    ODS_HOTLIGHT        = 00040h;
    ODS_INACTIVE        = 00080h;
%END


TYPE
    MEASUREITEMSTRUCT = RECORD
          CtlType        : UINT;
          CtlID          : UINT;
          itemID         : UINT;
          itemWidth      : UINT;
          itemHeight     : UINT;
          itemData       : DWORD;
    END;
    PMEASUREITEMSTRUCT   = POINTER TO MEASUREITEMSTRUCT;
    LPMEASUREITEMSTRUCT  = PMEASUREITEMSTRUCT;

    DRAWITEMSTRUCT = RECORD
          CtlType        : UINT;
          CtlID          : UINT;
          itemID         : UINT;
          itemAction     : UINT;
          itemState      : UINT;
          hwndItem       : HWND;
          hDC            : HDC;
          rcItem         : RECT;
          itemData       : DWORD;
    END;
    PDRAWITEMSTRUCT      = POINTER TO DRAWITEMSTRUCT;
    LPDRAWITEMSTRUCT     = PDRAWITEMSTRUCT;

    DELETEITEMSTRUCT = RECORD
          CtlType        : UINT;
          CtlID          : UINT;
          itemID         : UINT;
          hwndItem       : HWND;
          itemData       : UINT;
    END;
    PDELETEITEMSTRUCT    = POINTER TO DELETEITEMSTRUCT;
    LPDELETEITEMSTRUCT   = PDELETEITEMSTRUCT;

    COMPAREITEMSTRUCT = RECORD
          CtlType        : UINT;
          CtlID          : UINT;
          hwndItem       : HWND;
          itemID1        : UINT;
          itemData1      : DWORD;
          itemID2        : UINT;
          itemData2      : DWORD;
          dwLocaleId     : DWORD;
    END;
    PCOMPAREITEMSTRUCT   = POINTER TO COMPAREITEMSTRUCT;
    LPCOMPAREITEMSTRUCT  = PCOMPAREITEMSTRUCT;

PROCEDURE GetMessageA(VAR lpMsg : MSG;
                      hWnd : HWND;
                      wMsgFilterMin : UINT;
                      wMsgFilterMax : UINT) : BOOL;

PROCEDURE GetMessageW(VAR lpMsg : MSG;
                      hWnd : HWND;
                      wMsgFilterMin : UINT;
                      wMsgFilterMax : UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetMessage = GetMessageW;
%ELSE
PROCEDURE GetMessage = GetMessageA;
%END

PROCEDURE TranslateMessage(VAR lpMsg : MSG) : BOOL;

PROCEDURE DispatchMessageA(VAR lpMsg : MSG) : LONG;

PROCEDURE DispatchMessageW(VAR lpMsg : MSG) : LONG;

%IF UNICODE %THEN
PROCEDURE DispatchMessage = DispatchMessageW;
%ELSE
PROCEDURE DispatchMessage = DispatchMessageA;
%END

PROCEDURE SetMessageQueue(cMessagesMax : INTEGER) : BOOL;

PROCEDURE PeekMessageA(VAR lpMsg : MSG;
                       hWnd : HWND;
                       wMsgFilterMin : UINT;
                       wMsgFilterMax : UINT;
                       wRemoveMsg : UINT) : BOOL;

PROCEDURE PeekMessageW(VAR lpMsg : MSG;
                       hWnd : HWND;
                       wMsgFilterMin : UINT;
                       wMsgFilterMax : UINT;
                       wRemoveMsg : UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE PeekMessage = PeekMessageW;
%ELSE
PROCEDURE PeekMessage = PeekMessageA;
%END

CONST
    PM_NOREMOVE          = 00000h;
    PM_REMOVE            = 00001h;
    PM_NOYIELD           = 00002h;

PROCEDURE RegisterHotKey(hWnd : HWND;
                         id : INTEGER;
                         fsModifiers : UINT;
                         vk : UINT) : BOOL;

PROCEDURE UnregisterHotKey(hWnd : HWND;
                           id : INTEGER) : BOOL;


CONST
    MOD_ALT              = 00001h;
    MOD_CONTROL          = 00002h;
    MOD_SHIFT            = 00004h;
    MOD_WIN              = 00008h;

    IDHOT_SNAPWINDOW     = -1;
    IDHOT_SNAPDESKTOP    = -2;


    EW_RESTARTWINDOWS    = 00042h;
    EW_REBOOTSYSTEM      = 00043h;
    EW_EXITANDEXECAPP    = 00044h;


    ENDSESSION_LOGOFF    = 080000000h;

    EWX_LOGOFF           = 0h;
    EWX_SHUTDOWN         = 1h;
    EWX_REBOOT           = 2h;
    EWX_FORCE            = 4h;
    EWX_POWEROFF         = 8h;
%IF WIN5 %THEN
    EWX_FORCEIFHUNG      = 000000010h;(*NT only*)
%END

PROCEDURE ExitWindowsEx(uFlags : UINT;
                        dwReserved : DWORD) : BOOL;

PROCEDURE SwapMouseButton(fSwap : BOOL) : BOOL;

PROCEDURE GetMessagePos() : DWORD;

PROCEDURE GetMessageTime() : LONG;

PROCEDURE GetMessageExtraInfo() : LONG;


PROCEDURE SetMessageExtraInfo(lParam : LPARAM) : LPARAM;


PROCEDURE SendMessageA(hWnd : HWND;
                       Msg : UINT;
                       wParam : WPARAM;
                       lParam : LPARAM) : LRESULT;

PROCEDURE SendMessageW(hWnd : HWND;
                       Msg : UINT;
                       wParam : WPARAM;
                       lParam : LPARAM) : LRESULT;

%IF UNICODE %THEN
PROCEDURE SendMessage = SendMessageW;
%ELSE
PROCEDURE SendMessage = SendMessageA;
%END

PROCEDURE SendMessageTimeoutA(hWnd : HWND;
                              Msg : UINT;
                              wParam : WPARAM;
                              lParam : LPARAM;
                              fuFlags : UINT;
                              uTimeout : UINT;
                              VAR lpdwResult : DWORD) : LRESULT;

PROCEDURE SendMessageTimeoutW(hWnd : HWND;
                              Msg : UINT;
                              wParam : WPARAM;
                              lParam : LPARAM;
                              fuFlags : UINT;
                              uTimeout : UINT;
                              VAR lpdwResult : DWORD) : LRESULT;


%IF UNICODE %THEN
PROCEDURE SendMessageTimeout = SendMessageTimeoutW;
%ELSE
PROCEDURE SendMessageTimeout = SendMessageTimeoutA;
%END

PROCEDURE SendNotifyMessageA(hWnd : HWND;
                             Msg : UINT;
                             wParam : WPARAM;
                             lParam : LPARAM) : BOOL;

PROCEDURE SendNotifyMessageW(hWnd : HWND;
                             Msg : UINT;
                             wParam : WPARAM;
                             lParam : LPARAM) : BOOL;

%IF UNICODE %THEN
PROCEDURE SendNotifyMessage = SendNotifyMessageW;
%ELSE
PROCEDURE SendNotifyMessage = SendNotifyMessageA;
%END

PROCEDURE SendMessageCallbackA(hWnd : HWND;
                               Msg : UINT;
                               wParam : WPARAM;
                               lParam : LPARAM;
                               lpResultCallBack : SENDASYNCPROC;
                               dwData : DWORD) : BOOL;

PROCEDURE SendMessageCallbackW(hWnd : HWND;
                               Msg : UINT;
                               wParam : WPARAM;
                               lParam : LPARAM;
                               lpResultCallBack : SENDASYNCPROC;
                               dwData : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE SendMessageCallback = SendMessageCallbackW;
%ELSE
PROCEDURE SendMessageCallback = SendMessageCallbackA;
%END

(* only on NT *)
PROCEDURE BroadcastSystemMessageW(a: DWORD;
                                  VAR b: DWORD;
                                  c: UINT;
                                  d: WPARAM;
                                  e: LPARAM) : LONG;

(* only on NT *)
PROCEDURE BroadcastSystemMessageA(a: DWORD;
                                  VAR b: DWORD;
                                  c: UINT;
                                  d: WPARAM;
                                  e: LPARAM) : LONG;

(* only on Win9x*)
PROCEDURE BroadcastSystemMessage(a: DWORD;
                                 VAR b: DWORD;
                                 c: UINT;
                                 d: WPARAM;
                                 e: LPARAM) : LONG;

CONST
    BROADCAST_QUERY_DENY         = 424D5144h;(* Return this value to deny a query.*)

(*Broadcast Special Message Recipient list*)
    BSM_ALLCOMPONENTS       = 00000000h;
    BSM_VXDS                = 00000001h;
    BSM_NETDRIVER           = 00000002h;
    BSM_INSTALLABLEDRIVERS  = 00000004h;
    BSM_APPLICATIONS        = 00000008h;
    BSM_ALLDESKTOPS         = 00000010h;

(*Broadcast Special Message Flags*)
    BSF_QUERY               = 00000001h;
    BSF_IGNORECURRENTTASK   = 00000002h;
    BSF_FLUSHDISK           = 00000004h;
    BSF_NOHANG              = 00000008h;
    BSF_POSTMESSAGE         = 00000010h;
    BSF_FORCEIFHUNG         = 00000020h;
    BSF_NOTIMEOUTIFNOTHUNG  = 00000040h;

    DBWF_LPARAMPOINTER          = 08000h;

TYPE
    BROADCASTSYSMSG = RECORD
        uiMessage : UINT;
        wParam  : WPARAM;
        lParam  : LPARAM;
    END;
    LPBROADCASTSYSMSG   = POINTER TO BROADCASTSYSMSG;

%IF WIN5 %THEN
TYPE
    HDEVNOTIFY = PVOID;
    PHDEVNOTIFY = POINTER TO HDEVNOTIFY;

CONST
    EVICE_NOTIFY_WINDOW_HANDLE     = 00000000h;

PROCEDURE RegisterDeviceNotificationA(hRecipient : HANDLE;
                                      NotificationFilter : LPVOID;
                                      Flags : DWORD) : HDEVNOTIFY;

PROCEDURE RegisterDeviceNotificationW(hRecipient : HANDLE;
                                      NotificationFilter : LPVOID;
                                      Flags : DWORD) : HDEVNOTIFY;

%IF UNICODE %THEN
PROCEDURE RegisterDeviceNotification = RegisterDeviceNotificationW;
%ELSE
PROCEDURE RegisterDeviceNotification = RegisterDeviceNotificationA;
%END

PROCEDURE UnregisterDeviceNotification(Handle : HDEVNOTIFY) : BOOL;
%END

PROCEDURE PostMessageA(hWnd : HWND;
                       Msg : UINT;
                       wParam : WPARAM;
                       lParam : LPARAM) : BOOL;

PROCEDURE PostMessageW(hWnd : HWND;
                       Msg : UINT;
                       wParam : WPARAM;
                       lParam : LPARAM) : BOOL;

%IF UNICODE %THEN
PROCEDURE PostMessage = PostMessageW;
%ELSE
PROCEDURE PostMessage = PostMessageA;
%END

PROCEDURE PostThreadMessageA(idThread : DWORD;
                             Msg : UINT;
                             wParam : WPARAM;
                             lParam : LPARAM) : BOOL;

PROCEDURE PostThreadMessageW(idThread : DWORD;
                             Msg : UINT;
                             wParam : WPARAM;
                             lParam : LPARAM) : BOOL;

%IF UNICODE %THEN
PROCEDURE PostThreadMessage = PostThreadMessageW;
%ELSE
PROCEDURE PostThreadMessage = PostThreadMessageA;
%END

CONST
    HWND_BROADCAST   =  CAST(HWND,0ffffH);
%IF WIN5 %THEN
    HWND_MESSAGE     = CAST(HWND, -3);
%END

PROCEDURE AttachThreadInput(idAttach : DWORD;
                            idAttachTo : DWORD;
                            fAttach : BOOL) : BOOL;

PROCEDURE ReplyMessage(lResult : LRESULT) : BOOL;

PROCEDURE WaitMessage() : BOOL;

PROCEDURE WaitForInputIdle(hProcess : HANDLE;
                           dwMilliseconds : DWORD) : DWORD;

PROCEDURE DefWindowProcA(hWnd : HWND;
                         Msg : UINT;
                         wParam : WPARAM;
                         lParam : LPARAM) : LRESULT;

PROCEDURE DefWindowProcW(hWnd : HWND;
                         Msg : UINT;
                         wParam : WPARAM;
                         lParam : LPARAM) : LRESULT;

%IF UNICODE %THEN
PROCEDURE DefWindowProc = DefWindowProcW;
%ELSE
PROCEDURE DefWindowProc = DefWindowProcA;
%END

PROCEDURE PostQuitMessage(nExitCode : INTEGER);

PROCEDURE CallWindowProcA(lpPrevWndFunc : WNDPROC;
                          hWnd : HWND;
                          Msg : UINT;
                          wParam : WPARAM;
                          lParam : LPARAM) : LRESULT;

PROCEDURE CallWindowProcW(lpPrevWndFunc : WNDPROC;
                          hWnd : HWND;
                          Msg : UINT;
                          wParam : WPARAM;
                          lParam : LPARAM) : LRESULT;

%IF UNICODE %THEN
PROCEDURE CallWindowProc = CallWindowProcW;
%ELSE
PROCEDURE CallWindowProc = CallWindowProcA;
%END

PROCEDURE InSendMessage() : BOOL;

%IF WIN5 %THEN
PROCEDURE InSendMessageEx(lpReserved : LPVOID) : DWORD;

(*
 * InSendMessageEx return value
 *)
CONST
    ISMEX_NOSEND      = 00000000h;
    ISMEX_SEND        = 00000001h;
    ISMEX_NOTIFY      = 00000002h;
    ISMEX_CALLBACK    = 00000004h;
    ISMEX_REPLIED     = 00000008h;
%END

PROCEDURE GetDoubleClickTime() : UINT;

PROCEDURE SetDoubleClickTime(a : UINT) : BOOL;

PROCEDURE RegisterClassA(lpWndClass : WNDCLASSA) : ATOM;

PROCEDURE RegisterClassW(lpWndClass : WNDCLASSW) : ATOM;

%IF UNICODE %THEN
PROCEDURE RegisterClass = RegisterClassW;
%ELSE
PROCEDURE RegisterClass = RegisterClassA;
%END

PROCEDURE UnregisterClassA(lpClassName : ARRAY OF ACHAR;
                           a : HINSTANCE) : BOOL;

PROCEDURE UnregisterClassW(lpClassName : ARRAY OF UCHAR;
                           a : HINSTANCE) : BOOL;

%IF UNICODE %THEN
PROCEDURE UnregisterClass = UnregisterClassW;
%ELSE
PROCEDURE UnregisterClass = UnregisterClassA;
%END

PROCEDURE GetClassInfoA(a : HINSTANCE;
                        lpClassName : ARRAY OF ACHAR;
                        VAR lpWndClass : WNDCLASSA) : BOOL;

PROCEDURE GetClassInfoW(a : HINSTANCE;
                        lpClassName : ARRAY OF UCHAR;
                        VAR lpWndClass : WNDCLASSW) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetClassInfo = GetClassInfoW;
%ELSE
PROCEDURE GetClassInfo = GetClassInfoA;
%END



TYPE
    WNDCLASSEXA = RECORD
        cbSize          : UINT;

        style           : UINT;
        lpfnWndProc     : WNDPROC;
        cbClsExtra      : WINT;
        cbWndExtra      : WINT;
        hInstance       : HINSTANCE;
        hIcon           : HICON;
        hCursor         : HCURSOR;
        hbrBackground   : HBRUSH;
        lpszMenuName    : LPCSTR;
        lpszClassName   : LPCSTR;

        hIconSm         : HICON;
    END;
    PWNDCLASSEXA  = POINTER TO WNDCLASSEXA;
    LPWNDCLASSEXA = PWNDCLASSEXA;

    WNDCLASSEXW = RECORD
        cbSize          : UINT;

        style           : UINT;
        lpfnWndProc     : WNDPROC;
        cbClsExtra      : WINT;
        cbWndExtra      : WINT;
        hInstance       : HINSTANCE;
        hIcon           : HICON;
        hCursor         : HCURSOR;
        hbrBackground   : HBRUSH;
        lpszMenuName    : LPCWSTR;
        lpszClassName   : LPCWSTR;

        hIconSm         : HICON;
    END;
    PWNDCLASSEXW  = POINTER TO WNDCLASSEXW;
    LPWNDCLASSEXW = PWNDCLASSEXW;

%IF UNICODE %THEN
    WNDCLASSEX = WNDCLASSEXW;
    PWNDCLASSEX  = PWNDCLASSEXW;
%ELSE
    WNDCLASSEX = WNDCLASSEXA;
    PWNDCLASSEX  = PWNDCLASSEXA;
%END
    LPWNDCLASSEX = PWNDCLASSEX;

PROCEDURE RegisterClassExA(a: WNDCLASSEXA) : ATOM;

PROCEDURE RegisterClassExW(a: WNDCLASSEXW) : ATOM;

%IF UNICODE %THEN
PROCEDURE RegisterClassEx = RegisterClassExW;
%ELSE
PROCEDURE RegisterClassEx = RegisterClassExA;
%END

PROCEDURE GetClassInfoExA(a: HINSTANCE;
                          b: ARRAY OF ACHAR;
                          VAR c: WNDCLASSEXA) : BOOL;

PROCEDURE GetClassInfoExW(a: HINSTANCE;
                          b: ARRAY OF UCHAR;
                          VAR c: WNDCLASSEXW) : BOOL;
%IF UNICODE %THEN
PROCEDURE GetClassInfoEx = GetClassInfoExW;
%ELSE
PROCEDURE GetClassInfoEx = GetClassInfoExA;
%END




CONST
    CW_USEDEFAULT   = CAST(INTEGER, 080000000H);
    HWND_DESKTOP    = CAST(HWND, 0);

PROCEDURE CreateWindowExA(a : DWORD;
                          lpClassName : ARRAY OF ACHAR;
                          lpWindowName : ARRAY OF ACHAR;
                          dwStyle : DWORD;
                          X : INTEGER;
                          Y : INTEGER;
                          nWidth : INTEGER;
                          nHeight : INTEGER;
                          hWndParent : HWND;
                          b : HMENU;
                          c : HINSTANCE;
                          lpParam : LPVOID) : HWND;

PROCEDURE CreateWindowExW(a : DWORD;
                          lpClassName : ARRAY OF UCHAR;
                          lpWindowName : ARRAY OF UCHAR;
                          dwStyle : DWORD;
                          X : INTEGER;
                          Y : INTEGER;
                          nWidth : INTEGER;
                          nHeight : INTEGER;
                          hWndParent : HWND;
                          b : HMENU;
                          c : HINSTANCE;
                          lpParam : LPVOID) : HWND;

%IF UNICODE %THEN
PROCEDURE CreateWindowEx = CreateWindowExW;
%ELSE
PROCEDURE CreateWindowEx = CreateWindowExA;
%END


PROCEDURE IsWindow(hWnd : HWND) : BOOL;

PROCEDURE IsMenu(a : HMENU) : BOOL;

PROCEDURE IsChild(hWndParent : HWND;
                  hWnd : HWND) : BOOL;

PROCEDURE DestroyWindow(hWnd : HWND) : BOOL;

PROCEDURE ShowWindow(hWnd : HWND;
                     nCmdShow : INTEGER) : BOOL;


PROCEDURE ShowWindowAsync(hWnd : HWND; nCmdShow : WINT) : BOOL;

%IF WIN5 %THEN
PROCEDURE AnimateWindow(hWnd : HWND;
                        dwTime : DWORD;
                        dwFlags : DWORD) : BOOL;
%END

%IF WIN5 %THEN
CONST
    FLASHW_STOP         =0h;
    FLASHW_CAPTION      =000000001h;
    FLASHW_TRAY         =000000002h;
    FLASHW_ALL          =(FLASHW_CAPTION BOR FLASHW_TRAY);
    FLASHW_TIMER        =000000004h;
    FLASHW_TIMERNOFG    =00000000Ch;
%END

PROCEDURE FlashWindow(hWnd : HWND;
                    %IF WIN5 %THEN
                     dwFlags : DWORD
                    %ELSE
                      bInvert : BOOL
                    %END
                    ) : BOOL;

PROCEDURE ShowOwnedPopups(hWnd : HWND;
                          fShow : BOOL) : BOOL;

PROCEDURE OpenIcon(hWnd : HWND) : BOOL;

PROCEDURE CloseWindow(hWnd : HWND) : BOOL;

PROCEDURE MoveWindow(hWnd : HWND;
                     X : INTEGER;
                     Y : INTEGER;
                     nWidth : INTEGER;
                     nHeight : INTEGER;
                     bRepaint : BOOL) : BOOL;

PROCEDURE SetWindowPos(hWnd : HWND;
                       hWndInsertAfter : HWND;
                       X : INTEGER;
                       Y : INTEGER;
                       cx : INTEGER;
                       cy :INTEGER;
                       uFlags : UINT) : BOOL;

PROCEDURE GetWindowPlacement(hWnd : HWND;
                             VAR lpwndpl : WINDOWPLACEMENT) : BOOL;

PROCEDURE SetWindowPlacement(hWnd : HWND;
                             VAR lpwndpl : WINDOWPLACEMENT) : BOOL;

PROCEDURE BeginDeferWindowPos(nNumWindows : INTEGER) : HDWP;

PROCEDURE DeferWindowPos(hWinPosInfo : HDWP;
                         hWnd : HWND;
                         hWndInsertAfter : HWND;
                         x : INTEGER;
                         y :INTEGER ;
                         cx : INTEGER;
                         cy : INTEGER;
                         uFlags : UINT) : HDWP;

PROCEDURE EndDeferWindowPos(hWinPosInfo : HDWP) : BOOL;

PROCEDURE IsWindowVisible(hWnd : HWND) : BOOL;

PROCEDURE IsIconic(hWnd : HWND) : BOOL;

PROCEDURE AnyPopup() : BOOL;

PROCEDURE BringWindowToTop(hWnd : HWND) : BOOL;

PROCEDURE IsZoomed(hWnd : HWND) : BOOL;


CONST
    SWP_NOSIZE           = 00001h;
    SWP_NOMOVE           = 00002h;
    SWP_NOZORDER         = 00004h;
    SWP_NOREDRAW         = 00008h;
    SWP_NOACTIVATE       = 00010h;
    SWP_FRAMECHANGED     = 00020h;
    SWP_SHOWWINDOW       = 00040h;
    SWP_HIDEWINDOW       = 00080h;
    SWP_NOCOPYBITS       = 00100h;
    SWP_NOOWNERZORDER    = 00200h;
    SWP_NOSENDCHANGING   = 00400h;


    SWP_DRAWFRAME       = SWP_FRAMECHANGED;
    SWP_NOREPOSITION    = SWP_NOOWNERZORDER;

    SWP_DEFERERASE      = 02000h;
    SWP_ASYNCWINDOWPOS  = 04000h;


    HWND_TOP     = CAST(HWND, 0);
    HWND_BOTTOM          = CAST(HWND, 1);
    HWND_TOPMOST         = CAST(HWND, -1);
    HWND_NOTOPMOST       = CAST(HWND, -2);

TYPE
    <*/PUSH/PACK*>
    DLGTEMPLATE = RECORD
        style                   : DWORD;
        dwExtendedStyle         : DWORD;
        cdit                    : WORD;
        x                       : SHORT;
        y                       : SHORT;
        cx                      : SHORT;
        cy                      : SHORT;
    END;

    DLGITEMTEMPLATE = RECORD
          style          : DWORD;
          dwExtendedStyle: DWORD;
          x              : INTEGER16;
          y              : INTEGER16;
          cx              : INTEGER16;
          cy              : INTEGER16;
          id             : WORD;
    END;
    <*/POP*>

    LPDLGTEMPLATEW = POINTER TO DLGTEMPLATE;
    LPCDLGTEMPLATEW = LPDLGTEMPLATEW;
    LPDLGTEMPLATEA = LPDLGTEMPLATEW;
    LPCDLGTEMPLATEA = LPCDLGTEMPLATEW;

    LPDLGTEMPLATE = LPDLGTEMPLATEW;
    LPCDLGTEMPLATE = LPCDLGTEMPLATEW;

    PDLGITEMTEMPLATEW    = POINTER TO DLGITEMTEMPLATE;
    PDLGITEMTEMPLATEA    = PDLGITEMTEMPLATEW;
    PDLGITEMTEMPLATE     = PDLGITEMTEMPLATEW;

    LPDLGITEMTEMPLATEW   = PDLGITEMTEMPLATEW;
    LPDLGITEMTEMPLATEA   = PDLGITEMTEMPLATEW;
    LPDLGITEMTEMPLATE    = PDLGITEMTEMPLATEW;

PROCEDURE CreateDialogParamA(a : HINSTANCE;
                             lpTemplateName : ARRAY OF ACHAR;
                             hWndParent : HWND;
                             lpDialogFunc : DLGPROC;
                             dwInitParam : LPARAM) : HWND;

PROCEDURE CreateDialogParamW(a : HINSTANCE;
                             lpTemplateName : ARRAY OF UCHAR;
                             hWndParent : HWND;
                             lpDialogFunc : DLGPROC;
                             dwInitParam : LPARAM) : HWND;

%IF UNICODE %THEN
PROCEDURE CreateDialogParam = CreateDialogParamW;
%ELSE
PROCEDURE CreateDialogParam = CreateDialogParamA;
%END

PROCEDURE CreateDialogIndirectParamA(a : HINSTANCE;
                                     lpTemplate : LPCDLGTEMPLATEA;
                                     hWndParent : HWND;
                                     lpDialogFunc : DLGPROC;
                                     dwInitParam : LPARAM) : HWND;

PROCEDURE CreateDialogIndirectParamW(a : HINSTANCE;
                                     lpTemplate : LPCDLGTEMPLATEW;
                                     hWndParent : HWND;
                                     lpDialogFunc : DLGPROC;
                                     dwInitParam : LPARAM) : HWND;

%IF UNICODE %THEN
PROCEDURE CreateDialogIndirectParam = CreateDialogIndirectParamW;
%ELSE
PROCEDURE CreateDialogIndirectParam = CreateDialogIndirectParamA;
%END

PROCEDURE DialogBoxParamA(a : HINSTANCE;
                          lpTemplateName : ARRAY OF ACHAR;
                          hWndParent : HWND;
                          lpDialogFunc : DLGPROC;
                          dwInitParam : LPARAM) : INTEGER;

PROCEDURE DialogBoxParamW(a : HINSTANCE;
                          lpTemplateName : ARRAY OF UCHAR;
                          hWndParent : HWND;
                          lpDialogFunc : DLGPROC;
                          dwInitParam : LPARAM) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DialogBoxParam = DialogBoxParamW;
%ELSE
PROCEDURE DialogBoxParam = DialogBoxParamA;
%END

PROCEDURE DialogBoxIndirectParamA(a : HINSTANCE;
                                  hDialogTemplate : LPCDLGTEMPLATEA;
                                  hWndParent : HWND;
                                  lpDialogFunc : DLGPROC;
                                  dwInitParam : LPARAM) : INTEGER;

PROCEDURE DialogBoxIndirectParamW(a : HINSTANCE;
                                  hDialogTemplate : LPCDLGTEMPLATEW;
                                  hWndParent : HWND;
                                  lpDialogFunc : DLGPROC;
                                  dwInitParam : LPARAM) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DialogBoxIndirectParam = DialogBoxIndirectParamW;
%ELSE
PROCEDURE DialogBoxIndirectParam = DialogBoxIndirectParamA;
%END

PROCEDURE EndDialog(hDlg : HWND;
                    nResult : INTEGER) : BOOL;

PROCEDURE GetDlgItem(hDlg : HWND;
                     nIDDlgItem : INTEGER) : HWND [Invariant];

PROCEDURE SetDlgItemInt(hDlg : HWND;
                        nIDDlgItem : INTEGER;
                        uValue : UINT;
                        bSigned : BOOL) : BOOL;

PROCEDURE GetDlgItemInt(hDlg : HWND;
                        nIDDlgItem : INTEGER;
                        VAR lpTranslated : BOOL;
                        bSigned : BOOL) : UINT;

PROCEDURE SetDlgItemTextA(hDlg : HWND;
                          nIDDlgItem : INTEGER;
                          lpString : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetDlgItemTextW(hDlg : HWND;
                          nIDDlgItem : INTEGER;
                          lpString : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetDlgItemText = SetDlgItemTextW;
%ELSE
PROCEDURE SetDlgItemText = SetDlgItemTextA;
%END


PROCEDURE GetDlgItemTextW(hDlg : HWND;
                          nIDDlgItem : INTEGER;
                          VAR lpString : ARRAY OF UCHAR;
                          nMaxCount : INTEGER) : UINT;

PROCEDURE GetDlgItemTextA(hDlg : HWND;
                          nIDDlgItem : INTEGER;
                          VAR lpString : ARRAY OF ACHAR;
                          nMaxCount : INTEGER) : UINT;

%IF UNICODE %THEN
PROCEDURE GetDlgItemText = GetDlgItemTextW;
%ELSE
PROCEDURE GetDlgItemText = GetDlgItemTextA;
%END

PROCEDURE CheckDlgButton(hDlg : HWND;
                         nIDButton : INTEGER;
                         uCheck : UINT) : BOOL;

PROCEDURE CheckRadioButton(hDlg : HWND;
                           nIDFirstButton : INTEGER;
                           nIDLastButton : INTEGER;
                           nIDCheckButton : INTEGER) : BOOL;

PROCEDURE IsDlgButtonChecked(hDlg : HWND;
                             nIDButton : INTEGER) : UINT;

PROCEDURE SendDlgItemMessageA(hDlg : HWND;
                              nIDDlgItem : INTEGER;
                              Msg : UINT;
                              wParam : WPARAM;
                              lParam : LPARAM) : LONG;

PROCEDURE SendDlgItemMessageW(hDlg : HWND;
                              nIDDlgItem : INTEGER;
                              Msg : UINT;
                              wParam : WPARAM;
                              lParam : LPARAM) : LONG;

%IF UNICODE %THEN
PROCEDURE SendDlgItemMessage = SendDlgItemMessageW;
%ELSE
PROCEDURE SendDlgItemMessage = SendDlgItemMessageA;
%END

PROCEDURE GetNextDlgGroupItem(hDlg : HWND;
                              hCtl : HWND;
                              bPrevious : BOOL) : HWND;

PROCEDURE GetNextDlgTabItem(hDlg : HWND;
                            hCtl : HWND;
                            bPrevious : BOOL) : HWND;

PROCEDURE GetDlgCtrlID(hWnd : HWND) : INTEGER;

PROCEDURE GetDialogBaseUnits() : CARDINAL32;

PROCEDURE DefDlgProcA(hDlg : HWND;
                      Msg : UINT;
                      wParam : WPARAM;
                      lParam : LPARAM) : LRESULT;

PROCEDURE DefDlgProcW(hDlg : HWND;
                      Msg : UINT;
                      wParam : WPARAM;
                      lParam : LPARAM) : LRESULT;

%IF UNICODE %THEN
PROCEDURE DefDlgProc = DefDlgProcW;
%ELSE
PROCEDURE DefDlgProc = DefDlgProcA;
%END


CONST
    DLGWINDOWEXTRA       = 30;

PROCEDURE CallMsgFilterA(VAR lpMsg : MSG;
                         nCode : INTEGER) : BOOL;

PROCEDURE CallMsgFilterW(VAR lpMsg : MSG;
                         nCode : INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE CallMsgFilter = CallMsgFilterW;
%ELSE
PROCEDURE CallMsgFilter = CallMsgFilterA;
%END

PROCEDURE OpenClipboard(hWndNewOwner : HWND) : BOOL;

PROCEDURE CloseClipboard() : BOOL;

%IF WIN5 %THEN
PROCEDURE GetClipboardSequenceNumber() : DWORD;
%END

PROCEDURE GetClipboardOwner() : HWND;

PROCEDURE SetClipboardViewer(hWndNewViewer : HWND) : HWND;

PROCEDURE GetClipboardViewer() : HWND;

PROCEDURE ChangeClipboardChain(hWndRemove : HWND;
                               hWndNewNext : HWND) : BOOL;

PROCEDURE SetClipboardData(uFormat : UINT;
                           hMem : HANDLE) : HANDLE;

PROCEDURE GetClipboardData(uFormat : UINT) : HANDLE;

PROCEDURE RegisterClipboardFormatA(lpszFormat : ARRAY OF ACHAR) : UINT;

PROCEDURE RegisterClipboardFormatW(lpszFormat : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE RegisterClipboardFormat = RegisterClipboardFormatW;
%ELSE
PROCEDURE RegisterClipboardFormat = RegisterClipboardFormatA;
%END


PROCEDURE CountClipboardFormats() : INTEGER;

PROCEDURE EnumClipboardFormats(format : UINT) : UINT;

PROCEDURE GetClipboardFormatNameA(format : UINT;
                                  VAR lpszFormatName : ARRAY OF ACHAR;
                                  cchMaxCount : INTEGER) : INTEGER;

PROCEDURE GetClipboardFormatNameW(format : UINT;
                                  VAR lpszFormatName : ARRAY OF UCHAR;
                                  cchMaxCount : INTEGER) : INTEGER;
%IF UNICODE %THEN
PROCEDURE GetClipboardFormatName = GetClipboardFormatNameW;
%ELSE
PROCEDURE GetClipboardFormatName = GetClipboardFormatNameA;
%END


PROCEDURE EmptyClipboard() : BOOL;

PROCEDURE IsClipboardFormatAvailable(format : UINT) : BOOL;

PROCEDURE GetPriorityClipboardFormat(VAR paFormatPriorityList : UINT;
                                     cFormats : INTEGER) : INTEGER;

PROCEDURE GetOpenClipboardWindow() : HWND;

PROCEDURE CharToOemA(lpszSrc : ARRAY OF ACHAR;
                     VAR lpszDst : ARRAY OF ACHAR) : BOOL;

PROCEDURE CharToOemW(lpszSrc : ARRAY OF UCHAR;
                     VAR lpszDst : ARRAY OF ACHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE CharToOem = CharToOemW;
%ELSE
PROCEDURE CharToOem = CharToOemA;
%END

PROCEDURE OemToCharA(lpszSrc : ARRAY OF ACHAR;
                     VAR lpszDst : ARRAY OF ACHAR) : BOOL;

PROCEDURE OemToCharW(lpszSrc : ARRAY OF ACHAR;
                     VAR lpszDst : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE OemToChar = OemToCharW;
%ELSE
PROCEDURE OemToChar = OemToCharA;
%END

PROCEDURE CharToOemBuffA(lpszSrc : ARRAY OF ACHAR;
                         VAR lpszDst : ARRAY OF ACHAR;
                         cchDstLength : DWORD) : BOOL;

PROCEDURE CharToOemBuffW(lpszSrc : ARRAY OF UCHAR;
                         VAR lpszDst : ARRAY OF ACHAR;
                         cchDstLength : DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE CharToOemBuff = CharToOemBuffW;
%ELSE
PROCEDURE CharToOemBuff = CharToOemBuffA;
%END

PROCEDURE OemToCharBuffA(lpszSrc : ARRAY OF ACHAR;
                         VAR lpszDst : ARRAY OF ACHAR;
                         cchDstLength : DWORD) : BOOL;

PROCEDURE OemToCharBuffW(lpszSrc : ARRAY OF ACHAR;
                         VAR lpszDst : ARRAY OF UCHAR;
                         cchDstLength : DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE OemToCharBuff = OemToCharBuffW;
%ELSE
PROCEDURE OemToCharBuff = OemToCharBuffA;
%END

PROCEDURE CharUpperA(VAR lpsz : ARRAY OF ACHAR) : ACHAR;

PROCEDURE CharUpperW(VAR lpsz : ARRAY OF UCHAR) : UCHAR;

%IF UNICODE %THEN
PROCEDURE CharUpper = CharUpperW;
%ELSE
PROCEDURE CharUpper = CharUpperA;
%END

PROCEDURE CharUpperBuffA(VAR lpsz : ARRAY OF ACHAR;
                         cchLength : DWORD) : DWORD;

PROCEDURE CharUpperBuffW(VAR lpsz : ARRAY OF UCHAR;
                         cchLength : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE CharUpperBuff = CharUpperBuffW;
%ELSE
PROCEDURE CharUpperBuff = CharUpperBuffA;
%END

PROCEDURE CharLowerA(VAR lpsz : ARRAY OF ACHAR) : ACHAR;

PROCEDURE CharLowerW(VAR lpsz : ARRAY OF UCHAR) : UCHAR;

%IF UNICODE %THEN
PROCEDURE CharLower = CharLowerW;
%ELSE
PROCEDURE CharLower = CharLowerA;
%END

PROCEDURE CharLowerBuffA(VAR lpsz : ARRAY OF ACHAR;
                         cchLength : DWORD) : DWORD;

PROCEDURE CharLowerBuffW(VAR lpsz : ARRAY OF UCHAR;
                         cchLength : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE CharLowerBuff = CharLowerBuffW;
%ELSE
PROCEDURE CharLowerBuff = CharLowerBuffA;
%END

PROCEDURE CharNextA(lpsz : ARRAY OF ACHAR) : LPSTR;

PROCEDURE CharNextW(lpsz : ARRAY OF UCHAR) : LPWSTR;

%IF UNICODE %THEN
PROCEDURE CharNext = CharNextW;
%ELSE
PROCEDURE CharNext = CharNextA;
%END

PROCEDURE CharPrevA(lpszStart : ARRAY OF ACHAR;
                    lpszCurrent : ARRAY OF ACHAR) : LPSTR;

PROCEDURE CharPrevW(lpszStart : ARRAY OF UCHAR;
                    lpszCurrent : ARRAY OF UCHAR) : LPWSTR;

%IF UNICODE %THEN
PROCEDURE CharPrev = CharPrevW;
%ELSE
PROCEDURE CharPrev = CharPrevA;
%END


PROCEDURE CharNextExA(
                     CodePage : WORD;
                     lpCurrentChar : ARRAY OF ACHAR;
                     dwFlags : DWORD) : LPSTR;

PROCEDURE CharNextExW(
                     CodePage : WORD;
                     lpCurrentChar : ARRAY OF UCHAR;
                     dwFlags : DWORD) : LPWSTR;

%IF UNICODE %THEN
PROCEDURE CharNextEx = CharNextExW;
%ELSE
PROCEDURE CharNextEx = CharNextExA;
%END

PROCEDURE CharPrevExA(CodePage : WORD;
                      lpStart : ARRAY OF ACHAR;
                      lpCurrentChar : ARRAY OF ACHAR;
                      dwFlags : DWORD) : LPSTR;



PROCEDURE IsCharAlphaA(ch : ACHAR) : BOOL;

PROCEDURE IsCharAlphaW(ch : WCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE IsCharAlpha = IsCharAlphaW;
%ELSE
PROCEDURE IsCharAlpha = IsCharAlphaA;
%END

PROCEDURE IsCharAlphaNumericA(ch : ACHAR) : BOOL;

PROCEDURE IsCharAlphaNumericW(ch : WCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE IsCharAlphaNumeric = IsCharAlphaNumericW;
%ELSE
PROCEDURE IsCharAlphaNumeric = IsCharAlphaNumericA;
%END

PROCEDURE IsCharUpperA(ch : ACHAR) : BOOL;

PROCEDURE IsCharUpperW(ch : WCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE IsCharUpper = IsCharUpperW;
%ELSE
PROCEDURE IsCharUpper = IsCharUpperA;
%END

PROCEDURE IsCharLowerA(ch : ACHAR) : BOOL;

PROCEDURE IsCharLowerW(ch : WCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE IsCharLower = IsCharLowerW;
%ELSE
PROCEDURE IsCharLower = IsCharLowerA;
%END

PROCEDURE SetFocus(hWnd : HWND) : HWND;

PROCEDURE GetActiveWindow() : HWND;

PROCEDURE GetFocus() : HWND;

PROCEDURE GetKBCodePage() : UINT;

PROCEDURE GetKeyState(nVirtKey : INTEGER) : SHORT;

PROCEDURE GetAsyncKeyState(vKey : INTEGER) : SHORT;

PROCEDURE GetKeyboardState(VAR OUT lpKeyState : ARRAY OF SYSTEM.BYTE) : BOOL;

PROCEDURE SetKeyboardState(lpKeyState : ARRAY OF SYSTEM.BYTE) : BOOL;

PROCEDURE GetKeyNameTextA(lParam : LONG;
                          VAR lpString : ARRAY OF ACHAR;
                          nSize : INTEGER) : INTEGER;

PROCEDURE GetKeyNameTextW(lParam : LONG;
                          VAR lpString : ARRAY OF UCHAR;
                          nSize : INTEGER) : INTEGER;

%IF UNICODE %THEN
PROCEDURE GetKeyNameText = GetKeyNameTextW;
%ELSE
PROCEDURE GetKeyNameText = GetKeyNameTextA;
%END

PROCEDURE GetKeyboardType(nTypeFlag : INTEGER) : INTEGER;

PROCEDURE ToAscii(uVirtKey : UINT;
                  uScanCode : UINT;
                  lpKeyState : ARRAY OF SYSTEM.BYTE;
                  VAR OUT lpChar : ARRAY OF WORD;
                  uFlags : UINT) : INTEGER;


PROCEDURE ToAsciiEx(
            uVirtKey : UINT;
            uScanCode : UINT;
            lpKeyState : ARRAY OF SYSTEM.BYTE;
            VAR OUT lpChar : ARRAY OF WORD;
            uFlags : UINT;
            dwhkl : HKL) : WINT;


PROCEDURE ToUnicode(wVirtKey : UINT;
                    wScanCode : UINT;
                    lpKeyState : ARRAY OF  SYSTEM.BYTE;
                    VAR pwszBuff : ARRAY OF UCHAR;
                    cchBuff : INTEGER;
                    wFlags : UINT) : INTEGER;

PROCEDURE OemKeyScan(wOemChar : WORD) : DWORD;

PROCEDURE VkKeyScanA(ch : ACHAR) : SHORT;

PROCEDURE VkKeyScanW(ch : WCHAR) : SHORT;

%IF UNICODE %THEN
PROCEDURE VkKeyScan = VkKeyScanW;
%ELSE
PROCEDURE VkKeyScan = VkKeyScanA;
%END


PROCEDURE VkKeyScanExA(ch : ACHAR; dwhkl : HKL) : SHORT;

PROCEDURE VkKeyScanExW(ch : ACHAR; dwhkl : HKL) : SHORT;

%IF UNICODE %THEN
PROCEDURE VkKeyScanEx = VkKeyScanExW;
%ELSE
PROCEDURE VkKeyScanEx = VkKeyScanExA;
%END


CONST
    KEYEVENTF_EXTENDEDKEY= 00001h;
    KEYEVENTF_KEYUP      = 00002h;

PROCEDURE keybd_event(bVk : BYTE;
                      bScan : BYTE;
                      dwFlags : DWORD;
                      dwExtraInfo : DWORD);


CONST
    MOUSEEVENTF_MOVE     = 00001h;
    MOUSEEVENTF_LEFTDOWN = 00002h;
    MOUSEEVENTF_LEFTUP   = 00004h;
    MOUSEEVENTF_RIGHTDOWN= 00008h;
    MOUSEEVENTF_RIGHTUP  = 00010h;
    MOUSEEVENTF_MIDDLEDOWN= 00020h;
    MOUSEEVENTF_MIDDLEUP = 00040h;
    MOUSEEVENTF_WHEEL       = 00800h; (* wheel button rolled **)
    MOUSEEVENTF_ABSOLUTE = 08000h;

PROCEDURE mouse_event(dwFlags : DWORD;
                      dx : DWORD;
                      dy : DWORD;
                      cButtons : DWORD;
                      dwExtraInfo : DWORD);

TYPE
    (*NT only*)
    MOUSEINPUT = RECORD
    dx          : LONG;
    dy          : LONG;
    mouseData   : DWORD;
    dwFlags     : DWORD;
    time        : DWORD;
    dwExtraInfo : DWORD;
    END;
    PMOUSEINPUT = POINTER TO MOUSEINPUT;
    LPMOUSEINPUT = PMOUSEINPUT;

    (*NT only*)
    KEYBDINPUT = RECORD
    wVk         : WORD;
    wScan       : WORD;
    dwFlags     : DWORD;
    time        : DWORD;
    dwExtraInfo : DWORD;
    END;
    PKEYBDINPUT = POINTER TO KEYBDINPUT;
    LPKEYBDINPUT = PKEYBDINPUT;

    (*NT only*)
    HARDWAREINPUT = RECORD
    uMsg        : DWORD;
    wParamL     : WORD;
    wParamH     : WORD;
    END;
    PHARDWAREINPUT = POINTER TO HARDWAREINPUT;
    LPHARDWAREINPUT = PHARDWAREINPUT;

    (*NT only*)
    INPUT = RECORD
    type        : DWORD;

    CASE : CARDINAL OF
        0: mi : MOUSEINPUT;|
        1: ki : KEYBDINPUT;|
        2: hi : HARDWAREINPUT;
    ELSE
    END;
    END;
    PINPUT = POINTER TO INPUT;
    LPINPUT = PINPUT;

CONST
    INPUT_MOUSE     =0;
    INPUT_KEYBOARD  =1;
    INPUT_HARDWARE  =2;

(*NT only*)
PROCEDURE SendInput(cInputs : UINT;     (* number of input in the array*)
                    pInputs : INPUT;     (* array of inputs*)
                    cbSize : WINT) : UINT;    (* sizeof(INPUT)*)

%IF WIN5 %THEN
TYPE
    (*NT only*)
    LASTINPUTINFO = RECORD
    cbSize      : UINT;
    dwTime      : DWORD;
    END;
    PLASTINPUTINFO = POINTER TO LASTINPUTINFO;

(*NT only*)
PROCEDURE GetLastInputInfo(plii : LASTINPUTINFO) : BOOL;
%END

PROCEDURE MapVirtualKeyA(uCode : UINT;
                         uMapType : UINT) : UINT;

PROCEDURE MapVirtualKeyW(uCode : UINT;
                         uMapType : UINT) : UINT;

%IF UNICODE %THEN
PROCEDURE MapVirtualKey = MapVirtualKeyW;
%ELSE
PROCEDURE MapVirtualKey = MapVirtualKeyA;
%END


PROCEDURE MapVirtualKeyExA(
                            uCode : UINT;
                            uMapType : UINT;
                            dwhkl : HKL) : UINT;

PROCEDURE MapVirtualKeyExW(
                            uCode : UINT;
                            uMapType : UINT;
                            dwhkl : HKL) : UINT;

%IF UNICODE %THEN
PROCEDURE MapVirtualKeyEx = MapVirtualKeyExW;
%ELSE
PROCEDURE MapVirtualKeyEx = MapVirtualKeyExA;
%END



PROCEDURE GetInputState() : BOOL;

PROCEDURE GetQueueStatus(flags : UINT) : DWORD;

PROCEDURE GetCapture() : HWND;

PROCEDURE SetCapture(hWnd : HWND) : HWND;

PROCEDURE ReleaseCapture() : BOOL;

PROCEDURE MsgWaitForMultipleObjects(nCount : DWORD;
                                    pHandles : ARRAY OF HANDLE;
                                    fWaitAll : BOOL;
                                    dwMilliseconds : DWORD;
                                    dwWakeMask : DWORD) : DWORD;


PROCEDURE MsgWaitForMultipleObjectsEx(nCount : DWORD;
                                      pHandles : ARRAY OF HANDLE;
                                      dwMilliseconds : DWORD;
                                      dwWakeMask : DWORD;
                                      dwFlags : DWORD) : DWORD;

CONST
    MWMO_WAITALL        = 0001h;
    MWMO_ALERTABLE      = 0002h;
    MWMO_INPUTAVAILABLE = 0004h;

    QS_KEY               = 001h;
    QS_MOUSEMOVE         = 002h;
    QS_MOUSEBUTTON       = 004h;
    QS_POSTMESSAGE       = 008h;
    QS_TIMER             = 010h;
    QS_PAINT             = 020h;
    QS_SENDMESSAGE       = 040h;
    QS_HOTKEY            = 080h;
    QS_ALLPOSTMESSAGE    = 0100h;

    QS_MOUSE             =  QS_MOUSEMOVE BOR QS_MOUSEBUTTON;
    QS_INPUT             =  QS_MOUSE BOR QS_KEY;
    QS_ALLEVENTS         =      QS_INPUT BOR
                                QS_POSTMESSAGE BOR
                                QS_TIMER BOR
                                QS_PAINT BOR
                                QS_HOTKEY;
    QS_ALLINPUT          =      QS_SENDMESSAGE BOR
                                QS_PAINT BOR
                                QS_TIMER BOR
                                QS_POSTMESSAGE BOR
                                QS_MOUSEBUTTON BOR
                                QS_MOUSEMOVE BOR
                                QS_HOTKEY BOR
                                QS_KEY;

PROCEDURE SetTimer(hWnd : HWND;
                   nIDEvent : UINT;
                   uElapse : UINT;
                   lpTimerFunc : TIMERPROC) : UINT;

PROCEDURE KillTimer(hWnd : HWND;
                    uIDEvent : UINT) : BOOL;

PROCEDURE IsWindowUnicode(hWnd : HWND) : BOOL;

PROCEDURE EnableWindow(hWnd : HWND;
                       bEnable : BOOL) : BOOL;

PROCEDURE IsWindowEnabled(hWnd : HWND) : BOOL;

PROCEDURE LoadAcceleratorsA(a : HINSTANCE;
                            lpTableName : ARRAY OF ACHAR) : HACCEL;

PROCEDURE LoadAcceleratorsW(a : HINSTANCE;
                            lpTableName : ARRAY OF UCHAR) : HACCEL;

%IF UNICODE %THEN
PROCEDURE LoadAccelerators = LoadAcceleratorsW;
%ELSE
PROCEDURE LoadAccelerators = LoadAcceleratorsA;
%END

PROCEDURE CreateAcceleratorTableA(a : LPACCEL;
                                  b : INTEGER) : HACCEL;

PROCEDURE CreateAcceleratorTableW(a : LPACCEL;
                                  b : INTEGER) : HACCEL;

%IF UNICODE %THEN
PROCEDURE CreateAcceleratorTable = CreateAcceleratorTableW;
%ELSE
PROCEDURE CreateAcceleratorTable = CreateAcceleratorTableA;
%END

PROCEDURE DestroyAcceleratorTable(hAccel : HACCEL) : BOOL;

PROCEDURE CopyAcceleratorTableA(hAccelSrc : HACCEL;
                                VAR lpAccelDst : ARRAY OF ACCEL;
                                cAccelEntries : INTEGER) : INTEGER;

PROCEDURE CopyAcceleratorTableW(hAccelSrc : HACCEL;
                                VAR lpAccelDst : ARRAY OF ACCEL;
                                cAccelEntries : INTEGER) : INTEGER;

%IF UNICODE %THEN
PROCEDURE CopyAcceleratorTable = CopyAcceleratorTableW;
%ELSE
PROCEDURE CopyAcceleratorTable = CopyAcceleratorTableA;
%END

PROCEDURE TranslateAcceleratorA(hWnd : HWND;
                                hAccTable : HACCEL;
                                VAR lpMsg : MSG) : INTEGER;

PROCEDURE TranslateAcceleratorW(hWnd : HWND;
                                hAccTable : HACCEL;
                                VAR lpMsg : MSG) : INTEGER;

%IF UNICODE %THEN
PROCEDURE TranslateAccelerator = TranslateAcceleratorW;
%ELSE
PROCEDURE TranslateAccelerator = TranslateAcceleratorA;
%END

CONST
    SM_CXSCREEN          = 0;
    SM_CYSCREEN          = 1;
    SM_CXVSCROLL         = 2;
    SM_CYHSCROLL         = 3;
    SM_CYCAPTION         = 4;
    SM_CXBORDER          = 5;
    SM_CYBORDER          = 6;
    SM_CXDLGFRAME        = 7;
    SM_CYDLGFRAME        = 8;
    SM_CYVTHUMB          = 9;
    SM_CXHTHUMB          = 10;
    SM_CXICON            = 11;
    SM_CYICON            = 12;
    SM_CXCURSOR          = 13;
    SM_CYCURSOR          = 14;
    SM_CYMENU            = 15;
    SM_CXFULLSCREEN      = 16;
    SM_CYFULLSCREEN      = 17;
    SM_CYKANJIWINDOW     = 18;
    SM_MOUSEPRESENT      = 19;
    SM_CYVSCROLL         = 20;
    SM_CXHSCROLL         = 21;
    SM_DEBUG             = 22;
    SM_SWAPBUTTON        = 23;
    SM_RESERVED1         = 24;
    SM_RESERVED2         = 25;
    SM_RESERVED3         = 26;
    SM_RESERVED4         = 27;
    SM_CXMIN             = 28;
    SM_CYMIN             = 29;
    SM_CXSIZE            = 30;
    SM_CYSIZE            = 31;
    SM_CXFRAME           = 32;
    SM_CYFRAME           = 33;
    SM_CXMINTRACK        = 34;
    SM_CYMINTRACK        = 35;
    SM_CXDOUBLECLK       = 36;
    SM_CYDOUBLECLK       = 37;
    SM_CXICONSPACING     = 38;
    SM_CYICONSPACING     = 39;
    SM_MENUDROPALIGNMENT = 40;
    SM_PENWINDOWS        = 41;
    SM_DBCSENABLED       = 42;
    SM_CMOUSEBUTTONS     = 43;

    SM_CXFIXEDFRAME      = SM_CXDLGFRAME;
    SM_CYFIXEDFRAME      = SM_CYDLGFRAME;
    SM_CXSIZEFRAME       = SM_CXFRAME;
    SM_CYSIZEFRAME       = SM_CYFRAME;
    SM_SECURE            = 44;
    SM_CXEDGE            = 45;
    SM_CYEDGE            = 46;
    SM_CXMINSPACING      = 47;
    SM_CYMINSPACING      = 48;
    SM_CXSMICON          = 49;
    SM_CYSMICON          = 50;
    SM_CYSMCAPTION       = 51;
    SM_CXSMSIZE          = 52;
    SM_CYSMSIZE          = 53;
    SM_CXMENUSIZE        = 54;
    SM_CYMENUSIZE        = 55;
    SM_ARRANGE           = 56;
    SM_CXMINIMIZED       = 57;
    SM_CYMINIMIZED       = 58;
    SM_CXMAXTRACK        = 59;
    SM_CYMAXTRACK        = 60;
    SM_CXMAXIMIZED       = 61;
    SM_CYMAXIMIZED       = 62;
    SM_NETWORK           = 63;
    SM_CLEANBOOT         = 67;
    SM_CXDRAG            = 68;
    SM_CYDRAG            = 69;
    SM_SHOWSOUNDS        = 70;
    SM_CXMENUCHECK       = 71;
    SM_CYMENUCHECK       = 72;
    SM_SLOWMACHINE       = 73;
    SM_MIDEASTENABLED    = 74;
%IF WIN5 %THEN
    SM_MOUSEWHEELPRESENT    = 75;
%END
    SM_XVIRTUALSCREEN       =76;
    SM_YVIRTUALSCREEN       =77;
    SM_CXVIRTUALSCREEN      =78;
    SM_CYVIRTUALSCREEN      =79;
    SM_CMONITORS            =80;
    SM_SAMEDISPLAYFORMAT    =81;

%IF WIN5 %THEN
    SM_CMETRICS          = 83;
%ELSE
    SM_CMETRICS          = 76;
%END

PROCEDURE GetSystemMetrics(nIndex : INTEGER) : INTEGER;

PROCEDURE LoadMenuA(a : HINSTANCE; lpMenuName : ARRAY OF ACHAR) : HMENU;

PROCEDURE LoadMenuW(a : HINSTANCE; lpMenuName : ARRAY OF UCHAR) : HMENU;

%IF UNICODE %THEN
PROCEDURE LoadMenu = LoadMenuW;
%ELSE
PROCEDURE LoadMenu = LoadMenuA;
%END

PROCEDURE LoadMenuIndirectA(VAR lpMenuTemplate : MENUTEMPLATEA) : HMENU;

PROCEDURE LoadMenuIndirectW(VAR lpMenuTemplate : MENUTEMPLATEW) : HMENU;

%IF UNICODE %THEN
PROCEDURE LoadMenuIndirect = LoadMenuIndirectW;
%ELSE
PROCEDURE LoadMenuIndirect = LoadMenuIndirectA;
%END

PROCEDURE GetMenu(hWnd : HWND) : HMENU;

PROCEDURE SetMenu(hWnd : HWND;
                  a : HMENU) : BOOL;

PROCEDURE ChangeMenuA(a : HMENU;
                      cmd : UINT;
                      lpszNewItem : ARRAY OF ACHAR;
                      cmdInsert : UINT;
                      flags : UINT) : BOOL;

PROCEDURE ChangeMenuW(a : HMENU;
                      cmd : UINT;
                      lpszNewItem : ARRAY OF UCHAR;
                      cmdInsert : UINT;
                      flags : UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE ChangeMenu = ChangeMenuW;
%ELSE
PROCEDURE ChangeMenu = ChangeMenuA;
%END

PROCEDURE HiliteMenuItem(hWnd : HWND;
                         a : HMENU;
                         uIDHiliteItem : UINT;
                         uHilite : UINT) : BOOL;

PROCEDURE GetMenuStringA(a : HMENU;
                         uIDItem : UINT;
                         VAR lpString : ARRAY OF ACHAR;
                         nMaxCount : INTEGER;
                         uFlag : UINT) : INTEGER;

PROCEDURE GetMenuStringW(a : HMENU;
                         uIDItem : UINT;
                         VAR lpString : ARRAY OF UCHAR;
                         nMaxCount : INTEGER;
                         uFlag : UINT) : INTEGER;

%IF UNICODE %THEN
PROCEDURE GetMenuString = GetMenuStringW;
%ELSE
PROCEDURE GetMenuString = GetMenuStringA;
%END

PROCEDURE GetMenuState(a : HMENU;
                       uId : UINT;
                       uFlags : UINT) : UINT;

PROCEDURE DrawMenuBar(hWnd : HWND) : BOOL;

PROCEDURE GetSystemMenu(hWnd : HWND;
                        bRevert : BOOL) : HMENU;

PROCEDURE CreateMenu() : HMENU;

PROCEDURE CreatePopupMenu() : HMENU;

PROCEDURE DestroyMenu(a : HMENU) : BOOL;

PROCEDURE CheckMenuItem(a : HMENU;
                        uIDCheckItem : UINT;
                        uCheck : UINT) : DWORD;

PROCEDURE EnableMenuItem(a : HMENU;
                         uIDEnableItem : UINT;
                         uEnable : UINT) : DWORD;

PROCEDURE GetSubMenu(a : HMENU;
                     nPos : INTEGER) : HMENU;

PROCEDURE GetMenuItemID(a : HMENU;
                        nPos : INTEGER) : UINT;

PROCEDURE GetMenuItemCount(a : HMENU) : INTEGER;

PROCEDURE InsertMenuA(a : HMENU;
                      uPosition : UINT;
                      uFlags : UINT;
                      uIDNewItem : UINT;
                      lpNewItem : ARRAY OF ACHAR) : BOOL;

PROCEDURE InsertMenuW(a : HMENU;
                      uPosition : UINT;
                      uFlags : UINT;
                      uIDNewItem : UINT;
                      lpNewItem : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE InsertMenu = InsertMenuW;
%ELSE
PROCEDURE InsertMenu = InsertMenuA;
%END

PROCEDURE AppendMenuA(a : HMENU;
                      uFlags : UINT;
                      uIDNewItem : UINT;
                      lpNewItem : ARRAY OF ACHAR) : BOOL;

PROCEDURE AppendMenuW(a : HMENU;
                      uFlags : UINT;
                      uIDNewItem : UINT;
                      lpNewItem : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE AppendMenu = AppendMenuW;
%ELSE
PROCEDURE AppendMenu = AppendMenuA;
%END

PROCEDURE ModifyMenuA(hMnu : HMENU;
                      uPosition : UINT;
                      uFlags : UINT;
                      uIDNewItem : UINT;
                      lpNewItem : ARRAY OF ACHAR) : BOOL;

PROCEDURE ModifyMenuW(hMnu : HMENU;
                      uPosition : UINT;
                      uFlags : UINT;
                      uIDNewItem : UINT;
                      lpNewItem : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE ModifyMenu = ModifyMenuW;
%ELSE
PROCEDURE ModifyMenu = ModifyMenuA;
%END

PROCEDURE RemoveMenu(a : HMENU;
                     uPosition : UINT;
                     uFlags : UINT) : BOOL;

PROCEDURE DeleteMenu(a : HMENU;
                     uPosition : UINT;
                     uFlags : UINT) : BOOL;

PROCEDURE SetMenuItemBitmaps(a : HMENU;
                             uPosition : UINT;
                             uFlags : UINT;
                             hBitmapUnchecked : HBITMAP;
                             hBitmapChecked : HBITMAP) : BOOL;

PROCEDURE GetMenuCheckMarkDimensions() : LONG;

PROCEDURE TrackPopupMenu(a : HMENU;
                         uFlags : UINT;
                         x : INTEGER;
                         y : INTEGER;
                         nReserved : INTEGER;
                         hWnd : HWND;
                         prcRect : RECT) : BOOL;


CONST
    MNC_IGNORE  = 0;
    MNC_CLOSE   = 1;
    MNC_EXECUTE = 2;
    MNC_SELECT  = 3;

TYPE
    TPMPARAMS = RECORD
        cbSize          : UINT;
        rcExclude       : RECT;
    END;
    LPTPMPARAMS = POINTER TO TPMPARAMS;

PROCEDURE TrackPopupMenuEx(a: HMENU;
                           b: UINT;
                           c: WINT;
                           d: WINT;
                           e: HWND;
                           VAR f: TPMPARAMS) : BOOL;

%IF WIN5 %THEN
CONST
    MNS_NOCHECK         = 80000000h;
    MNS_MODELESS        = 40000000h;
    MNS_DRAGDROP        = 20000000h;
    MNS_AUTODISMISS     = 10000000h;
    MNS_NOTIFYBYPOS     = 08000000h;
    MNS_CHECKORBMP      = 04000000h;

    MIM_MAXHEIGHT               = 00000001h;
    MIM_BACKGROUND              = 00000002h;
    MIM_HELPID                  = 00000004h;
    MIM_MENUDATA                =00000008h;
    MIM_STYLE                   = 00000010h;
    MIM_APPLYTOSUBMENUS         = 80000000h;

TYPE
    MENUINFO = RECORD
    cbSize      : DWORD;
    fMask       : DWORD;
    dwStyle     : DWORD;
    cyMax       : UINT;
    hbrBack     : HBRUSH;
    dwContextHelpID : DWORD;
    dwMenuData : DWORD;
    END;
    LPMENUINFO = POINTER TO MENUINFO;
    LPCMENUINFO = LPMENUINFO;

PROCEDURE GetMenuInfo(a : HMENU; VAR b : MENUINFO) : BOOL;

PROCEDURE SetMenuInfo(a : HMENU; b : MENUINFO);

PROCEDURE EndMenu() : BOOL;

(*
 * WM_MENUDRAG return values.
 *)
CONST
    MND_CONTINUE       =0;
    MND_ENDMENU        =1;

TYPE
    MENUGETOBJECTINFO = RECORD
    dwFlags : DWORD;
    uPos : UINT;
    hmenu : HMENU;
    riid : PVOID;
    pvObj : PVOID;
    END;
    PMENUGETOBJECTINFO = POINTER TO MENUGETOBJECTINFO;

(*
 * MENUGETOBJECTINFO dwFlags values
 *)

CONST
    MNGOF_GAP            = 00000003h;

(*
 * WM_MENUGETOBJECT return values
 *)
    MNGO_NOINTERFACE     = 00000000h;
    MNGO_NOERROR         = 00000001h;

%END

CONST
    MIIM_STATE       = 000000001h;
    MIIM_ID          = 000000002h;
    MIIM_SUBMENU     = 000000004h;
    MIIM_CHECKMARKS  = 000000008h;
    MIIM_TYPE        = 000000010h;
    MIIM_DATA        = 000000020h;

%IF WIN5 %THEN
    MIIM_STRING      = 00000040h;
    MIIM_BITMAP      = 00000080h;
    MIIM_FTYPE       = 00000100h;

    HBMMENU_CALLBACK            =CAST(HBITMAP, -1);
    HBMMENU_SYSTEM              =CAST(HBITMAP,  1);
    HBMMENU_MBAR_RESTORE        =CAST(HBITMAP,  2);
    HBMMENU_MBAR_MINIMIZE       =CAST(HBITMAP,  3);
    HBMMENU_MBAR_CLOSE          =CAST(HBITMAP,  5);
    HBMMENU_MBAR_CLOSE_D        =CAST(HBITMAP,  6);
    HBMMENU_MBAR_MINIMIZE_D     =CAST(HBITMAP,  7);
    HBMMENU_POPUP_CLOSE         =CAST(HBITMAP,  8);
    HBMMENU_POPUP_RESTORE       =CAST(HBITMAP,  9);
    HBMMENU_POPUP_MAXIMIZE      =CAST(HBITMAP, 10);
    HBMMENU_POPUP_MINIMIZE      =CAST(HBITMAP, 11);
%END

TYPE
    MENUITEMINFOA = RECORD
        cbSize          : UINT;
        fMask           : UINT;
        fType           : UINT;
        fState          : UINT;
        wID             : UINT;
        hSubMenu        : HMENU;
        hbmpChecked     : HBITMAP;
        hbmpUnchecked   : HBITMAP;
        dwItemData      : DWORD;
        dwTypeData      : LPSTR;
        cch             : UINT;
        %IF WIN5 %THEN
        (*NT only*)
        hbmpItem        : HBITMAP; (* used if MIIM_BITMAP*)
        %END
    END;
    LPMENUITEMINFOA     = POINTER TO MENUITEMINFOA;
    LPCMENUITEMINFOA    = LPMENUITEMINFOA;

    MENUITEMINFOW = RECORD
        cbSize          : UINT;
        fMask           : UINT;
        fType           : UINT;
        fState          : UINT;
        wID             : UINT;
        hSubMenu        : HMENU;
        hbmpChecked     : HBITMAP;
        hbmpUnchecked   : HBITMAP;
        dwItemData      : DWORD;
        dwTypeData      : LPWSTR;
        cch             : UINT;
        %IF WIN5 %THEN
        (*NT only*)
        hbmpItem        : HBITMAP; (* used if MIIM_BITMAP*)
        %END
    END;
    LPMENUITEMINFOW     = POINTER TO MENUITEMINFOW;
    LPCMENUITEMINFOW    = LPMENUITEMINFOW;

%IF UNICODE %THEN
    MENUITEMINFO        = MENUITEMINFOW;
    LPMENUITEMINFO      = LPMENUITEMINFOW;
%ELSE
    MENUITEMINFO        = MENUITEMINFOA;
    LPMENUITEMINFO      = LPMENUITEMINFOA;
%END
    LPCMENUITEMINFO     = LPMENUITEMINFO;

PROCEDURE InsertMenuItemA(
                        a: HMENU;
                        b: UINT;
                        c: BOOL;
                        d: MENUITEMINFOA
                        ) : BOOL;

PROCEDURE InsertMenuItemW(
                        a: HMENU;
                        b: UINT;
                        c: BOOL;
                        d: MENUITEMINFOW
                        ) : BOOL;

%IF UNICODE %THEN
PROCEDURE InsertMenuItem = InsertMenuItemW;
%ELSE
PROCEDURE InsertMenuItem = InsertMenuItemA;
%END

PROCEDURE GetMenuItemInfoA(
                            a: HMENU;
                            b: UINT;
                            c: BOOL;
                            VAR d: MENUITEMINFOA
                            ) : BOOL;

PROCEDURE GetMenuItemInfoW(
                            a: HMENU;
                            b: UINT;
                            c: BOOL;
                            VAR d: MENUITEMINFOW
                            ) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetMenuItemInfo = GetMenuItemInfoW;
%ELSE
PROCEDURE GetMenuItemInfo = GetMenuItemInfoA;
%END

PROCEDURE SetMenuItemInfoA(
                            a: HMENU;
                            b: UINT;
                            c: BOOL;
                            d: MENUITEMINFOA
                            ) : BOOL;

PROCEDURE SetMenuItemInfoW(
                            a: HMENU;
                            b: UINT;
                            c: BOOL;
                            d: MENUITEMINFOW
                            ) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetMenuItemInfo = SetMenuItemInfoW;
%ELSE
PROCEDURE SetMenuItemInfo = SetMenuItemInfoA;
%END

CONST
    GMDI_USEDISABLED    = 00001h;
    GMDI_GOINTOPOPUPS   = 00002h;

PROCEDURE GetMenuDefaultItem(hMenu : HMENU;
                             fByPos : UINT;
                             gmdiFlags : UINT) : UINT;

PROCEDURE SetMenuDefaultItem(hMenu : HMENU;
                             uItem : UINT;
                             fByPos :  UINT) : BOOL;

PROCEDURE GetMenuItemRect(hWnd : HWND;
                          hMenu : HWND;
                          uItem : UINT;
                          VAR lprcItem : RECT ) : BOOL;

PROCEDURE MenuItemFromPoint(hWnd : HWND;
                            hMenu : HMENU;
                            ptScreen : VALUE POINT) : WINT;


CONST
    TPM_LEFTBUTTON       = 00000h;
    TPM_RIGHTBUTTON      = 00002h;
    TPM_LEFTALIGN        = 00000h;
    TPM_CENTERALIGN      = 00004h;
    TPM_RIGHTALIGN       = 00008h;

    TPM_TOPALIGN        = 0000h;
    TPM_VCENTERALIGN    = 0010h;
    TPM_BOTTOMALIGN     = 0020h;

    TPM_HORIZONTAL      = 0000h;
    TPM_VERTICAL        = 0040h;
    TPM_NONOTIFY        = 0080h;
    TPM_RETURNCMD       = 0100h;

%IF WIN5 %THEN
    TPM_RECURSE         = 0001h;
%END

TYPE
    DROPSTRUCT = RECORD
        hwndSource      : HWND;
        hwndSink        : HWND;
        wFmt            : DWORD;
        dwData          : DWORD;
        ptDrop          : POINT;
        dwControlData   : DWORD;
    END;
    PDROPSTRUCT         = POINTER TO DROPSTRUCT;
    LPDROPSTRUCT        = PDROPSTRUCT;

CONST
    DOF_EXECUTABLE      = 8001h;
    DOF_DOCUMENT        = 8002h;
    DOF_DIRECTORY       = 8003h;
    DOF_MULTIPLE        = 8004h;
    DOF_PROGMAN         = 0001h;
    DOF_SHELLDATA       = 0002h;

    DO_DROPFILE         = 454C4946h;
    DO_PRINTFILE        = 544E5250h;

PROCEDURE DragObject(a: HWND;
                     b: HWND;
                     c: UINT;
                     d: DWORD;
                     e: HCURSOR) : DWORD;

PROCEDURE DragDetect(a: HWND; b: VALUE POINT) : BOOL;


PROCEDURE DrawIcon(hDC : HDC;
                   X : INTEGER;
                   Y : INTEGER;
                   hIcon : HICON) : BOOL;


CONST
    DT_TOP               = 00000h;
    DT_LEFT              = 00000h;
    DT_CENTER            = 00001h;
    DT_RIGHT             = 00002h;
    DT_VCENTER           = 00004h;
    DT_BOTTOM            = 00008h;
    DT_WORDBREAK         = 00010h;
    DT_SINGLELINE        = 00020h;
    DT_EXPANDTABS        = 00040h;
    DT_TABSTOP           = 00080h;
    DT_NOCLIP            = 00100h;
    DT_EXTERNALLEADING   = 00200h;
    DT_CALCRECT          = 00400h;
    DT_NOPREFIX          = 00800h;
    DT_INTERNAL          = 01000h;

    DT_EDITCONTROL       = 00002000h;
    DT_PATH_ELLIPSIS     = 00004000h;
    DT_END_ELLIPSIS      = 00008000h;
    DT_MODIFYSTRING      = 00010000h;
    DT_RTLREADING        = 00020000h;
    DT_WORD_ELLIPSIS     = 00040000h;

TYPE
    DRAWTEXTPARAMS = RECORD
        cbSize          : UINT;
        iTabLength      : WINT;
        iLeftMargin     : WINT;
        iRightMargin    : WINT;
        uiLengthDrawn   : UINT;
    END;
    LPDRAWTEXTPARAMS    = POINTER TO DRAWTEXTPARAMS;


PROCEDURE DrawTextA(hDC : HDC;
                    lpString : ARRAY OF ACHAR;
                    nCount : INTEGER;
                    lpRect : RECT;
                    uFormat : UINT) : INTEGER;

PROCEDURE DrawTextW(hDC : HDC;
                    lpString : ARRAY OF UCHAR;
                    nCount : INTEGER;
                    lpRect : RECT;
                    uFormat : UINT) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DrawText = DrawTextW;
%ELSE
PROCEDURE DrawText = DrawTextA;
%END


PROCEDURE DrawTextExA(a: HDC;
                      b: ARRAY OF ACHAR;
                      c: WINT;
                      d: RECT;
                      e: UINT;
                      VAR f: DRAWTEXTPARAMS) : WINT;

PROCEDURE DrawTextExW(a: HDC;
                      b: ARRAY OF UCHAR;
                      c: WINT;
                      d: RECT;
                      e: UINT;
                      VAR f: DRAWTEXTPARAMS) : WINT;
%IF UNICODE %THEN
PROCEDURE DrawTextEx = DrawTextExW;
%ELSE
PROCEDURE DrawTextEx = DrawTextExA;
%END



PROCEDURE GrayStringA(hDC : HDC;
                      hBrush : HBRUSH;
                      lpOutputFunc : GRAYSTRINGPROC;
                      lpData : LPARAM;
                      nCount : INTEGER;
                      X : INTEGER;
                      Y : INTEGER;
                      nWidth : INTEGER;
                      nHeight : INTEGER) : BOOL;

PROCEDURE GrayStringW(hDC : HDC;
                      hBrush : HBRUSH;
                      lpOutputFunc : GRAYSTRINGPROC;
                      lpData : LPARAM;
                      nCount : INTEGER;
                      X : INTEGER;
                      Y : INTEGER;
                      nWidth : INTEGER;
                      nHeight : INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE GrayString = GrayStringW;
%ELSE
PROCEDURE GrayString = GrayStringA;
%END

CONST
    DST_COMPLEX     = 0000h;
    DST_TEXT        = 0001h;
    DST_PREFIXTEXT  = 0002h;
    DST_ICON        = 0003h;
    DST_BITMAP      = 0004h;

    DSS_NORMAL      = 0000h;
    DSS_UNION       = 0010h;
    DSS_DISABLED    = 0020h;
    DSS_MONO        = 0080h;
    DSS_RIGHT       = 8000h;

PROCEDURE DrawStateA(a: HDC;
                     b: HBRUSH;
                     c: DRAWSTATEPROC;
                     d: LPARAM;
                     e: WPARAM;
                     f: WINT;
                     g: WINT;
                     h: WINT;
                     i: WINT;
                     j: UINT) : BOOL;

PROCEDURE DrawStateW(a: HDC;
                     b: HBRUSH;
                     c: DRAWSTATEPROC;
                     d: LPARAM;
                     e: WPARAM;
                     f: WINT;
                     g: WINT;
                     h: WINT;
                     i: WINT;
                     j: UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE DrawState = DrawStateW;
%ELSE
PROCEDURE DrawState = DrawStateA;
%END

PROCEDURE TabbedTextOutA(hDC : HDC;
                         X : INTEGER;
                         Y : INTEGER;
                         lpString : ARRAY OF ACHAR;
                         nCount : INTEGER;
                         nTabPositions : INTEGER;
                         lpnTabStopPositions : ARRAY OF WINT;
                         nTabOrigin : INTEGER) : LONG;

PROCEDURE TabbedTextOutW(hDC : HDC;
                         X : INTEGER;
                         Y : INTEGER;
                         lpString : ARRAY OF UCHAR;
                         nCount : INTEGER;
                         nTabPositions : INTEGER;
                         lpnTabStopPositions : ARRAY OF WINT;
                         nTabOrigin : INTEGER) : LONG;

%IF UNICODE %THEN
PROCEDURE TabbedTextOut = TabbedTextOutW;
%ELSE
PROCEDURE TabbedTextOut = TabbedTextOutA;
%END

PROCEDURE GetTabbedTextExtentA(hDC : HDC;
                               lpString : ARRAY OF ACHAR;
                               nCount : INTEGER;
                               nTabPositions : INTEGER;
                               VAR lpnTabStopPositions : ARRAY OF WINT) : DWORD;

PROCEDURE GetTabbedTextExtentW(hDC : HDC;
                               lpString : ARRAY OF UCHAR;
                               nCount : INTEGER;
                               nTabPositions : INTEGER;
                               VAR lpnTabStopPositions : ARRAY OF WINT) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetTabbedTextExtent = GetTabbedTextExtentW;
%ELSE
PROCEDURE GetTabbedTextExtent = GetTabbedTextExtentA;
%END

PROCEDURE UpdateWindow(hWnd : HWND) : BOOL;

PROCEDURE SetActiveWindow(hWnd : HWND) : HWND;

PROCEDURE GetForegroundWindow() : HWND;


PROCEDURE PaintDesktop(hdc : HDC) : BOOL;

PROCEDURE SwitchToThisWindow(hwnd : HWND; fUnknown : BOOL);


PROCEDURE SetForegroundWindow(hWnd : HWND) : BOOL;

PROCEDURE WindowFromDC(hDC : HDC) : HWND;

PROCEDURE GetDC(hWnd : HWND) : HDC;

PROCEDURE GetDCEx(hWnd : HWND;
                  hrgnClip : HRGN;
                  flags : DWORD) : HDC;


CONST
    DCX_WINDOW           = 000000001h;
    DCX_CACHE            = 000000002h;
    DCX_NORESETATTRS     = 000000004h;
    DCX_CLIPCHILDREN     = 000000008h;
    DCX_CLIPSIBLINGS     = 000000010h;
    DCX_PARENTCLIP       = 000000020h;
    DCX_EXCLUDERGN       = 000000040h;
    DCX_INTERSECTRGN     = 000000080h;
    DCX_EXCLUDEUPDATE    = 000000100h;
    DCX_INTERSECTUPDATE  = 000000200h;
    DCX_LOCKWINDOWUPDATE = 000000400h;
    DCX_NORECOMPUTE      = 000100000h;
    DCX_VALIDATE         = 000200000h;

PROCEDURE AlignRects(arc : RECT;
                     cCount : DWORD;
                     iPrimary : DWORD;
                     dwFlags : DWORD) : BOOL;

(*
 AlignRects flags
*)
CONST
    CUDR_NORMAL             =00000h;
    CUDR_NOSNAPTOGRID       =00001h;
    CUDR_NORESOLVEPOSITIONS =00002h;
    CUDR_NOCLOSEGAPS        =00004h;
    CUDR_NEGATIVECOORDS     =00008h;
    CUDR_NOPRIMARY          =00010h;

PROCEDURE GetWindowDC(hWnd : HWND) : HDC;

PROCEDURE ReleaseDC(hWnd : HWND;
                    hDC : HDC) : INTEGER;

PROCEDURE BeginPaint(hWnd : HWND;
                     VAR lpPaint : PAINTSTRUCT) : HDC;

PROCEDURE EndPaint(hWnd : HWND;
                   VAR lpPaint : PAINTSTRUCT) : BOOL;

PROCEDURE GetUpdateRect(hWnd : HWND;
                        VAR LPRect : RECT;
                        bErase : BOOL) : BOOL;

PROCEDURE GetUpdateRgn(hWnd : HWND;
                       hRgn : HRGN;
                       bErase : BOOL) : INTEGER;

PROCEDURE SetWindowRgn(hWnd : HWND;
                       hRgn : HRGN;
                       bRedraw : BOOL) : WINT;

PROCEDURE GetWindowRgn(hWnd : HWND;
                       hRgn : HRGN) : WINT;

PROCEDURE ExcludeUpdateRgn(hDC : HDC;
                           hWnd : HWND) : INTEGER;

PROCEDURE InvalidateRect(hWnd : HWND;
                         lpRect : RECT;
                         bErase : BOOL) : BOOL;

PROCEDURE ValidateRect(hWnd : HWND;
                       lpRect : RECT) : BOOL;

PROCEDURE InvalidateRgn(hWnd : HWND;
                        hRgn : HRGN;
                        bErase : BOOL) : BOOL;

PROCEDURE ValidateRgn(hWnd : HWND;
                      hRgn : HRGN) : BOOL;

PROCEDURE RedrawWindow(hWnd : HWND;
                       lprcUpdate : RECT;
                       hrgnUpdate : HRGN;
                       flags : UINT) : BOOL;


CONST
    RDW_INVALIDATE       = 00001h;
    RDW_INTERNALPAINT    = 00002h;
    RDW_ERASE            = 00004h;
    RDW_VALIDATE         = 00008h;
    RDW_NOINTERNALPAINT  = 00010h;
    RDW_NOERASE          = 00020h;
    RDW_NOCHILDREN       = 00040h;
    RDW_ALLCHILDREN      = 00080h;
    RDW_UPDATENOW        = 00100h;
    RDW_ERASENOW         = 00200h;
    RDW_FRAME            = 00400h;
    RDW_NOFRAME          = 00800h;

PROCEDURE LockWindowUpdate(hWndLock : HWND) : BOOL;

PROCEDURE ScrollWindow(hWnd : HWND;
                       XAmount : INTEGER;
                       YAmount : INTEGER;
                       lpRect : RECT;
                       lpClipRect : RECT) : BOOL;

PROCEDURE ScrollDC(hDC : HDC;
                   dx : INTEGER;
                   dy : INTEGER;
                   lprcScroll : RECT;
                   lprcClip : RECT;
                   hrgnUpdate : HRGN;
                   VAR lprcUpdate : RECT) : BOOL;

PROCEDURE ScrollWindowEx(hWnd : HWND;
                         dx : INTEGER;
                         dy : INTEGER;
                         prcScroll : RECT;
                         prcClip : RECT;
                         hrgnUpdate : HRGN;
                         VAR prcUpdate : RECT;
                         flags : UINT) : INTEGER;


CONST
    SW_SCROLLCHILDREN    = 00001h;
    SW_INVALIDATE        = 00002h;
    SW_ERASE             = 00004h;
%IF WIN5 %THEN
    SW_SMOOTHSCROLL     = 0010h;  (* Use smooth scrolling *)
%END

PROCEDURE SetScrollPos(hWnd : HWND;
                       nBar : INTEGER;
                       nPos : INTEGER;
                       bRedraw : BOOL) : INTEGER;

PROCEDURE GetScrollPos(hWnd : HWND;
                       nBar : INTEGER) : INTEGER;

PROCEDURE SetScrollRange(hWnd : HWND;
                         nBar : INTEGER;
                         nMinPos : INTEGER;
                         nMaxPos : INTEGER;
                         bRedraw : BOOL) : BOOL;

PROCEDURE GetScrollRange(hWnd : HWND;
                         nBar : INTEGER;
                         VAR lpMinPos : WINT;
                         VAR lpMaxPos : WINT) : BOOL;

PROCEDURE ShowScrollBar(hWnd : HWND;
                        wBar : INTEGER;
                        bShow : BOOL) : BOOL;

PROCEDURE EnableScrollBar(hWnd : HWND;
                          wSBflags : UINT;
                          wArrows : UINT) : BOOL;


CONST
    ESB_ENABLE_BOTH      = 00000h;
    ESB_DISABLE_BOTH     = 00003h;
    ESB_DISABLE_LEFT     = 00001h;
    ESB_DISABLE_RIGHT    = 00002h;
    ESB_DISABLE_UP       = 00001h;
    ESB_DISABLE_DOWN     = 00002h;
    ESB_DISABLE_LTUP     = ESB_DISABLE_LEFT;
    ESB_DISABLE_RTDN     = ESB_DISABLE_RIGHT;


PROCEDURE SetPropA(hWnd : HWND;
                   lpString : ARRAY OF ACHAR;
                   hData : HANDLE) : BOOL;

PROCEDURE SetPropW(hWnd : HWND;
                   lpString : ARRAY OF UCHAR;
                   hData : HANDLE) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetProp = SetPropW;
%ELSE
PROCEDURE SetProp = SetPropA;
%END


PROCEDURE GetPropA(hWnd : HWND;
                   lpString : ARRAY OF ACHAR) : HANDLE;

PROCEDURE GetPropW(hWnd : HWND;
                   lpString : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE GetProp = GetPropW;
%ELSE
PROCEDURE GetProp = GetPropA;
%END

PROCEDURE RemovePropA(hWnd : HWND;
                      lpString : ARRAY OF ACHAR) : HANDLE;

PROCEDURE RemovePropW(hWnd : HWND;
                      lpString : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE RemoveProp = RemovePropW;
%ELSE
PROCEDURE RemoveProp = RemovePropA;
%END

PROCEDURE EnumPropsExA(hWnd : HWND;
                       lpEnumFunc : PROPENUMPROCEXA;
                       lParam : LPARAM) : INTEGER;

PROCEDURE EnumPropsExW(hWnd : HWND;
                       lpEnumFunc : PROPENUMPROCEXW;
                       lParam : LPARAM) : INTEGER;

%IF UNICODE %THEN
PROCEDURE EnumPropsEx = EnumPropsExW;
%ELSE
PROCEDURE EnumPropsEx = EnumPropsExA;
%END

PROCEDURE EnumPropsA(hWnd : HWND;
                     lpEnumFunc : PROPENUMPROCA) : INTEGER;

PROCEDURE EnumPropsW(hWnd : HWND;
                     lpEnumFunc : PROPENUMPROCW) : INTEGER;

%IF UNICODE %THEN
PROCEDURE EnumProps = EnumPropsW;
%ELSE
PROCEDURE EnumProps = EnumPropsA;
%END

PROCEDURE SetWindowTextA(hWnd : HWND;
                         lpString : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetWindowTextW(hWnd : HWND;
                         lpString : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetWindowText = SetWindowTextW;
%ELSE
PROCEDURE SetWindowText = SetWindowTextA;
%END

PROCEDURE GetWindowTextA(hWnd : HWND;
                         VAR lpString : ARRAY OF ACHAR;
                         nMaxCount : INTEGER) : INTEGER;

PROCEDURE GetWindowTextW(hWnd : HWND;
                         VAR lpString : ARRAY OF UCHAR;
                         nMaxCount : INTEGER) : INTEGER;

%IF UNICODE %THEN
PROCEDURE GetWindowText = GetWindowTextW;
%ELSE
PROCEDURE GetWindowText = GetWindowTextA;
%END

PROCEDURE GetWindowTextLengthA(hWnd : HWND) : INTEGER;

PROCEDURE GetWindowTextLengthW(hWnd : HWND) : INTEGER;

%IF UNICODE %THEN
PROCEDURE GetWindowTextLength = GetWindowTextLengthW;
%ELSE
PROCEDURE GetWindowTextLength = GetWindowTextLengthA;
%END

PROCEDURE GetClientRect(hWnd : HWND;
                        VAR lpRect : RECT) : BOOL;

PROCEDURE GetWindowRect(hWnd : HWND;
                        VAR lpRect : RECT) : BOOL;

PROCEDURE AdjustWindowRect(VAR lpRect : RECT;
                           dwStyle : DWORD;
                           bMenu : BOOL) : BOOL;

PROCEDURE AdjustWindowRectEx(VAR lpRect : RECT;
                             dwStyle : DWORD;
                             bMenu : BOOL;
                             dwExStyle : DWORD) : BOOL;

CONST
    HELPINFO_WINDOW    = 1;
    HELPINFO_MENUITEM  = 2;

TYPE
    HELPINFO = RECORD
        cbSize  : UINT;
        iContextType: WINT;
        iCtrlId : WINT;
        hItemHandle     : HANDLE;
        dwContextId     : DWORD;
        MousePos        : POINT;
    END;
    LPHELPINFO = POINTER TO HELPINFO;

PROCEDURE SetWindowContextHelpId(a: HWND; b: DWORD) : BOOL;

PROCEDURE GetWindowContextHelpId(a: HWND) : DWORD;

PROCEDURE SetMenuContextHelpId(a: HMENU; b: DWORD) : BOOL;

PROCEDURE GetMenuContextHelpId(a: HMENU) : DWORD;


CONST
    MB_OK                = 000000000h;
    MB_OKCANCEL          = 000000001h;
    MB_ABORTRETRYIGNORE  = 000000002h;
    MB_YESNOCANCEL       = 000000003h;
    MB_YESNO             = 000000004h;
    MB_RETRYCANCEL       = 000000005h;
    MB_ICONHAND          = 000000010h;
    MB_ICONSTOP          = MB_ICONHAND;
    MB_ICONQUESTION      = 000000020h;
    MB_ICONEXCLAMATION   = 000000030h;
    MB_ICONASTERISK      = 000000040h;

    MB_ICONWARNING       = MB_ICONEXCLAMATION;
    MB_ICONERROR         = MB_ICONHAND;

    MB_ICONINFORMATION   = MB_ICONASTERISK;

    MB_DEFBUTTON1        = 000000000h;
    MB_DEFBUTTON2        = 000000100h;
    MB_DEFBUTTON3        = 000000200h;
    MB_DEFBUTTON4        = 000000300h;(*95*)

    MB_APPLMODAL         = 000000000h;
    MB_SYSTEMMODAL       = 000001000h;
    MB_TASKMODAL         = 000002000h;

    MB_HELP              = 000004000h;
    MB_RIGHT             = 000080000h;
    MB_RTLREADING        = 000100000h;


    MB_NOFOCUS                  = 000008000h;
    MB_SETFOREGROUND            = 000010000h;
    MB_DEFAULT_DESKTOP_ONLY     = 000020000h;
    MB_TOPMOST                  = 000040000h;

    MB_SERVICE_NOTIFICATION     = 00200000h;(*NT*)
    MB_SERVICE_NOTIFICATION_NT3X= 00040000h;(*NT*)

    MB_TYPEMASK          = 00000000Fh;
    MB_USERICON          = 000000080h;(*95*)

    MB_ICONMASK          = 0000000F0h;
    MB_DEFMASK           = 000000F00h;
    MB_MODEMASK          = 000003000h;
    MB_MISCMASK          = 00000C000h;

PROCEDURE MessageBoxA(hWnd : HWND;
                      lpText : ARRAY OF ACHAR;
                      lpCaption : ARRAY OF ACHAR;
                      uType : UINT) : INTEGER;

PROCEDURE MessageBoxW(hWnd : HWND;
                      lpText : ARRAY OF UCHAR;
                      lpCaption : ARRAY OF UCHAR;
                      uType : UINT) : INTEGER;

%IF UNICODE %THEN
PROCEDURE MessageBox = MessageBoxW;
%ELSE
PROCEDURE MessageBox = MessageBoxA;
%END

PROCEDURE MessageBoxExA(hWnd : HWND;
                        lpText : ARRAY OF ACHAR;
                        lpCaption : ARRAY OF ACHAR;
                        uType : UINT;
                        wLanguageId : WORD) : INTEGER;

PROCEDURE MessageBoxExW(hWnd : HWND;
                        lpText : ARRAY OF UCHAR;
                        lpCaption : ARRAY OF UCHAR;
                        uType : UINT;
                        wLanguageId : WORD) : INTEGER;

%IF UNICODE %THEN
PROCEDURE MessageBoxEx = MessageBoxExW;
%ELSE
PROCEDURE MessageBoxEx = MessageBoxExA;
%END

TYPE
    MSGBOXCALLBACK      = PROCEDURE(VAR HELPINFO) [EXPORT];

    MSGBOXPARAMSA = RECORD
        cbSize          : UINT;
        hwndOwner       : HWND;
        hInstance       : HINSTANCE;
        lpszText        : LPCSTR;
        lpszCaption     : LPCSTR;
        dwStyle         : DWORD;
        lpszIcon        : LPCSTR;
        dwContextHelpId : DWORD;
        lpfnMsgBoxCallback : MSGBOXCALLBACK;
        dwLanguageId    : DWORD;
    END;
    PMSGBOXPARAMSA   = POINTER TO MSGBOXPARAMSA;
    LPMSGBOXPARAMSA  = PMSGBOXPARAMSA;

    MSGBOXPARAMSW = RECORD
        cbSize          : UINT;
        hwndOwner       : HWND;
        hInstance       : HINSTANCE;
        lpszText        : LPCWSTR;
        lpszCaption     : LPCWSTR;
        dwStyle         : DWORD;
        lpszIcon        : LPCWSTR;
        dwContextHelpId : DWORD;
        lpfnMsgBoxCallback : MSGBOXCALLBACK;
        dwLanguageId    : DWORD;
    END;
    PMSGBOXPARAMSW   = POINTER TO MSGBOXPARAMSW;
    LPMSGBOXPARAMSW  = PMSGBOXPARAMSW;

%IF UNICODE %THEN
    MSGBOXPARAMS   = MSGBOXPARAMSW;
    PMSGBOXPARAMS   = PMSGBOXPARAMSW;
%ELSE
    MSGBOXPARAMS   = MSGBOXPARAMSA;
    PMSGBOXPARAMS   = PMSGBOXPARAMSA;
%END
    LPMSGBOXPARAMS  = PMSGBOXPARAMS;

PROCEDURE MessageBoxIndirectA(VAR a: MSGBOXPARAMSA) : WINT;

PROCEDURE MessageBoxIndirectW(VAR a: MSGBOXPARAMSW) : WINT;

%IF UNICODE %THEN
PROCEDURE MessageBoxIndirect = MessageBoxIndirectW;
%ELSE
PROCEDURE MessageBoxIndirect = MessageBoxIndirectA;
%END

PROCEDURE MessageBeep(uType : UINT) : BOOL;

PROCEDURE ShowCursor(bShow : BOOL) : INTEGER;

PROCEDURE SetCursorPos(X : INTEGER;
                       Y : INTEGER) : BOOL;

PROCEDURE SetCursor(hCursor : HCURSOR) : HCURSOR;

PROCEDURE GetCursorPos(VAR lpPoint : POINT) : BOOL;

PROCEDURE ClipCursor(lpRect : RECT) : BOOL;

PROCEDURE GetClipCursor(VAR lpRect : RECT) : BOOL;

PROCEDURE GetCursor() : HCURSOR;

PROCEDURE CreateCaret(hWnd : HWND;
                      hBitmap : HBITMAP;
                      nWidth : INTEGER;
                      nHeight : INTEGER) : BOOL;

PROCEDURE GetCaretBlinkTime() : UINT;

PROCEDURE SetCaretBlinkTime(uMSeconds : UINT) : BOOL;

PROCEDURE DestroyCaret() : BOOL;

PROCEDURE HideCaret(hWnd : HWND) : BOOL;

PROCEDURE ShowCaret(hWnd : HWND) : BOOL;

PROCEDURE SetCaretPos(X : INTEGER;
                      Y : INTEGER) : BOOL;

PROCEDURE GetCaretPos(VAR lpPoint : POINT) : BOOL;

PROCEDURE ClientToScreen(hWnd : HWND;
                         VAR lpPoint : POINT) : BOOL;

PROCEDURE ScreenToClient(hWnd : HWND;
                         VAR lpPoint : POINT) : BOOL;

PROCEDURE MapWindowPoints(hWndFrom : HWND;
                          hWndTo : HWND;
                          VAR lpPoints : ARRAY OF POINT;
                          cPoints : UINT) : INTEGER;

PROCEDURE WindowFromPoint(Point : VALUE POINT) : HWND;

PROCEDURE ChildWindowFromPoint(hWndParent : HWND;
                               Point : VALUE POINT) : HWND;


CONST
    CWP_ALL             = 0000h;
    CWP_SKIPINVISIBLE   = 0001h;
    CWP_SKIPDISABLED    = 0002h;
    CWP_SKIPTRANSPARENT = 0004h;

PROCEDURE ChildWindowFromPointEx(a: HWND; b: VALUE POINT; c: UINT) : HWND;




CONST
    CTLCOLOR_MSGBOX      = 0;
    CTLCOLOR_EDIT        = 1;
    CTLCOLOR_LISTBOX     = 2;
    CTLCOLOR_BTN         = 3;
    CTLCOLOR_DLG         = 4;
    CTLCOLOR_SCROLLBAR   = 5;
    CTLCOLOR_STATIC      = 6;
    CTLCOLOR_MAX         = 8;

    COLOR_SCROLLBAR      = 0;
    COLOR_BACKGROUND     = 1;
    COLOR_ACTIVECAPTION  = 2;
    COLOR_INACTIVECAPTION= 3;
    COLOR_MENU           = 4;
    COLOR_WINDOW         = 5;
    COLOR_WINDOWFRAME    = 6;
    COLOR_MENUTEXT       = 7;
    COLOR_WINDOWTEXT     = 8;
    COLOR_CAPTIONTEXT    = 9;
    COLOR_ACTIVEBORDER   = 10;
    COLOR_INACTIVEBORDER = 11;
    COLOR_APPWORKSPACE   = 12;
    COLOR_HIGHLIGHT      = 13;
    COLOR_HIGHLIGHTTEXT  = 14;
    COLOR_BTNFACE        = 15;
    COLOR_BTNSHADOW      = 16;
    COLOR_GRAYTEXT       = 17;
    COLOR_BTNTEXT        = 18;
    COLOR_INACTIVECAPTIONTEXT= 19;
    COLOR_BTNHIGHLIGHT   = 20;

    COLOR_3DDKSHADOW        = 21;
    COLOR_3DLIGHT           = 22;
    COLOR_INFOTEXT          = 23;
    COLOR_INFOBK            = 24;

%IF WIN5 %THEN
    COLOR_HOTLIGHT                  =26;
    COLOR_GRADIENTACTIVECAPTION     =27;
    COLOR_GRADIENTINACTIVECAPTION   =28;
%END

    COLOR_DESKTOP           = COLOR_BACKGROUND;
    COLOR_3DFACE            = COLOR_BTNFACE;
    COLOR_3DSHADOW          = COLOR_BTNSHADOW;
    COLOR_3DHIGHLIGHT       = COLOR_BTNHIGHLIGHT;
    COLOR_3DHILIGHT         = COLOR_BTNHIGHLIGHT;
    COLOR_BTNHILIGHT        = COLOR_BTNHIGHLIGHT;


PROCEDURE GetSysColor(nIndex : INTEGER) : DWORD;


PROCEDURE GetSysColorBrush(nIndex : WINT) : HBRUSH;


PROCEDURE SetSysColors(cElements : INTEGER;
                       lpaElements : ARRAY OF WINT;
                       lpaRgbValues : ARRAY OF COLORREF) : BOOL;

PROCEDURE DrawFocusRect(hDC : HDC;
                        lprc : RECT) : BOOL;

PROCEDURE FillRect(hDC : HDC;
                   lprc : RECT;
                   hbr : HBRUSH) : INTEGER;

PROCEDURE FrameRect(hDC : HDC;
                    lprc : RECT;
                    hbr : HBRUSH) : INTEGER;

PROCEDURE InvertRect(hDC : HDC;
                     lprc : RECT) : BOOL;

PROCEDURE SetRect(VAR lprc : RECT;
                  xLeft : INTEGER;
                  yTop : INTEGER;
                  xRight : INTEGER;
                  yBottom : INTEGER) : BOOL;

PROCEDURE SetRectEmpty(VAR lprc : RECT) : BOOL;

PROCEDURE CopyRect(VAR LPRCDST : RECT;
                   lprcSrc : RECT) : BOOL;

PROCEDURE InflateRect(VAR lprc : RECT;
                      dx : INTEGER;
                      dy : INTEGER) : BOOL;

PROCEDURE IntersectRect(VAR lprcDst : RECT;
                        lprcSrc1 : RECT;
                        lprcSrc2 : RECT) : BOOL;

PROCEDURE UnionRect(VAR lprcDst : RECT;
                    lprcSrc1 : RECT;
                    lprcSrc2 : RECT) : BOOL;

PROCEDURE SubtractRect(VAR lprcDst : RECT;
                       lprcSrc1 : RECT;
                       lprcSrc2 : RECT) : BOOL;

PROCEDURE OffsetRect(VAR lprc : RECT;
                     dx : INTEGER;
                     dy : INTEGER) : BOOL;

PROCEDURE IsRectEmpty(lprc : RECT) : BOOL;

PROCEDURE EqualRect(lprc1 : RECT;
                    lprc2 : RECT) : BOOL;

PROCEDURE PtInRect(lprc : RECT;
                   pt : VALUE POINT) : BOOL;

PROCEDURE GetWindowWord(hWnd : HWND;
                        nIndex : INTEGER) : WORD;

PROCEDURE SetWindowWord(hWnd : HWND;
                        nIndex : INTEGER;
                        wNewWord : WORD) : WORD;

PROCEDURE GetWindowLongA(hWnd : HWND;
                         nIndex : INTEGER) : LONG;

PROCEDURE GetWindowLongW(hWnd : HWND;
                         nIndex : INTEGER) : LONG;

%IF UNICODE %THEN
PROCEDURE GetWindowLong = GetWindowLongW;
%ELSE
PROCEDURE GetWindowLong = GetWindowLongA;
%END

PROCEDURE SetWindowLongA(hWnd : HWND;
                         nIndex : INTEGER;
                         dwNewLong : LONG) : LONG;

PROCEDURE SetWindowLongW(hWnd : HWND;
                         nIndex : INTEGER;
                         dwNewLong : LONG) : LONG;

%IF UNICODE %THEN
PROCEDURE SetWindowLong = SetWindowLongW;
%ELSE
PROCEDURE SetWindowLong = SetWindowLongA;
%END

PROCEDURE GetClassWord(hWnd : HWND;
                       nIndex : INTEGER) : WORD;

PROCEDURE SetClassWord(hWnd : HWND;
                       nIndex : INTEGER;
                       wNewWord : WORD) : WORD;

PROCEDURE GetClassLongA(hWnd : HWND;
                        nIndex : INTEGER) : DWORD;

PROCEDURE GetClassLongW(hWnd : HWND;
                        nIndex : INTEGER) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetClassLong = GetClassLongW;
%ELSE
PROCEDURE GetClassLong = GetClassLongA;
%END

PROCEDURE SetClassLongA(hWnd : HWND;
                        nIndex : INTEGER;
                        dwNewLong : LONG) : DWORD;

PROCEDURE SetClassLongW(hWnd : HWND;
                        nIndex : INTEGER;
                        dwNewLong : LONG) : DWORD;

%IF UNICODE %THEN
PROCEDURE SetClassLong = SetClassLongW;
%ELSE
PROCEDURE SetClassLong = SetClassLongA;
%END

PROCEDURE GetDesktopWindow() : HWND;

PROCEDURE GetParent(hWnd : HWND) : HWND;

PROCEDURE SetParent(hWndChild : HWND;
                    hWndNewParent : HWND) : HWND;

PROCEDURE EnumChildWindows(hWndParent : HWND;
                           lpEnumFunc : WNDENUMPROC;
                           lParam : LPARAM) : BOOL;

PROCEDURE FindWindowA(lpClassName : ARRAY OF ACHAR;
                      lpWindowName : ARRAY OF ACHAR) : HWND;

PROCEDURE FindWindowW(lpClassName : ARRAY OF UCHAR;
                      lpWindowName : ARRAY OF UCHAR) : HWND;

%IF UNICODE %THEN
PROCEDURE FindWindow = FindWindowW;
%ELSE
PROCEDURE FindWindow = FindWindowA;
%END

PROCEDURE FindWindowExA(a: HWND;
                        b: HWND;
                        c: ARRAY OF ACHAR;
                        d: ARRAY OF ACHAR) : HWND;

PROCEDURE FindWindowExW(a: HWND;
                        b: HWND;
                        c: ARRAY OF UCHAR;
                        d: ARRAY OF UCHAR) : HWND;

%IF UNICODE %THEN
PROCEDURE FindWindowEx = FindWindowExW;
%ELSE
PROCEDURE FindWindowEx = FindWindowExA;
%END


PROCEDURE EnumWindows(lpEnumFunc : WNDENUMPROC;
                      lParam : LPARAM) : BOOL;

PROCEDURE EnumThreadWindows(dwThreadId : DWORD;
                            lpfn : WNDENUMPROC;
                            lParam : LPARAM) : BOOL;

PROCEDURE GetClassNameA(hWnd : HWND;
                        VAR lpClassName : ARRAY OF ACHAR;
                        nMaxCount : INTEGER) : INTEGER;

PROCEDURE GetClassNameW(hWnd : HWND;
                        VAR lpClassName : ARRAY OF UCHAR;
                        nMaxCount : INTEGER) : INTEGER;

%IF UNICODE %THEN
PROCEDURE GetClassName = GetClassNameW;
%ELSE
PROCEDURE GetClassName = GetClassNameA;
%END

PROCEDURE GetTopWindow(hWnd : HWND) : HWND;


PROCEDURE GetWindowThreadProcessId(hWnd : HWND;
                                   VAR lpdwProcessId : DWORD) : DWORD;

PROCEDURE GetLastActivePopup(hWnd : HWND) : HWND;


CONST
    GW_HWNDFIRST         = 0;
    GW_HWNDLAST          = 1;
    GW_HWNDNEXT          = 2;
    GW_HWNDPREV          = 3;
    GW_OWNER             = 4;
    GW_CHILD             = 5;
%IF WIN5 %THEN
    GW_ENABLEDPOPUP      = 6;
    GW_MAX               = 6;
%ELSE
    GW_MAX               = 5;
%END

PROCEDURE GetWindow(hWnd : HWND;
                    uCmd : UINT) : HWND;

PROCEDURE SetWindowsHookA(nFilterType : INTEGER;
                          pfnFilterProc : HOOKPROC) : HHOOK;

PROCEDURE SetWindowsHookW(nFilterType : INTEGER;
                          pfnFilterProc : HOOKPROC) : HHOOK;

%IF UNICODE %THEN
PROCEDURE SetWindowsHook = SetWindowsHookW;
%ELSE
PROCEDURE SetWindowsHook = SetWindowsHookA;
%END

PROCEDURE UnhookWindowsHook(nCode : INTEGER;
                            pfnFilterProc : HOOKPROC) : BOOL;

PROCEDURE SetWindowsHookExA(idHook : INTEGER;
                            lpfn : HOOKPROC;
                            hmod : HINSTANCE;
                            dwThreadId : DWORD) : HHOOK;

PROCEDURE SetWindowsHookExW(idHook : INTEGER;
                            lpfn : HOOKPROC;
                            hmod : HINSTANCE;
                            dwThreadId : DWORD) : HHOOK;

%IF UNICODE %THEN
PROCEDURE SetWindowsHookEx = SetWindowsHookExW;
%ELSE
PROCEDURE SetWindowsHookEx = SetWindowsHookExA;
%END

PROCEDURE UnhookWindowsHookEx(hhk : HHOOK) : BOOL;

PROCEDURE CallNextHookEx(hhk : HHOOK;
                         nCode : INTEGER;
                         wParam : WPARAM;
                         lParam : LPARAM) : LRESULT;

CONST
    MF_INSERT            = 000000000h;
    MF_CHANGE            = 000000080h;
    MF_APPEND            = 000000100h;
    MF_DELETE            = 000000200h;
    MF_REMOVE            = 000001000h;
    MF_BYCOMMAND         = 000000000h;
    MF_BYPOSITION        = 000000400h;
    MF_SEPARATOR         = 000000800h;
    MF_ENABLED           = 000000000h;
    MF_GRAYED            = 000000001h;
    MF_DISABLED          = 000000002h;
    MF_UNCHECKED         = 000000000h;
    MF_CHECKED           = 000000008h;
    MF_USECHECKBITMAPS   = 000000200h;
    MF_STRING            = 000000000h;
    MF_BITMAP            = 000000004h;
    MF_OWNERDRAW         = 000000100h;
    MF_POPUP             = 000000010h;
    MF_MENUBARBREAK      = 000000020h;
    MF_MENUBREAK         = 000000040h;
    MF_UNHILITE          = 000000000h;
    MF_HILITE            = 000000080h;
    MF_SYSMENU           = 000002000h;
    MF_HELP              = 000004000h;
    MF_MOUSESELECT       = 000008000h;

    MF_DEFAULT           = 000001000h;
    MF_RIGHTJUSTIFY      = 000004000h;
    MF_END               = 000000080h;

    MFT_STRING           = MF_STRING;
    MFT_BITMAP           = MF_BITMAP;
    MFT_MENUBARBREAK     = MF_MENUBARBREAK;
    MFT_MENUBREAK        = MF_MENUBREAK;
    MFT_OWNERDRAW        = MF_OWNERDRAW;
    MFT_RADIOCHECK       = 000000200h;
    MFT_SEPARATOR        = MF_SEPARATOR;
    MFT_RIGHTORDER       = 000002000h;
    MFT_RIGHTJUSTIFY     = MF_RIGHTJUSTIFY;

    MFS_GRAYED           = 000000003h;
    MFS_DISABLED         = MFS_GRAYED;
    MFS_CHECKED          = MF_CHECKED;
    MFS_HILITE           = MF_HILITE;
    MFS_ENABLED          = MF_ENABLED;
    MFS_UNCHECKED        = MF_UNCHECKED;
    MFS_UNHILITE         = MF_UNHILITE;
    MFS_DEFAULT          = MF_DEFAULT;

%IF WIN5 %THEN
    MFS_MASK            = 0000108Bh;
    MFS_HOTTRACKDRAWN   = 10000000h;
    MFS_CACHEDBMP       = 20000000h;
    MFS_BOTTOMGAPDROP   = 40000000h;
    MFS_TOPGAPDROP      = 80000000h;
    MFS_GAPDROP         = 0C0000000h;
%ELSE
%END

    MFR_POPUP            = 1h;
    MFR_END              = MF_END;

PROCEDURE CheckMenuRadioItem(a: HMENU;
                             b: UINT;
                             c: UINT;
                             d: UINT;
                             e: UINT) : BOOL;



TYPE
    MENUITEMTEMPLATEHEADER = RECORD
          versionNumber  : WORD;
          offset         : WORD;
    END;
    PMENUITEMTEMPLATEHEADER     = POINTER TO MENUITEMTEMPLATEHEADER;

    MENUITEMTEMPLATE = RECORD
          mtOption       : WORD;
          mtID           : WORD;
          mtString       : ARRAY [0..1 - 1] OF WCHAR;
    END;
    PMENUITEMTEMPLATE   = POINTER TO MENUITEMTEMPLATE;

CONST
    SC_SIZE              = 0F000h;
    SC_MOVE              = 0F010h;
    SC_MINIMIZE          = 0F020h;
    SC_MAXIMIZE          = 0F030h;
    SC_NEXTWINDOW        = 0F040h;
    SC_PREVWINDOW        = 0F050h;
    SC_CLOSE             = 0F060h;
    SC_VSCROLL           = 0F070h;
    SC_HSCROLL           = 0F080h;
    SC_MOUSEMENU         = 0F090h;
    SC_KEYMENU           = 0F100h;
    SC_ARRANGE           = 0F110h;
    SC_RESTORE           = 0F120h;
    SC_TASKLIST          = 0F130h;
    SC_SCREENSAVE        = 0F140h;
    SC_HOTKEY            = 0F150h;


    SC_DEFAULT           = 0F160h;
    SC_MONITORPOWER      = 0F170h;
    SC_CONTEXTHELP       = 0F180h;
    SC_SEPARATOR         = 0F00Fh;
    SC_ICON              = SC_MINIMIZE;
    SC_ZOOM              = SC_MAXIMIZE;


PROCEDURE LoadBitmapA(a : HINSTANCE;
                      lpBitmapName : ARRAY OF ACHAR) : HBITMAP;

PROCEDURE LoadBitmapW(a : HINSTANCE;
                      lpBitmapName : ARRAY OF UCHAR) : HBITMAP;

%IF UNICODE %THEN
PROCEDURE LoadBitmap = LoadBitmapW;
%ELSE
PROCEDURE LoadBitmap = LoadBitmapA;
%END

PROCEDURE LoadCursorA(a : HINSTANCE;
                      lpCursorName : ARRAY OF ACHAR) : HCURSOR;

PROCEDURE LoadCursorW(a : HINSTANCE;
                      lpCursorName : ARRAY OF UCHAR) : HCURSOR;

%IF UNICODE %THEN
PROCEDURE LoadCursor = LoadCursorW;
%ELSE
PROCEDURE LoadCursor = LoadCursorA;
%END


PROCEDURE LoadCursorFromFileA(lpFileName : ARRAY OF ACHAR) : HCURSOR;

PROCEDURE LoadCursorFromFileW(lpFileName : ARRAY OF UCHAR) : HCURSOR;

%IF UNICODE %THEN
PROCEDURE LoadCursorFromFile = LoadCursorFromFileW;
%ELSE
PROCEDURE LoadCursorFromFile = LoadCursorFromFileA;
%END



PROCEDURE CreateCursor(hInst : HINSTANCE;
                       xHotSpot : INTEGER;
                       yHotSpot : INTEGER;
                       nWidth : INTEGER;
                       nHeight : INTEGER;
                       pvANDPlane : LPVOID;
                       pvXORPlane : LPVOID) : HCURSOR;

PROCEDURE DestroyCursor(hCursor : HCURSOR) : BOOL;

CONST
    IDC_ARROW           = CAST(LPTSTR, 32512);
    IDC_IBEAM           = CAST(LPTSTR, 32513);
    IDC_WAIT            = CAST(LPTSTR, 32514);
    IDC_CROSS           = CAST(LPTSTR, 32515);
    IDC_UPARROW         = CAST(LPTSTR, 32516);
    (* Fixed wrong #'s*)
    IDC_SIZE            = CAST(LPTSTR, 32640);
    IDC_ICON            = CAST(LPTSTR, 32641);
    IDC_SIZENWSE        = CAST(LPTSTR, 32642);
    IDC_SIZENESW        = CAST(LPTSTR, 32643);
    IDC_SIZEWE          = CAST(LPTSTR, 32644);
    IDC_SIZENS          = CAST(LPTSTR, 32645);
    IDC_SIZEALL         = CAST(LPTSTR, 32646);
    IDC_NO              = CAST(LPTSTR, 32648);
    IDC_APPSTARTING     = CAST(LPTSTR, 32650);
    IDC_HELP            = CAST(LPTSTR, 32651);

%IF WIN5 %THEN
    IDC_HAND            = CAST(LPTSTR, 32649);
%END

(*95*)
PROCEDURE SetSystemCursor(
                            hcur : HCURSOR;
                            id : DWORD) : BOOL;

TYPE
    ICONINFO = RECORD
          fIcon          : BOOL;
          xHotspot       : DWORD;
          yHotspot       : DWORD;
          hbmMask        : HBITMAP;
          hbmColor       : HBITMAP;
    END;
    PICONINFO            = POINTER TO ICONINFO;

PROCEDURE LoadIconA(a : HINSTANCE;
                    lpIconName : ARRAY OF ACHAR) : HICON;

PROCEDURE LoadIconW(a : HINSTANCE;
                    lpIconName : ARRAY OF UCHAR) : HICON;

%IF UNICODE %THEN
PROCEDURE LoadIcon = LoadIconW;
%ELSE
PROCEDURE LoadIcon = LoadIconA;
%END

PROCEDURE CreateIcon(a : HINSTANCE;
                     nWidth : INTEGER;
                     nHeight : INTEGER;
                     cPlanes : BYTE;
                     cBitsPixel : BYTE;
                     lpbANDbits : LPVOID;
                     lpbXORbits : LPVOID) : HICON;

PROCEDURE DestroyIcon(hIcon : HICON) : BOOL;

PROCEDURE LookupIconIdFromDirectory(presbits : PBYTE;
                                    fIcon : BOOL) : INTEGER;


PROCEDURE LookupIconIdFromDirectoryEx(presbits : PBYTE;
                                      fIcon : BOOL;
                                      cxDesired : WINT;
                                      cyDesired : WINT;
                                      Flags : UINT) : WINT;

PROCEDURE CreateIconFromResource(presbits : PBYTE;
                                 dwResSize : DWORD;
                                 fIcon : BOOL;
                                 dwVer : DWORD) : HICON;

PROCEDURE CreateIconFromResourceEx(presbits : PBYTE;
                                   dwResSize : DWORD;
                                   fIcon : BOOL;
                                   dwVer : DWORD;
                                   cxDesired : WINT;
                                   cyDesired : WINT;
                                   Flags : UINT) : HICON;

TYPE
    CURSORSHAPE = RECORD
        xHotSpot        : WINT;
        yHotSpot        : WINT;
        cx              : WINT;
        cy              : WINT;
        cbWidth         : WINT;
        Planes          : BYTE;
        BitsPixel       : BYTE;
    END;
    LPCURSORSHAPE       = POINTER TO CURSORSHAPE;

CONST
    IMAGE_BITMAP        = 0;
    IMAGE_ICON          = 1;
    IMAGE_CURSOR        = 2;
    IMAGE_ENHMETAFILE   = 3;

    LR_DEFAULTCOLOR     = 0000h;
    LR_MONOCHROME       = 0001h;
    LR_COLOR            = 0002h;
    LR_COPYRETURNORG    = 0004h;
    LR_COPYDELETEORG    = 0008h;
    LR_LOADFROMFILE     = 0010h;
    LR_LOADTRANSPARENT  = 0020h;
    LR_DEFAULTSIZE      = 0040h;
    LR_LOADREALSIZE     = 0080h;
    LR_LOADMAP3DCOLORS  = 1000h;
    LR_CREATEDIBSECTION = 2000h;
    LR_VGACOLOR         = 0080h;
    LR_COPYFROMRESOURCE = 4000h;
    LR_SHARED           = 8000h;

PROCEDURE LoadImageA(
        a: HINSTANCE;
        b: ARRAY OF ACHAR;
        c: UINT;
        d: WINT;
        e: WINT;
        f: UINT) : HANDLE;

PROCEDURE LoadImageW(
        a: HINSTANCE;
        b: ARRAY OF UCHAR;
        c: UINT;
        d: WINT;
        e: WINT;
        f: UINT) : HANDLE;

%IF UNICODE %THEN
PROCEDURE LoadImage = LoadImageW;
%ELSE
PROCEDURE LoadImage = LoadImageA;
%END

PROCEDURE CopyImage(a: HANDLE;
                    b: UINT;
                    c: WINT;
                    d: WINT;
                    e: UINT) : HICON;

CONST
    DI_MASK         = 0001h;
    DI_IMAGE        = 0002h;
    DI_NORMAL       = 0003h;
    DI_COMPAT       = 0004h;
    DI_DEFAULTSIZE  = 0008h;

PROCEDURE DrawIconEx(hdc : HDC;
                     xLeft : WINT;
                     yTop : WINT;
                     hIcon : HICON;
                     cxWidth : WINT;
                     cyWidth : WINT;
                     istepIfAniCur : UINT;
                     hbrFlickerFreeDraw : HBRUSH;
                     diFlags : UINT) : BOOL;



PROCEDURE CreateIconIndirect(piconinfo : PICONINFO) : HICON;

PROCEDURE CopyIcon(hIcon : HICON) : HICON;

PROCEDURE GetIconInfo(hIcon : HICON;
                      piconinfo : PICONINFO) : BOOL;


CONST

    RES_ICON             = 1;
    RES_CURSOR           = 2;


    OBM_CLOSE            = 32754;
    OBM_UPARROW          = 32753;
    OBM_DNARROW          = 32752;
    OBM_RGARROW          = 32751;
    OBM_LFARROW          = 32750;
    OBM_REDUCE           = 32749;
    OBM_ZOOM             = 32748;
    OBM_RESTORE          = 32747;
    OBM_REDUCED          = 32746;
    OBM_ZOOMD            = 32745;
    OBM_RESTORED         = 32744;
    OBM_UPARROWD         = 32743;
    OBM_DNARROWD         = 32742;
    OBM_RGARROWD         = 32741;
    OBM_LFARROWD         = 32740;
    OBM_MNARROW          = 32739;
    OBM_COMBO            = 32738;
    OBM_UPARROWI         = 32737;
    OBM_DNARROWI         = 32736;
    OBM_RGARROWI         = 32735;
    OBM_LFARROWI         = 32734;
    OBM_OLD_CLOSE        = 32767;
    OBM_SIZE             = 32766;
    OBM_OLD_UPARROW      = 32765;
    OBM_OLD_DNARROW      = 32764;
    OBM_OLD_RGARROW      = 32763;
    OBM_OLD_LFARROW      = 32762;
    OBM_BTSIZE           = 32761;
    OBM_CHECK            = 32760;
    OBM_CHECKBOXES       = 32759;
    OBM_BTNCORNERS       = 32758;
    OBM_OLD_REDUCE       = 32757;
    OBM_OLD_ZOOM         = 32756;
    OBM_OLD_RESTORE      = 32755;

    OCR_NORMAL           = 32512;
    OCR_IBEAM            = 32513;
    OCR_WAIT             = 32514;
    OCR_CROSS            = 32515;
    OCR_UP               = 32516;
    OCR_SIZE             = 32640;
    OCR_ICON             = 32641;
    OCR_SIZENWSE         = 32642;
    OCR_SIZENESW         = 32643;
    OCR_SIZEWE           = 32644;
    OCR_SIZENS           = 32645;
    OCR_SIZEALL          = 32646;
    OCR_ICOCUR           = 32647;
    OCR_NO               = 32648;
    OCR_APPSTARTING      = 32650;
%IF WIN5 %THEN
    OCR_HAND             = 32649;
%END

    OIC_SAMPLE           = 32512;
    OIC_HAND             = 32513;
    OIC_QUES             = 32514;
    OIC_BANG             = 32515;
    OIC_NOTE             = 32516;

    OIC_WINLOGO          = 32517;
    OIC_WARNING          = OIC_BANG;
    OIC_ERROR            = OIC_HAND;
    OIC_INFORMATION      = OIC_NOTE;


    ORD_LANGDRIVER       = 1;

    IDI_APPLICATION             = CAST(LPTSTR, 32512);
    IDI_HAND                    = CAST(LPTSTR, 32513);
    IDI_QUESTION                = CAST(LPTSTR, 32514);
    IDI_EXCLAMATION             = CAST(LPTSTR, 32515);
    IDI_ASTERISK                = CAST(LPTSTR, 32516);
    IDI_WINLOGO                 = CAST(LPTSTR, 32517);(*95*)


    IDI_WARNING                 = IDI_EXCLAMATION;
    IDI_ERROR                   = IDI_HAND;
    IDI_INFORMATION             = IDI_ASTERISK;


PROCEDURE LoadStringA(a : HINSTANCE;
                      uID : UINT;
                      VAR lpBuffer : ARRAY OF ACHAR;
                      nBufferMax : INTEGER) : INTEGER;

PROCEDURE LoadStringW(a : HINSTANCE;
                      uID : UINT;
                      VAR lpBuffer : ARRAY OF UCHAR;
                      nBufferMax : INTEGER) : INTEGER;

%IF UNICODE %THEN
PROCEDURE LoadString = LoadStringW;
%ELSE
PROCEDURE LoadString = LoadStringA;
%END

CONST
    IDOK                 = 1;
    IDCANCEL             = 2;
    IDABORT              = 3;
    IDRETRY              = 4;
    IDIGNORE             = 5;
    IDYES                = 6;
    IDNO                 = 7;

    IDCLOSE              = 8;
    IDHELP               = 9;


    ES_LEFT              = 00000h;
    ES_CENTER            = 00001h;
    ES_RIGHT             = 00002h;
    ES_MULTILINE         = 00004h;
    ES_UPPERCASE         = 00008h;
    ES_LOWERCASE         = 00010h;
    ES_PASSWORD          = 00020h;
    ES_AUTOVSCROLL       = 00040h;
    ES_AUTOHSCROLL       = 00080h;
    ES_NOHIDESEL         = 00100h;
    ES_OEMCONVERT        = 00400h;
    ES_READONLY          = 00800h;
    ES_WANTRETURN        = 01000h;
    ES_NUMBER            = 02000h;(*95*)

    EN_SETFOCUS          = 00100h;
    EN_KILLFOCUS         = 00200h;
    EN_CHANGE            = 00300h;
    EN_UPDATE            = 00400h;
    EN_ERRSPACE          = 00500h;
    EN_MAXTEXT           = 00501h;
    EN_HSCROLL           = 00601h;
    EN_VSCROLL           = 00602h;


    EC_LEFTMARGIN        = 00001h;
    EC_RIGHTMARGIN       = 00002h;
    EC_USEFONTINFO       = 0ffffh;

%IF WIN5 %THEN
(* wParam of EM_GET/SETIMESTATUS  *)
    EMSIS_COMPOSITIONSTRING        = 0001h;

(* lParam for EMSIS_COMPOSITIONSTRING  *)
    EIMES_GETCOMPSTRATONCE         = 0001h;
    EIMES_CANCELCOMPSTRINFOCUS     = 0002h;
    EIMES_COMPLETECOMPSTRKILLFOCUS = 0004h;
%END

    EM_GETSEL            = 000B0h;
    EM_SETSEL            = 000B1h;
    EM_GETRECT           = 000B2h;
    EM_SETRECT           = 000B3h;
    EM_SETRECTNP         = 000B4h;
    EM_SCROLL            = 000B5h;
    EM_LINESCROLL        = 000B6h;
    EM_SCROLLCARET       = 000B7h;
    EM_GETMODIFY         = 000B8h;
    EM_SETMODIFY         = 000B9h;
    EM_GETLINECOUNT      = 000BAh;
    EM_LINEINDEX         = 000BBh;
    EM_SETHANDLE         = 000BCh;
    EM_GETHANDLE         = 000BDh;
    EM_GETTHUMB          = 000BEh;
    EM_LINELENGTH        = 000C1h;
    EM_REPLACESEL        = 000C2h;
    EM_GETLINE           = 000C4h;
    EM_LIMITTEXT         = 000C5h;
    EM_CANUNDO           = 000C6h;
    EM_UNDO              = 000C7h;
    EM_FMTLINES          = 000C8h;
    EM_LINEFROMCHAR      = 000C9h;
    EM_SETTABSTOPS       = 000CBh;
    EM_SETPASSWORDCHAR   = 000CCh;
    EM_EMPTYUNDOBUFFER   = 000CDh;
    EM_GETFIRSTVISIBLELINE= 000CEh;
    EM_SETREADONLY       = 000CFh;
    EM_SETWORDBREAKPROC  = 000D0h;
    EM_GETWORDBREAKPROC  = 000D1h;
    EM_GETPASSWORDCHAR   = 000D2h;

    EM_SETMARGINS        = 000D3h;
    EM_GETMARGINS        = 000D4h;
    EM_SETLIMITTEXT      = EM_LIMITTEXT;
    EM_GETLIMITTEXT      = 000D5h;
    EM_POSFROMCHAR       = 000D6h;
    EM_CHARFROMPOS       = 000D7h;

%IF WIN5 %THEN
    EM_SETIMESTATUS         =000D8h;
    EM_GETIMESTATUS         =000D9h;
%END

    WB_LEFT              = 0;
    WB_RIGHT             = 1;
    WB_ISDELIMITER       = 2;

    BS_PUSHBUTTON        = 000h;
    BS_DEFPUSHBUTTON     = 001h;
    BS_CHECKBOX          = 002h;
    BS_AUTOCHECKBOX      = 003h;
    BS_RADIOBUTTON       = 004h;
    BS_3STATE            = 005h;
    BS_AUTO3STATE        = 006h;
    BS_GROUPBOX          = 007h;
    BS_USERBUTTON        = 008h;
    BS_AUTORADIOBUTTON   = 009h;
    BS_OWNERDRAW         = 00Bh;
    BS_LEFTTEXT          = 020h;

    BS_TEXT              = 00000000h;
    BS_ICON              = 00000040h;
    BS_BITMAP            = 00000080h;
    BS_LEFT              = 00000100h;
    BS_RIGHT             = 00000200h;
    BS_CENTER            = 00000300h;
    BS_TOP               = 00000400h;
    BS_BOTTOM            = 00000800h;
    BS_VCENTER           = 00000C00h;
    BS_PUSHLIKE          = 00001000h;
    BS_MULTILINE         = 00002000h;
    BS_NOTIFY            = 00004000h;
    BS_FLAT              = 00008000h;
    BS_RIGHTBUTTON       = BS_LEFTTEXT;


    BN_CLICKED           = 0;
    BN_PAINT             = 1;
    BN_HILITE            = 2;
    BN_UNHILITE          = 3;
    BN_DISABLE           = 4;
    BN_DOUBLECLICKED     = 5;

    BN_PUSHED            = BN_HILITE;
    BN_UNPUSHED          = BN_UNHILITE;
    BN_DBLCLK            = BN_DOUBLECLICKED;
    BN_SETFOCUS          = 6;
    BN_KILLFOCUS         = 7;


    BM_GETCHECK          = 000F0h;
    BM_SETCHECK          = 000F1h;
    BM_GETSTATE          = 000F2h;
    BM_SETSTATE          = 000F3h;
    BM_SETSTYLE          = 000F4h;

    BM_CLICK             = 00F5h;
    BM_GETIMAGE          = 00F6h;
    BM_SETIMAGE          = 00F7h;

    BST_UNCHECKED        = 0000h;
    BST_CHECKED          = 0001h;
    BST_INDETERMINATE    = 0002h;
    BST_PUSHED           = 0004h;
    BST_FOCUS            = 0008h;


    SS_LEFT              = 000h;
    SS_CENTER            = 001h;
    SS_RIGHT             = 002h;
    SS_ICON              = 003h;
    SS_BLACKRECT         = 004h;
    SS_GRAYRECT          = 005h;
    SS_WHITERECT         = 006h;
    SS_BLACKFRAME        = 007h;
    SS_GRAYFRAME         = 008h;
    SS_WHITEFRAME        = 009h;
    SS_USERITEM          = 00Ah;
    SS_SIMPLE            = 00Bh;
    SS_LEFTNOWORDWRAP    = 00Ch;

    SS_BITMAP            = 0000000Eh;
    SS_OWNERDRAW         = 0000000Dh;
    SS_ENHMETAFILE       = 0000000Fh;
    SS_ETCHEDHORZ        = 00000010h;
    SS_ETCHEDVERT        = 00000011h;
    SS_ETCHEDFRAME       = 00000012h;
    SS_TYPEMASK          = 0000001Fh;

    SS_NOPREFIX          = 080h;

    SS_NOTIFY            = 00000100h;
    SS_CENTERIMAGE       = 00000200h;
    SS_RIGHTJUST         = 00000400h;
    SS_REALSIZEIMAGE     = 00000800h;
    SS_SUNKEN            = 00001000h;
    SS_RAISED            = 00002000h;
    SS_ENDELLIPSIS      = 00004000h;
    SS_PATHELLIPSIS     = 00008000h;
    SS_WORDELLIPSIS     = 0000C000h;
    SS_ELLIPSISMASK     = 0000C000h;


    STM_SETICON          = 0170h;
    STM_GETICON          = 0171h;

    STM_SETIMAGE         = 00172h;
    STM_GETIMAGE         = 00173h;
    STM_MSGMAX           = 00174h;

    STN_CLICKED          = 0;
    STN_DBLCLK           = 1;
    STN_ENABLE           = 2;
    STN_DISABLE          = 3;


    WC_DIALOG    = CAST(LPATOM, 08002H);

    DWL_MSGRESULT        = 0;
    DWL_DLGPROC          = 4;
    DWL_USER             = 8;

PROCEDURE IsDialogMessageA(hDlg : HWND;
                           VAR lpMsg : MSG) : BOOL;

PROCEDURE IsDialogMessageW(hDlg : HWND;
                           VAR lpMsg : MSG) : BOOL;

%IF UNICODE %THEN
PROCEDURE IsDialogMessage = IsDialogMessageW;
%ELSE
PROCEDURE IsDialogMessage = IsDialogMessageA;
%END

PROCEDURE MapDialogRect(hDlg : HWND;
                        VAR lpRect : RECT) : BOOL;

PROCEDURE DlgDirListA(hDlg : HWND;
                      VAR lpPathSpec : ARRAY OF ACHAR;
                      nIDListBox : INTEGER;
                      nIDStaticPath : INTEGER;
                      uFileType : UINT) : INTEGER;

PROCEDURE DlgDirListW(hDlg : HWND;
                      VAR lpPathSpec : ARRAY OF UCHAR;
                      nIDListBox : INTEGER;
                      nIDStaticPath : INTEGER;
                      uFileType : UINT) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DlgDirList = DlgDirListW;
%ELSE
PROCEDURE DlgDirList = DlgDirListA;
%END

CONST
    DDL_READWRITE        = 00000h;
    DDL_READONLY         = 00001h;
    DDL_HIDDEN           = 00002h;
    DDL_SYSTEM           = 00004h;
    DDL_DIRECTORY        = 00010h;
    DDL_ARCHIVE          = 00020h;
    DDL_POSTMSGS         = 02000h;
    DDL_DRIVES           = 04000h;
    DDL_EXCLUSIVE        = 08000h;

PROCEDURE DlgDirSelectExA(hDlg : HWND;
                          VAR lpString : ARRAY OF ACHAR;
                          nCount : INTEGER;
                          nIDListBox : INTEGER) : BOOL;

PROCEDURE DlgDirSelectExW(hDlg : HWND;
                          VAR lpString : ARRAY OF UCHAR;
                          nCount : INTEGER;
                          nIDListBox : INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE DlgDirSelectEx = DlgDirSelectExW;
%ELSE
PROCEDURE DlgDirSelectEx = DlgDirSelectExA;
%END

PROCEDURE DlgDirListComboBoxA(hDlg : HWND;
                              VAR lpPathSpec : ARRAY OF ACHAR;
                              nIDComboBox : INTEGER;
                              nIDStaticPath : INTEGER;
                              uFiletype : UINT) : INTEGER;

PROCEDURE DlgDirListComboBoxW(hDlg : HWND;
                              VAR lpPathSpec : ARRAY OF UCHAR;
                              nIDComboBox : INTEGER;
                              nIDStaticPath : INTEGER;
                              uFiletype : UINT) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DlgDirListComboBox = DlgDirListComboBoxW;
%ELSE
PROCEDURE DlgDirListComboBox = DlgDirListComboBoxA;
%END

PROCEDURE DlgDirSelectComboBoxExA(hDlg : HWND;
                                  VAR lpString : ARRAY OF ACHAR;
                                  nCount : INTEGER;
                                  nIDComboBox : INTEGER) : BOOL;

PROCEDURE DlgDirSelectComboBoxExW(hDlg : HWND;
                                  VAR lpString : ARRAY OF UCHAR;
                                  nCount : INTEGER;
                                  nIDComboBox : INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExW;
%ELSE
PROCEDURE DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExA;
%END

CONST
    DS_ABSALIGN          = 001h;
    DS_SYSMODAL          = 002h;
    DS_LOCALEDIT         = 020h;
    DS_SETFONT           = 040h;
    DS_MODALFRAME        = 080h;
    DS_NOIDLEMSG         = 0100h;
    DS_SETFOREGROUND     = 0200h;

    DS_3DLOOK            = 00004h;
    DS_FIXEDSYS          = 00008h;
    DS_NOFAILCREATE      = 00010h;
    DS_CONTROL           = 00400h;
    DS_CENTER            = 00800h;
    DS_CENTERMOUSE       = 01000h;

    DS_CONTEXTHELP       = 02000h;
    DS_SHELLFONT         = DS_SETFONT BOR DS_FIXEDSYS;

    DM_GETDEFID          = WM_USER + 0;
    DM_SETDEFID          = WM_USER + 1;

    DM_REPOSITION        = WM_USER + 2;

    PSM_PAGEINFO         = WM_USER + 100;
    PSM_SHEETINFO        = WM_USER + 101;

    PSI_SETACTIVE        = 0001h;
    PSI_KILLACTIVE       = 0002h;
    PSI_APPLY            = 0003h;
    PSI_RESET            = 0004h;
    PSI_HASHELP          = 0005h;
    PSI_HELP             = 0006h;

    PSI_CHANGED          = 0001h;
    PSI_GUISTART         = 0002h;
    PSI_REBOOT           = 0003h;
    PSI_GETSIBLINGS      = 0004h;


    DC_HASDEFID          = 0534Bh;

    DLGC_WANTARROWS      = 00001h;
    DLGC_WANTTAB         = 00002h;
    DLGC_WANTALLKEYS     = 00004h;
    DLGC_WANTMESSAGE     = 00004h;
    DLGC_HASSETSEL       = 00008h;
    DLGC_DEFPUSHBUTTON   = 00010h;
    DLGC_UNDEFPUSHBUTTON = 00020h;
    DLGC_RADIOBUTTON     = 00040h;
    DLGC_WANTCHARS       = 00080h;
    DLGC_STATIC          = 00100h;
    DLGC_BUTTON          = 02000h;
    DLGC_RECURSE         = 08000h;(*95*)

    LB_CTLCODE           = 0;
    LB_OKAY              = 0;
    LB_ERR               = -1;
    LB_ERRSPACE          = -2;

    LBN_ERRSPACE         = -2;
    LBN_SELCHANGE        = 1;
    LBN_DBLCLK           = 2;
    LBN_SELCANCEL        = 3;
    LBN_SETFOCUS         = 4;
    LBN_KILLFOCUS        = 5;

    LB_ADDSTRING         = 00180h;
    LB_INSERTSTRING      = 00181h;
    LB_DELETESTRING      = 00182h;
    LB_SELITEMRANGEEX    = 00183h;
    LB_RESETCONTENT      = 00184h;
    LB_SETSEL            = 00185h;
    LB_SETCURSEL         = 00186h;
    LB_GETSEL            = 00187h;
    LB_GETCURSEL         = 00188h;
    LB_GETTEXT           = 00189h;
    LB_GETTEXTLEN        = 0018Ah;
    LB_GETCOUNT          = 0018Bh;
    LB_SELECTSTRING      = 0018Ch;
    LB_DIR               = 0018Dh;
    LB_GETTOPINDEX       = 0018Eh;
    LB_FINDSTRING        = 0018Fh;
    LB_GETSELCOUNT       = 00190h;
    LB_GETSELITEMS       = 00191h;
    LB_SETTABSTOPS       = 00192h;
    LB_GETHORIZONTALEXTENT= 00193h;
    LB_SETHORIZONTALEXTENT= 00194h;
    LB_SETCOLUMNWIDTH    = 00195h;
    LB_ADDFILE           = 00196h;
    LB_SETTOPINDEX       = 00197h;
    LB_GETITEMRECT       = 00198h;
    LB_GETITEMDATA       = 00199h;
    LB_SETITEMDATA       = 0019Ah;
    LB_SELITEMRANGE      = 0019Bh;
    LB_SETANCHORINDEX    = 0019Ch;
    LB_GETANCHORINDEX    = 0019Dh;
    LB_SETCARETINDEX     = 0019Eh;
    LB_GETCARETINDEX     = 0019Fh;
    LB_SETITEMHEIGHT     = 001A0h;
    LB_GETITEMHEIGHT     = 001A1h;
    LB_FINDSTRINGEXACT   = 001A2h;
    LB_SETLOCALE         = 001A5h;
    LB_GETLOCALE         = 001A6h;
    LB_SETCOUNT          = 001A7h;

    LB_INITSTORAGE       = 001A8h;
    LB_ITEMFROMPOINT     = 001A9h;
%IF WIN4 %THEN
    LB_MSGMAX            = 001B0h;
%ELSE
    LB_MSGMAX            = 001A8h;
%END


    LBS_NOTIFY           = 00001h;
    LBS_SORT             = 00002h;
    LBS_NOREDRAW         = 00004h;
    LBS_MULTIPLESEL      = 00008h;
    LBS_OWNERDRAWFIXED   = 00010h;
    LBS_OWNERDRAWVARIABLE= 00020h;
    LBS_HASSTRINGS       = 00040h;
    LBS_USETABSTOPS      = 00080h;
    LBS_NOINTEGRALHEIGHT = 00100h;
    LBS_MULTICOLUMN      = 00200h;
    LBS_WANTKEYBOARDINPUT= 00400h;
    LBS_EXTENDEDSEL      = 00800h;
    LBS_DISABLENOSCROLL  = 01000h;
    LBS_NODATA           = 02000h;
    LBS_STANDARD         = LBS_NOTIFY BOR
                           LBS_SORT BOR
                           WS_VSCROLL BOR
                           WS_BORDER;
    LBS_NOSEL            = 04000h;(*95*)

    CB_OKAY              = 0;
    CB_ERR               = -1;
    CB_ERRSPACE          = -2;

    CBN_ERRSPACE         = -1;
    CBN_SELCHANGE        = 1;
    CBN_DBLCLK           = 2;
    CBN_SETFOCUS         = 3;
    CBN_KILLFOCUS        = 4;
    CBN_EDITCHANGE       = 5;
    CBN_EDITUPDATE       = 6;
    CBN_DROPDOWN         = 7;
    CBN_CLOSEUP          = 8;
    CBN_SELENDOK         = 9;
    CBN_SELENDCANCEL     = 10;

    CBS_SIMPLE           = 00001h;
    CBS_DROPDOWN         = 00002h;
    CBS_DROPDOWNLIST     = 00003h;
    CBS_OWNERDRAWFIXED   = 00010h;
    CBS_OWNERDRAWVARIABLE= 00020h;
    CBS_AUTOHSCROLL      = 00040h;
    CBS_OEMCONVERT       = 00080h;
    CBS_SORT             = 00100h;
    CBS_HASSTRINGS       = 00200h;
    CBS_NOINTEGRALHEIGHT = 00400h;
    CBS_DISABLENOSCROLL  = 00800h;

    CBS_UPPERCASE        = 02000h;
    CBS_LOWERCASE        = 04000h;


    CB_GETEDITSEL        = 00140h;
    CB_LIMITTEXT         = 00141h;
    CB_SETEDITSEL        = 00142h;
    CB_ADDSTRING         = 00143h;
    CB_DELETESTRING      = 00144h;
    CB_DIR               = 00145h;
    CB_GETCOUNT          = 00146h;
    CB_GETCURSEL         = 00147h;
    CB_GETLBTEXT         = 00148h;
    CB_GETLBTEXTLEN      = 00149h;
    CB_INSERTSTRING      = 0014Ah;
    CB_RESETCONTENT      = 0014Bh;
    CB_FINDSTRING        = 0014Ch;
    CB_SELECTSTRING      = 0014Dh;
    CB_SETCURSEL         = 0014Eh;
    CB_SHOWDROPDOWN      = 0014Fh;
    CB_GETITEMDATA       = 00150h;
    CB_SETITEMDATA       = 00151h;
    CB_GETDROPPEDCONTROLRECT= 00152h;
    CB_SETITEMHEIGHT     = 00153h;
    CB_GETITEMHEIGHT     = 00154h;
    CB_SETEXTENDEDUI     = 00155h;
    CB_GETEXTENDEDUI     = 00156h;
    CB_GETDROPPEDSTATE   = 00157h;
    CB_FINDSTRINGEXACT   = 00158h;
    CB_SETLOCALE         = 00159h;
    CB_GETLOCALE         = 0015ah;

    CB_GETTOPINDEX              = 015bh;
    CB_SETTOPINDEX              = 015ch;
    CB_GETHORIZONTALEXTENT      = 015dh;
    CB_SETHORIZONTALEXTENT      = 015eh;
    CB_GETDROPPEDWIDTH          = 015fh;
    CB_SETDROPPEDWIDTH          = 0160h;
    CB_INITSTORAGE              = 0161h;
%IF WIN4 %THEN
    CB_MSGMAX            = 00162h;
%ELSE
    CB_MSGMAX            = 0015bh;
%END


    SBS_HORZ             = 00000h;
    SBS_VERT             = 00001h;
    SBS_TOPALIGN         = 00002h;
    SBS_LEFTALIGN        = 00002h;
    SBS_BOTTOMALIGN      = 00004h;
    SBS_RIGHTALIGN       = 00004h;
    SBS_SIZEBOXTOPLEFTALIGN= 00002h;
    SBS_SIZEBOXBOTTOMRIGHTALIGN= 00004h;
    SBS_SIZEBOX          = 00008h;
    SBS_SIZEGRIP         = 00010h;

    SBM_SETPOS           = 000E0h;
    SBM_GETPOS           = 000E1h;
    SBM_SETRANGE         = 000E2h;
    SBM_SETRANGEREDRAW   = 000E6h;
    SBM_GETRANGE         = 000E3h;
    SBM_ENABLE_ARROWS    = 000E4h;

    SBM_SETSCROLLINFO    = 000E9h;
    SBM_GETSCROLLINFO    = 000EAh;

    SIF_RANGE            = 00001h;
    SIF_PAGE             = 00002h;
    SIF_POS              = 00004h;
    SIF_DISABLENOSCROLL  = 00008h;
    SIF_TRACKPOS         = 00010h;
    SIF_ALL              = SIF_RANGE BOR
                           SIF_PAGE BOR
                           SIF_POS BOR
                           SIF_TRACKPOS;

TYPE
    SCROLLINFO = RECORD
        cbSize  : UINT;
        fMask   : UINT;
        nMin    : WINT;
        nMax    : WINT;
        nPage   : UINT;
        nPos    : WINT;
        nTrackPos : WINT;
    END;
    LPSCROLLINFO        = POINTER TO SCROLLINFO;
    LPCSCROLLINFO       = LPSCROLLINFO;

PROCEDURE SetScrollInfo(a: HWND;
                        b: WINT;
                        c: SCROLLINFO;
                        d: BOOL) :  WINT;

PROCEDURE GetScrollInfo(a: HWND;
                        b: WINT;
                        VAR c: SCROLLINFO) : BOOL;


CONST
    MDIS_ALLCHILDSTYLES  = 00001h;
    MDITILE_VERTICAL     = 00000h;
    MDITILE_HORIZONTAL   = 00001h;
    MDITILE_SKIPDISABLED = 00002h;

TYPE
    MDICREATESTRUCTA = RECORD
          szClass        : LPCSTR;
          szTitle        : LPCSTR;
          hOwner         : HANDLE;
          x              : INTEGER;
          y              : INTEGER;
          cx             : INTEGER;
          cy             : INTEGER;
          style          : DWORD;
          lParam         : LPARAM;
    END;
    LPMDICREATESTRUCTA   = POINTER TO MDICREATESTRUCTA;

    MDICREATESTRUCTW = RECORD
          szClass        : LPCWSTR;
          szTitle        : LPCWSTR;
          hOwner         : HANDLE;
          x              : INTEGER;
          y              : INTEGER;
          cx             : INTEGER;
          cy             : INTEGER;
          style          : DWORD;
          lParam         : LPARAM;
    END;
    LPMDICREATESTRUCTW   = POINTER TO MDICREATESTRUCTW;

    %IF UNICODE %THEN
    MDICREATESTRUCT      = MDICREATESTRUCTW;
    LPMDICREATESTRUCT    = LPMDICREATESTRUCTW;
    %ELSE
    MDICREATESTRUCT      = MDICREATESTRUCTA;
    LPMDICREATESTRUCT    = LPMDICREATESTRUCTA;
    %END

    CLIENTCREATESTRUCT = RECORD
          hWindowMenu    : HMENU;
          idFirstChild   : UINT;
    END;
    LPCLIENTCREATESTRUCT = POINTER TO CLIENTCREATESTRUCT;

PROCEDURE DefFrameProcA(hWnd : HWND;
                        hWndMDIClient : HWND;
                        uMsg : UINT;
                        wParam : WPARAM;
                        lParam : LPARAM) : LRESULT;

PROCEDURE DefFrameProcW(hWnd : HWND;
                        hWndMDIClient : HWND;
                        uMsg : UINT;
                        wParam : WPARAM;
                        lParam : LPARAM) : LRESULT;

%IF UNICODE %THEN
PROCEDURE DefFrameProc = DefFrameProcW;
%ELSE
PROCEDURE DefFrameProc = DefFrameProcA;
%END

PROCEDURE DefMDIChildProcA(hWnd : HWND;
                           uMsg : UINT;
                           wParam : WPARAM;
                           lParam : LPARAM) : LRESULT;

PROCEDURE DefMDIChildProcW(hWnd : HWND;
                           uMsg : UINT;
                           wParam : WPARAM;
                           lParam : LPARAM) : LRESULT;

%IF UNICODE %THEN
PROCEDURE DefMDIChildProc = DefMDIChildProcW;
%ELSE
PROCEDURE DefMDIChildProc = DefMDIChildProcA;
%END

PROCEDURE TranslateMDISysAccel(hWndClient : HWND;
                               VAR lpMsg : MSG) : BOOL;

PROCEDURE ArrangeIconicWindows(hWnd : HWND) : UINT;

PROCEDURE CreateMDIWindowA(lpClassName : ARRAY OF ACHAR;
                           lpWindowName : ARRAY OF ACHAR;
                           dwStyle : DWORD;
                           X : INTEGER;
                           Y : INTEGER;
                           nWidth : INTEGER;
                           nHeight : INTEGER;
                           hWndParent : HWND;
                           a : HINSTANCE;
                           lParam : LPARAM) : HWND;

PROCEDURE CreateMDIWindowW(lpClassName : ARRAY OF UCHAR;
                           lpWindowName : ARRAY OF UCHAR;
                           dwStyle : DWORD;
                           X : INTEGER;
                           Y : INTEGER;
                           nWidth : INTEGER;
                           nHeight : INTEGER;
                           hWndParent : HWND;
                           a : HINSTANCE;
                           lParam : LPARAM) : HWND;

%IF UNICODE %THEN
PROCEDURE CreateMDIWindow = CreateMDIWindowW;
%ELSE
PROCEDURE CreateMDIWindow = CreateMDIWindowA;
%END


PROCEDURE TileWindows(hwndParent : HWND;
                      wHow : UINT;
                      lpRect : RECT;
                      cKids : UINT;
                      lpKids : ARRAY OF HWND) : WORD;

PROCEDURE CascadeWindows(hwndParent : HWND;
                         wHow : UINT;
                         lpRect : RECT;
                         cKids : UINT;
                         lpKids : ARRAY OF HWND) : WORD;



CONST
    IMC_GETCONVERSIONMODE           = 0001h;
    IMC_SETCONVERSIONMODE           = 0002h;
    IMC_GETSENTENCEMODE             = 0003h;
    IMC_SETSENTENCEMODE             = 0004h;
    IMC_GETOPENSTATUS               = 0005h;
    IMC_SETOPENSTATUS               = 0006h;
    IMC_GETCANDIDATEPOS             = 0007h;
    IMC_SETCANDIDATEPOS             = 0008h;
    IMC_GETCOMPOSITIONFONT          = 0009h;
    IMC_SETCOMPOSITIONFONT          = 000Ah;
    IMC_GETCOMPOSITIONWINDOW        = 000Bh;
    IMC_SETCOMPOSITIONWINDOW        = 000Ch;
    IMC_GETSTATUSWINDOWPOS          = 000Fh;
    IMC_SETSTATUSWINDOWPOS          = 0010h;
    IMC_CLOSESTATUSWINDOW           = 0021h;
    IMC_OPENSTATUSWINDOW            = 0022h;

    IMN_CLOSESTATUSWINDOW      = 0001h;
    IMN_OPENSTATUSWINDOW       = 0002h;
    IMN_CHANGECANDIDATE        = 0003h;
    IMN_CLOSECANDIDATE         = 0004h;
    IMN_OPENCANDIDATE          = 0005h;
    IMN_SETCONVERSIONMODE      = 0006h;
    IMN_SETSENTENCEMODE        = 0007h;
    IMN_SETOPENSTATUS          = 0008h;
    IMN_SETCANDIDATEPOS        = 0009h;
    IMN_SETCOMPOSITIONFONT     = 000Ah;
    IMN_SETCOMPOSITIONWINDOW   = 000Bh;
    IMN_SETSTATUSWINDOWPOS     = 000Ch;
    IMN_GUIDELINE              = 000Dh;
    IMN_PRIVATE                = 000Eh;


TYPE
    HELPPOLY             = DWORD;

    MULTIKEYHELPA = RECORD
          mkSize         : DWORD;
          mkKeylist      : ACHAR;
          szKeyphrase    : ARRAY [0..1 - 1] OF ACHAR;
    END;
    PMULTIKEYHELPA       = POINTER TO MULTIKEYHELPA;
    LPMULTIKEYHELPA      = PMULTIKEYHELPA;

    MULTIKEYHELPW = RECORD
          mkSize         : DWORD;
          mkKeylist      : WCHAR;
          szKeyphrase    : ARRAY [0..1 - 1] OF WCHAR;
    END;
    PMULTIKEYHELPW       = POINTER TO MULTIKEYHELPW;
    LPMULTIKEYHELPW      = PMULTIKEYHELPW;

    %IF UNICODE %THEN
    MULTIKEYHELP         = MULTIKEYHELPW;
    PMULTIKEYHELP        = PMULTIKEYHELPW;
    %ELSE
    MULTIKEYHELP         = MULTIKEYHELPA;
    PMULTIKEYHELP        = PMULTIKEYHELPA;
    %END
    LPMULTIKEYHELP       = PMULTIKEYHELP;

    HELPWININFOA = RECORD
          wStructSize    : INTEGER;
          x              : INTEGER;
          y              : INTEGER;
          dx             : INTEGER;
          dy             : INTEGER;
          wMax           : INTEGER;
          rgchMember     : ARRAY [0..2 - 1] OF ACHAR;
    END;
    PHELPWININFOA        = POINTER TO HELPWININFOA;
    LPHELPWININFOA       = PHELPWININFOA;

    HELPWININFOW = RECORD
          wStructSize    : INTEGER;
          x              : INTEGER;
          y              : INTEGER;
          dx             : INTEGER;
          dy             : INTEGER;
          wMax           : INTEGER;
          rgchMember     : ARRAY [0..2 - 1] OF WCHAR;
    END;
    PHELPWININFOW        = POINTER TO HELPWININFOW;
    LPHELPWININFOW       = PHELPWININFOW;

    %IF UNICODE %THEN
    HELPWININFO          = HELPWININFOW;
    PHELPWININFO         = PHELPWININFOW;
    %ELSE
    HELPWININFO          = HELPWININFOA;
    PHELPWININFO         = PHELPWININFOA;
    %END
    LPHELPWININFO        = PHELPWININFO;

CONST
    HELP_CONTEXT         = 00001h;
    HELP_QUIT            = 00002h;
    HELP_INDEX           = 00003h;
    HELP_CONTENTS        = 00003h;
    HELP_HELPONHELP      = 00004h;
    HELP_SETINDEX        = 00005h;
    HELP_SETCONTENTS     = 00005h;
    HELP_CONTEXTPOPUP    = 00008h;
    HELP_FORCEFILE       = 00009h;
    HELP_KEY             = 00101h;
    HELP_COMMAND         = 00102h;
    HELP_PARTIALKEY      = 00105h;
    HELP_MULTIKEY        = 00201h;
    HELP_SETWINPOS       = 00203h;

    HELP_CONTEXTMENU     = 000ah;
    HELP_FINDER          = 000bh;
    HELP_WM_HELP         = 000ch;
    HELP_SETPOPUP_POS    = 000dh;

    HELP_TCARD              = 8000h;
    HELP_TCARD_DATA         = 0010h;
    HELP_TCARD_OTHER_CALLER = 0011h;

    IDH_NO_HELP                     = 28440;
    IDH_MISSING_CONTEXT             = 28441;
    IDH_GENERIC_HELP_BUTTON         = 28442;
    IDH_OK                          = 28443;
    IDH_CANCEL                      = 28444;
    IDH_HELP                        = 28445;


PROCEDURE WinHelpA(hWndMain : HWND;
                   lpszHelp : ARRAY OF ACHAR;
                   uCommand : UINT;
                   dwData : DWORD) : BOOL;

PROCEDURE WinHelpW(hWndMain : HWND;
                   lpszHelp : ARRAY OF UCHAR;
                   uCommand : UINT;
                   dwData : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE WinHelp = WinHelpW;
%ELSE
PROCEDURE WinHelp = WinHelpA;
%END

%IF WIN5 %THEN
CONST
    GR_GDIOBJECTS     =0;       (* Count of GDI objects *)
    GR_USEROBJECTS    =1;       (* Count of USER objects *)

PROCEDURE GetGuiResources(hProcess : HANDLE; uiFlags : DWORD) : DWORD;
%END

CONST
    SPI_GETBEEP          = 1;
    SPI_SETBEEP          = 2;
    SPI_GETMOUSE         = 3;
    SPI_SETMOUSE         = 4;
    SPI_GETBORDER        = 5;
    SPI_SETBORDER        = 6;
    SPI_GETKEYBOARDSPEED = 10;
    SPI_SETKEYBOARDSPEED = 11;
    SPI_LANGDRIVER       = 12;
    SPI_ICONHORIZONTALSPACING= 13;
    SPI_GETSCREENSAVETIMEOUT= 14;
    SPI_SETSCREENSAVETIMEOUT= 15;
    SPI_GETSCREENSAVEACTIVE= 16;
    SPI_SETSCREENSAVEACTIVE= 17;
    SPI_GETGRIDGRANULARITY= 18;
    SPI_SETGRIDGRANULARITY= 19;
    SPI_SETDESKWALLPAPER = 20;
    SPI_SETDESKPATTERN   = 21;
    SPI_GETKEYBOARDDELAY = 22;
    SPI_SETKEYBOARDDELAY = 23;
    SPI_ICONVERTICALSPACING= 24;
    SPI_GETICONTITLEWRAP = 25;
    SPI_SETICONTITLEWRAP = 26;
    SPI_GETMENUDROPALIGNMENT= 27;
    SPI_SETMENUDROPALIGNMENT= 28;
    SPI_SETDOUBLECLKWIDTH= 29;
    SPI_SETDOUBLECLKHEIGHT= 30;
    SPI_GETICONTITLELOGFONT= 31;
    SPI_SETDOUBLECLICKTIME= 32;
    SPI_SETMOUSEBUTTONSWAP= 33;
    SPI_SETICONTITLELOGFONT= 34;
    SPI_GETFASTTASKSWITCH= 35;
    SPI_SETFASTTASKSWITCH= 36;

    SPI_SETDRAGFULLWINDOWS     = 37;
    SPI_GETDRAGFULLWINDOWS     = 38;
    SPI_GETNONCLIENTMETRICS    = 41;
    SPI_SETNONCLIENTMETRICS    = 42;
    SPI_GETMINIMIZEDMETRICS    = 43;
    SPI_SETMINIMIZEDMETRICS    = 44;
    SPI_GETICONMETRICS         = 45;
    SPI_SETICONMETRICS         = 46;
    SPI_SETWORKAREA            = 47;
    SPI_GETWORKAREA            = 48;
    SPI_SETPENWINDOWS          = 49;

    SPI_GETHIGHCONTRAST        = 66;
    SPI_SETHIGHCONTRAST        = 67;
    SPI_GETKEYBOARDPREF        = 68;
    SPI_SETKEYBOARDPREF        = 69;
    SPI_GETSCREENREADER        = 70;
    SPI_SETSCREENREADER        = 71;
    SPI_GETANIMATION           = 72;
    SPI_SETANIMATION           = 73;
    SPI_GETFONTSMOOTHING       = 74;
    SPI_SETFONTSMOOTHING       = 75;
    SPI_SETDRAGWIDTH           = 76;
    SPI_SETDRAGHEIGHT          = 77;
    SPI_SETHANDHELD            = 78;
    SPI_GETLOWPOWERTIMEOUT     = 79;
    SPI_GETPOWEROFFTIMEOUT     = 80;
    SPI_SETLOWPOWERTIMEOUT     = 81;
    SPI_SETPOWEROFFTIMEOUT     = 82;
    SPI_GETLOWPOWERACTIVE      = 83;
    SPI_GETPOWEROFFACTIVE      = 84;
    SPI_SETLOWPOWERACTIVE      = 85;
    SPI_SETPOWEROFFACTIVE      = 86;
    SPI_SETCURSORS             = 87;
    SPI_SETICONS               = 88;
    SPI_GETDEFAULTINPUTLANG    = 89;
    SPI_SETDEFAULTINPUTLANG    = 90;
    SPI_SETLANGTOGGLE          = 91;
    SPI_GETWINDOWSEXTENSION    = 92;
    SPI_SETMOUSETRAILS         = 93;
    SPI_GETMOUSETRAILS         = 94;
    SPI_SCREENSAVERUNNING      = 97;
    SPI_SETSCREENSAVERRUNNING  = 97;
    SPI_SCREENSAVERRUNNING     = SPI_SETSCREENSAVERRUNNING;

    SPI_GETFILTERKEYS          = 50;
    SPI_SETFILTERKEYS          = 51;
    SPI_GETTOGGLEKEYS          = 52;
    SPI_SETTOGGLEKEYS          = 53;
    SPI_GETMOUSEKEYS           = 54;
    SPI_SETMOUSEKEYS           = 55;
    SPI_GETSHOWSOUNDS          = 56;
    SPI_SETSHOWSOUNDS          = 57;
    SPI_GETSTICKYKEYS          = 58;
    SPI_SETSTICKYKEYS          = 59;
    SPI_GETACCESSTIMEOUT       = 60;
    SPI_SETACCESSTIMEOUT       = 61;
    SPI_GETSERIALKEYS          = 62;
    SPI_SETSERIALKEYS          = 63;
    SPI_GETSOUNDSENTRY         = 64;
    SPI_SETSOUNDSENTRY         = 65;

    SPI_GETMOUSEHOVERWIDTH     =98;
    SPI_SETMOUSEHOVERWIDTH     =99;
    SPI_GETMOUSEHOVERHEIGHT   =100;
    SPI_SETMOUSEHOVERHEIGHT   =101;
    SPI_GETMOUSEHOVERTIME     =102;
    SPI_SETMOUSEHOVERTIME     =103;
    SPI_GETWHEELSCROLLLINES   =104;
    SPI_SETWHEELSCROLLLINES   =105;

    SPI_GETSHOWIMEUI          =110;
    SPI_SETSHOWIMEUI          =111;

    SPI_GETMOUSESPEED         =112;
    SPI_SETMOUSESPEED         =113;
    SPI_GETSCREENSAVERRUNNING =114;

    SPI_GETACTIVEWINDOWTRACKING         =01000h;
    SPI_SETACTIVEWINDOWTRACKING         =01001h;
    SPI_GETMENUANIMATION                =01002h;
    SPI_SETMENUANIMATION                =01003h;
    SPI_GETCOMBOBOXANIMATION            =01004h;
    SPI_SETCOMBOBOXANIMATION            =01005h;
    SPI_GETLISTBOXSMOOTHSCROLLING       =01006h;
    SPI_SETLISTBOXSMOOTHSCROLLING       =01007h;
    SPI_GETGRADIENTCAPTIONS             =01008h;
    SPI_SETGRADIENTCAPTIONS             =01009h;
    SPI_GETMENUUNDERLINES               =0100Ah;
    SPI_SETMENUUNDERLINES               =0100Bh;
    SPI_GETACTIVEWNDTRKZORDER           =0100Ch;
    SPI_SETACTIVEWNDTRKZORDER           =0100Dh;
    SPI_GETHOTTRACKING                  =0100Eh;
    SPI_SETHOTTRACKING                  =0100Fh;
    SPI_GETFOREGROUNDLOCKTIMEOUT        =02000h;
    SPI_SETFOREGROUNDLOCKTIMEOUT        =02001h;
    SPI_GETACTIVEWNDTRKTIMEOUT          =02002h;
    SPI_SETACTIVEWNDTRKTIMEOUT          =02003h;
    SPI_GETFOREGROUNDFLASHCOUNT         =02004h;
    SPI_SETFOREGROUNDFLASHCOUNT         =02005h;

    SPIF_UPDATEINIFILE   = 00001h;
    SPIF_SENDWININICHANGE= 00002h;
    SPIF_SENDCHANGE      = SPIF_SENDWININICHANGE;


    METRICS_USEDEFAULT   = -1;

TYPE
    NONCLIENTMETRICSA = RECORD
        cbSize          : UINT;
        iBorderWidth    : WINT;
        iScrollWidth    : WINT;
        iScrollHeight   : WINT;
        iCaptionWidth   : WINT;
        iCaptionHeight  : WINT;
        lfCaptionFont   : LOGFONTA;
        iSmCaptionWidth : WINT;
        iSmCaptionHeight: WINT;
        lfSmCaptionFont : LOGFONTA;
        iMenuWidth      : WINT;
        iMenuHeight     : WINT;
        lfMenuFont      : LOGFONTA;
        lfStatusFont    : LOGFONTA;
        lfMessageFont   : LOGFONTA;
    END;
    PNONCLIENTMETRICSA          = POINTER TO NONCLIENTMETRICSA;
    LPNONCLIENTMETRICSA         = PNONCLIENTMETRICSA;

    NONCLIENTMETRICSW = RECORD
        cbSize          : UINT;
        iBorderWidth    : WINT;
        iScrollWidth    : WINT;
        iScrollHeight   : WINT;
        iCaptionWidth   : WINT;
        iCaptionHeight  : WINT;
        lfCaptionFont   : LOGFONTW;
        iSmCaptionWidth : WINT;
        iSmCaptionHeight: WINT;
        lfSmCaptionFont : LOGFONTW;
        iMenuWidth      : WINT;
        iMenuHeight     : WINT;
        lfMenuFont      : LOGFONTW;
        lfStatusFont    : LOGFONTW;
        lfMessageFont   : LOGFONTW;
    END;
    PNONCLIENTMETRICSW          = POINTER TO NONCLIENTMETRICSW;
    LPNONCLIENTMETRICSW         = PNONCLIENTMETRICSW;

%IF UNICODE %THEN
    NONCLIENTMETRICS            = NONCLIENTMETRICSW;
    PNONCLIENTMETRICS           = PNONCLIENTMETRICSW;
%ELSE
    NONCLIENTMETRICS            = NONCLIENTMETRICSA;
    PNONCLIENTMETRICS           = PNONCLIENTMETRICSA;
%END
    LPNONCLIENTMETRICS          = PNONCLIENTMETRICS;

CONST
    ARW_BOTTOMLEFT              = 0000h;
    ARW_BOTTOMRIGHT             = 0001h;
    ARW_TOPLEFT                 = 0002h;
    ARW_TOPRIGHT                = 0003h;
    ARW_STARTMASK               = 0003h;
    ARW_STARTRIGHT              = 0001h;
    ARW_STARTTOP                = 0002h;

    ARW_LEFT                    = 0000h;
    ARW_RIGHT                   = 0000h;
    ARW_UP                      = 0004h;
    ARW_DOWN                    = 0004h;
    ARW_HIDE                    = 0008h;
    ARW_VALID                   = 000Fh;

TYPE
    MINIMIZEDMETRICS = RECORD
        cbSize  : UINT;
        iWidth  : WINT;
        iHorzGap: WINT;
        iVertGap: WINT;
        iArrange: WINT;
    END;
    PMINIMIZEDMETRICS   = POINTER TO MINIMIZEDMETRICS;
    LPMINIMIZEDMETRICS  = PMINIMIZEDMETRICS;

    ICONMETRICSA = RECORD
        cbSize          : UINT;
        iHorzSpacing    : WINT;
        iVertSpacing    : WINT;
        iTitleWrap      : WINT;
        lfFont          : LOGFONTA;
    END;
    PICONMETRICSA       = POINTER TO ICONMETRICSA;
    LPICONMETRICSA      = PICONMETRICSA;

    ICONMETRICSW = RECORD
        cbSize          : UINT;
        iHorzSpacing    : WINT;
        iVertSpacing    : WINT;
        iTitleWrap      : WINT;
        lfFont          : LOGFONTW;
    END;
    PICONMETRICSW       = POINTER TO ICONMETRICSW;
    LPICONMETRICSW      = PICONMETRICSW;

%IF UNICODE %THEN
    ICONMETRICS         = ICONMETRICSW;
    PICONMETRICS        = PICONMETRICSW;
%ELSE
    ICONMETRICS         = ICONMETRICSA;
    PICONMETRICS        = PICONMETRICSA;
%END
    LPICONMETRICS       = PICONMETRICS;

    ANIMATIONINFO = RECORD
        cbSize          : UINT;
        iMinAnimate     : WINT;
    END;
    LPANIMATIONINFO     = POINTER TO ANIMATIONINFO;

    SERIALKEYSA = RECORD
        cbSize          : UINT;
        dwFlags         : DWORD;
        lpszActivePort  : LPSTR;
        lpszPort        : LPSTR;
        iBaudRate       : UINT;
        iPortState      : UINT;
        iActive         : UINT;
    END;
    LPSERIALKEYSA       = POINTER TO SERIALKEYSA;

    SERIALKEYSW = RECORD
        cbSize          : UINT;
        dwFlags         : DWORD;
        lpszActivePort  : LPWSTR;
        lpszPort        : LPWSTR;
        iBaudRate       : UINT;
        iPortState      : UINT;
        iActive         : UINT;
    END;
    LPSERIALKEYSW       = POINTER TO SERIALKEYSW;

%IF UNICODE %THEN
    SERIALKEYS          = SERIALKEYSW;
    LPSERIALKEYS        = LPSERIALKEYSW;
%ELSE
    SERIALKEYS          = SERIALKEYSA;
    LPSERIALKEYS        = LPSERIALKEYSA;
%END

CONST
    SERKF_SERIALKEYSON  = 000000001h;
    SERKF_AVAILABLE     = 000000002h;
    SERKF_INDICATOR     = 000000004h;

TYPE
    HIGHCONTRASTA = RECORD
        cbSize  : UINT;
        dwFlags : DWORD;
        lpszDefaultScheme : LPSTR;
    END;
    LPHIGHCONTRASTA     = POINTER TO HIGHCONTRASTA;

    HIGHCONTRASTW = RECORD
        cbSize  : UINT;
        dwFlags : DWORD;
        lpszDefaultScheme : LPWSTR;
    END;
    LPHIGHCONTRASTW     = POINTER TO HIGHCONTRASTW;

%IF UNICODE %THEN
    HIGHCONTRAST        = HIGHCONTRASTW;
    LPHIGHCONTRAST      = LPHIGHCONTRASTW;
%ELSE
    HIGHCONTRAST        = HIGHCONTRASTA;
    LPHIGHCONTRAST      = LPHIGHCONTRASTA;
%END

CONST
    HCF_HIGHCONTRASTON  = 00000001h;
    HCF_AVAILABLE       = 00000002h;
    HCF_HOTKEYACTIVE    = 00000004h;
    HCF_CONFIRMHOTKEY   = 00000008h;
    HCF_HOTKEYSOUND     = 00000010h;
    HCF_INDICATOR       = 00000020h;
    HCF_HOTKEYAVAILABLE = 00000040h;

    CDS_UPDATEREGISTRY  = 00000001h;
    CDS_TEST            = 00000002h;
    CDS_FULLSCREEN      = 00000004h;
    CDS_GLOBAL          =000000008h;
    CDS_SET_PRIMARY     =000000010h;
    CDS_RESET           =040000000h;
    CDS_SETRECT         =020000000h;
    CDS_NORESET         =010000000h;

    DISP_CHANGE_SUCCESSFUL   =    0;
    DISP_CHANGE_RESTART      =    1;
    DISP_CHANGE_FAILED       =   -1;
    DISP_CHANGE_BADMODE      =   -2;
    DISP_CHANGE_NOTUPDATED   =   -3;
    DISP_CHANGE_BADFLAGS     =   -4;
    DISP_CHANGE_BADPARAM     =   -5;

PROCEDURE ChangeDisplaySettingsA(VAR lpDevMode : DEVMODEA;
                                 dwFlags : DWORD) : LONG;

PROCEDURE ChangeDisplaySettingsW(VAR lpDevMode : DEVMODEW;
                                 dwFlags : DWORD) : LONG;

%IF UNICODE %THEN
PROCEDURE ChangeDisplaySettings = ChangeDisplaySettingsW;
%ELSE
PROCEDURE ChangeDisplaySettings = ChangeDisplaySettingsA;
%END

PROCEDURE ChangeDisplaySettingsExA(lpszDeviceName : ARRAY OF ACHAR;
                                   lpDevMode : DEVMODEA;
                                   hwnd : HWND;
                                   dwflags : DWORD;
                                   lParam : LPVOID) : LONG;

PROCEDURE ChangeDisplaySettingsExW(lpszDeviceName : ARRAY OF UCHAR;
                                   lpDevMode : DEVMODEW;
                                   hwnd : HWND;
                                   dwflags : DWORD;
                                   lParam : LPVOID) : LONG;

%IF UNICODE %THEN
PROCEDURE ChangeDisplaySettingsEx = ChangeDisplaySettingsExW;
%ELSE
PROCEDURE ChangeDisplaySettingsEx = ChangeDisplaySettingsExA;
%END

CONST
    ENUM_CURRENT_SETTINGS       = CAST(DWORD, -1);
    ENUM_REGISTRY_SETTINGS      = CAST(DWORD, -2);

PROCEDURE EnumDisplaySettingsA( lpszDeviceName : ARRAY OF ACHAR;
                                iModeNum : DWORD;
                                VAR lpDevMode : DEVMODEA) : BOOL;

PROCEDURE EnumDisplaySettingsW( lpszDeviceName : ARRAY OF UCHAR;
                                iModeNum : DWORD;
                                VAR lpDevMode : DEVMODEW) : BOOL;

%IF UNICODE %THEN
PROCEDURE EnumDisplaySettings = EnumDisplaySettingsW;
%ELSE
PROCEDURE EnumDisplaySettings = EnumDisplaySettingsA;
%END


%IF WIN5 %THEN
PROCEDURE EnumDisplayDevicesA(Unused : PVOID;
                              iDevNum : DWORD;
                              lpDisplayDevice : DISPLAY_DEVICEA;
                              dwFlags : DWORD) : BOOL;

PROCEDURE EnumDisplayDevicesW(Unused : PVOID;
                              iDevNum : DWORD;
                              lpDisplayDevice : DISPLAY_DEVICEW;
                              dwFlags : DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE EnumDisplayDevices = EnumDisplayDevicesW;
%ELSE
PROCEDURE EnumDisplayDevices = EnumDisplayDevicesA;
%END
%END

PROCEDURE SystemParametersInfoA(uiAction : UINT;
                                uiParam : UINT;
                                pvParam : PVOID;
                                fWinIni : UINT) : BOOL;

PROCEDURE SystemParametersInfoW(uiAction : UINT;
                                uiParam : UINT;
                                pvParam : PVOID;
                                fWinIni : UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE SystemParametersInfo = SystemParametersInfoW;
%ELSE
PROCEDURE SystemParametersInfo = SystemParametersInfoA;
%END


TYPE
    FILTERKEYS = RECORD
        cbSize          : UINT;
        dwFlags         : DWORD;
        iWaitMSec       : DWORD;
        iDelayMSec      : DWORD;
        iRepeatMSec     : DWORD;
        iBounceMSec     : DWORD;
    END;
    LPFILTERKEYS        = POINTER TO FILTERKEYS;

CONST
    FKF_FILTERKEYSON    = 00000001h;
    FKF_AVAILABLE       = 00000002h;
    FKF_HOTKEYACTIVE    = 00000004h;
    FKF_CONFIRMHOTKEY   = 00000008h;
    FKF_HOTKEYSOUND     = 00000010h;
    FKF_INDICATOR       = 00000020h;
    FKF_CLICKON         = 00000040h;

TYPE
    STICKYKEYS = RECORD
        cbSize  : UINT;
        dwFlags : DWORD;
    END;
    LPSTICKYKEYS = POINTER TO STICKYKEYS;

CONST
    SKF_STICKYKEYSON    = 00000001h;
    SKF_AVAILABLE       = 00000002h;
    SKF_HOTKEYACTIVE    = 00000004h;
    SKF_CONFIRMHOTKEY   = 00000008h;
    SKF_HOTKEYSOUND     = 00000010h;
    SKF_INDICATOR       = 00000020h;
    SKF_AUDIBLEFEEDBACK = 00000040h;
    SKF_TRISTATE        = 00000080h;
    SKF_TWOKEYSOFF      = 00000100h;

%IF WIN5 %THEN
    (*NT only*)
    SKF_LALTLATCHED       =010000000h;
    SKF_LCTLLATCHED       =004000000h;
    SKF_LSHIFTLATCHED     =001000000h;
    SKF_RALTLATCHED       =020000000h;
    SKF_RCTLLATCHED       =008000000h;
    SKF_RSHIFTLATCHED     =002000000h;
    SKF_LWINLATCHED       =040000000h;
    SKF_RWINLATCHED       =080000000h;
    SKF_LALTLOCKED        =000100000h;
    SKF_LCTLLOCKED        =000040000h;
    SKF_LSHIFTLOCKED      =000010000h;
    SKF_RALTLOCKED        =000200000h;
    SKF_RCTLLOCKED        =000080000h;
    SKF_RSHIFTLOCKED      =000020000h;
    SKF_LWINLOCKED        =000400000h;
    SKF_RWINLOCKED        =000800000h;
%END

TYPE
    MOUSEKEYS = RECORD
        cbSize          : UINT;
        dwFlags         : DWORD;
        iMaxSpeed       : DWORD;
        iTimeToMaxSpeed : DWORD;
        iCtrlSpeed      : DWORD;
        dwReserved1     : DWORD;
        dwReserved2     : DWORD;
    END;
    LPMOUSEKEYS = POINTER TO MOUSEKEYS;

CONST
    MKF_MOUSEKEYSON     = 00000001h;
    MKF_AVAILABLE       = 00000002h;
    MKF_HOTKEYACTIVE    = 00000004h;
    MKF_CONFIRMHOTKEY   = 00000008h;
    MKF_HOTKEYSOUND     = 00000010h;
    MKF_INDICATOR       = 00000020h;
    MKF_MODIFIERS       = 00000040h;
    MKF_REPLACENUMBERS  = 00000080h;

%IF WIN5 %THEN
    (*NT only*)
    MKF_LEFTBUTTONSEL   = 010000000h;
    MKF_RIGHTBUTTONSEL  = 020000000h;
    MKF_LEFTBUTTONDOWN  = 001000000h;
    MKF_RIGHTBUTTONDOWN = 002000000h;
    MKF_MOUSEMODE       = 080000000h;
%END

TYPE
    ACCESSTIMEOUT = RECORD
        cbSize          : UINT;
        dwFlags         : DWORD;
        iTimeOutMSec    : DWORD;
    END;
    LPACCESSTIMEOUT     = POINTER TO ACCESSTIMEOUT;

CONST
    ATF_TIMEOUTON       = 00000001h;
    ATF_ONOFFFEEDBACK   = 00000002h;

    SSGF_NONE           = 0;
    SSGF_DISPLAY        = 3;

    SSTF_NONE           = 0;
    SSTF_CHARS          = 1;
    SSTF_BORDER         = 2;
    SSTF_DISPLAY        = 3;

    SSWF_NONE           = 0;
    SSWF_TITLE          = 1;
    SSWF_WINDOW         = 2;
    SSWF_DISPLAY        = 3;
    SSWF_CUSTOM         = 4;

TYPE
    SOUNDSENTRYA = RECORD
        cbSize                  : UINT;
        dwFlags                 : DWORD;
        iFSTextEffect           : DWORD;
        iFSTextEffectMSec       : DWORD;
        iFSTextEffectColorBits  : DWORD;
        iFSGrafEffect           : DWORD;
        iFSGrafEffectMSec       : DWORD;
        iFSGrafEffectColor      : DWORD;
        iWindowsEffect          : DWORD;
        iWindowsEffectMSec      : DWORD;
        lpszWindowsEffectDLL    : LPSTR;
        iWindowsEffectOrdinal   : DWORD;
    END;
    LPSOUNDSENTRYA = POINTER TO SOUNDSENTRYA;

    SOUNDSENTRYW = RECORD
        cbSize                  : UINT;
        dwFlags                 : DWORD;
        iFSTextEffect           : DWORD;
        iFSTextEffectMSec       : DWORD;
        iFSTextEffectColorBits  : DWORD;
        iFSGrafEffect           : DWORD;
        iFSGrafEffectMSec       : DWORD;
        iFSGrafEffectColor      : DWORD;
        iWindowsEffect          : DWORD;
        iWindowsEffectMSec      : DWORD;
        lpszWindowsEffectDLL    : LPWSTR;
        iWindowsEffectOrdinal   : DWORD;
    END;
    LPSOUNDSENTRYW = POINTER TO SOUNDSENTRYW;

%IF UNICODE %THEN
    SOUNDSENTRY = SOUNDSENTRYW;
    LPSOUNDSENTRY = LPSOUNDSENTRYW;
%ELSE
    SOUNDSENTRY = SOUNDSENTRYA;
    LPSOUNDSENTRY = LPSOUNDSENTRYA;
%END

CONST
    SSF_SOUNDSENTRYON   = 00000001h;
    SSF_AVAILABLE       = 00000002h;
    SSF_INDICATOR       = 00000004h;

TYPE
    TOGGLEKEYS = RECORD
        cbSize  : UINT;
        dwFlags : DWORD;
    END;
    LPTOGGLEKEYS        = POINTER TO TOGGLEKEYS;

CONST
    TKF_TOGGLEKEYSON    = 00000001h;
    TKF_AVAILABLE       = 00000002h;
    TKF_HOTKEYACTIVE    = 00000004h;
    TKF_CONFIRMHOTKEY   = 00000008h;
    TKF_HOTKEYSOUND     = 00000010h;
    TKF_INDICATOR       = 00000020h;

CONST
    ctlFirst             = 00400h;
    ctlLast              = 004ffh;
    psh1                 = 00400h;
    psh2                 = 00401h;
    psh3                 = 00402h;
    psh4                 = 00403h;
    psh5                 = 00404h;
    psh6                 = 00405h;
    psh7                 = 00406h;
    psh8                 = 00407h;
    psh9                 = 00408h;
    psh10                = 00409h;
    psh11                = 0040ah;
    psh12                = 0040bh;
    psh13                = 0040ch;
    psh14                = 0040dh;
    psh15                = 0040eh;
    psh16                = 0040fh;
    chx1                 = 00410h;
    chx2                 = 00411h;
    chx3                 = 00412h;
    chx4                 = 00413h;
    chx5                 = 00414h;
    chx6                 = 00415h;
    chx7                 = 00416h;
    chx8                 = 00417h;
    chx9                 = 00418h;
    chx10                = 00419h;
    chx11                = 0041ah;
    chx12                = 0041bh;
    chx13                = 0041ch;
    chx14                = 0041dh;
    chx15                = 0041eh;
    chx16                = 0041fh;
    rad1                 = 00420h;
    rad2                 = 00421h;
    rad3                 = 00422h;
    rad4                 = 00423h;
    rad5                 = 00424h;
    rad6                 = 00425h;
    rad7                 = 00426h;
    rad8                 = 00427h;
    rad9                 = 00428h;
    rad10                = 00429h;
    rad11                = 0042ah;
    rad12                = 0042bh;
    rad13                = 0042ch;
    rad14                = 0042dh;
    rad15                = 0042eh;
    rad16                = 0042fh;
    grp1                 = 00430h;
    grp2                 = 00431h;
    grp3                 = 00432h;
    grp4                 = 00433h;
    frm1                 = 00434h;
    frm2                 = 00435h;
    frm3                 = 00436h;
    frm4                 = 00437h;
    rct1                 = 00438h;
    rct2                 = 00439h;
    rct3                 = 0043ah;
    rct4                 = 0043bh;
    ico1                 = 0043ch;
    ico2                 = 0043dh;
    ico3                 = 0043eh;
    ico4                 = 0043fh;
    stc1                 = 00440h;
    stc2                 = 00441h;
    stc3                 = 00442h;
    stc4                 = 00443h;
    stc5                 = 00444h;
    stc6                 = 00445h;
    stc7                 = 00446h;
    stc8                 = 00447h;
    stc9                 = 00448h;
    stc10                = 00449h;
    stc11                = 0044ah;
    stc12                = 0044bh;
    stc13                = 0044ch;
    stc14                = 0044dh;
    stc15                = 0044eh;
    stc16                = 0044fh;
    stc17                = 00450h;
    stc18                = 00451h;
    stc19                = 00452h;
    stc20                = 00453h;
    stc21                = 00454h;
    stc22                = 00455h;
    stc23                = 00456h;
    stc24                = 00457h;
    stc25                = 00458h;
    stc26                = 00459h;
    stc27                = 0045ah;
    stc28                = 0045bh;
    stc29                = 0045ch;
    stc30                = 0045dh;
    stc31                = 0045eh;
    stc32                = 0045fh;
    lst1                 = 00460h;
    lst2                 = 00461h;
    lst3                 = 00462h;
    lst4                 = 00463h;
    lst5                 = 00464h;
    lst6                 = 00465h;
    lst7                 = 00466h;
    lst8                 = 00467h;
    lst9                 = 00468h;
    lst10                = 00469h;
    lst11                = 0046ah;
    lst12                = 0046bh;
    lst13                = 0046ch;
    lst14                = 0046dh;
    lst15                = 0046eh;
    lst16                = 0046fh;
    cmb1                 = 00470h;
    cmb2                 = 00471h;
    cmb3                 = 00472h;
    cmb4                 = 00473h;
    cmb5                 = 00474h;
    cmb6                 = 00475h;
    cmb7                 = 00476h;
    cmb8                 = 00477h;
    cmb9                 = 00478h;
    cmb10                = 00479h;
    cmb11                = 0047ah;
    cmb12                = 0047bh;
    cmb13                = 0047ch;
    cmb14                = 0047dh;
    cmb15                = 0047eh;
    cmb16                = 0047fh;
    edt1                 = 00480h;
    edt2                 = 00481h;
    edt3                 = 00482h;
    edt4                 = 00483h;
    edt5                 = 00484h;
    edt6                 = 00485h;
    edt7                 = 00486h;
    edt8                 = 00487h;
    edt9                 = 00488h;
    edt10                = 00489h;
    edt11                = 0048ah;
    edt12                = 0048bh;
    edt13                = 0048ch;
    edt14                = 0048dh;
    edt15                = 0048eh;
    edt16                = 0048fh;
    scr1                 = 00490h;
    scr2                 = 00491h;
    scr3                 = 00492h;
    scr4                 = 00493h;
    scr5                 = 00494h;
    scr6                 = 00495h;
    scr7                 = 00496h;
    scr8                 = 00497h;
    FILEOPENORD          = 1536;
    MULTIFILEOPENORD     = 1537;
    PRINTDLGORD          = 1538;
    PRNSETUPDLGORD       = 1539;
    FINDDLGORD           = 1540;
    REPLACEDLGORD        = 1541;
    FONTDLGORD           = 1542;
    FORMATDLGORD31       = 1543;
    FORMATDLGORD30       = 1544;
    PAGESETUPDLGORD      = 1546;

TYPE
    CRGB = RECORD
          bRed           : BYTE;
          bGreen         : BYTE;
          bBlue          : BYTE;
          bExtra         : BYTE;
    END;

CONST
    DLG_COLOR            = 10;
    COLOR_HUESCROLL      = 700;
    COLOR_SATSCROLL      = 701;
    COLOR_LUMSCROLL      = 702;
    COLOR_HUE            = 703;
    COLOR_SAT            = 704;
    COLOR_LUM            = 705;
    COLOR_RED            = 706;
    COLOR_GREEN          = 707;
    COLOR_BLUE           = 708;
    COLOR_CURRENT        = 709;
    COLOR_RAINBOW        = 710;
    COLOR_SAVE           = 711;
    COLOR_ADD            = 712;
    COLOR_SOLID          = 713;
    COLOR_TUNE           = 714;
    COLOR_SCHEMES        = 715;
    COLOR_ELEMENT        = 716;
    COLOR_SAMPLES        = 717;
    COLOR_PALETTE        = 718;
    COLOR_MIX            = 719;
    COLOR_BOX1           = 720;
    COLOR_CUSTOM1        = 721;
    COLOR_HUEACCEL       = 723;
    COLOR_SATACCEL       = 724;
    COLOR_LUMACCEL       = 725;
    COLOR_REDACCEL       = 726;
    COLOR_GREENACCEL     = 727;
    COLOR_BLUEACCEL      = 728;
    NUM_BASIC_COLORS     = 48;
    NUM_CUSTOM_COLORS    = 16;


PROCEDURE PostAppMessageA(a : HTASK;
                         b : UINT;
                         c : WPARAM;
                         d : LPARAM) : BOOL;
PROCEDURE PostAppMessageW(a : HTASK;
                         b : UINT;
                         c : WPARAM;
                         d : LPARAM) : BOOL;
%IF UNICODE %THEN
PROCEDURE PostAppMessage = PostAppMessageW;
%ELSE
PROCEDURE PostAppMessage = PostAppMessageA;
%END

PROCEDURE CreateWindowA(a : ARRAY OF ACHAR;
                       b : ARRAY OF ACHAR;
                       c : DWORD;
                       d : INTEGER;
                       e : INTEGER;
                       f : INTEGER;
                       g : INTEGER;
                       h : HWND;
                       i : HMENU;
                       j : HINSTANCE;
                       k : LPVOID) : HWND;

PROCEDURE CreateWindowW(a : ARRAY OF UCHAR;
                       b : ARRAY OF UCHAR;
                       c : DWORD;
                       d : INTEGER;
                       e : INTEGER;
                       f : INTEGER;
                       g : INTEGER;
                       h : HWND;
                       i : HMENU;
                       j : HINSTANCE;
                       k : LPVOID) : HWND;

%IF UNICODE %THEN
PROCEDURE CreateWindow = CreateWindowW;
%ELSE
PROCEDURE CreateWindow = CreateWindowA;
%END

PROCEDURE CreateDialogA(a : HINSTANCE;
                       b : ARRAY OF ACHAR;
                       c : HWND;
                       d : DLGPROC) : HWND;

PROCEDURE CreateDialogW(a : HINSTANCE;
                       b : ARRAY OF UCHAR;
                       c : HWND;
                       d : DLGPROC) : HWND;

%IF UNICODE %THEN
PROCEDURE CreateDialog = CreateDialogW;
%ELSE
PROCEDURE CreateDialog = CreateDialogA;
%END

PROCEDURE CreateDialogIndirectW(a : HINSTANCE;
                               lpTemplate : LPCDLGTEMPLATEW;
                               c : HWND;
                               d : DLGPROC) : HWND;

PROCEDURE CreateDialogIndirectA(a : HINSTANCE;
                               lpTemplate : LPCDLGTEMPLATEA;
                               c : HWND;
                               d : DLGPROC) : HWND;

%IF UNICODE %THEN
PROCEDURE CreateDialogIndirect = CreateDialogIndirectW;
%ELSE
PROCEDURE CreateDialogIndirect = CreateDialogIndirectA;
%END

PROCEDURE DialogBoxA(a : HINSTANCE;
                    b : ARRAY OF ACHAR;
                    c : HWND;
                    d : DLGPROC) : INTEGER;

PROCEDURE DialogBoxW(a : HINSTANCE;
                    b : ARRAY OF UCHAR;
                    c : HWND;
                    d : DLGPROC) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DialogBox = DialogBoxW;
%ELSE
PROCEDURE DialogBox = DialogBoxA;
%END

PROCEDURE DialogBoxIndirectA(a : HINSTANCE;
                            b : HGLOBAL;
                            c : HWND;
                            d : DLGPROC) : INTEGER;

PROCEDURE DialogBoxIndirectW(a : HINSTANCE;
                            b : HGLOBAL;
                            c : HWND;
                            d : DLGPROC) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DialogBoxIndirect = DialogBoxIndirectW;
%ELSE
PROCEDURE DialogBoxIndirect = DialogBoxIndirectA;
%END

PROCEDURE DefHookProc(a : INTEGER;
                      b : WPARAM;
                      c : LPARAM;
                      VAR d : HOOKPROC) : LRESULT;

PROCEDURE ExitWindows(a : DWORD; b : UINT) : BOOL;

PROCEDURE EnumTaskWindows["_EnumThreadWindows@12"]
        (a : HTASK; a : WNDENUMPROC; c : LPARAM) : BOOL;

PROCEDURE GetNextWindow["_GetWindow@8"]
            (a : HWND; b: UINT) : HWND;

PROCEDURE GetSysModalWindow() : HWND;

PROCEDURE SetSysModalWindow(a : HWND) : HWND;

PROCEDURE GetWindowTask(a : HWND) : HTASK;

PROCEDURE CopyCursor(a : HCURSOR): HCURSOR;


(* MACROS *)
PROCEDURE MAKELONG(LowWord, HiWord : WORD): DWORD [Invariant];
PROCEDURE MAKELPARAM(LowWord, HiWord : WORD): LPARAM [Invariant];
PROCEDURE MAKEWPARAM(LowWord, HiWord : WORD): WPARAM [Invariant];
PROCEDURE MAKELRESULT(LowWord, HiWord : WORD): LRESULT [Invariant];
PROCEDURE LOWORD(l : SYSTEM.DWORD): WORD [Invariant];
PROCEDURE HIWORD(l : SYSTEM.DWORD): WORD [Invariant];
PROCEDURE MAKEWORD(lowbyte, highbyte : SYSTEM.BYTE) : WORD [Invariant];
PROCEDURE LOBYTE(w : SYSTEM.WORD) : BYTE [Invariant];
PROCEDURE HIBYTE(w : SYSTEM.WORD) : BYTE [Invariant];

PROCEDURE AnsiToOem(lpszSrc : ARRAY OF ACHAR;
                    VAR lpszDst : ARRAY OF ACHAR) : BOOL;

PROCEDURE OemToAnsi(lpszSrc : ARRAY OF ACHAR;
                    VAR lpszDst : ARRAY OF ACHAR) : BOOL;

PROCEDURE AnsiToOemBuff(lpszSrc : ARRAY OF ACHAR;
                         VAR lpszDst : ARRAY OF ACHAR;
                         cchDstLength : DWORD) : BOOL;

PROCEDURE OemToAnsiBuff(lpszSrc : ARRAY OF ACHAR;
                         VAR lpszDst : ARRAY OF ACHAR;
                         cchDstLength : DWORD) : BOOL;

PROCEDURE AnsiUpper(VAR lpsz : ARRAY OF ACHAR) : ACHAR;

PROCEDURE AnsiUpperBuff(VAR lpsz : ARRAY OF ACHAR;
                         cchLength : DWORD) : DWORD;

PROCEDURE AnsiLower(VAR lpsz : ARRAY OF ACHAR) : ACHAR;

PROCEDURE AnsiLowerBuff(VAR lpsz : ARRAY OF ACHAR;
                         cchLength : DWORD) : DWORD;

PROCEDURE AnsiNext(lpsz : ARRAY OF ACHAR) : LPSTR;

PROCEDURE AnsiPrev(lpszStart : ARRAY OF ACHAR;
                    lpszCurrent : ARRAY OF ACHAR) : LPSTR;



 (*Duplicated in WIN32*)
CONST
    SLE_ERROR            = 000000001h;
    SLE_MINORERROR       = 000000002h;
    SLE_WARNING          = 000000003h;

PROCEDURE SetLastErrorEx(dwErrCode : DWORD;
                         dwType : DWORD);


%IF WIN5 %THEN
(*
 * Multimonitor API.
 *)
CONST
    MONITOR_DEFAULTTONULL       = 00000000h;
    MONITOR_DEFAULTTOPRIMARY    = 00000001h;
    MONITOR_DEFAULTTONEAREST    = 00000002h;

PROCEDURE MonitorFromPoint(pt : VALUE POINT; dwFlags : DWORD) : HMONITOR;

PROCEDURE MonitorFromRect(lprc : RECT; dwFlags : DWORD) : HMONITOR;

PROCEDURE MonitorFromWindow(hwnd : HWND; dwFlags : DWORD) : HMONITOR;

CONST
    MONITORINFOF_PRIMARY        = 00000001h;

TYPE
    MONITORINFO = RECORD
    cbSize      : DWORD;
    rcMonitor   : RECT;
    rcWork      : RECT;
    dwFlags     : DWORD;
    END;
    LPMONITORINFO = POINTER TO MONITORINFO;

    MONITORINFOEXA = RECORD
    cbSize      : DWORD;
    rcMonitor   : RECT;
    rcWork      : RECT;
    dwFlags     : DWORD;
    szDevice    : ARRAY [0..CCHDEVICENAME-1] OF ACHAR;
    END;
    LPMONITORINFOEXA = POINTER TO MONITORINFOEXA;

    MONITORINFOEXW = RECORD
    cbSize      : DWORD;
    rcMonitor   : RECT;
    rcWork      : RECT;
    dwFlags     : DWORD;
    szDevice    : ARRAY [0..CCHDEVICENAME-1] OF UCHAR;
    END;
    LPMONITORINFOEXW = POINTER TO MONITORINFOEXW;

    %IF UNICODE %THEN
    MONITORINFOEX = MONITORINFOEXW;
    LPMONITORINFOEX = LPMONITORINFOEXW;
    %ELSE
    MONITORINFOEX = MONITORINFOEXA;
    LPMONITORINFOEX = LPMONITORINFOEXA;
    %END

PROCEDURE GetMonitorInfoA(hMonitor : HMONITOR; VAR lpmi : MONITORINFO) : BOOL;
PROCEDURE GetMonitorInfoW(hMonitor : HMONITOR; VAR lpmi : MONITORINFO) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetMonitorInfo = GetMonitorInfoW;
%ELSE
PROCEDURE GetMonitorInfo = GetMonitorInfoA;
%END

TYPE MONITORENUMPROC = PROCEDURE(HMONITOR, HDC, VAR RECT, LPARAM) : BOOL [EXPORT];

PROCEDURE EnumDisplayMonitors(hdc : HDC;
                              lprcClip : RECT;
                              lpfnEnum : MONITORENUMPROC;
                              dwData : LPARAM) : BOOL;

%END

PROCEDURE SetDebugErrorLevel(dwLevel : DWORD);


%IF WIN5 %THEN
(*
 * WinEvents - Active Accessibility hooks
 *)

PROCEDURE NotifyWinEvent(event : DWORD;
                         hwnd : HWND;
                         idObject : LONG;
                         idChild : LONG);

TYPE
    WINEVENTPROC = PROCEDURE(HWINEVENTHOOK(*hWinEventHook*),
                             DWORD         (*event*),
                             HWND          (*hwnd*),
                             LONG          (*idObject*),
                             LONG          (*idChild*),
                             DWORD         (*idEventThread*),
                             DWORD         (*dwmsEventTime*)) [EXPORT];

(*
 * idObject values for WinEventProc and NotifyWinEvent
 *)

(*
 * hwnd + idObject can be used with OLEACC.DLL's OleGetObjectFromWindow()
 * to get an interface pointer to the container.  indexChild is the item
 * within the container in question.  Setup a VARIANT with vt VT_I4 and
 * lVal the indexChild and pass that in to all methods.  Then you
 * are raring to go.
 *)


(*
 * Common object IDs (cookies, only for sending WM_GETOBJECT to get at the
 * thing in question).  Positive IDs are reserved for apps (app specific),
 * negative IDs are system things and are global, 0 means "just little old
 * me".
 *)

CONST
    CHILDID_SELF        =0;
    INDEXID_OBJECT      =0;
    INDEXID_CONTAINER   =0;

(*
 * Reserved IDs for system objects
 *)
    OBJID_WINDOW        =000000000h;
    OBJID_SYSMENU       =0FFFFFFFFh;
    OBJID_TITLEBAR      =0FFFFFFFEh;
    OBJID_MENU          =0FFFFFFFDh;
    OBJID_CLIENT        =0FFFFFFFCh;
    OBJID_VSCROLL       =0FFFFFFFBh;
    OBJID_HSCROLL       =0FFFFFFFAh;
    OBJID_SIZEGRIP      =0FFFFFFF9h;
    OBJID_CARET         =0FFFFFFF8h;
    OBJID_CURSOR        =0FFFFFFF7h;
    OBJID_ALERT         =0FFFFFFF6h;
    OBJID_SOUND         =0FFFFFFF5h;

(*
 * EVENT DEFINITION
 *)
    EVENT_MIN           =000000001h;
    EVENT_MAX           =07FFFFFFFh;


(*
 *  EVENT_SYSTEM_SOUND
 *  Sent when a sound is played.  Currently nothing is generating this, we
 *  this event when a system sound (for menus, etc) is played.  Apps
 *  generate this, if accessible, when a private sound is played.  For
 *  example, if Mail plays a "New Mail" sound.
 *
 *  System Sounds:
 *  (Generated by PlaySoundEvent in USER itself)
 *      hwnd            is NULL
 *      idObject        is OBJID_SOUND
 *      idChild         is sound child ID if one
 *  App Sounds:
 *  (PlaySoundEvent won't generate notification; up to app)
 *      hwnd + idObject gets interface pointer to Sound object
 *      idChild identifies the sound in question
 *  are going to be cleaning up the SOUNDSENTRY feature in the control panel
 *  and will use this at that time.  Applications implementing WinEvents
 *  are perfectly welcome to use it.  Clients of IAccessible* will simply
 *  turn around and get back a non-visual object that describes the sound.
 *)

    EVENT_SYSTEM_SOUND              =00001h;

(*
 * EVENT_SYSTEM_ALERT
 * System Alerts:
 * (Generated by MessageBox() calls for example)
 *      hwnd            is hwndMessageBox
 *      idObject        is OBJID_ALERT
 * App Alerts:
 * (Generated whenever)
 *      hwnd+idObject gets interface pointer to Alert
 *)

    EVENT_SYSTEM_ALERT              = 00002h;

(*
 * EVENT_SYSTEM_FOREGROUND
 * Sent when the foreground (active) window changes, even if it is changing
 * to another window in the same thread as the previous one.
 *      hwnd            is hwndNewForeground
 *      idObject        is OBJID_WINDOW
 *      idChild    is INDEXID_OBJECT
 *)

    EVENT_SYSTEM_FOREGROUND         = 00003h;

(*
 * Menu
 *      hwnd            is window (top level window or popup menu window)
 *      idObject        is ID of control (OBJID_MENU, OBJID_SYSMENU, OBJID_SELF for popup)
 *      idChild         is CHILDID_SELF
 *
 * EVENT_SYSTEM_MENUSTART
 * EVENT_SYSTEM_MENUEND
 * For MENUSTART, hwnd+idObject+idChild refers to the control with the menu bar,
 *  or the control bringing up the context menu.
 *
 * Sent when entering into and leaving from menu mode (system, app bar, and
 * track popups).
 *)
    EVENT_SYSTEM_MENUSTART          =00004h;
    EVENT_SYSTEM_MENUEND            =00005h;

(*
 * EVENT_SYSTEM_MENUPOPUPSTART
 * EVENT_SYSTEM_MENUPOPUPEND
 * Sent when a menu popup comes up and just before it is taken down.  Note
 * that for a call to TrackPopupMenu(), a client will see EVENT_SYSTEM_MENUSTART
 * followed almost immediately by EVENT_SYSTEM_MENUPOPUPSTART for the popup
 * being shown.
 *
 * For MENUPOPUP, hwnd+idObject+idChild refers to the NEW popup coming up, not the
 * parent item which is hierarchical.  You can get the parent menu/popup by
 * asking for the accParent object.
 *)

    EVENT_SYSTEM_MENUPOPUPSTART     =00006h;
    EVENT_SYSTEM_MENUPOPUPEND       =00007h;


(*
 * EVENT_SYSTEM_CAPTURESTART
 * EVENT_SYSTEM_CAPTUREEND
 * Sent when a window takes the capture and releases the capture.
 *)
    EVENT_SYSTEM_CAPTURESTART       =00008h;
    EVENT_SYSTEM_CAPTUREEND         =00009h;

(*
 * Move Size
 * EVENT_SYSTEM_MOVESIZESTART
 * EVENT_SYSTEM_MOVESIZEEND
 * Sent when a window enters and leaves move-size dragging mode.
 *)

    EVENT_SYSTEM_MOVESIZESTART      =0000Ah;
    EVENT_SYSTEM_MOVESIZEEND        =0000Bh;

(*
 * Context Help
 * EVENT_SYSTEM_CONTEXTHELPSTART
 * EVENT_SYSTEM_CONTEXTHELPEND
 * Sent when a window enters and leaves context sensitive help mode.
 *)

    EVENT_SYSTEM_CONTEXTHELPSTART   =0000Ch;
    EVENT_SYSTEM_CONTEXTHELPEND     =0000Dh;

(*
 * Drag & Drop
 * EVENT_SYSTEM_DRAGDROPSTART
 * EVENT_SYSTEM_DRAGDROPEND
 * Send the START notification just before going into drag&drop loop.  Send
 * the END notification just after canceling out.
 * Note that it is up to apps and OLE to generate this, since the system
 * doesn't know.  Like EVENT_SYSTEM_SOUND, it will be a while before this
 * is prevalent.
 *)
    EVENT_SYSTEM_DRAGDROPSTART      =0000Eh;
    EVENT_SYSTEM_DRAGDROPEND        =0000Fh;

(*
 * Dialog
 * Send the START notification right after the dialog is completely
 *  initialized and visible.  Send the END right before the dialog
 *  is hidden and goes away.
 * EVENT_SYSTEM_DIALOGSTART
 * EVENT_SYSTEM_DIALOGEND
 *)

    EVENT_SYSTEM_DIALOGSTART        =00010h;
    EVENT_SYSTEM_DIALOGEND          =00011h;

(*
 * EVENT_SYSTEM_SCROLLING
 * EVENT_SYSTEM_SCROLLINGSTART
 * EVENT_SYSTEM_SCROLLINGEND
 * Sent when beginning and ending the tracking of a scrollbar in a window,
 * and also for scrollbar controls.
 *)
    EVENT_SYSTEM_SCROLLINGSTART     =00012h;
    EVENT_SYSTEM_SCROLLINGEND       =00013h;

(*
 * Alt-Tab Window
 * Send the START notification right after the switch window is initialized
 * and visible.  Send the END right before it is hidden and goes away.
 * EVENT_SYSTEM_SWITCHSTART
 * EVENT_SYSTEM_SWITCHEND
 *)
    EVENT_SYSTEM_SWITCHSTART        =00014h;
    EVENT_SYSTEM_SWITCHEND          =00015h;

(*
 * EVENT_SYSTEM_MINIMIZESTART
 * EVENT_SYSTEM_MINIMIZEEND
 * Sent when a window minimizes and just before it restores.
 *)
    EVENT_SYSTEM_MINIMIZESTART      =00016h;
    EVENT_SYSTEM_MINIMIZEEND        =00017h;

(*
 * Object events
 *
 * The system AND apps generate these.  The system generates these for
 * real windows.  Apps generate these for objects within their window which
 * act like a separate control, e.g. an item in a list view.
 *
 * When the system generate them, dwParam2 is always WMOBJID_SELF.  When
 * apps generate them, apps put the has-meaning-to-the-app-only ID value
 * in dwParam2.
 * For all events, if you want detailed accessibility information, callers
 * should
 *      * Call AccessibleObjectFromWindow() with the hwnd, idObject parameters
 *          of the event, and IID_IAccessible as the REFIID, to get back an
 *          IAccessible* to talk to
 *      * Initialize and fill in a VARIANT as VT_I4 with lVal the idChild
 *          parameter of the event.
 *      * If idChild isn't zero, call get_accChild() in the container to see
 *          if the child is an object in its own right.  If so, you will get
 *          back an IDispatch* object for the child.  You should release the
 *          parent, and call QueryInterface() on the child object to get its
 *          IAccessible*.  Then you talk directly to the child.  Otherwise,
 *          if get_accChild() returns you nothing, you should continue to
 *          use the child VARIANT.  You will ask the container for the properties
 *          of the child identified by the VARIANT.  In other words, the
 *          child in this case is accessible but not a full-blown object.
 *          Like a button on a titlebar which is 'small' and has no children.
 *)

(*
 * For all EVENT_OBJECT events,
 *      hwnd is the dude to Send the WM_GETOBJECT message to (unless NULL,
 *          see above for system things)
 *      idObject is the ID of the object that can resolve any queries a
 *          client might have.  It's a way to deal with windowless controls,
 *          controls that are just drawn on the screen in some larger parent
 *          window (like SDM), or standard frame elements of a window.
 *      idChild is the piece inside of the object that is affected.  This
 *          allows clients to access things that are too small to have full
 *          blown objects in their own right.  Like the thumb of a scrollbar.
 *          The hwnd/idObject pair gets you to the container, the dude you
 *          probably want to talk to most of the time anyway.  The idChild
 *          can then be passed into the acc properties to get the name/value
 *          of it as needed.
 *
 * Example #1:
 *      System propagating a listbox selection change
 *      EVENT_OBJECT_SELECTION
 *          hwnd == listbox hwnd
 *          idObject == OBJID_WINDOW
 *          idChild == new selected item, or CHILDID_SELF if
 *              nothing now selected within container.
 *      Word '97 propagating a listbox selection change
 *          hwnd == SDM window
 *          idObject == SDM ID to get at listbox 'control'
 *          idChild == new selected item, or CHILDID_SELF if
 *              nothing
 *
 * Example #2:
 *      System propagating a menu item selection on the menu bar
 *      EVENT_OBJECT_SELECTION
 *          hwnd == top level window
 *          idObject == OBJID_MENU
 *          idChild == ID of child menu bar item selected
 *
 * Example #3:
 *      System propagating a dropdown coming off of said menu bar item
 *      EVENT_OBJECT_CREATE
 *          hwnd == popup item
 *          idObject == OBJID_WINDOW
 *          idChild == CHILDID_SELF
 *
 * Example #4:
 *
 * For EVENT_OBJECT_REORDER, the object referred to by hwnd/idObject is the
 * PARENT container in which the zorder is occurring.  This is because if
 * one child is zordering, all of them are changing their relative zorder.
 *)
    EVENT_OBJECT_CREATE                 =08000h;  (* hwnd + ID + idChild is created item*)
    EVENT_OBJECT_DESTROY                =08001h;  (* hwnd + ID + idChild is destroyed item*)
    EVENT_OBJECT_SHOW                   =08002h;  (* hwnd + ID + idChild is shown item*)
    EVENT_OBJECT_HIDE                   =08003h;  (* hwnd + ID + idChild is hidden item*)
    EVENT_OBJECT_REORDER                =08004h;  (* hwnd + ID + idChild is parent of zordering children*)

(*
 * NOTE:
 * Minimize the number of notifications!
 *
 * When you are hiding a parent object, obviously all child objects are no
 * longer visible on screen.  They still have the same "visible" status,
 * but are not truly visible.  Hence do not send HIDE notifications for the
 * children also.  One implies all.  The same goes for SHOW.
 *)


    EVENT_OBJECT_FOCUS                  =08005h;  (* hwnd + ID + idChild is focused item*)
    EVENT_OBJECT_SELECTION              =08006h;  (* hwnd + ID + idChild is selected item (if only one), or idChild is OBJID_WINDOW if complex*)
    EVENT_OBJECT_SELECTIONADD           =08007h;  (* hwnd + ID + idChild is item added*)
    EVENT_OBJECT_SELECTIONREMOVE        =08008h;  (* hwnd + ID + idChild is item removed*)
    EVENT_OBJECT_SELECTIONWITHIN        =08009h;  (* hwnd + ID + idChild is parent of changed selected items*)

(*
 * NOTES:
 * There is only one "focused" child item in a parent.  This is the place
 * keystrokes are going at a given moment.  Hence only send a notification
 * about where the NEW focus is going.  A NEW item getting the focus already
 * implies that the OLD item is losing it.
 *
 * SELECTION however can be multiple.  Hence the different SELECTION
 * notifications.  Here's when to use each:
 *
 * (1) Send a SELECTION notification in the simple single selection
 *     case (like the focus) when the item with the selection is
 *     merely moving to a different item within a container.  hwnd + ID
 *     is the container control, idChildItem is the new child with the
 *     selection.
 *
 * (2) Send a SELECTIONADD notification when a new item has simply been added
 *     to the selection within a container.  This is appropriate when the
 *     number of newly selected items is very small.  hwnd + ID is the
 *     container control, idChildItem is the new child added to the selection.
 *
 * (3) Send a SELECTIONREMOVE notification when a new item has simply been
 *     removed from the selection within a container.  This is appropriate
 *     when the number of newly selected items is very small, just like
 *     SELECTIONADD.  hwnd + ID is the container control, idChildItem is the
 *     new child removed from the selection.
 *
 * (4) Send a SELECTIONWITHIN notification when the selected items within a
 *     control have changed substantially.  Rather than propagate a large
 *     number of changes to reflect removal for some items, addition of
 *     others, just tell somebody who cares that a lot happened.  It will
 *     be faster an easier for somebody watching to just turn around and
 *     query the container control what the new bunch of selected items
 *     are.
 *)

    EVENT_OBJECT_STATECHANGE            =0800Ah;  (* hwnd + ID + idChild is item w/ state change*)

(*
 * Examples of when to send an EVENT_OBJECT_STATECHANGE include
 *      * It is being enabled/disabled (USER does for windows)
 *      * It is being pressed/released (USER does for buttons)
 *      * It is being checked/unchecked (USER does for radio/check buttons)
 *)
    EVENT_OBJECT_LOCATIONCHANGE         =0800Bh;  (* hwnd + ID + idChild is moved/sized item*)

(*
 * Note:
 * A LOCATIONCHANGE is not sent for every child object when the parent
 * changes shape/moves.  Send one notification for the topmost object
 * that is changing.  For example, if the user resizes a top level window,
 * USER will generate a LOCATIONCHANGE for it, but not for the menu bar,
 * title bar, scrollbars, etc.  that are also changing shape/moving.
 *
 * In other words, it only generates LOCATIONCHANGE notifications for
 * real windows that are moving/sizing.  It will not generate a LOCATIONCHANGE
 * for every non-floating child window when the parent moves (the children are
 * logically moving also on screen, but not relative to the parent).
 *
 * Now, if the app itself resizes child windows as a result of being
 * sized, USER will generate LOCATIONCHANGEs for those dudes also because
 * it doesn't know better.
 *
 * Note also that USER will generate LOCATIONCHANGE notifications for two
 * non-window sys objects:
 *      (1) System caret
 *      (2) Cursor
 *)

    EVENT_OBJECT_NAMECHANGE             =0800Ch;  (* hwnd + ID + idChild is item w/ name change*)
    EVENT_OBJECT_DESCRIPTIONCHANGE      =0800Dh;  (* hwnd + ID + idChild is item w/ desc change*)
    EVENT_OBJECT_VALUECHANGE            =0800Eh;  (* hwnd + ID + idChild is item w/ value change*)
    EVENT_OBJECT_PARENTCHANGE           =0800Fh;  (* hwnd + ID + idChild is item w/ new parent*)
    EVENT_OBJECT_HELPCHANGE             =08010h;  (* hwnd + ID + idChild is item w/ help change*)
    EVENT_OBJECT_DEFACTIONCHANGE        =08011h;  (* hwnd + ID + idChild is item w/ def action change*)
    EVENT_OBJECT_ACCELERATORCHANGE      =08012h;  (* hwnd + ID + idChild is item w/ keybd accel change*)

(*
 * Child IDs
 *)

(*
 * System Sounds (idChild of system SOUND notification)
 *)
    SOUND_SYSTEM_STARTUP            =1;
    SOUND_SYSTEM_SHUTDOWN           =2;
    SOUND_SYSTEM_BEEP               =3;
    SOUND_SYSTEM_ERROR              =4;
    SOUND_SYSTEM_QUESTION           =5;
    SOUND_SYSTEM_WARNING            =6;
    SOUND_SYSTEM_INFORMATION        =7;
    SOUND_SYSTEM_MAXIMIZE           =8;
    SOUND_SYSTEM_MINIMIZE           =9;
    SOUND_SYSTEM_RESTOREUP          =10;
    SOUND_SYSTEM_RESTOREDOWN        =11;
    SOUND_SYSTEM_APPSTART           =12;
    SOUND_SYSTEM_FAULT              =13;
    SOUND_SYSTEM_APPEND             =14;
    SOUND_SYSTEM_MENUCOMMAND        =15;
    SOUND_SYSTEM_MENUPOPUP          =16;
    CSOUND_SYSTEM                   =16;

(*
 * System Alerts (indexChild of system ALERT notification)
 *)
    ALERT_SYSTEM_INFORMATIONAL      =1;       (* MB_INFORMATION*)
    ALERT_SYSTEM_WARNING            =2;       (* MB_WARNING*)
    ALERT_SYSTEM_ERROR              =3;       (* MB_ERROR*)
    ALERT_SYSTEM_QUERY              =4;       (* MB_QUESTION*)
    ALERT_SYSTEM_CRITICAL           =5;       (* HardSysErrBox*)
    CALERT_SYSTEM                   =6;

PROCEDURE SetWinEventHook(eventMin : DWORD;
                          eventMax : DWORD;
                          hmodWinEventProc : HMODULE;
                          pfnWinEventProc : WINEVENTPROC;
                          idProcess : DWORD;
                          idThread : DWORD;
                          dwFlags : DWORD) : HWINEVENTHOOK;

PROCEDURE UnhookWinEvent(hWinEventHook : HWINEVENTHOOK) : BOOL;

(*
 * dwFlags for SetWinEventHook
 *)
CONST
    WINEVENT_OUTOFCONTEXT   =00000h;  (* Events are ASYNC*)
    WINEVENT_SKIPOWNTHREAD  =00001h;  (* Don't call back for events on installer's thread*)
    WINEVENT_SKIPOWNPROCESS =00002h;  (* Don't call back for events on installer's process*)
    WINEVENT_INCONTEXT      =00004h;  (* Events are SYNC, this causes your dll to be injected into every process*)

TYPE
    GUITHREADINFO = RECORD
    cbSize              : DWORD;
    flags               : DWORD;
    hwndActive          : HWND;
    hwndFocus           : HWND;
    hwndCapture         : HWND;
    hwndMenuOwner       : HWND;
    hwndMoveSize        : HWND;
    hwndCaret           : HWND;
    rcCaret             : RECT;
    END;
    PGUITHREADINFO = POINTER TO GUITHREADINFO;

CONST
    GUI_CARETBLINKING   =000000001h;
    GUI_INMOVESIZE      =000000002h;
    GUI_INMENUMODE      =000000004h;
    GUI_SYSTEMMENUMODE  =000000008h;
    GUI_POPUPMENUMODE   =000000010h;

PROCEDURE GetGUIThreadInfo(idThread : DWORD;
                           VAR pgui : GUITHREADINFO) : BOOL;

PROCEDURE GetWindowModuleFileNameA(hwnd : HWND;
                                   VAR pszFileName : ARRAY OF ACHAR;
                                   cchFileNameMax : UINT) : UINT;

PROCEDURE GetWindowModuleFileNameW(hwnd : HWND;
                                   VAR pszFileName : ARRAY OF UCHAR;
                                   cchFileNameMax : UINT) : UINT;

%IF UNICODE %THEN
PROCEDURE GetWindowModuleFileName = GetWindowModuleFileNameW;
%ELSE
PROCEDURE GetWindowModuleFileName = GetWindowModuleFileNameA;
%END

CONST
    STATE_SYSTEM_UNAVAILABLE        = 00000001h;  (* Disabled*)
    STATE_SYSTEM_SELECTED           = 00000002h;
    STATE_SYSTEM_FOCUSED            = 00000004h;
    STATE_SYSTEM_PRESSED            = 00000008h;
    STATE_SYSTEM_CHECKED            = 00000010h;
    STATE_SYSTEM_MIXED              = 00000020h;  (* 3-state checkbox or toolbar button*)
    STATE_SYSTEM_READONLY           = 00000040h;
    STATE_SYSTEM_HOTTRACKED         = 00000080h;
    STATE_SYSTEM_DEFAULT            = 00000100h;
    STATE_SYSTEM_EXPANDED           = 00000200h;
    STATE_SYSTEM_COLLAPSED          = 00000400h;
    STATE_SYSTEM_BUSY               = 00000800h;
    STATE_SYSTEM_FLOATING           = 00001000h;  (* Children "owned" not "contained" by parent*)
    STATE_SYSTEM_MARQUEED           = 00002000h;
    STATE_SYSTEM_ANIMATED           = 00004000h;
    STATE_SYSTEM_INVISIBLE          = 00008000h;
    STATE_SYSTEM_OFFSCREEN          = 00010000h;
    STATE_SYSTEM_SIZEABLE           = 00020000h;
    STATE_SYSTEM_MOVEABLE           = 00040000h;
    STATE_SYSTEM_SELFVOICING        = 00080000h;
    STATE_SYSTEM_FOCUSABLE          = 00100000h;
    STATE_SYSTEM_SELECTABLE         = 00200000h;
    STATE_SYSTEM_LINKED             = 00400000h;
    STATE_SYSTEM_TRAVERSED          = 00800000h;
    STATE_SYSTEM_MULTISELECTABLE    = 01000000h;  (* Supports multiple selection*)
    STATE_SYSTEM_EXTSELECTABLE      = 02000000h;  (* Supports extended selection*)
    STATE_SYSTEM_ALERT_LOW          = 04000000h;  (* This information is of low priority*)
    STATE_SYSTEM_ALERT_MEDIUM       = 08000000h;  (* This information is of medium priority*)
    STATE_SYSTEM_ALERT_HIGH         = 10000000h;  (* This information is of high priority*)
    STATE_SYSTEM_VALID              = 0FFFFFFFh;

    CCHILDREN_TITLEBAR              =5;
    CCHILDREN_SCROLLBAR             =5;

(*
 * Information about the global cursor.
 *)
TYPE
    CURSORINFO = RECORD
    cbSize      : DWORD;
    flags       : DWORD;
    hCursor     : HCURSOR;
    ptScreenPos : POINT;
    END;
    PCURSORINFO = POINTER TO CURSORINFO;
    LPCURSORINFO  = PCURSORINFO;

CONST
    CURSOR_SHOWING     = 00000001h;

PROCEDURE GetCursorInfo(pci : CURSORINFO) : BOOL;

(*
 * Window information snapshot
 *)
TYPE
    WINDOWINFO = RECORD
    cbSize              : DWORD;
    rcWindow            : RECT;
    rcClient            : RECT;
    dwStyle             : DWORD;
    dwExStyle           : DWORD;
    dwOtherStuff        : DWORD;
    cxWindowBorders     : UINT;
    cyWindowBorders     : UINT;
    atomWindowType      : ATOM;
    wCreatorVersion     : WORD;
    END;
    PWINDOWINFO = POINTER TO WINDOWINFO;
    LPWINDOWINFO =  PWINDOWINFO;

CONST
    WS_ACTIVECAPTION    = 0001h;

PROCEDURE GetWindowInfo(hwnd : HWND; VAR pwi : WINDOWINFO) : BOOL;

(*
 * Titlebar information.
 *)
TYPE
    TITLEBARINFO = RECORD
    cbSize      : DWORD;
    rcTitleBar  : RECT;
    rgstate     : ARRAY [0..CCHILDREN_TITLEBAR+1-1] OF DWORD;
    END;
    PTITLEBARINFO = POINTER TO TITLEBARINFO;
    LPTITLEBARINFO = PTITLEBARINFO;

PROCEDURE GetTitleBarInfo(hwnd : HWND; VAR pti : TITLEBARINFO) : BOOL;

(*
 * Menubar information
 *)

TYPE
    MENUBARINFO = RECORD
    cbSize              : DWORD;
    rcBar               : RECT;  (* rect of bar, popup, item*)
    hMenu               : HMENU; (* real menu handle of bar, popup*)
    hwndMenu            : HWND;  (* hwnd of item submenu if one*)
    fBarFocused         : DWORD;
    (*
    BOOL  fBarFocused:1;  (* bar, popup has the focus*)
    BOOL  fFocused:1;     (* item has the focus*)
    *)
    END;
    PMENUBARINFO = POINTER TO MENUBARINFO;
    LPMENUBARINFO = PMENUBARINFO;

PROCEDURE GetMenuBarInfo(hwnd : HWND;
                         idObject : LONG;
                         idItem : LONG;
                         VAR pmbi : MENUBARINFO) : BOOL;

(*
 * Scrollbar information
 *)
TYPE
    SCROLLBARINFO = RECORD
    cbSize              : DWORD;
    rcScrollBar         : RECT;
    dxyLineButton       : WINT;
    xyThumbTop          : WINT;
    xyThumbBottom       : WINT;
    bogus               : WINT;
    rgstate             : ARRAY [0..CCHILDREN_SCROLLBAR+1-1] OF DWORD;
    END;
    PSCROLLBARINFO = POINTER TO SCROLLBARINFO;
    LPSCROLLBARINFO = PSCROLLBARINFO;

PROCEDURE GetScrollBarInfo(hwnd : HWND;
                           idObject : LONG;
                           VAR psbi : SCROLLBARINFO) : BOOL;

(*
 * Combobox information
 *)

TYPE
    COMBOBOXINFO = RECORD
    cbSize              : DWORD;
    rcItem              : RECT;
    rcButton            : RECT;
    stateButton         : DWORD;
    hwndCombo           : HWND;
    hwndItem            : HWND;
    hwndList            : HWND;
    END;
    PCOMBOBOXINFO = POINTER TO COMBOBOXINFO;
    LPCOMBOBOXINFO = PCOMBOBOXINFO;

PROCEDURE GetComboBoxInfo(hwndCombo : HWND;
                          VAR pcbi : COMBOBOXINFO) : BOOL;

(*
 * The "real" ancestor window
 *)
CONST
    GA_MIC          =1;
    GA_PARENT       =1;
    GA_ROOT         =2;
    GA_ROOTOWNER    =3;
    GA_MAC          =4;

PROCEDURE GetAncestor(hwnd : HWND;
                      gaFlags : UINT) : HWND;

(*
 * This gets the REAL child window at the point.  If it is in the dead
 * space of a group box, it will try a sibling behind it.  But static
 * fields will get returned.  In other words, it is kind of a cross between
 * ChildWindowFromPointEx and WindowFromPoint.
 *)

PROCEDURE RealChildWindowFromPoint(hwndParent : HWND;
                                   ptParentClientCoords : VALUE POINT) : HWND;


(*
 * This gets the name of the window TYPE, not class.  This allows us to
 * recognize ThunderButton32 et al.
 *)

PROCEDURE RealGetWindowClassA(hwnd : HWND;
                              VAR pszType : ARRAY OF ACHAR;
                              cchType : UINT) : UINT;

PROCEDURE RealGetWindowClassW(hwnd : HWND;
                              VAR pszType : ARRAY OF UCHAR;
                              cchType : UINT) : UINT;
(*
 * This gets the name of the window TYPE, not class.  This allows us to
 * recognize ThunderButton32 et al.
 *)

%IF UNICODE %THEN
PROCEDURE RealGetWindowClass = RealGetWindowClassW;
%ELSE
PROCEDURE RealGetWindowClass = RealGetWindowClassA;
%END

(*
 * Alt-Tab Switch window information.
 *)
TYPE
    ALTTABINFO = RECORD
    cbSize              : DWORD;
    cItems              : WINT;
    cColumns            : WINT;
    cRows               : WINT;
    iColFocus           : WINT;
    iRowFocus           : WINT;
    cxItem              : WINT;
    cyItem              : WINT;
    ptStart             : POINT;
    END;
    PALTTABINFO = POINTER TO ALTTABINFO;
    LPALTTABINFO = PALTTABINFO;

PROCEDURE GetAltTabInfoA(hwnd : HWND;
                         iItem : WINT;
                         pati : PALTTABINFO;
                         VAR pszItemText : ARRAY OF ACHAR;
                         cchItemText : UINT) : BOOL;

PROCEDURE GetAltTabInfoW(hwnd : HWND;
                         iItem : WINT;
                         pati : PALTTABINFO;
                         VAR pszItemText : ARRAY OF UCHAR;
                         cchItemText : UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetAltTabInfo = GetAltTabInfoW;
%ELSE
PROCEDURE GetAltTabInfo = GetAltTabInfoA;
%END

(*
 * Listbox information.
 * Returns the number of items per row.
 *)

PROCEDURE GetListBoxInfo(hwnd : HWND) : DWORD;

(*NT only*)
PROCEDURE LockWorkStation() : BOOL;

(*NT only*)
PROCEDURE UserHandleGrantAccess(hUserHandle : HANDLE;
                                hJob : HANDLE) : BOOL;
%END

END WINUSER.
IMPLEMENTATION MODULE SRealIO;

(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs  1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman

          Implementation  1993
                by R. Sutcliffe
       (Portions coded by G. Tischer)
        Trinity Western University
7600 Glover Rd., Langley, BC Canada V3A 6H4
         e-mail: rsutc@twu.ca

    Stony Brook Software Implementation ported
    from above implementation source, those
        portions copyright (c) 1994-2002
        by Stony Brook Software
    procedures are marked as modified by Stony Brook
=========================================== *)

  (* Input and output of real numbers in decimal text form over default
     channels.  The read result is of the type IOConsts.ReadResults.
  *)

  (* The text form of a signed fixed-point real number is
       ["+" | "-"], decimal digit, {decimal digit},
       [".", {decimal digit}]

     The text form of a signed floating-point real number is
       signed fixed-point real number,
       "E", ["+" | "-"], decimal digit, {decimal digit}
  *)


IMPORT StdChans, RealIO;

PROCEDURE ReadReal(VAR real : REAL);
  (* Skips leading spaces, and removes any remaining characters from the
     default input channel that form part of a signed fixed or floating
     point number. The value of this number is assigned to real.  The
     read result is set to the value allRight, outOfRange, wrongFormat,
     endOfLine, or endOfInput. *)
BEGIN
    RealIO.ReadReal(StdChans.InChan(), real);
END ReadReal;

PROCEDURE WriteFloat(real : REAL; sigFigs : CARDINAL; width : CARDINAL);
  (* Writes the value of real to the default output channel in
     floating-point text form, with sigFigs significant figures, in a
     field of the given minimum width.  *)
BEGIN
    RealIO.WriteFloat(StdChans.OutChan(), real, sigFigs, width);
END WriteFloat;

PROCEDURE WriteEng(real : REAL; sigFigs : CARDINAL; width : CARDINAL);
  (* As for WriteFloat, except that the number is scaled with one to
     three digits in the whole number part, and with an exponent that is a
     multiple of three.  *)
BEGIN
    RealIO.WriteEng(StdChans.OutChan(), real, sigFigs, width);
END WriteEng;

PROCEDURE WriteFixed(real : REAL; place, width : CARDINAL);
  (* Writes the value of real to the default output channel in
     fixed-point text form, rounded to the given place relative to the
     decimal point, in a field of the given minimum width.  *)
BEGIN
    RealIO.WriteFixed(StdChans.OutChan(), real, place, width);
END WriteFixed;

PROCEDURE WriteReal(real : REAL; width : CARDINAL);
  (* Writes the value of real to the default output channel, as WriteFixed
     if the sign and magnitude can be shown in the given width, or
     otherwise as WriteFloat.  The number of places or significant digits
     depends on the given width.  *)
BEGIN
    RealIO.WriteReal(StdChans.OutChan(), real, width);
END WriteReal;

END SRealIO.

DEFINITION MODULE LongConv;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs  1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman
=========================================== *)

(* Low-level LONGREAL/string conversions *)

IMPORT
    ConvTypes;

TYPE
    ConvResults = ConvTypes.ConvResults;
                (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

(* the string form of a signed fixed-point real number is
     ["+" | "-"], decimal digit, {decimal digit}, [".", {decimal digit}]
*)

(* the string form of a signed floating-point real number is
   signed fixed-point real number,
   "E",
   ["+" | "-"], decimal digit, {decimal digit}
*)

PROCEDURE ScanReal(inputCh : CHAR;
                   VAR chClass : ConvTypes.ScanClass;
                   VAR nextState : ConvTypes.ScanState);
(* Represents the start state of a finite state scanner for real
   numbers - assigns class of inputCh to chClass and a procedure
   representing the next state to nextState.
*)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

PROCEDURE FormatReal(str : ARRAY OF CHAR) : ConvResults;
(* Returns the format of the string value for conversion to REAL *)

PROCEDURE ValueReal(str : ARRAY OF CHAR) : LONGREAL;
(* Returns the value corresponding to the real number string
   value str if str is well-formed; otherwise raises the RealConv exception.
*)

PROCEDURE LengthFloatReal(real : LONGREAL; sigFigs : CARDINAL) : CARDINAL;
(* Returns the number of characters in the floating-point
   string representation of real with sigFigs significant figures
*)

PROCEDURE LengthEngReal(real : LONGREAL; sigFigs : CARDINAL) : CARDINAL;
(* Returns the number of characters in the floating-point engineering
   string representation of real with sigFigs significant figures
*)

PROCEDURE LengthFixedReal(real : LONGREAL; place : INTEGER) : CARDINAL;
(* Returns the number of characters in the fixed-point
   string representation of real rounded to the given place relative to
   the decimal point
*)

PROCEDURE IsRConvException() : BOOLEAN;
(* Returns TRUE if the current coroutine is in the exceptional execution
   state because of the raising of an exception in a routine from this
   module; otherwise returns FALSE
*)

END LongConv.

DEFINITION MODULE SLongIO;
(* =========================================
            Definition Module from
                  ISO Modula-2
Draft Standard CD10515 by JTC1/SC22/WG13
    Language and Module designs  1992 by
BSI, D.J. Andrews, B.J. Cornelius, R. B. Henry
R. Sutcliffe, D.P. Ward, and M. Woodman
=========================================== *)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END



  (* Input and output of real numbers in decimal text form over default
     channels.  The read result is of the type IOConsts.ReadResults.
  *)

  (* The text form of a signed fixed-point real number is
       ["+" | "-"], decimal digit, {decimal digit},
       [".", {decimal digit}]

     The text form of a signed floating-point real number is
       signed fixed-point real number,
       "E", ["+" | "-"], decimal digit, {decimal digit}
  *)

PROCEDURE ReadReal(VAR real : LONGREAL);
  (* Skips leading spaces, and removes any remaining characters from
     the default input channel that form part of a signed fixed or
     floating point number. The value of this number is assigned to real.
     The read result is set to the value allRight, outOfRange, wrongFormat,
     endOfLine, or endOfInput.
  *)

PROCEDURE WriteFloat(real : LONGREAL; sigFigs : CARDINAL; width : CARDINAL);
  (* Writes the value of real to the default output channel in
     floating-point text form, with sigFigs significant figures, in a
     field of the given minimum width. *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

PROCEDURE WriteEng(real : LONGREAL; sigFigs : CARDINAL; width : CARDINAL);
  (* As for WriteFloat, except that the number is scaled with one to three
     digits in the whole number part, and with an exponent that is a
     multiple of three. *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

PROCEDURE WriteFixed(real : LONGREAL; place, width : CARDINAL);
  (* Writes the value of real to the default output channel in
     fixed-point text form, rounded to the given place relative to the
     decimal point, in a field of the given minimum width. *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

PROCEDURE WriteReal(real : LONGREAL; width : CARDINAL);
  (* Writes the value of real to the default output channel, as WriteFixed
     if the sign and magnitude can be shown in the given width, or otherwise
     as WriteFloat.  The number of places or significant digits depends on
     the given width. *)
(* if width = 0 then a single space character will always be output *)
(* before the number. *)

END SLongIO.

(***************************************************************************)

(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1992-2004                             *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)
DEFINITION MODULE WinShell;
(*
  This module provides an encapsulation of the underlying operating system
  interface for handling windows and messages.
  no operating system types, constants or procedures are exported from
  this module. therefore any code that uses this module will not change
  when ported to another system.

  This module does not try to create a "very high level" interface.
  It mostly maps itself directly to the underlying system. However, there
  is some functionality not typically provided by typical system API calls.

  This module does not attempt to map the entire underlying system.
  Features are added to this module on an as needed basis. In other words,
  why write the code, if it has no immediate use.

  Implementations.
      Windows
      GTK+ 1.2
      Macintosh Carbon OS X (using the p1 compiler)
*)

(* implementation limitations
   Win32
       ScaleDrawableArea requires GDI+ be installed to use interpolation modes
           other than InterpLowQuality. If GDI+ is not available then InterpLowQuality
           is always used.
       LoadBitmap and LoadBitmapFromFile require GDI+ to load JPEG, TIFF, GIF and PNG
           graphics formats. If GDI+ is not available then these formats cannot be
           loaded.
*)

(* about resources.
   See also, SetResourceFile API call in this module.

   Resource name identifiers.
       Resource names are not case sensitive.

       Resource names can consist of two parts, a name and an id number.
       Windows supports resources identified by name or number.
       On GTK resources are identified by name.
       On the Mac resources are identified by id number and have an optional name.

       Name formats accepted.
           Name
           #number
           Name#number

           This module will break apart resource names into its respective components.

           For portability across all platforms use the Name or Name#number format.
           For portability across Win32 and GTK use the Name format.
           For portability across Win32 and Mac you can use any format.

           Since Windows supports named and numbered resources and a WinShell resource
           identifier can have a name and number this module first searches for the
           named resource and then searches for the numbered resource.

           Classic Mac resources are primarily identified by number if you use
           the Name#number format the number is used, so the number should be correct.
           If you do not supply a number this module will find the resource by name
           and then get the resource id number from the found resource. It is done
           this way because many APIs like GetMenu, GetNewMBar and GetPicture do not
           support named resources and only support resource id numbers.

   ---------------------------------------------------------------
   ---------------------------------------------------------------
   ---------------------------------------------------------------
   Windows - normal Windows resources are used.

           An accelerator table resource needs to have the same name
           as the menu resource it is associated with.

           Additional "bitmap" resource types are supported in addition to the
           Windows native bitmap format.
           JPEG, PNG, GIF and TIFF formats are supported.
           Gdi+ is used to load these formats.

           When loading a bitmap from the resource file this module first looks
           for a native bitmap resource of the given name, and if this is not found
           then looks for JPEG, PNG, GIF and TIFF resources in that order.

           JPEG resources are identified by the "JPEG" resource type.
           PNG resources are identified by the "PNG" resource type.
           GIF resources are identified by the "GIF" resource type.
           TIFF resources are identified by the "TIFF" resource type.

           LoadBitmapFromFile also supports these formats.

   ---------------------------------------------------------------
   ---------------------------------------------------------------
   ---------------------------------------------------------------
   Gtk - The concept of resources does not exist in the Unix toolkit
         world, and Gtk is no exception.
         We use a combination of various files to get the same effect.

       Dialogs - Glade XML files.
           For further information consult DlgShell.

       ---------------------------------------------------------------
       Menu's and accelerators. Glade XML files.
           Create a window in glade, mark the window as NOT visible.
           The name of the window is the name of your menu resource.
           Put your menubar into this window. The menu bar name must be named
           "menubar". The accelerators you define in the menubar will be used.

           For accelerators not tied to a menu item you create a menu in
           your menubar named "hiddenaccel" and put your accelerators
           on menu items within this menu. This menu will be hidden by
           this module.

           Popup menus are glade popup menu resources.

       ---------------------------------------------------------------
       String table - Proprietary format used by this module.
           This file format is the one that the Win32 resource editor uses
           to export/import string tables to stand alone files.

           Format.
           IdNumber = "...

           IdNumber = the string id number
           '=' the equal character.
           '"' the double quote character.
           The string is all data after the '"' character to the end of
           the line.

           Carrage return, line feed, tab, and backspace characters are
               in "escape" notation. These characters are converted to binary
               format when the string is loaded.
           \r = Carriage return = CHR(13). ignored on Unix systems.
           \n = line feed (new line) = CHR(10)
           \t = tab = CHR(9)
           \b = backspace = CHR(8)
           \\ = \ backslash character.

        ---------------------------------------------------------------
        Bitmaps - Proprietary format used by this module.
            This is a text file that describes the resource name
            and the associated bitmap file to load. Therefore each
            bitmap resource is an individual file. The bitmap file names
            can be relative file names that are relative to the bitmap
            resource file.

            libgdk_pixbuf is used to load bitmaps, it must be installed!

            Format
            ResourceName = FileName
            where ResoruceName and FileName must be enclosed in double quote
            characters.
            Only one resource description entry per line.

            Example
            "Splash" = "pixmaps/splash.png"

            Assuming the resource file is in directory "/opt/MyCompany",
            then the full path of the example bitmap file is
            "/opt/MyCompany/pixmaps/splash.png"

            Bitmap resource files can be any graphics file format supported
            by the Gdk Pixbuf library.
            This includes
                BMP, JPEG, PNG, TIFF, XPM, GIF, ICO.

            LoadBitmapFromFile can load any image format that GTK supports.

   ---------------------------------------------------------------
   ---------------------------------------------------------------
   ---------------------------------------------------------------
    Macintosh - In flux. Only Classic for now. In the future Dialogs and menus
                    will only support Interface Builder.
                 Classic Mac resources.
                     We suggest you use the Resorcerer program for creating and editing
                     your Mac resources. www.mathemaesthetics.com
                     Resources used internally by this module all have id numbers
                     32000 or higher.
                 Interface builder.
                     Not yet supported.

       ---------------------------------------------------------------
       Menus - Mac standard + extended information generated by Resorcerer.
           Create your menus with Resorcerer and enter the menu id number in the
               "command Id" field. Resorcerer automatically generates a resource type
               "Mcmd" which contains the menu item command id numbers. This module
               loads and parses this resource and sets the menu item command id numbers.

       ---------------------------------------------------------------
       String Table - Proprietary format or standard Mac format.
           Proprietary format.
               See the GTK string table resource documentation for the table format.
               This format does not have a 255 character limit.
               The resource type is "strX" and the resource id number is 128.
           Mac classic.
               TEXT and STR# resources.
               The STR# resource id must be 128.
               STR# string lists have an individual string limit of 255 characters.
               Therefore this module will try and load a TEXT resource of the given
               string id number. if that fails then it will try to load the string
               from the STR# resource.

       ---------------------------------------------------------------
       Bitmaps
           Mac classic.
               This can be a PICT or cicn resource.
               the cicn (color icon) resource is handy for small bitmaps.
               Additional "bitmap" resource types are supported in addition to the
               native formats.

               BMP, JPEG, PNG, GIF and TIFF formats are supported.
               Quicktime is used to load these formats.

               When loading a bitmap from the resource file this module first looks
               for a native bitmap resource of the given name, and if this is not found
               then looks for BMP(Window  bitmap), JPEG, PNG, TIFF and GIF
               resources in that order.

               BMP resources are identified by the "WRLE" (kBMPCodecType) resource type.
               JPEG resources are identified by the "jpeg" (kJPEGCodecType) resource type.
               PNG resources are identified by the "png " (kPNGCodecType) resource type.
               GIF resources are identified by the "gif " (kGIFCodecType) resource type.
               TIFF resources are identified by the "tiff" (kTIFFCodecType) resource type.

           LoadBitmapFromFile can load any image format that Quicktime supports which
               is considerable.
*)

(* about threads
   Win32 - you may use the GUI features in a fully multi threaded manner.

   Gtk - Only one thread, the main thread, may use the GUI features.

   Mac - Currently only one thread, the main thread, may use the GUI features.

   In all systems you can have any thread safely use the LoadString API.

   In all systems you can have a background thread send or post a message
   to a window. For send, the background thread will wait until the message is
   received and processed by the UI thread before returning from the
   send message call.
*)

<*IF StonyBrook THEN*>
    <*/NOPACK*>

    (* a hack so we can do editing and compiling for syntax of Mac code
       using our compiler. *)
    <*/VALIDVERSION:MAC*>
    %IF p1 %THEN(*how we signal compiling Mac code*)
        <*/NOVERSION:WIN32*>
        <*/VERSION:MAC*>
    %END
<*ELSIF p1 THEN*>
    <*ASSIGN (AlignModelPPC, TRUE)*>
    <*DEFINE (MAC, TRUE)*>
<*ELSE*>
    fix me
<*END*>

FROM SYSTEM IMPORT
    ADDRESS, CAST,
    CARD8;

TYPE
    Window;
    Drawable;
    DrawContext;
    TreeClientNode;
    MenuHandle;
    BitmapHandle;
    ImageListHandle;
    FontHandle;
    PrintDriverInfo;

CONST
    (* Stony Brook compilers implement an extension that allows opaque types to be
       compatible with NIL outside of their native implementation module.
       For compilers not supporting this feature you use these constants to assign
       and compare variables of the respective opaque type with NIL.
    *)
    NIL_Window          = CAST(Window, NIL);
    NIL_Drawable        = CAST(Drawable, NIL);
    NIL_DrawContext     = CAST(DrawContext, NIL);
    NIL_TreeClientNode  = CAST(TreeClientNode, NIL);
    NIL_MenuHandle      = CAST(MenuHandle, NIL);
    NIL_BitmapHandle    = CAST(BitmapHandle, NIL);
    NIL_ImageListHandle = CAST(ImageListHandle, NIL);
    NIL_FontHandle      = CAST(FontHandle, NIL);
    NIL_PrintDriverInfo = CAST(PrintDriverInfo, NIL);

TYPE
    WindowTypes         = (ToplevelWindow, ChildWindow);
    (*
      ToplevelWindow - a normal Window.
      ChildWindow - a window that is child of a TabClient or SplitterClient window.
    *)

    ClientTypes         = (DrawClient,
                           ListClient, TreeClient, FormClient,
                           TabClient, SplitterClient);
    (*
      !!! not yet implemented
          GTK => the FormClient form editor is not implemented.
                 The FormClient is functional.
      !!!

      DrawClient - a free form area in which you can draw anything you like.
                   it is your responsibility to redraw the area on demand.
                       see WSM_PAINT message.
                       see SetBackgroundAutoErase

      ListClient - displays a list of items.
                   the list may have one or more columns.
                   the list may have a header window describing said columns.

      TreeClient - a typical hierarchical tree display that can be expanded
                   and contracted.

      FormClient - an area in which you can place various "controls" like typically
                   used in dialog boxes. In fact you can use this client type in
                   a toplevel window to create "dialog boxes". even modal ones.

      TabClient - like notebook tabs.
                  Each tab can contain any client window type.
                  you can have single or multi-line tabs.
                  you can have as many tabs as you want. in single line mode
                  the user can scroll left/right through the tabs. in milti-line
                  mode all tabs are always visible and the tab content rect gets
                  smaller and smaller as more tab lines are created.

                  Win32
                      single a multi-line tabs are supported.
                  GTK+
                      only single line tabs are supported.
                  Mac
                     only single line tabs are supported.
                     However, the Mac control cannot scroll tabs.
                     Therefore, you can only have as many tabs as can
                     be display in the window. this of course varies depending on the
                     size of window at any given time.

          TabClient Multiple Document Interface.
              If a ToplevelWindow client type is TabClient then the individual
              tab client children may have a unique menu and this module will
              automatically switch the ToplevelWindow menubar to the menu of the
              currently active tab client. if the tab client does not have a
              menu, or if no tab clients are open, then the ToplevelWindow menu
              becomes active.

      SplitterClient - splits a region into two parts. Each part may contain any
                       client window type. The region may be split vertically
                       or horizontally.
                       The relative proportions of each part are user sizable.
    *)

    TabPosition         = (TabTop, TabBottom, TabLeft, TabRight);

    TextAlignment       = (AlignLeft, AlignCenter, AlignRight);

<*IF StonyBrook THEN*>
    StringData          = POINTER TO ARRAY [0..0] OF CHAR;
<*ELSIF p1 THEN*>
    StringData          = POINTER TO ARRAY [0..(8*1024)-1] OF CHAR;
<*ELSE*>
    fix me
<*END*>

    ColorValue          = CARDINAL;
    (* in hex notation the color value components are. AABBGGRRh
       RR = red. the low order byte.
       GG = green
       BB = blue
       AA = alpha channel. currently not used.
    *)

    CommonColors =
    (
        (* SVG standard colors *)
        AliceBlue,
        AntiqueWhite,
        Aqua,
        Aquamarine,
        Azure,
        Beige,
        Bisque,
        Black,
        BlanchedAlmond,
        Blue,
        BlueViolet,
        Brown,
        BurlyWood,
        CadetBlue,
        Chartreuse,
        Chocolate,
        Coral,
        CornflowerBlue,
        Cornsilk,
        Crimson,
        Cyan,
        DarkBlue,
        DarkCyan,
        DarkGoldenrod,
        DarkGray,
        DarkGreen,
        DarkKhaki,
        DarkMagenta,
        DarkOliveGreen,
        DarkOrange,
        DarkOrchid,
        DarkRed,
        DarkSalmon,
        DarkSeaGreen,
        DarkSlateBlue,
        DarkSlateGray,
        DarkTurquoise,
        DarkViolet,
        DeepPink,
        DeepSkyBlue,
        DimGray,
        DodgerBlue,
        Firebrick,
        FloralWhite,
        ForestGreen,
        Fuchsia,
        Gainsboro,
        GhostWhite,
        Gold,
        Goldenrod,
        Gray,
        Green,
        GreenYellow,
        Honeydew,
        HotPink,
        IndianRed,
        Indigo,
        Ivory,
        Khaki,
        Lavender,
        LavenderBlush,
        LawnGreen,
        LemonChiffon,
        LightBlue,
        LightCoral,
        LightCyan,
        LightGoldenrodYellow,
        LightGray,
        LightGreen,
        LightPink,
        LightSalmon,
        LightSeaGreen,
        LightSkyBlue,
        LightSlateGray,
        LightSteelBlue,
        LightYellow,
        Lime,
        LimeGreen,
        Linen,
        Magenta,
        Maroon,
        MediumAquamarine,
        MediumBlue,
        MediumOrchid,
        MediumPurple,
        MediumSeaGreen,
        MediumSlateBlue,
        MediumSpringGreen,
        MediumTurquoise,
        MediumVioletRed,
        MidnightBlue,
        MintCream,
        MistyRose,
        Moccasin,
        NavajoWhite,
        Navy,
        OldLace,
        Olive,
        OliveDrab,
        Orange,
        OrangeRed,
        Orchid,
        PaleGoldenrod,
        PaleGreen,
        PaleTurquoise,
        PaleVioletRed,
        PapayaWhip,
        PeachPuff,
        Peru,
        Pink,
        Plum,
        PowderBlue,
        Purple,
        Red,
        RosyBrown,
        RoyalBlue,
        SaddleBrown,
        Salmon,
        SandyBrown,
        SeaGreen,
        SeaShell,
        Sienna,
        Silver,
        SkyBlue,
        SlateBlue,
        SlateGray,
        Snow,
        SpringGreen,
        SteelBlue,
        Tan,
        Teal,
        Thistle,
        Tomato,
        Turquoise,
        Violet,
        Wheat,
        White,
        WhiteSmoke,
        Yellow,
        YellowGreen,

        (* other colors *)
        TransparentColor
    );

    CommonColorsArray   = ARRAY CommonColors OF ColorValue;

CONST
    Colors = CommonColorsArray{
        (*AliceBlue*) 0FFF8F0h,
        (*AntiqueWhite*) 0D7EBFAh,
        (*Aqua*) 0FFFF00h,
        (*Aquamarine*) 0D4FF7Fh,
        (*Azure*) 0FFFFF0h,
        (*Beige*) 0DCF5F5h,
        (*Bisque*) 0C4E4FFh,
        (*Black*) 0000000h,
        (*BlanchedAlmond*) 0CDEBFFh,
        (*Blue*) 0FF0000h,
        (*BlueViolet*) 0E22B8Ah,
        (*Brown*) 02A2AA5h,
        (*BurlyWood*) 087B8DEh,
        (*CadetBlue*) 0A09E5Fh,
        (*Chartreuse*) 000FF7Fh,
        (*Chocolate*) 01E69D2h,
        (*Coral*) 0507FFFh,
        (*CornflowerBlue*) 0ED9564h,
        (*Cornsilk*) 0DCF8FFh,
        (*Crimson*) 03C14DCh,
        (*Cyan*) 0FFFF00h,
        (*DarkBlue*) 08B0000h,
        (*DarkCyan*) 08B8B00h,
        (*DarkGoldenrod*) 00B86B8h,
        (*DarkGray*) 0A9A9A9h,
        (*DarkGreen*) 0006400h,
        (*DarkKhaki*) 06BB7BDh,
        (*DarkMagenta*) 08B008Bh,
        (*DarkOliveGreen*) 02F6B55h,
        (*DarkOrange*) 0008CFFh,
        (*DarkOrchid*) 0CC3299h,
        (*DarkRed*) 000008Bh,
        (*DarkSalmon*) 07A96E9h,
        (*DarkSeaGreen*) 08BBC8Fh,
        (*DarkSlateBlue*) 08B3D48h,
        (*DarkSlateGray*) 04F4F2Fh,
        (*DarkTurquoise*) 0D1CE00h,
        (*DarkViolet*) 0D30094h,
        (*DeepPink*) 09314FFh,
        (*DeepSkyBlue*) 0FFBF00h,
        (*DimGray*) 0696969h,
        (*DodgerBlue*) 0FF901Eh,
        (*Firebrick*) 02222B2h,
        (*FloralWhite*) 0F0FAFFh,
        (*ForestGreen*) 0228B22h,
        (*Fuchsia*) 0FF00FFh,
        (*Gainsboro*) 0DCDCDCh,
        (*GhostWhite*) 0FFF8F8h,
        (*Gold*) 000D7FFh,
        (*Goldenrod*) 020A5DAh,
        (*Gray*) 0808080h,
        (*Green*) 0008000h,
        (*GreenYellow*) 02FFFADh,
        (*Honeydew*) 0F0FFF0h,
        (*HotPink*) 0B469FFh,
        (*IndianRed*) 05C5CCDh,
        (*Indigo*) 082004Bh,
        (*Ivory*) 0F0FFFFh,
        (*Khaki*) 08CE6F0h,
        (*Lavender*) 0FAE6E6h,
        (*LavenderBlush*) 0F5F0FFh,
        (*LawnGreen*) 000FC7Ch,
        (*LemonChiffon*) 0CDFAFFh,
        (*LightBlue*) 0E6D8ADh,
        (*LightCoral*) 08080F0h,
        (*LightCyan*) 0FFFFE0h,
        (*LightGoldenrodYellow*) 0D2FAFAh,
        (*LightGray*) 0D3D3D3h,
        (*LightGreen*) 090EE90h,
        (*LightPink*) 0C1B6FFh,
        (*LightSalmon*) 07AA0FFh,
        (*LightSeaGreen*) 0AAB220h,
        (*LightSkyBlue*) 0FACE87h,
        (*LightSlateGray*) 0998877h,
        (*LightSteelBlue*) 0DEC4B0h,
        (*LightYellow*) 0E0FFFFh,
        (*Lime*) 000FF00h,
        (*LimeGreen*) 032CD32h,
        (*Linen*) 0E6F0FAh,
        (*Magenta*) 0FF00FFh,
        (*Maroon*) 0000080h,
        (*MediumAquamarine*) 0AACD66h,
        (*MediumBlue*) 0CD0000h,
        (*MediumOrchid*) 0D355BAh,
        (*MediumPurple*) 0DB7093h,
        (*MediumSeaGreen*) 071B33Ch,
        (*MediumSlateBlue*) 0EE687Bh,
        (*MediumSpringGreen*) 09AFA00h,
        (*MediumTurquoise*) 0CCD148h,
        (*MediumVioletRed*) 08515C7h,
        (*MidnightBlue*) 0701919h,
        (*MintCream*) 0FAFFF5h,
        (*MistyRose*) 0E1E4FFh,
        (*Moccasin*) 0B5E4FFh,
        (*NavajoWhite*) 0ADDEFFh,
        (*Navy*) 0800000h,
        (*OldLace*) 0E6F5FDh,
        (*Olive*) 0008080h,
        (*OliveDrab*) 0238E6Bh,
        (*Orange*) 000A5FFh,
        (*OrangeRed*) 00045FFh,
        (*Orchid*) 0D670DAh,
        (*PaleGoldenrod*) 0AAE8EEh,
        (*PaleGreen*) 098FB98h,
        (*PaleTurquoise*) 0EEEEAFh,
        (*PaleVioletRed*) 09370DBh,
        (*PapayaWhip*) 0D5EFFFh,
        (*PeachPuff*) 0B9DAFFh,
        (*Peru*) 03F85CDh,
        (*Pink*) 0CBC0FFh,
        (*Plum*) 0DDA0DDh,
        (*PowderBlue*) 0E6E0B0h,
        (*Purple*) 0800080h,
        (*Red*) 00000FFh,
        (*RosyBrown*) 08F8FBCh,
        (*RoyalBlue*) 0E16941h,
        (*SaddleBrown*) 013458Bh,
        (*Salmon*) 07280FAh,
        (*SandyBrown*) 060A4F4h,
        (*SeaGreen*) 0578B2Eh,
        (*SeaShell*) 0EEF5FFh,
        (*Sienna*) 02D52A0h,
        (*Silver*) 0C0C0C0h,
        (*SkyBlue*) 0EBCE87h,
        (*SlateBlue*) 0CD5A6Ah,
        (*SlateGray*) 0908070h,
        (*Snow*) 0FAFAFFh,
        (*SpringGreen*) 07FFF00h,
        (*SteelBlue*) 0B48246h,
        (*Tan*) 08CB4D2h,
        (*Teal*) 0808000h,
        (*Thistle*) 0D8BFD8h,
        (*Tomato*) 04763FFh,
        (*Turquoise*) 0D0E040h,
        (*Violet*) 0EE82EEh,
        (*Wheat*) 0B3DEF5h,
        (*White*) 0FFFFFFh,
        (*WhiteSmoke*) 0F5F5F5h,
        (*Yellow*) 000FFFFh,
        (*YellowGreen*) 032CD9Ah,

        (*TransparentColor*)0FFFFFFFFh(*transparent white*)
     };

    OpaqueOpacity       = 0;
    TransparentOpacity  = 255;

TYPE
    RgbPixelFormat      = (Rgb8, Rgba8, Rgb16, Rgba16,
                           Bgr8, Bgra8, Bgr16, Bgra16,
                           Abgr8, Abgr16);

    ColumnContentTypes  = (ColumnText, ColumnBitmap, ColumnBitmapText);

    ClientColumnInfo =
        RECORD
        header          : StringData;(*can be NIL, which means no header text.
                                       if no column has a header then the list will not
                                       display a header.
                                     *)
        width           : INTEGER;(* -1 = autosize, the units are screen pixels. *)
        align           : TextAlignment;
        content         : ColumnContentTypes;
        sortable        : BOOLEAN;(* the list is sortable on this column.
                                     also, if ClientCreateData.headerSortButtons is
                                     TRUE then the user can click on the column header
                                     to select the column for sorting and/or change
                                     the order order between ascending and descending.
                                  *)
        END;

    SortDirection       = (SortAscending, SortDescending);

    ListClientSortCompareProc = PROCEDURE((*item1:*) ADDRESS,
                                          (*item2:*) ADDRESS,
                                          (*column:*) CARDINAL,
                                          (*data :*) ADDRESS) : INTEGER;
    (* return < 0 if item1 < item2
       return = 0 ite item1 = item2
       return > 0 if item1 > item2
       item1 and item2 are the (.userData) items associateed with the list rows
           to be sorted. while sorting the list is not an a state that you can use
           various list API calls.
       column is the column being sorted.
       data = arbitrary data (.sortCompareData)
    *)
    ClientCreateData =(* used with CreateWindow. *)
        RECORD
        CASE : ClientTypes OF
        ListClient:
            numColumns          : CARDINAL;
            sortColumn          : INTEGER;(* if < 0, then no sort column. *)
            singleSelect        : BOOLEAN;
            headerSortButtons   : BOOLEAN;(* if TRUE then the header titles act like
                                             a button allowing the user select the
                                             sort column and toggle the sort mode between
                                             ascending and descending.
                                          *)
            listReturnKeys      : BOOLEAN;(* if TRUE the window procedure will receive
                                             the WSM_KEY message. see the WSM_KEY
                                             message for futher information.
                                          *)
            sortCompareProc     : ListClientSortCompareProc;
                                  (* the default compare procedure compares on the text
                                     in the sort column.
                                  *)
            sortCompareData     : ADDRESS;
            sortDirection       : SortDirection;
            imageList           : ImageListHandle;
            <*IF StonyBrook THEN*>
            columnInfo          : POINTER TO ARRAY [0..0] OF ClientColumnInfo;
            <*ELSIF p1 THEN*>
            columnInfo          : POINTER TO ARRAY [0..31] OF ClientColumnInfo;
            <*ELSE*>
                fix me
            <*END*>
        |
        TreeClient:
            treeLines           : BOOLEAN;(*lines connecting the tree nodes.
                                            some operating systems may not support
                                            treeLines = TRUE.
                                          *)
            treeReturnKeys      : BOOLEAN;(* if TRUE the window procedure will receive
                                             the WSM_KEY message. see the WSM_KEY
                                             message for futher information.
                                          *)
            CASE treeFolders    : BOOLEAN OF(*display image for open/closed state*)
            TRUE:
                folderClosedImage,
                folderOpenImage     : ARRAY [0..31] OF CHAR;
                                      (* defaults, "", are an open and closed folder.
                                         Win32
                                             Bitmap or Icon resource.
                                         Mac
                                             'icns' resource.
                                      *)

                folderMaskColor     : ColorValue;
                   (*
                     ignored if the default images are used.

                     this is the color in the bitmap that is to be "transparent",
                     having the same color as the background.
                     The loaded bitmaps will be altered to make this so.
                     if the transparent color does not exist in a bitmap then the bitmap
                     is loaded unaltered without error.
                     if the bitmap resource already has transparency information then
                     this value is ignored. in this case use the value TransparentColor
                     *)
            |
            FALSE:
            END;
        |
        TabClient:
            tabPos              : TabPosition;
            multiLineTabs       : BOOLEAN;(* this attribute is optional behavior.
                                             if the underlying system cannot support
                                             multi-line tabs then this option is
                                             ignored.*)
        |
        SplitterClient:
            splitHorizontal     : BOOLEAN;(*FALSE means split vertical*)
            splitPos            : CARDINAL;(*percent or pixels*)
            splitPosPercent     : BOOLEAN;
        |
        DrawClient:
        |
        FormClient:
        END;
        END;
    ClientCreateDataPointer     = POINTER TO ClientCreateData;

    ControlTypes = (CheckBox,
                    RadioButton,
                    PushButton,
                    ToggleButton,
                    SpinButton,
                    ListBox,
                    DropDownList,
                    ComboBox,
                    TextLabel,
                    TextEdit,

                    GroupBox,
                    MultiPage);
    (* these should be obvious.

       the GroupBox and MultiPage controls are "container" controls. that is they
       have "child" controls which are contained within their boundaries.

       MultiPage is a tabbed multiple page control.
       each page in a MultiPage control can contain other controls.
    *)

    WinShellMsg         = (
                           WSM_CREATE,
                           WSM_CLOSE,
                           WSM_SIZE,
                           WSM_GAINFOCUS,
                           WSM_LOSEFOCUS,
                           WSM_TIMER,
                           WSM_USER,

                           (* ToplevelWindow only *)
                           WSM_POSITIONCHANGED,
                           WSM_ACTIVATEAPP,
                           WSM_DEACTIVATEAPP,
                           WSM_TERMINATEAPP,

                           (* ToplevelWindow + "Mdi" tab children *)
                           WSM_MENU,
                           WSM_MENUSELECT,
                           WSM_MENUSTART,
                           WSM_MENUEND,

                           (* TreeClient and ListClient *)
                           WSM_SELECTION_CHANGED,
                           WSM_SELECTION_DOUBLECLICK,
                           WSM_SELECTION_ENTERKEY,

                           (* DrawClient
                              TreeClient and ListClient
                                for these clients this message is supplied so you can
                                perform text matching and selection.
                                you should let the OS handle normal keyboard operation
                                except in the above stated case.
                                your window procedure should return DEFAULT_HANDLE for
                                this message unless you fully handle the key, otherwise
                                the system keyboard handler will not be executed.
                                If you handle the key then return USER_HANDLE.
                           *)
                           WSM_KEY,

                           (* DrawClient *)
                           WSM_MOUSE,
                           WSM_PAINT,
                           WSM_SCROLL,

                           (* TabClient *)
                           WSM_TAB_ACTIVE,

                           (* SplitterClient *)
                           WSM_SPLIT_CHANGED,

                           (* TreeClient *)
                           WSM_TREE_EXPAND,
                           WSM_TREE_COLLAPSE,

                           (* ListClient *)
                           WSM_LIST_COLUMN_WIDTH_CHANGED,
                           WSM_LIST_SORTED,

                           (* FormClient. control notifications *)
                           WSM_NOTIFY
                          );

(******************** Message Definitions ************************************
    WSM_CREATE          this window has been created, not yet shown.
                        you may use various API calls on the window at this point.

    WSM_GAINFOCUS       this window has gained the input focus

    WSM_LOSEFOCUS       this window has lost the input focus

    WSM_CLOSE           this window hasbeen or may be closed
        closeMode =  the close "mode"
                CM_REQUEST = you are being asked if you will close the window
                    RETURN OkayToClose
                        you will then later get a TWM_CLOSE with a mode of
                        CM_DICTATE
                    RETURN NotOkayToClose
                        at which point no further close action will take place
                        and the window will remain open.
                CM_DICTATE = you *ARE* closing
                        the return value is ignored in this case

    WSM_SIZE            the window *HAS* been resized
        sizeType = The type of sizing operation
        width = the new width
        height = the new height
        wasMinimized = TRUE if the window previous size was minimized.
                       sizeType defines the new window size.
                       if you want to detect a transition from minimized to
                       normal/maximized then look at this field.

    WSM_POSITIONCHANGED         the window has been moved on screen
        windowPos       = The window position

    WSM_STARTMENU       the user has opened a menu
        you should use this to check/uncheck, activate/disable any menu items
        as necessary here. You do not know which menu was opened so you
        should just do all menus in the menu hierarchy of the window.

    WSM_MENU            a menu item has been selected
        menuId = the menu resource id number for the menu item

    WSM_MENUSELECT      a menu is highlighted
        menuId = the menu resource id number for the menu item
                 Typically this is used if a program has a status line
                 and you want to display simple single line help
                 descriptions of each menu item.

    WSM_ENDMENU         the user has exited the menu system
        If you were using MENUSELECT to display quick help you can use this
        to restore the status line to its proper state.

    WSM_TIMER           the specified timer duration has elapsed
        timerId = identifies which timer has elapsed

    WSM_USER
        userId = user defined value to identify the user message type
        userData =  if not used should be NIL
                    otherwise generally used to
                    pass a pointer to some data

    WSM_MOUSE           this window received a mouse event
        m_pos = Window Coordinates of click
        m_button = Which button the event is for
        m_event = the type of event
        m_state = the state of various other keys at the time of the mouse event
        m_wheel = the mouse wheel movement. positive is forward towards the front
                of the mouse. This value is scroll increments.
                1 = one scroll increment

    WSM_KEY             this window received keyboard input
        k_ch = character keystroke if not special
        k_state = various extended keys when not a normal ASCII character
        k_special = the various special keys. If NOTSPECIAL then
                  ch contains the ANSI character
        k_count = The key repeat count. Normally 1.

    WSM_PAINT   a region of this window needs to be repainted.
                the text caret, if any, is automatically hidden and
                restored around this message.
        paintRect = rectangle of region that needs to be painted.
        paintDraw = a drawable available to use for painting.
                    the default context will be selectd into the Drawable if
                    a default context was setup. otherwise this Drawable does
                    not have any DrawContext associated with it. you must
                    setup a DrawContext for the drawable before you paint.
        paintContext = the default draw context. can be NIL if you did not setup a
                       default context.

    WSM_SCROLL          the window has been scrolled
        dir = indicates direction to scroll
        class = the amount to scroll
        absOffs = absolute scroll position within the scroll range

    WSM_ACTIVATEAPP     the application is now the foreground application the
                        user is using.
    WSM_DEACTIVATEAPP   the application is no longer the foreground application the
                        user is using.

                        these two messages is simulated on GTK systems.

                        if no window in the WinShell "world" has the focus for a
                        certain timeout and then a window does gain focus,
                        then this is assumed to be a situation where the user had
                        moved to and used some other application and has just
                        switched to "this" applicaton which WinShell controls.
                        a ACTIVATEAPP message is sent in this circumstance.

                        for DEACTIVATEAPP a message is sent when a window has lost
                        focus and a timeout has occured and no window currently has
                        focus.

                        if this simuation is not accurate enough then you should
                        avoid these messages in portable applications.

    WSM_TERMINATEAPP    the user or system has requested the application be terminated
                        Win32
                            this message comes from the WM_QUERYENDSESSION message.
                            If you return DEFAULT_HANDLE the application will be
                            terminated, otherwise whatever action your message
                            handler took is the net effect.
                        GTK+
                            there is no source for the message.
                        Mac
                            this message comes from the application Quit menu
                            item which is on the application menu.
                            If you return DEFAULT_HANDLE the application will be
                            terminated, otherwise whatever action your message
                            handler took is the net effect.

    WSM_TABACTIVE     this Tab child window is the foreground Tab child window.

    WSM_NOTIFY          messages related sent by controls of a FormClient.

    WSM_SPLIT_CHANGED   the window split position has changed.

    WSM_TREE_EXPAND     the specified tree node has been expanded.
    WSM_TREE_COLLAPSE   the specified tree node has been collapsed

    WSM_LIST_COLUMN_WIDTH_CHANGED       the user has changed the size of the specified
                                        list column.

    WSM_LIST_SORTED     the list has been sorted. this happens when
                        a) new data is inserted into the list
                        b) ListClientSetSortColumn is called
                        c) when the user changes the sort column or sort order
*****************************************************************************)

    NotifyMessage       = (
                           NM_Clicked,(*PushButton,CheckBox,RadioButton*)
                           NM_DoubleClicked,(*ListBox*)
                           NM_SelectionChanged,(*DropDownList,ListBox,ComboBox*)
                           NM_ValueChanged,(*TextEdit,ComboBox,SpinButton*)
                           NM_GainFocus,
                           NM_LoseFocus
                          );

    ResponseType        = (
                           USER_HANDLE, (* you handled the message *)
                           DEFAULT_HANDLE, (* use default message processing *)
                           OkayToClose,(* see WSM_CLOSE *)
                           NotOkayToClose(* see WSM_CLOSE *)
                          );

    WinAttr             = (
                           WA_VISIBLE,(* window is visible.
                                         only applies to ToplevelWindow and
                                         to children of a TabClient window.
                                      *)

                           WA_TITLE,(* has a caption title bar.
                                       only applies to ToplevelWindow. *)
                           WA_SYSMENU,(* has system menu in caption.
                                         only applies to ToplevelWindow. *)
                           WA_MINIMIZEBOX,(* has minimize button in caption.
                                             only applies to ToplevelWindow.
                                          *)
                           WA_MAXIMIZEBOX,(* has maximize button in caption.
                                             only applies to ToplevelWindow.
                                          *)
                           WA_RESIZABLE,(* can be sized by the user.
                                           only applies to ToplevelWindow. *)
                           WA_TOPMOST,(*window will maintain a topmost position.
                                        only applies to ToplevelWindow.
                                        Windows has native support for this.
                                        On GTK systems this is simulated, therefore
                                            be carefull using this. if two topmost
                                            windows overlap they will fight each other
                                            to stay on top and they will endlessly
                                            raise themselve over the other.
                                            best to stick with one topmost window.
                                      *)
                           WA_STATUSLINE,(* has a status line.
                                            only applies to ToplevelWindow. *)

                           WA_HSCROLL,(* has/can have horizontal scroll bar.
                                         only applies to DrawClient. *)
                           WA_VSCROLL,(* has/can have vertical scroll bar.
                                         only applies to DrawClient.
                                      *)
                           WA_HSCROLLTRACK,(* receive scroll messages while
                                              the user is dragging the scroll bar thumb.
                                               only applies to DrawClient. *)
                           WA_VSCROLLTRACK,(* receive scroll messages while
                                              the user is dragging the scroll bar thumb.
                                              only applies to DrawClient. *)

                           WA_SPLIT_POS2(* if set, bottom/right splitter pane.
                                           otherwise top/left.
                                           ignored unless the window is a child of a
                                           SplitterClient.
                                         *)
                          );
    WinAttrSet          = SET OF WinAttr;

    CloseModes          = (CM_REQUEST, CM_DICTATE);(* see WSM_CLOSE *)

    ScrollDirection     = (DIR_UP, DIR_DOWN, DIR_LEFT, DIR_RIGHT); (* obvious *)

    ScrollClass         = (
                           SCROLL_LINE,(* scroll by lines *)
                           SCROLL_PAGE,(* scroll by pages *)
                           SCROLL_ABSOLUTE,(* set to absolute scroll position within
                                              the scroll range *)
                           SCROLL_EXTREME(* position to the extreme edges of the
                                            scroll range. ScrollDirection
                                            determines which edge is scrolled to *)
                          );

    ScrollRange         = INTEGER;

    SizeType    = (
                   SizeNormal,(* normal window size. no minimize or maximize *)
                   SizeMinimized,(* window is minimized *)
                   SizeMaximized(* window is maximized *)
                  );

    SpecialKeys = (
                   KEY_NOTSPECIAL,(* normal key/character *)
                   KEY_PAGEUP, KEY_PAGEDOWN, KEY_HOME, KEY_END,
                   KEY_RIGHTARROW, KEY_LEFTARROW, KEY_UPARROW, KEY_DOWNARROW,
                   KEY_INSERT, KEY_DELETE,
                   KEY_MENU,(*context menu key.
                              not all keyboards have this.
                              not all operating systems support such a thing*)
                   KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6,
                   KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11, KEY_F12
                  );

    KeyStateType = (
                    KS_SHIFT,
                    KS_CONTROL,
                    KS_ALT(*alt/option on the Mac*)
                   );
    KeyStateSet  = SET OF KeyStateType;

    SystemColors = (
                    SC_WINDOW_BACKGROUND,
                    SC_HIGHLIGHT,
                    SC_HIGHLIGHTTEXT,
                    SC_GRAYTEXT,
                    SC_BUTTON_FACE
                   );

CONST
    (* some useful predefined window attributes *)

    NormalWindow        = WinAttrSet{WA_VISIBLE,
                                     WA_TITLE,
                                     WA_RESIZABLE,
                                     WA_SYSMENU,
                                     WA_MINIMIZEBOX,
                                     WA_MAXIMIZEBOX
                                    };

    NormalChildWindow   = WinAttrSet{WA_VISIBLE};

    AddStatusLine       = WinAttrSet{WA_STATUSLINE};
    AddSplitPos2        = WinAttrSet{WA_SPLIT_POS2};

    (* only applicable when the client is a DrawClient *)
    AddVScrollBar       = WinAttrSet{WA_VSCROLL};
    AddHScrollBar       = WinAttrSet{WA_HSCROLL};
    AddScrollBars       = AddVScrollBar + AddHScrollBar;
    AddScrollTrack      = WinAttrSet{WA_HSCROLLTRACK, WA_VSCROLLTRACK};

TYPE
    MouseButton         = (LeftButton, MiddleButton, RightButton, NoButton);
    MouseEventType      = (ButtonDown, ButtonUp,
                           ButtonDouble,
                           MouseMove, MouseWheel);
                           (* ButtonDouble is a "software" mouse event.
                              You always receive the hardware
                              mouse Down and Up events.
                              You always receive an Up for every Down.
                              You will never receive an Up without a preceeding
                              Down.
                            *)

    MouseStateType      = (
                           MS_SHIFT,(* shift key was down *)
                           MS_CONTROL,(* control key was down *)
                           MS_ALT,(*alt/option key was down. not Windows*)
                           MS_LEFTBUTTON,(* is pressed *)
                           MS_RIGHTBUTTON,(* is pressed *)
                           MS_MIDDLEBUTTON(* is pressed *)
                          );
    MouseStateSet       = SET OF MouseStateType;

    COORDINATE  = INTEGER;

    wsPOINT =
        RECORD
        x        : COORDINATE;
        y        : COORDINATE;
        END;

    wsRECT =
        RECORD
        x1, y1   : COORDINATE;(*upper left*)
        x2, y2   : COORDINATE;(*lower right*)
        END;

    ClipboardFormat     = (CLIPBOARD_ASCII, CLIPBOARD_UNICODE);

    HelpCommand         = (
                           HelpTopic,(* open help to a specific topic *)
                           HelpContents(*Win32 only, open help in table of contents *)
                          );

    FontWeights         = (FwLight, FwNormal, FwDemiBold, FwBold, FwHeavy);

    CharacterSets       = (
                           LATIN1_CHARSET,(*ansi, iso*)
                           LATIN2_CHARSET,(*latin + eastern europe*)
                           SYMBOL_CHARSET,
                           ASCII_CHARSET,
                           DEFAULT_CHARSET
                          );
    FontInfo            =
        RECORD
        height          : INTEGER;(* positive = tenths of a point.
                                                100 = 10.0 points
                                                105 = 10.5 points.
                                     negative = device pixels
                                  *)
        italic          : BOOLEAN;
        fixedPitch      : BOOLEAN;(* if TRUE then only fixed pitch *)
                                  (* if FALSE then any pitch, including fixed *)
        weight          : FontWeights;
        charSet         : CharacterSets;
        name            : ARRAY [0..63] OF CHAR;(* font family name.
                                                   GTK
                                                     may also optionally include
                                                     the font foundary in the name.
                                                     the foundary and font family name
                                                     are separated by the '-' character.
                                                *)
        END;

    TextMetrics         =
        RECORD
        ascent          : CARDINAL;(*maximum ascent*)
        descent         : CARDINAL;(*maximum descent*)
        height          : CARDINAL;(*the maximum height of the font*)
                                   (*this is max ascent + max decent *)
        aveCharWidth    : CARDINAL;(*average character width.
                                     for fixed pitch fonts this is the
                                     character width. *)
        externalLeading : CARDINAL;(*extra spacing not in font,
                                     but specified by the font designer *)
        END;

    TextDrawOrigin      = (
                           OriginBaseLeft,
                           OriginTopLeft,
                           OriginBaseCenter,
                           OriginTopCenter
                          );
                          (*
                             BaseLeft = the x origin is the left side of the
                                            first character.
                                        the y origin is on the font
                                            baseline.
                             TopLeft = the x origin is the left side of the
                                            first character.
                                       the y origin is at the top of the
                                       font. The is basically above the
                                       baseline by the ascender amount of
                                       the string.
                             BaseCenter = the x origin is the middle of
                                          the string in device pixels.
                                        the y origin is on the font
                                            baseline.
                             TopCenter = the x origin is the middle of
                                          the string in device pixels.
                                       the y origin is at the top of the
                                       font. The is basically above the
                                       baseline by the ascender amount of
                                       the string.
                          *)

    LineStyles       = (SolidLine, DashLine, DotLine, DashDotLine, DashDotDotLine);
    JoinStyles       = (JoinBevel, JoinMiter, JoinRound);
    EndCaps          = (
                        EndCapFlat,
                        EndCapSquare,(* the line entends beyond the line end
                                        points by have the line width.*)
                        EndCapRound(* the line will extend beyond the line
                                      end points to draw the rounded end. *)
                       );

    DrawFunctions       = (
                           DrawFuncCopy,(* result = source color *)
                           DrawFuncInvert,(* result = inverse of dest color *)
                           DrawFuncXor(* result = source color XOR dest color *)
                          );

    PixelInterpolation  = (
                           InterpLowQuality,(*fast*)
                           InterpMediumQuality,
                           InterpHighQuality(*slow*)
                          );

    DrawContextValues   =
        RECORD
        foreground              : ColorValue;
        background              : ColorValue;
        font                    : FontHandle;
        textExtraSpacing        : INTEGER;
        textOrigin              : TextDrawOrigin;
        lineWidth               : CARDINAL;
        lineStyle               : LineStyles;
        joinStyle               : JoinStyles;
        endCap                  : EndCaps;
        drawFunc                : DrawFunctions;
        END;

CONST
    DrawContextDefaults =
                DrawContextValues{0,(*foreground (black) *)
                                  0FFFFFFh,(*background (white) *)
                                  NIL_FontHandle,(*font*)
                                  0,(*extra spacing*)
                                  OriginTopLeft,
                                  1,(*line width*)
                                  SolidLine,
                                  JoinBevel,
                                  EndCapFlat,
                                  DrawFuncCopy
                                 };

TYPE
    DrawTextOptions     = (DT_CLIPPED, DT_OPAQUE);
    DrawTextOptionSet   = SET OF DrawTextOptions;

CONST
    DrawTextOpaque      = DrawTextOptionSet{DT_OPAQUE};
    DrawTextClipped     = DrawTextOptionSet{DT_CLIPPED};

TYPE
    CursorTypes         = (
                           LeftArrowCursor,(* arrow pointing left, default *)
                           RightArrowCursor,(* arrow pointing right *)
                           WaitCursor,(* an hourglass or similar *)
                           TextCursor,(* standard text cursor *)
                           CrossHairCursor(*just like it sounds*)
                          );

    CaretTypes          = ((* caret shapes *)
                           CtVerticalBar,(* thin vertical bar*)
                           CtHorizontalBar,(* thin horizontal bar*)
                           CtHalfBlock,
                           CtFullBlock
                          );

    Beeps               = (NormalBeep, QuestionBeep, WarningBeep, ErrorBeep);
                          (* some systems may not support different user defined
                             sounds. in this case all of these "beeps" will generate
                             the same sound, probably a simple beep.
                          *)

    DisplayModes        = (
                           DisplayNormal, (* will activate window *)
                                          (* make it visible *)
                                          (* reverses minimized or maximized *)
                           DisplayVisible,(* makes window visible *)
                                          (* will not activate window *)
                           DisplayHidden,(* hides window *)
                                         (* active window changes *)
                           DisplayMinimized,(* minimizes window *)
                                            (* does not change active window *)
                           DisplayMaximized(* will activate window *)
                                           (* maximizes window *)
                          );

    WindowDisplayInfo =
        RECORD
        x       : COORDINATE;(* upper left corner *)
        y       : COORDINATE;(* upper left corner *)
        width   : CARDINAL;
        height  : CARDINAL;
        mode    : DisplayModes;
        END;

    ScreenMetrics =
        RECORD
        xSize,
        ySize           : CARDINAL;(* width and height in pixels *)
        colors          : CARDINAL;(* number of simultaneous colors supported *)
        xDpi,
        yDpi            : CARDINAL(* display resolution. dots per inch *)
        (*workArea        : wsRECT;(* working area of screen.
                                    subtracts the area taken up by the desktop
                                    taskbar.
                                 *)*)
        END;

    WindowPositions     = (CenterOnScreen, CenterOnParent);

    MessageRec          =
    RECORD
        CASE msg : WinShellMsg OF
        WSM_GAINFOCUS, WSM_LOSEFOCUS,
        WSM_MENUSTART, WSM_MENUEND,
        WSM_ACTIVATEAPP, WSM_DEACTIVATEAPP, WSM_TERMINATEAPP,
        WSM_TAB_ACTIVE,
        WSM_SELECTION_CHANGED, WSM_SELECTION_DOUBLECLICK, WSM_SELECTION_ENTERKEY,
        WSM_LIST_SORTED:
            (* no data fields for these *)
        |
        WSM_CREATE:
            createParam         : ADDRESS;
        |
        WSM_MOUSE:
            m_button            : MouseButton;
            m_event             : MouseEventType;
            m_pos               : wsPOINT;
            m_wheel             : INTEGER;
            m_state             : MouseStateSet;
        |
        WSM_KEY:
            k_ch                : CHAR;
            k_special           : SpecialKeys;
            k_count             : CARDINAL;
            k_state             : KeyStateSet;
        |
        WSM_CLOSE:
            closeMode           : CloseModes;
        |
        WSM_PAINT:
            paintRect           : wsRECT;
            paintDraw           : Drawable;
            paintContext        : DrawContext;
        |
        WSM_SIZE:
            sizeType            : SizeType;
            width               : COORDINATE;
            height              : COORDINATE;
            wasMinimized        : BOOLEAN;
        |
        WSM_POSITIONCHANGED:
            windowPos           : wsPOINT;
        |
        WSM_SCROLL:
            scrollDir           : ScrollDirection;
            scrollClass         : ScrollClass;
            scrollPos           : ScrollRange;
        |
        WSM_MENUSELECT,
        WSM_MENU:
            menuId              : CARDINAL;
        |
        WSM_TIMER:
            timerId             : CARDINAL;
        |
        WSM_USER:
            userId              : CARDINAL;
            userData            : ADDRESS;
        |
        WSM_NOTIFY:
            notify              : NotifyMessage;
            ctrlId              : CARDINAL;
                                  (* the control id number which generated the
                                     notification. control notifications are
                                     received by the FormClient window.
                                  *)
        |
        WSM_TREE_EXPAND,
        WSM_TREE_COLLAPSE:
            treeNode            : TreeClientNode;
        |
        WSM_LIST_COLUMN_WIDTH_CHANGED:
            listColumn          : CARDINAL;
            listColumnWidth     : CARDINAL;
        |
        WSM_SPLIT_CHANGED:
            splitPosPixels      : CARDINAL;
            splitPosPercent     : CARDINAL;
        END;
    END;

    (* Form Units
       these coordinate units are based upon the font used in displaying the control(s).
       in this way the relative position and sizes of the controls grow/shrink as the
       size of the font changes.
       X dimension. 4 form units = the average character width of the font.
       Y dimension. 8 form units = the font height.

       So a control that is of size (width=16, height=8) is approximatly four characters
       wide and the height of the font.
       Generally, you do not want a control exactly the vertical size of the font.
       Many times a vertical height of 12 is good.
       Since with proportional fonts we are using the average character width to size
       the X dimension you should always pad the horizontal width by some percentage.
       Therefore if you want your control to be big enough for 10 characters this would
       mean a size of 40 plus some amount of padding, say 10-20%.
    *)

    ControlColumnInfo =
        RECORD
        header  : StringData;(*can be NIL, which means no header text *)
        width   : INTEGER;(* -1 = autosize,
                             for a FormClient controls the units are form units.
                             otherwise the units are pixels.
                          *)
        align   : TextAlignment;
        END;

    ControlProperties =
    RECORD
        idNum           : CARDINAL;(* the numeric value to identify the control.*)

        x, y            : COORDINATE;(* the coordinates of the control window.
                                      the corrdinates are relative to the
                                      origin of the FormClient window.
                                      if the control is contained within a MultiPage
                                      or GroupBox control then the coordinates are
                                      relative to the MultiPage/GroupBox control.

                                      the cooridinates are in form Units.
                                   *)
        width,
        height          : CARDINAL;(* the width and height of the control.
                                      these sizes are in form Units.

                                      for the ComboBox control the height includes the
                                      size of the popup list which is displayed. when the
                                      list is not displayed the control is displayed
                                      much smaller.

                                      GTK+
                                         the height is ignored for ComboBox
                                         and DropDownList controls.
                                      Mac
                                         the height is ignored for the DropDownList
                                         control.

                                      for portability you should give an appropriate
                                      height for the DropDownList and ComboBox controls.
                                      GTK+ and the Mac may ignore the extra height but
                                      windows will use the height to size the popup
                                      list.
                                   *)

        tipTextPtr      : StringData;
        tipTextId       : INTEGER;(* if tipTextPtr <> NIL then that string is used
                                     for the tool tip.
                                     if tipTextId >= 0 then that string string resource
                                     is used for the tooltip text.
                                  *)

        visible         : BOOLEAN;
        enabled         : BOOLEAN;

        CASE controlType : ControlTypes OF
        RadioButton:
            rb_textPtr          : StringData;
            rb_textId           : INTEGER;(* if textPtr <> NIL then that string is used
                                             for the button.
                                             if textId >= 0 then that string resource
                                             is used for the button.
                                             textPtr has priority over textId.
                                          *)
            rb_group            : CARDINAL;(* this allows you to group radio buttons
                                              such that selecting one button will
                                              unselect all others in the group.
                                              0 = no group.
                                           *)
        |
        CheckBox:
            chk_textPtr         : StringData;
            chk_textId          : INTEGER;(* if textPtr <> NIL then that string is used
                                             for the button.
                                             if textId >= 0 then that string resource
                                             is used for the button.
                                             textPtr has priority over textId.
                                          *)
        |
        SpinButton:
            sb_low              : INTEGER;
            sb_high             : INTEGER;(* the valid numeric range of the control. *)
            sb_editable         : BOOLEAN;(*TRUE then user can enter a value in the
                                            edit field area.
                                            FALSE then only the control buttons can
                                            be use to alter the value.
                                            *)
        |
        ToggleButton, PushButton:
            b_textPtr           : StringData;
            b_textId            : INTEGER;(* if textPtr <> NIL then that string is used
                                             for the button.
                                             if textId >= 0 then that string resource
                                             is used for the button.
                                             textPtr has priority over textId.
                                          *)
            b_default           : BOOLEAN;(*only PushButton*)
            (* the cancel button of a form is a PushButton control with an id
               value of 2.
            *)
        |
        ListBox:
            lb_numColumns       : CARDINAL;
            <*IF StonyBrook THEN*>
            lb_columnInfo       : POINTER TO ARRAY [0..0] OF ControlColumnInfo;
            <*ELSIF p1 THEN*>
            lb_columnInfo       : POINTER TO ARRAY [0..31] OF ControlColumnInfo;
            <*ELSE*>
                fix me
            <*END*>
            (* can be NIL, in which case no column headers exist and all columns
               are autosized.
               otherwise lb_columnInfo *must* have entries for all columns.
            *)
            lb_multiSelect      : BOOLEAN;
        |
        ComboBox:
            cb_editLimit        : CARDINAL;(* 0 = operating system default limit.
                                                  otherwise the number of characters
                                                  that the user is allowed to enter.
                                           *)
        |
        TextLabel:
            tl_textPtr          : StringData;
            tl_textId           : INTEGER;(* if textPtr <> NIL then that string is used
                                             for the button.
                                             if textId >= 0 then that string resource
                                             is used for the button.
                                             textPtr has priority over textId.
                                          *)
            tl_align            : TextAlignment;
        |
        TextEdit:
            te_align            : TextAlignment;
            te_limit            : CARDINAL;(* 0 = operating system default limit.
                                                  otherwise the number of characters
                                                  that the user is allowed to enter.
                                           *)
            te_password         : BOOLEAN;(*the text shown/entered will be obscured*)
            te_multiLine        : BOOLEAN;
            te_horizScroll      : BOOLEAN;(*if multi line, has horiz scroll bar*)
            te_vertScroll       : BOOLEAN;(*if multi line, has vert scroll bar*)
        |
        GroupBox:
            grp_textPtr         : StringData;
            grp_textId          : INTEGER;(* if textPtr <> NIL then that string is used
                                             for the button.
                                             if textId >= 0 then that string resource
                                             is used for the button.
                                             textPtr has priority over textId.
                                          *)
            grp_numControls     : CARDINAL;
            grp_controls        : ADDRESS;(*ControlPropertyArrayPtr*)
                                  (* we have to be untyped here because we need a
                                     pointer to an array of the record we are
                                     currently declaring.
                                     an array of pointers to records would be an ugly
                                     solution.
                                  *)
        |
        MultiPage:
            mp_numPages         : CARDINAL;
            mp_pageInfo         : ADDRESS;(*ControlPageInfoArray*)
                                  (*we have to be untyped here because we have two
                                    records that reference each other.
                                    an array of pointers to records would be an ugly
                                    solution.
                                  *)
        ELSE
        END;
    END;

    <*IF StonyBrook THEN*>
    ControlPropertyArrayPtr     = POINTER TO ARRAY [0..0] OF ControlProperties;
    <*ELSIF p1 THEN*>
    ControlPropertyArrayPtr     = POINTER TO ARRAY [0..127] OF ControlProperties;
    <*ELSE*>
        fix me
    <*END*>

    ControlPageInfo =
        RECORD
        label           : StringData;
        numControls     : CARDINAL;
        controls        : ControlPropertyArrayPtr;
        END;

    <*IF StonyBrook THEN*>
    ControlPageInfoArray        = POINTER TO ARRAY [0..0] OF ControlPageInfo;
    <*ELSIF p1 THEN*>
    ControlPageInfoArray        = POINTER TO ARRAY [0..31] OF ControlPageInfo;
    <*ELSE*>
        fix me
    <*END*>

TYPE
    NewControlProc              = PROCEDURE(Window,
                                            VAR INOUT ControlProperties);
    ControlPropertiesProc       = PROCEDURE(Window,
                                            VAR INOUT ControlProperties) : BOOLEAN;
    ControlEndEditProc          = PROCEDURE(Window);

CONST
    CtrlMenuProperties  = 32000;(*call the properties procedure*)
    CtrlMenuDelete      = 32001;(*delete the selected control*)
    CtrlMenuFormTitle   = 32002;(*edit the form title,
                                only ToplevelWindow forms support this.
                                this is editied simular to a normal control.
                                it is identitied as control with an
                                id number of MAX(CARDINAL), and the control type
                                is TextEdit.
                                the tipTextPtr field is used for the text.
                                no other fields are defined.
                                *)

    CtrlMenuAlignLeft   = 32010;(*align to left of primary control*)
    CtrlMenuAlignCenter = 32011;(*align to center of primary control*)
    CtrlMenuAlignRight  = 32012;(*align to right of primary control*)
    CtrlMenuAlignTop    = 32013;(*align to top of primary control*)
    CtrlMenuAlignMiddle = 32014;(*align to middle of primary control*)
    CtrlMenuAlignBottom = 32015;(*align to bottom of primary control*)

    CtrlMenuSizeWidth   = 32020;(*size controls to width of primary*)
    CtrlMenuSizeHeight  = 32021;(*size controls to height of primary*)
    CtrlMenuSizeBoth    = 32022;(*size controls to width and height of primary*)

    CtrlMenuOrderMoveUp         = 32030;(*move control up one place in tab order*)
    CtrlMenuOrderMoveDown       = 32031;(*move control down one place in tab order*)
    CtrlMenuOrderMoveToTop      = 32032;(*move control to the top of the tab order*)
    CtrlMenuOrderMoveToBottom   = 32033;(*move control to the bottom of the tab order*)

    CtrlMenuGroup               = 32040;(*group radio buttons*)
    CtrlMenuUngroup             = 32041;(*ungroup radio buttons*)

    CtrlMenuMultiPageAdd        = 32050;
    CtrlMenuMultiPageDelete     = 32051;
    CtrlMenuMultiPageMoveLeft   = 32052;
    CtrlMenuMultiPageMoveRight  = 32053;

    CtrlMenuNewCheckBox         = 32060;(*creates a new control*)
    CtrlMenuNewRadioButton      = 32061;
    CtrlMenuNewPushButton       = 32062;
    CtrlMenuNewToggleButton     = 32063;
    CtrlMenuNewSpinButton       = 32064;
    CtrlMenuNewListBox          = 32065;
    CtrlMenuDropDownList        = 32066;
    CtrlMenuNewComboBox         = 32067;
    CtrlMenuNewTextLabel        = 32068;
    CtrlMenuNewTextEdit         = 32069;
    CtrlMenuNewGroupBox         = 32070;
    CtrlMenuNewMultiPage        = 32071;

    CtrlMenuExitFormEdit        = 32100;

CONST
    TOOLBAR_SEPARATOR           = MAX(CARDINAL);

TYPE
    StdToolbarBitmaps =
    ((* standard built-in bitmaps for toolbars *)
     TB_BMP_CUT,
     TB_BMP_COPY,
     TB_BMP_PASTE,
     TB_BMP_UNDO,
     TB_BMP_REDO,
     TB_BMP_DELETE,
     TB_BMP_FILENEW,
     TB_BMP_FILEOPEN,
     TB_BMP_FILESAVE,
     TB_BMP_PROPERTIES,
     TB_BMP_HELP,
     TB_BMP_FIND,
     TB_BMP_REPLACE,
     TB_BMP_PRINT
    );

    ToolbarButtonTypes  = (TbPushButton, TbToggleButton);

    BitmapResName       = ARRAY [0..31] OF CHAR;

    ToolbarButtonInfo =
        RECORD
        image           : ADDRESS;(* non user field, for internal WinShell use.
                                     should be initialized to NIL. *)
        imageType       : CARDINAL;(* non useer field, for internal WinShell use.
                                      initialize to zero. *)

        actionId        : CARDINAL;(* menu id number *)
        textId          : CARDINAL;(* button label string resource id number *)
        helpId          : CARDINAL;(* tooltip string resource id number *)
        type            : ToolbarButtonTypes;
        CASE stdButton : BOOLEAN OF
        FALSE:
            bmpResName  : BitmapResName;(*bitmap resource name
                                           Win32.
                                               Bitmap resource.
                                           Mac
                                               'cicn' resource.
                                         *)
        |
        TRUE:
            stdName     : StdToolbarBitmaps;
        END;
        END;

    WindowProcedure     = PROCEDURE(Window, MessageRec) : ResponseType;

    WindowNotification = (
                          WindowMinimized,
                          WindowMaximized,
                          WindowSized,
                          WindowMoved,
                          WindowClosed
                         );

    WindowNotifyProcedure = PROCEDURE((*w : *)Window,
                                      (*notify :*)WindowNotification,
                                      (*data : *)ADDRESS);
    (* this is the format of a window notification procedure.
       w = the window in question
       notify = the action that occured
       data = user data.
    *)

    DispatchStartupProc = PROCEDURE((*param :*) ADDRESS);

    IdleResults         = (ContinueIdle, SuspendIdle, TerminateIdle);
    IdleProcType        = PROCEDURE((*userdata*)ADDRESS,
                                    (*count*)CARDINAL) : IdleResults;
                        (* count is the number of times the idle procedure.
                           has been called in the current idle cycle.
                           userdata is arbitrary user data
                           *)

    HostSystem  = (Windows, GTK, Macintosh);

    ListClientInsertRec =
        RECORD
        insertPos       : INTEGER;(* -1 for append to list *)

        userData        : ADDRESS;(*user data associated with the inserted row *)

        numColumns      : CARDINAL;(* number of columns of data in the arrays *)
        textPtr         : ARRAY [0..31] OF StringData;
        textId          : ARRAY [0..31] OF INTEGER;
        bmpId           : ARRAY [0..31] OF CARDINAL;
        (* if you have more columns than supported by this record then you will
           have to use API calls to set the text.

           if textPtr <> NIL then that string is used.
           if textId >= 0 then that string string resource is used for the text.
           for a specific column textPtr can be NIL *and* textId = -1.
           in this case then nothing is done with the column.

           if the column content type allows a bitmap then you must setup the bmpId field.
           if bmpId > 0 then that bitmap is used. The id number is the image index
               in the image list associated with the ListClient.
           if bmpId = 0 then no image is set for the item.
        *)
        END;

    TreeClientInsertRec =
        RECORD
        parent          : TreeClientNode;(* NIL = the tree root is the parent,
                                            otherwise the parent is the tree
                                            node in which the new node will be
                                            inserted.
                                         *)
        sibling         : TreeClientNode;
        insertBefore    : BOOLEAN;(* the sibling within the parent node in which
                                      the new node is inserted in relation to.

                                      (sibling = NIL) AND insertBefore
                                          then insert at the head of the parents list.
                                      (sibling = NIL) AND (NOT insertBefore)
                                          then insert at the tail of the parents list.
                                      (sibling <> NIL) AND insertBefore
                                          the new node is inserted before the specified
                                          node.
                                      (sibling <> NIL) AND (NOT insertBefore)
                                          the new node is inserted after the specified
                                          node.
                                   *)
        userData        : ADDRESS;(*user data associated with the inserted node *)

        textPtr         : StringData;
        textId          : INTEGER;
        (* if textPtr <> NIL then that string is used.
           if textId >= 0 then that string string resource is used for the text.
        *)

        folder          : BOOLEAN;(* the inserted item may have children.
                                     folder nodes will display the folder open and
                                     closed bitmaps.
                                  *)
        END;

VAR
    MainWindow          : Window;
    (* this value is initialied with the first TopLevel window created.
       You may assign your own value to this.
       This value is used by DlgShell.GetDialogParent().
    *)

    StartupDisplayMode  : DisplayModes;(* the display mode the user
                                          requested the application be started in *)

    Host                : HostSystem;
    HostMajorVersion    : CARDINAL;(* Win32s = 3
                                      Windows95, Windows98 = 4
                                      Windows ME = ? 4
                                      WindowsCE = ?
                                      WindowsNT = 3, 4
                                      Windows2000/XP = 5

                                      GTK = 1
                                      Mac OS/X = 10
                                      *)
    HostMinorVersion    : CARDINAL;(* Win32s = 10 for 3.10
                                      Windows95 = 0 for 4.0
                                      Windows98 = 10 for 4.10
                                      WindowsME = ?
                                      WindowsCE = ?
                                      WindowsNT = 50 for 3.50
                                                  51 for 3.51
                                                  00 for 4.00
                                      Windows2000 = 00
                                      WindowsXP = 01

                                      GTK = 2
                                      Max OS/X = 0, 1 or 2.
                                      *)

    <*IF StonyBrook THEN*>
        %IF WIN32 %THEN
        WindowsNT           : BOOLEAN;
        WasSystemDialogBox  : BOOLEAN;
        %END
    <*END*>

    ScreenInfo          : ScreenMetrics;

<*IF StonyBrook THEN*>
    %IF DLL %THEN
    <*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
    %END
<*END*>

PROCEDURE AllocWinShellMem(VAR OUT addr : ADDRESS; amount : CARDINAL);
PROCEDURE ReallocWinShellMem(VAR INOUT addr : ADDRESS; amount : CARDINAL);
PROCEDURE DeallocWinShellMem(VAR INOUT addr : ADDRESS; amount : CARDINAL);
(* utility procedure which allocate memory from the heap this module uses.
   can be useful in FormClient, edit mode callback procedures.
*)

PROCEDURE CreateStringData(str : ARRAY OF CHAR) : StringData;
PROCEDURE DisposeStringData(strPtr : StringData);
PROCEDURE DuplicateStringData(strPtr : StringData) : StringData;
PROCEDURE StringDataLength(strPtr : StringData) : CARDINAL;
PROCEDURE AssignStringData(strPtr : StringData; VAR OUT str : ARRAY OF CHAR);
(* assign strPtr to str. strPtr is assumed to be null terminated *)

PROCEDURE SetResourceFile(name : ARRAY OF CHAR) : BOOLEAN;
PROCEDURE GetResourceFile(VAR OUT name : ARRAY OF CHAR);
(* for Win32 name = "" means the resources are in the executable,
  otherwise it is some DLL and a .dll extension is provided if not
  supplied.

  for Gtk it specifies the base path and name for various resource files.
  the various resource files are identified by file extension.
  .xml file contains menus, dialogs and accelerators
  .str file contains a string table
  .img file contains bitmaps
*)

PROCEDURE AddIdleProcedure(idle : IdleProcType; data : ADDRESS) : CARDINAL;
(* add an idle procedure to the system.
   for Windows, idle procedures are thread specific (unique per thread input queue).
   the return value identifies the idle procedure for removal.
   a return value of zero indicates failure.
   the idle procedure will be called when no messages are pending for the
   input thread.
   the idle procedure will be repeatedly called while no messages are being
   received and the idle procedure returns ContinueIdle.
   if it returns SuspendIdle then it will not be called until the next idle
   cycle. an idle cycle is the idle period between receiving messages.
   if it returns TerminateIdle the idle handler is removed from the system.
*)

PROCEDURE RemoveIdleProcedure(id : CARDINAL);
(* remove a previously installed idle procedure *)

PROCEDURE DispatchMessages(startup : DispatchStartupProc; param : ADDRESS) : CARDINAL;
PROCEDURE DispatchMessagesTemp() : CARDINAL;
(* these procedures receive and dispatch message to your window(s).

   any thread that has windows must have a message dispatch loop.
   a dispatch loop just loops forever sending messages to the appropriate
   window. A window is attached to a specific thread. this thread is the current thread
   at the time of window creation.

   message boxes and modal dialogs do not count as "windows" for this
   definition since they create their own temporary message dispatch loop.

   This procedure never returns until the message loop is terminated.
   A message dispatch loop is terminated with a call to
   TerminateDispatchMessages. The return value from this procedure is
   the value passed to TerminateDispatchMessages.

   you can create temporary dispatch loops, using DispatchMessagesTemp,
   in a thread that is already executing DispatchMessages.
   Remember that TerminateDispatchMessages only terminates the most recent call to
   DispatchMessages/DispatchMessagesTemp. Typically you would use a temp dispatch
   loop because you want to serialize execution in the application, but of course,
   you still want messages to be received and processed. RunWindowModalLoop might be
   more appropriate in many cases to serialize execution.

   returns MAX(CARDINAL) is an error occurs.

   you should to not create windows before DispatchMessages is called. Just put that
   code into a procedure and pass the procedure to DispatchMessages.

   startup.
   this parameter exists to allow the message dispatch loop to have been entered
   before you create an windows. on some underlying systems this might help or
   be necessary. DispatchMessages calls the start procedure after the dispatch
   loop has been initiated.
      GTK. this startup procedure parameter exists because it helps on GTK. some
           quirky things happen with window creation on GTK when the event loop
           has not been initiated. this is probably due to the window model as defined
           in this DEF is a bit different than GTK "normal" operation.
*)

PROCEDURE CheckMessages() : BOOLEAN;
(* many times you perform tasks that will take a reasonable amount of time
   so that the user interface will not become unresponsive you can call
   this procedure to dispatch any messages that are already sitting
   in the message queue. If no messages are available this procedure
   returns.
   If this function returns TRUE it means that the message loop has received
   a "terminate" message and the dispatch loop will be terminated.
*)

PROCEDURE TerminateDispatchMessages(code : CARDINAL);
(* this procedure terminates a previous call to DispatchMessages.
   code = an arbitrary value that DispatchMessages will return as
   its function result. You can use it as a result code
*)

PROCEDURE RunWindowModalLoop(w : Window) : CARDINAL;
(*
  w = a ToplevelWindow.

  this procedure runs the window in a modal loop, like a modal dialog.
  the procedure does not return until QuitWindowModalLoop is called.

  this procedure lets you use a FormClient, or any window, like a modal dialog.

  RETURNs MAX(CARDINAL) if an error occurs
  otherwise returns the code passed to QuitWindowModalLoop
*)

PROCEDURE QuitWindowModalLoop(w : Window; code : CARDINAL);
(* w = a window which is currently executing a modal loop via RunWindowModalLoop.
       causes RunWindowModalLoop to return the value 'code'.
*)

PROCEDURE InitClientCreateData(clientType : ClientTypes; VAR OUT data : ClientCreateData);
(* initializes the data record to the default settings.
   you should use this API call since future setup options might be added to the
   data record. any new fields will be initialized in such a manner so as to be
   compatible with previous versions.

  Defaults
      TabClient.
          tabPos = TabBottom
          multiLineTabs = FALSE
      SplitterClient
          splitHorizontal = FALSE
          splitPos = 50
          splitPosPercent = TRUE
      ListClient
          numColumns = 1
          singleSelect = TRUE
          column alignment = AlignLeft
          column width = -1 (autosize)
          column content = ColumnText
          headerSortButtons = FALSE
          listReturnKeys = FALSE
          sortColumn = -1
          compareProc = procedure which compares the text in the column.
          compareData = NIL
      TreeClient
          treeLines = FALSE
          treeFolders = TRUE
          treeReturnKeys = FALSE
          folderClosedBitmap = a 16x16 closed folder bitmap.
          folderOpenBitmap = a 16x16 open folder bitmap.
          folderMaskColor = Colors[TransparentColor]
*)

PROCEDURE CreateWindow(parent : Window;
                       name : ARRAY OF CHAR;
                       menu : ARRAY OF CHAR;
                       icon : ARRAY OF CHAR;
                       windowType : WindowTypes;
                       clientType : ClientTypes;
                       wndProc : WindowProcedure;
                       attribs : WinAttrSet;
                       x, y : COORDINATE;
                       width, height : COORDINATE;
                       clientCreateData : ClientCreateDataPointer;
                       createParam : ADDRESS) : Window;
(* create a new window
   parent = the parent window of this window. Can be NIL.
            A ChildWindow must have a parent window.

            Toplevel windows can have a parent and the exact meaning of this is
            somewhat operating system dependent. We call a Toplevel window with
            a parent an owned window.

            For Win32 owned windows are always displayed above the parent window.
            Owned windows are minimized when the parent is minimized.
            Owned windows do not show on the taskbar.

            For Gtk the parent is the window that is the leader
            in a window manager "group" of windows. Just what this means
            is dependent on the specific window manager in use.

            For Mac the owned windows are a part of a window group. Window groups
            are shown/hidden and collapsed/zoomed as a group. This is similar to
            the behavior in Windows

   name = the caption text of the window. if the window does not have a
          caption then this parameter is ignored. On Tab child windows
          the caption is the window selection tab.

   menu = the menu for the window. Can be "", which means no menu.

   icon = the icon associated with this window. Can be "".
           For Win32 you should have both 16x16 and 32x32 icons in the icon set.
           For Gtk this parameter is ignored.
           For Mac this parameter is ignored, at this time.

   windowType = the window type. child windows *must* have a parent window. the child
           window parent must be a "container" window. splitter and tab clients are
           containers. the child parent may itself be a child window.

   clientType = the window client type.

   wndProc = the window procedure

   attribs = the window attributes for the window
             for child windows whose parent is a SplitterClient window you specify
             the splitter pane where the child is to be placed by using the
             WA_SPLIT_POS2 attribute.

   x, y = the initial screen coordinates for the window to be displayed
          if a parameters is -1 then the operating system will choose
          a default location. these coordinates are relative to the
          origin to the screen.

          ignored for child windows.

   width, height = the initial size of the window when created.
                   if a parameter is -1 the operating system will
                   choose a default size.

                   ignored for child windows.

   clientCreateData = create data unique to a specific client type.
                      some clients have no unique creation data.
                      if NIL is passed then defaults are used.
                      if you do not pass NIL you should call
                      InitClientCreateData on your data record before setting/changing
                      the options you wish changed.
                      see InitClientCreateData comments.

   createParam = an arbitrary value you can use to pass information
                 to the window procedure of the window. this value is
                 passed in the WSM_CREATE message.

   For Tab child windows Ctrl+Tab (forward), Ctrl+Shift+Tab (backward) are accelerator
   keys to cycle through the various Tab child windows.

   returns the window handle if successfull, otherwise NIL
*)

PROCEDURE SetSplitPosition(w : Window; pos : CARDINAL; percent : BOOLEAN);
(*
  w can be a SplitterClient or Toplevel window whose client is a SplitterClient.

  set the splitter position as relative to the top/left edge of the
  splitter client size.

  if percent = TRUE the split value is interpreted as a percentage of the
      splitter client width.
  otherwise the value is in pixels
*)

PROCEDURE SetDefaultDrawContext(w : Window; context : DrawContext);
(* for DrawClient windows. sets the draw context setup by default when
   a WSM_PAINT messages is received and when NIL is passed to BeginPaint
   for a context value *)

PROCEDURE GetSplitPosition(w : Window; percent : BOOLEAN) : CARDINAL;
(*
  w can be a SplitterClient or Toplevel window whose client is a SplitterClient.
  if percent = TRUE then
      get the splitter position as a percentage relative to the top/left edge of the
      splitter client size.
  otherwise
      get the splitter position in pixels relative to the top/left edge of the
      splitter client size.
*)

PROCEDURE SplitWindow(w : Window;
                      wndProc : WindowProcedure;
                      splitY : BOOLEAN;
                      VAR OUT newChild : Window);
(*
  w can be a toplevel window with any client type, or any child window.
  if splitY = TRUE the the window will be split into a top and bottom halves.

  on return
  newChild is a child window with the same client type as w and has the window
      procedure of w.
  w has a clientType of SplitterClient.
      wndProc is the new window procedure for this window.

  w and newChild both have the same "window data"
  newChild keeps the notify procedures,
    w has notify procedures cleared.
*)

PROCEDURE UnsplitWindow(w : Window; keepChild : Window) : BOOLEAN;
(*
   w must have a client type of SplitterClient.
   the client type of w becomes that of "keepChild". keepChild must currently be a
   child of the splitter window.

  w keeps its "window data"
  w gets the notify procs of keepChild
*)

PROCEDURE SetTabPosition(w : Window; tabPos : TabPosition);
(* set the position of the tabs in a TabClient window.
   w must be an TabClient window, or a Toplevel whose client is a TabClient window.
   the default tab position is TabBottom.

   Win32
       Windows seems to have issues with changing between some tab positions.
       Changing between top and bottom works. Changing between left and right works.
       Changing left/right to/from top/bottom does not work.
   Mac
       You cannot change the tab position after creation.
*)

PROCEDURE CycleActiveTabChild(w : Window; direction : INTEGER);
(*
  w can be an TabClient or Toplevel window whose client is a tabClient.
  if direction > 0 then the next Tab child becomes the active window.
  if direction < 0 then the previous Tab child becomes the active window.

   Ctrl+Tab (forward), Ctrl+Shift+Tab (backward) are user accelerator
   keys to cycle through the various Tab child windows.
*)

PROCEDURE ConvertTabChildToTopLevel(w : Window) : BOOLEAN;
(* convert the TabChild window to a Toplevel window.
   if the Toplevel window has a toolbar and/or statusline the new
   toplevel window will create copies of these for itself.
*)

PROCEDURE AddWindowNotify(w : Window;
                          proc : WindowNotifyProcedure;
                          data : ADDRESS) : BOOLEAN;
(* the passed procedure "proc" will be called when the window "w"
   has one of the notify actions occur.
   "data" is aribtrary data you can have passed to the close procedure.
   you can have multiple notify procedures attached to a window.
   returns TRUE if the notify procedure was added.
*)

PROCEDURE RemoveWindowNotify(w : Window; proc : WindowNotifyProcedure);
(* reverses AddWindowNotify *)

PROCEDURE CloseWindow(w : Window; mode : CloseModes) : BOOLEAN;
(* close an existing window.
   mode = CM_REQUEST you are requesting that the window close.
          for example this can give a window a change to prompt for saving any
          unsaved changes and possibly aborting the close.
   mode = CM_DICTATE the window *WILL* be closed
   returns TRUE if the window is closing
*)

PROCEDURE CloseAllChildren(parent : Window; mode : CloseModes) : BOOLEAN;
(* the effect here is to call CloseWindow with the given close mode
   for all child windows of the given window.
   returns TRUE if all child windows were closed
*)

PROCEDURE DisplayTabChildNumber(w : Window; yes : BOOLEAN);
(*
  w must be an TabClient or a Toplevel window whose client is a TabClient window.
  yes = TRUE means that the Tab child titles will be prefixed with a number 0-9.
        This corresponds to the position of the child in the frame window.
        This can be used in conjunction with the GetIthTabChild API call.
        The 10th child and beyond will not have a number.
*)

PROCEDURE SetBackgroundAutoErase(w : Window; color : ColorValue);
(* for DrawClient windows.
   this will have the window automatically erase any region that
   needs to be painted with a background color before any paint
   message is sent.

   by default the window does not erase its background. the reason for this is because
   erasing a background and then painting  is a major cause of "flicker" in
   applications.

   if the color set is TransparentColor then the window will revert to not
   erasing its background before paint messages are sent.
*)

PROCEDURE IsWindow(w : Window) : BOOLEAN;
(* is the window handle passed in w a valid window handle
   for example a window might have been closed and a copy of the window
   handle an application had stored somewhere may no longer be valid
   retuns TRUE if the window handle is valid
*)

PROCEDURE GetWindowType(w : Window) : WindowTypes;
(* return the window type for the window *)

PROCEDURE GetClientType(w : Window) : ClientTypes;
(* return the client window type for the window *)

PROCEDURE GetWindowParent(w : Window) : Window;
(* return the parent window *)

PROCEDURE GetIthTabChild(w : Window; num : CARDINAL) : Window;
(* return the ith child in the list of child windows.
   the first child is number 0.
   child windows are ordered by the order of creation.
   hidden child windows are not considered by this procedure.
*)

PROCEDURE GetActiveTabChild(w : Window) : Window;
(*
  w can be an TabClient or Toplevel window whose client is a tabClient.
  the return value is the child window that is on top of all the
  other Tab child windows.
*)

PROCEDURE SetActiveTabChild(w : Window);
(*
  w must be an Tab child window.
  set w to be the active Tab child window. this is the child that
  is on top of all the other Tab child windows.
*)

PROCEDURE SetTabChildPosition(w : Window; index : CARDINAL);
(*
  w must be an Tab child window.
  set the position of the window in the child window selection tabs.
  0 = the "first" tab.
*)

PROCEDURE GetTabChildPosition(w : Window) : INTEGER;
(*
  w must be an Tab child window.
  get the position of the window in the child window selection tabs.
  0 = the "first" tab.
  -1 (< 0) = error, or the tab child is currently hidden.
*)

PROCEDURE CreateImageList(width, height : CARDINAL;
                          initialCount, growth : CARDINAL) : ImageListHandle;
(* create a new image list. the size of the individual images in the list is
   contained in the width and height parameters.
   The list is allocated enough space for initialCount number of images.
   The growth parameter determines the number of additional images beyond
   initialCount that the list may ultimately contain.

   images in a image list are identified by index order. the index order is the order
   that they are added to the list. index 0, signifies a blank image. in other words
   no image.
*)

PROCEDURE DestroyImageList(im : ImageListHandle);
(* dispose of an image list. the list should not be associated with any window. *)

PROCEDURE ImageListLoadImage(im : ImageListHandle;
                             resName : ARRAY OF CHAR;
                             bmp : BitmapHandle;
                             transparent : ColorValue) : INTEGER;
(* add an image to an image list.
   transparent is the color which should be considered transparent in the image.
   use Colors[TransparentColor] if you do not want to specify any transparency.
   if bmp <> NIL, then resName is ignored.
   if bmp = NIL, then resName specifies the resource image to load.
   if the resource image type has transparency information then transparent
   is ignored.
   returns -1 if an error occurs, otherwise the image index is returned.

   Resource images...
   Win32 and GTK+
       an image can be any supported bitmap image type.
       you can add multiple images from a single loaded image.
       the number of images added is inferred from the width of the image loaded.
       the returned index is the index of the first image added. the additional images
       will have consecutive indexes after the value returned.
   Mac
       an image can be any supported bitmap image type.
*)

PROCEDURE SetDisplayMode(w : Window; mode : DisplayModes);
(* set the display mode for the window identified by w *)

PROCEDURE GetDisplayMode(w : Window) : DisplayModes;
(* get the display mode for the window identified by w *)

PROCEDURE SetWindowEnable(w : Window; enabled : BOOLEAN);
(* enable/disable the window identified by w
   if w = NIL, then all ToplevelWindows will be affected.

   if enabled = TRUE then the window will be enabled, otherwise the window
   will be disabled
   A disabled window cannot receive any user interaction.

   the window maintains an enable count, therefore you must mirror your
   calls to enable and disable the window.
   e.g. two successive calls to disabled, must be followed by two successive calls
   to enabled before the window is actually enabled.
*)

PROCEDURE IsMinimized(w : Window) : BOOLEAN;
(* retuns TRUE if the window identified by w is currently minimized *)

PROCEDURE IsMaximized(w : Window) : BOOLEAN;
(* retuns TRUE if the window identified by w is currently maximized *)

PROCEDURE IsVisible(w : Window) : BOOLEAN;
(* retuns TRUE if the window identified by w is currently visible and not minimized *)

PROCEDURE ClientAreaIsClipped(w : Window) : BOOLEAN;
(* returns TRUE if the client area of the window identified by w is
   currently clipped by some other window.
   By clipped we mean that the entire client area is not visible.
*)

PROCEDURE BringWindowToTop(w : Window);
(* procedure does what it says; the currently focused window is not changed. *)

PROCEDURE GetForegroundWindow() : Window;
(* get the current window with input focus.
   if the focused window is not a window managed by this module
   the returned value will be NIL
*)

PROCEDURE SetForegroundWindow(w : Window);
(* makes the window the foreground window
   also makes the window have the keyboard input focus.

   depending on the underlying system this function may FAIL if the thread
   associated with the window is not the current foreground thread.
*)

PROCEDURE RepaintRect(w : Window; rect : wsRECT);
(* force the rectangle in rect to be repainted in the window identified by w *)
(* the repaint is queued, and not drawn immediately *)

PROCEDURE RepaintWindow(w : Window);
(* repaint the entire client window area.*)

PROCEDURE UpdateWindow(w : Window);
(* force any pending repaint messsages to be sent before this call returns
   only applicable to DrawClient windows.
*)

PROCEDURE GetClientSize(w : Window; VAR OUT width, height : COORDINATE);
(* get the size of the windows client area in screen coordinates *)

PROCEDURE SetClientSize(w : Window; width, height : COORDINATE);
(* set the size of the windows client area in screen coordinates
   the actual size of the window will likely be larger due to a caption,
   border, menus, scroll bars and other goodies
*)

PROCEDURE SetMinClientSize(w : Window; width, height : COORDINATE);
(* limit the window to a certain minimum client area size
   this does not effect the windows ability to be minimized.

   this call only supported for ToplevelWindows.
*)

PROCEDURE SetMaxClientSize(w : Window; width, height : COORDINATE);
(* limit the window to a certain maximum client area size
   Such a window should probably not be capable of being maximized

   this call only supported for ToplevelWindows.
*)

PROCEDURE SetWindowGrains(w : Window; width, height : COORDINATE);
(* use this procedure to limit the possible window sizes to values
   such that the client area will be an even multiple of width and height.

   this setting has no effect on a maximized, or minimized window.

   Gtk - not implemented
   Window managers have a geometry hints option but when I used this the
   Window manager(s)/X/Gtk freak out and strange things happen.
   Manual implemenation also had other wierd side effects.

   this call only supported for ToplevelWindows.
*)

PROCEDURE GetWindowSize(w : Window; VAR OUT width, height : COORDINATE);
(* get the size of the window area in screen coordinates
   this includes the client area and all the other goodies.

   Gtk
       On X the border and caption title are not a part of a user window.
       they are the domain of the window manager.
*)

PROCEDURE SetWindowSize(w : Window; width, height : COORDINATE);
(* set the size of the window area in screen coordinates
   this includes the client area and all the other goodies.

   Gtk
       On X the border and caption title are not a part of a user window.
       they are the domain of the window manager.
*)

PROCEDURE GetWindowPos(w : Window; VAR OUT x, y : COORDINATE);
(* get the screen coordinates of the upper left corner of the window

   Gtk
       X and/or window managers have issues with this. The position retrieved
       seems to be interpreted differently than a when setting a window position.
*)

PROCEDURE SetWindowPos(w : Window; x, y : COORDINATE);
(* set the screen coordinates of the upper left corner of the window.
   must be a top level window.

   Gtk
       X and/or window managers have issues with this. The position retrieved
       seems to be interpreted differently than when setting a window position.
*)

PROCEDURE SetWindowPosition(w : Window; pos : WindowPositions);
(*
  w must be a top level window.
  if w has no parent then CenterOnParent is the same as CenterOnScreen.
*)

PROCEDURE SetWindowPosClient(w, parent : Window; x, y : COORDINATE);
(* as SetWindowPos, but the coordinates are relative the the client of the
   window "parent".
   w must be a top level window.
*)

PROCEDURE GetWindowDisplayInfo(w : Window; VAR OUT info : WindowDisplayInfo);
(* get the size a position information for the window
   this is useful for remembering the size and position of a window
   across multiple execution sessions
   if info.mode = SizeMinimized or SizeMaximized then the size and
   position information is the size and position information for the window
   when it is not minimized or maximized.

   Gtk
       X and/or window managers have issues with this. The position retrieved
       seems to be interpreted differently than when setting a window position.
       On X the border and caption title are not a part of a user window.
       they are the domain of the window manager.
*)

PROCEDURE SetWindowDisplayInfo(w : Window; info : WindowDisplayInfo);
(* set the size and position information for the window.

   Gtk
       X and/or window managers have issues with this. The position retrieved
       seems to be interpreted differently than when setting a window position.
       On X the border and caption title are not a part of a user window.
       they are the domain of the window manager.
*)

PROCEDURE CascadeWindow(cascadeThis, onThis : Window);
(* this positions the window 'cascadeThis' just below and to the right of the
   caption of the window 'onThis'.
   the window size is not altered
*)

PROCEDURE SetWindowTitle(w : Window; title : ARRAY OF CHAR);
(* set the caption text for the window.
   if the window does not have a caption then nothing happens.
   title must be null terminated.
*)

PROCEDURE SetWindowData(w : Window;
                        index : CARDINAL;
                        data : ADDRESS) : BOOLEAN;
PROCEDURE SetWindowDataNum(w : Window;
                           index : CARDINAL;
                           data : CARDINAL) : BOOLEAN;
(* this procedure will place the store the data in "data"
   into the window storage array position specified by index.
   index positions are from 0..31,
   returns TRUE if successful
*)

PROCEDURE GetWindowData(w : Window; index : CARDINAL) : ADDRESS;
PROCEDURE GetWindowDataNum(w : Window; index : CARDINAL) : CARDINAL;
(* returns the data from the window storage array location specified by index.
   index positions are from 0..31.
*)

PROCEDURE SetWindowIsBusy(w : Window; busy : BOOLEAN);
(* set the window to a "busy" state
   for each call with busy = TRUE, you must have a corresponding call
   with busy = FALSE to remove the busy state.
   this call changes the mouse cursor of the window to "busy" cursor
   generally an hourglass cursor.
   when the window reverts back to not busy, whatever the mouse cursor
   was before the window was busy is restored.
   generally you use this call when your user interface thread is performing
   a task that might take a while so you give the user some feedback
   with this call
*)

PROCEDURE RedirectMessage(w : Window; msg : MessageRec);
(* this call simply passes the message to the window specified.
   the window should be of the same thread as the window that received
   the message originally. Everything should work if not, but unforseen problems
   may occur.
*)

PROCEDURE SendUserMessage(w : Window;
                          userId : CARDINAL; userData : ADDRESS);
PROCEDURE PostUserMessage(w : Window;
                          userId : CARDINAL; userData : ADDRESS);
(* send a user message to a window
   the window receiving the message can be associated with any thread and
   need not be associated with the current thread.
   userId = arbitrary number
   userData = arbitrary data
   SendUserMessage waits for the message to be received and processed before returning.

   PostUserMessage send the message and return immediately.
   when using PostUserMessage you should not pass the address of local data
   in the item userData since it is not known when the other window
   will process the message and when the procedure that calls this API
   procedure ends the local data is invalidated.
   global variables, constants, and allocated memory can be safe to use
   for the userData item. "can be" because you can use safe memory in an
   unsafe manner.
*)

PROCEDURE IsUserMessageWaiting(w : Window) : BOOLEAN;
(* returns TRUE if a user message is currently waiting in the message queue
   of the current thread
*)

PROCEDURE ClientToScreen(w : Window; VAR INOUT x, y : COORDINATE);
(* convert client coordinates of the given window to screen
   relative coordinates
*)

PROCEDURE ScreenToClient(w : Window; VAR INOUT x, y : COORDINATE);
(* convert screen coordinates to client relative coordinates for
   the given window. The returned coordinates can be negative.
*)

PROCEDURE CreateStatusLine(w : Window; fmt : ARRAY OF INTEGER) : BOOLEAN;
(* add a status line to a window that does not have a status line.
   see SetStatusFormat for the meaning of the fmt parameter.
   returns TRUE if successfull.
   FALSE is returned if the window already has a status line, or
   some other error occurred.
*)

PROCEDURE RemoveStatusLine(w : Window);
(* if the window has a status line then remove the status line
   from the window
*)

PROCEDURE SetStatusFormat(w : Window; fmt : ARRAY OF INTEGER);
(* set the format of the status line
   each element in the fmt array defines a status line field.
   the numeric value in the field defines the number characters
   in size the field should be. The average character width is used to
   determine this size in screen coordinates.
   The last field can contain the value -1 which means
   the field will go all the way to the right side of the window.

   As a convenience if a Tab child window is passed as the window
   parameter, and the Window client is a TabClient,
   the write will affect the Toplevel window.
*)

PROCEDURE WriteStatusField(w : Window;
                           field : CARDINAL;
                           text : ARRAY OF CHAR);
(* write the text given in txt to the field identified by field
   in the status line for the window w
   if the window does not have a status line nothing happens
   txt must be null terminated. if txt is too long for the defined size
   of the field the text will be clipped.

   As a convenience if a Tab child window is passed as the window
   parameter, and the Window client is a TabClient,
   the write will affect the Toplevel window.
*)

PROCEDURE LoadToolbarBitmaps(VAR INOUT buttons : ARRAY OF ToolbarButtonInfo;
                             transparent : ColorValue) : BOOLEAN;
(* load the bitmaps for the toolbar buttons from the resource file.
   For standard bitmaps the stdButton = TRUE and stdName = the button.
   otherwise, the bitmap resource names are taken from bmpResName field.
   This call will not load a bitmap unless the image field is NIL,
   and the bmpResName field is <> "".

   transparent is the color in the bitmap that is to be "transparent", having the
   same color as the button background.
   The loaded bitmaps will be altered to make this so.
   if the transparent color does not exist in a bitmap then the bitmap is loaded
   unaltered without error.
   if the bitmap resource already has transparency information then this parameter
   is ignored. in this case use the value TransparentColor

   returns TRUE if successful, which means ALL bitmaps were loaded.
*)

PROCEDURE UnloadToolbarBitmaps(VAR INOUT buttons : ARRAY OF ToolbarButtonInfo);
(* unload the bitmaps for the toolbar buttons.
   if a button does not have a bitmap currently loaded that button is
   skipped.
*)

PROCEDURE CreateToolbar(w : Window;
                        buttons : ARRAY OF ToolbarButtonInfo;
                        hasText : BOOLEAN;
                        hasHelp : BOOLEAN;
                        canCustomize : BOOLEAN) : BOOLEAN;
(* create a toolbar for the given window.
   buttons = the buttons of the toolbar. this is ALL possible buttons.
             button bitmaps should be 24x24.
             this call does not use the bmpResId field of the button
             info record.
             the bitmap field must be initialized with the handle
             of your bitmap, or the value of a standard bitmap.
             Use SYSTEM.MAKEADR to create an address with the
             standard bitmap ordinal. MAKEADR(ORD(TB_BMP_CUT))
             You can use LoadToolbarBitmaps to load your bitmaps
             or you can load them via other means.
   hasText = TRUE the buttons will display text labels if available.
             FALSE only the bitmaps will be displayed.
   hasHelp = TRUE the buttons will display tooltip help popups if available
             FALSE the buttons will not display tooltips
   canCustomize = TRUE the toolbar will allow the user to customize the
                  buttons displayed and the order they are displayed.
                  You should fetch this information and save it so you can
                  remember the user preferred toolbar settings.
*)

PROCEDURE DestroyToolbar(w : Window);
(* destroy the toolbar for the window if it has one *)

PROCEDURE SetToolbarButtons(w : Window; fmt : ARRAY OF CARDINAL);
(* set which buttons from the list of available buttons will be
   displayed. The HIGH bound of the passed array determines the
   number of toolbar buttons.
   the numeric value if each array element specifies the ordinal index
   into the list of available buttons passed to CreateToolbar.
   if the window does not have a toolbar nothing happens
*)

PROCEDURE GetToolbarButtons(w : Window; VAR OUT fmt : ARRAY OF CARDINAL) : CARDINAL;
(* get the current buttons displayed and their layout.
   the returned value is number of buttons returned into the parameter
   fmt. you should  make sure fmt is big enough to hold all possible
   buttons so you will not lose information. the maximum number of buttons
   is known from the CreateToolbar procedure call.
   the numeric value if each array element specifies the ordinal index
   into the list of available buttons passed to CreateToolbar.
   if the window does not have a toolbar nothing happens.

   Win32
       the system toolbar control supports toolbar customization by the user
       with no interaction necessary on our part.
       the user customizes a toolbar by double clicking on an empty area in the tool
       bar. Windows displays a customization dialog the user interacts with.
   GTK
       no user customization is currently implemented.
*)

PROCEDURE IsToolbarButtonDown(w : Window; index : CARDINAL) : BOOLEAN;
(* is the button identified by index currenly in the down position.
   this call is only valid for TbToggle buttons
   a button must be shown before it can be toggled.
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if the button is shown and checked in the toolbar
*)

PROCEDURE IsToolbarButtonEnabled(w : Window; index : CARDINAL) : BOOLEAN;
(* is the button identified by index currently enabled
   returns TRUE means the button is active an can be pressed
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if the button is enabled in the toolbar
*)

PROCEDURE IsToolbarButtonShown(w : Window; index : CARDINAL) : BOOLEAN;
(* is the button identified by index currently shown
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if the button is shown in the toolbar
*)

PROCEDURE ToggleToolbarButton(w : Window;
                              index : CARDINAL;
                              down : BOOLEAN) : BOOLEAN;
(* set the toggled state of the button identified by index
   this call is only valid for TbToggle buttons
   down = TRUE means the button should be in the down position.
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if successful
*)

PROCEDURE EnableToolbarButton(w : Window;
                              index : CARDINAL;
                              enable : BOOLEAN) : BOOLEAN;
(* set the enabled state of the button identified by index
   enable = TRUE means the button should be enabled
   index is the ordinal index into the button list array passed
   to CreateToolbar
   returns TRUE if successful
*)

PROCEDURE ShowToolbarButton(w : Window;
                            index : CARDINAL;
                            show : BOOLEAN) : BOOLEAN;
(* set the shown state of the button identified by index
   show = TRUE means the button should be shown
   index is the ordinal index into the button list array passed
   to CreateToolbar
*)

PROCEDURE CaretOn(w : Window);
(* only applicable for DrawClients
   turn the display of a text caret ON in the window.
   if the window is the input focus window then the caret will be
   displayed otherwise the caret is not displayed.

*)

PROCEDURE CaretOff(w : Window);
(* only applicable for DrawClients
   turn the display of a text caret OFF in the window *)

PROCEDURE HideCaret(w : Window);
(* only applicable for DrawClients
   this call is not normally necessary.
   the caret must not be displayed when you paint to maintain a proper display.
   BeginPaint, and PAINT messages automatically hide/show the caret.
   this call is only necessary when using non transient window drawables,
   since in these cases you may not be using BeginPaint.
   HideCaret maintains a hide count therefore you must call ShowCaret
   once for each call to HideCaret.
*)

PROCEDURE ShowCaret(w : Window);
(* only applicable for DrawClients
   see HideCaret
*)

PROCEDURE MoveCaretTo(w : Window; x, y : INTEGER);
(*
   move the text caret to a specific location
   the coordinates are client area relative
   the window need not have the caret turned on for this function
   to operate. the coordinates will be remembered
*)

PROCEDURE GetCaretPos(w : Window; VAR OUT x, y : COORDINATE);
(* fetch the current text caret position *)

PROCEDURE SetCaretType(w : Window; ct : CaretTypes; width, height : CARDINAL);
(* set the type and size of the caret for this window
   ct = the shape of the caret.
   width, height = the width and height in screen coordinates of the caret.
   the window need not have the caret turned on for this function
   to operate. the information will be remembered
*)

PROCEDURE SetScrollBarRange(w : Window;
                            which : WinAttr;
                            min : ScrollRange;
                            max : ScrollRange;
                            pageSize : ScrollRange);
(* set the range information for the given scroll bar in the given window
   which = which scroll bar
   min = the lower limit of the scroll bar range
   max = the upper limit of the scroll bar range
         if min = max then the scroll bar is remove or disabled
   pageSize = the size of a "page" in scroll bar range units.
   for example in a text file
    the range might be (min = 1) (max = 534) and (pageSize = 10)
    in this case the lower limit is always line number 1.
    the upper limit is the number of lines in the text file.
    pageSize is the most likely the size of the window in lines or one or two
        lines less than this.
    scroll bar ranges are whatever you what them to be
*)

PROCEDURE SetScrollBarRanges(w : Window;
                             minX : ScrollRange;
                             maxX : ScrollRange;
                             pageX : ScrollRange;
                             minY : ScrollRange;
                             maxY : ScrollRange;
                             pageY : ScrollRange);
(* like SetScrollBarRange except that you are setting the range for
   both the horizontal, X, and vertical, Y, scroll bars.
   See SetScrollBarRange
*)

PROCEDURE SetScrollBarPos(w : Window;
                          which : WinAttr;
                          pos : ScrollRange);
(* set the position of the scroll bar thumb
   which = which scroll bar
   pos = the position. (pos >= minRange) AND (pos <= maxRange)
*)

PROCEDURE GetScrollBarPos(w : Window; which : WinAttr) : ScrollRange;
(* get the position of the scroll bar thumb
   which = which scroll bar
*)

PROCEDURE SetScrollDisableWhenNone(w : Window; yesH, yesV : BOOLEAN);
(* this procedure controls whether a scroll bar disappears or becomes
   disabled when the window is large enough to display the entire
   "document" and thus a scroll bar is not necessary.
   this sets the policy for both scroll bars, but each scroll bar
   acts independently regarding its own state.
   yes = TRUE means the scroll bar(s) will disable
         FALSE means the scroll bar(s) will disappear
   yesH = horizontal, yesV = vertical
   default = FALSE
*)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

PROCEDURE SetWindowIcon(w : Window; icon : ARRAY OF CHAR) : BOOLEAN;
(*
   set the icon associated with the window
   the resource can have many icon formats and the most appropriate
   icon will be chosen depending on how the icon is going to
   be used by the system. generally 32x32 and a 16x16 16color icons should
   be provided at a minimum in the icon resource.

   Gtk
       not currently implemented.
*)

PROCEDURE SetWindowCursor(w : Window; typ : CursorTypes);
(* set the cursor type displayed when the mouse cursor is within the
   confines of the windows client area.
   the window must have a client type of DrawClient.
*)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

PROCEDURE SetWindowMenu(w : Window;
                        menu : ARRAY OF CHAR) : BOOLEAN;
(* set/change the menu for the given window.
   menu = the menu resource. Can be "", which means no menu.
*)

PROCEDURE GetWindowMenu(w : Window) : MenuHandle;
(* get the menu handle for menu currently associated with the window
   the return value can be NIL if the window has no menu
*)

(* for the following "check" and "enable" functions
   in an "MDI" situation where tab client children of the toplevel window have
   unique windows you can apply this function to the main winddow and it will
   act on the currently active menu for the toplevel window.
*)

PROCEDURE SetMenuItemEnable(w : Window; id : CARDINAL; enabled : BOOLEAN);
(* set whether a menu item identified by id is enabled
   enabled = TRUE the menu item is enabled
             FALSE the menu item is disabled
*)

PROCEDURE GetMenuItemEnable(w : Window; id : CARDINAL) : BOOLEAN;
(* get whether a menu item identified by id is enabled
   returns = TRUE the menu item is enabled
             FALSE the menu item is disabled
*)

PROCEDURE SetMenuItemCheck(w : Window; id : CARDINAL; checked : BOOLEAN);
(* set whether a menu item identified by id has a check mark displayed
   in the menu.
   checked = TRUE => a check mark will be displayed
             FALSE => no check mark will be displayed
*)

PROCEDURE GetMenuItemCheck(w : Window; id : CARDINAL) : BOOLEAN;
(* get the checked state a menu item identified by id
   returns = TRUE a check mark is displayed
             FALSE no check mark is displayed
*)

PROCEDURE SetMenuItemRadioCheck(w : Window;
                                first, last, set : CARDINAL);
(* similar to check menu item, however this identifies a group of
   menu items of which one is checked and the others are unchecked.

   first..last is the range of menu items in the radio group.
   set is the menu item in the group to be "checked".
*)

PROCEDURE GetMenuItemRadioCheck(w : Window; first, last : CARDINAL) : CARDINAL;
(* get the checked menu item in a radio menu item group
   returns 0 if some error occurs, or none are checked.
*)

PROCEDURE LoadMenu(w : Window;
                   menu : ARRAY OF CHAR;
                   popup : BOOLEAN) : MenuHandle;
(* load a menu resource identified by menu.
   the menu is associated with the identified window.
   the return value will be NIL if the resource does not exist
   or there was an error loading the resource.

   popup = TRUE if the menu being loaded is a popup menu.
           For Win32 the menu resource is loaded and the first menu
           is returned.
           For Gtk a popup menu resource is loaded.
*)

PROCEDURE DestroyMenu(VAR INOUT menuH : MenuHandle);
(* destroy a previously loaded menu resource *)

PROCEDURE GetSubMenu(menuH : MenuHandle; subMenuId : CARDINAL) : MenuHandle;
(*
   get the menu handle of a sub menu within a menu
   can return NIL of the sub menu does not exist or there was an error.
   the sub menu is identified by id number.

   On Windows you must use an extended menu resource to apply an id number
   to a popup menu.

   On the Mac the subMenuId parameter is a menuId number, NOT a resource idNumber.
   Generally the menuId and resource id are set to the same value. Note that menuId
   number on the Mac have a limited number range.
*)

PROCEDURE DisposeSubMenu(menuH : MenuHandle);
(* dispose of a previously fetched submenu of a memu resource *)

PROCEDURE AppendMenuItemStr(w : Window;
                            menuH : MenuHandle;
                            str : ARRAY OF CHAR;
                            id : CARDINAL) : BOOLEAN;
(* append a new menu item to the menu identified by menuH
   str = the text of the menu. must be null terminated
   id = the id number used to identify the menu item.
   you can "underscore" a character in the menu for keyboard activation
   by preceeding the desired character with an underscore character ('_').
   returns TRUE if successfull
*)

PROCEDURE AppendMenuItemSeparator(w : Window; menuH : MenuHandle) : BOOLEAN;
(* append a new menu item to the menu identified by menuH
   the menu item appended is a menu separator
   this is usually a thin line drawn across the menu
   returns TRUE if successfull
*)

PROCEDURE SetMenuItemStr(w : Window;
                         id : CARDINAL;
                         str : ARRAY OF CHAR) : BOOLEAN;
(* change the text of an existing menu item.
   id = the id number used to identify the menu item.
   str = the text of the menu. must be null terminated
   you can "underscore" a character in the menu for keyboard activation
   by preceeding the desired character with an underscore character ('_').
   returns TRUE if successfull
*)

PROCEDURE DeleteMenuItemPosition(menuH : MenuHandle;
                                 pos : CARDINAL) : BOOLEAN;
(* remove a menu item from the menu identified by menuH
   pos = the ordinal position of the menu item starting at zero for the
         first item in the menu
*)

PROCEDURE PopupMenu(w : Window;
                    menu : ARRAY OF CHAR;
                    button : MouseButton;
                    x, y : COORDINATE);
(* display a popup menu at client coordinates x, y.
   the menu is identified the parameter menu.
   button = the button used to "open" the popup menu and thus when this
            button is released the menu will close.

   This call is modal, meaning the call does not return until the popup
   menu is closed.

   For Win32 the menu resource is loaded and the first menu is used.
   For Gtk a popup menu resource is used.
*)

PROCEDURE PopupMenuHandle(w : Window;
                          menu : MenuHandle;
                          button : MouseButton;
                          x, y : COORDINATE);
(* like PopupMenu except that the menu is identified by a MenuHandle.
   this allows you to modify the menu resource before displaying the menu
   See PopupMenu

   This call is modal, meaning the call does not return until the popup
   menu is closed.
*)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

PROCEDURE LoadString(idNum : CARDINAL; VAR OUT str : ARRAY OF CHAR);
(*
  Load a string from the string resource.
  the string is identified by idNum.
  str = "" if not successfull.
*)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

PROCEDURE OpenClipboard(w : Window) : BOOLEAN;
(* open the system clipboard and give ownership to the specified window.
   returns TRUE if successful.
   only a foreground window should make such a request, and then only
   on behalf of a users request

   Gtk
       on X systems the "clipboard" can be many different things and some programs
       may only support one type of "clipboard". X calls these "selections".
       This module defines its own selection, and also tries to use other selections
       to try and be compatible with as many programs as possible.
*)

PROCEDURE CloseClipboard(w : Window);
(* close and release ownership of the clipboard. *)

PROCEDURE EmptyClipboard(w : Window) : BOOLEAN;
(* empty all contents of the clipboard
   if the window does not own the clipboard the call will fail
   returns TRUE if the operation is successfull
*)

PROCEDURE ClipboardFormatAvailable(fmt : ClipboardFormat) : BOOLEAN;
(* returns TRUE if data of the given clipboard format is available
   in the clipboard.
   returns TRUE if the format is available, otherwise FALSE if the
   clipboard is empty or some other data type is available.
   all text formats are automatically converted to other text formats
   on demand. Therefore if you put ASCII into the clipboard you can
   retrieve Unicode from the clipboard.
*)

PROCEDURE AllocClipboardMemory(size : CARDINAL) : ADDRESS;
(* allocate system memory suitable for placing in the clipboard.
   size = the amount of memory in bytes
   if NIL is returned the call failed, otherwise a valid address is returned which
   you can use to write to the clipboard memory.
*)

PROCEDURE SetClipboard(fmt : ClipboardFormat) : BOOLEAN;
(* place data into the clipboard
   the format of the data is given in fmt parameter.
   the memory placed in the clipboard is the memory previously allocated with
   AllocClipboardMemory.

   Win32 and Mac
       the operating system will deallocate this memory for you since you
       cannot know how long the data will exist in the clipboard.
   Gtk
       Data put into the clipboard is only available to other programs as long
       as your process is running.

   returns TRUE if successfull.
*)

PROCEDURE GetClipboard(fmt : ClipboardFormat) : ADDRESS;
(* get clipboard data of the given format.
   returns NIL if the format was not available or the clip board was empty.
   otherwise a valid address is returned and the data is locked.
   you MUST unlock the data when you are done reading the data.
   all text formats are automatically converted to other text formats
   on demand. Therefore if you put ASCII into the clipboard you can
   retrieve Unicode from the clipboard.
   text formats are returned null terminated.
*)

PROCEDURE UnlockClipboardMemory;
(* the clipboard memory received by GetClipboard is unlocked by this call.
   this memory must be unlocked after it is used.
*)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

PROCEDURE SetTimer(w : Window; timerId : CARDINAL; interval : CARDINAL);
(* create/reset a timer associated with the specified window
   timerId = a unique number to identify the timer.
   interval = the amount of time in milliseconds between WSM_TIMER messages
              this interval is only an approximate time
   calling SetTimer with the same timerId as a previous call but with
   a different interval has the effect of resetting the interval from
   the previous value to the new value *)

PROCEDURE KillTimer(w : Window; timerId : CARDINAL);
(* dispose of a previously created timer
   timerId = the identification number of an existing timer *)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

PROCEDURE PointInRect(x, y : COORDINATE; rect : wsRECT) : BOOLEAN;

PROCEDURE RectOverlap(r1, r2 : wsRECT) : BOOLEAN;

PROCEDURE IntersectRect(r1, r2 : wsRECT; VAR OUT r3 : wsRECT) : BOOLEAN;

PROCEDURE UnionRect(r1, r2 : wsRECT; VAR OUT r3 : wsRECT);

PROCEDURE OffsetRect(x, y : COORDINATE; VAR INOUT rect : wsRECT);

<*IF StonyBrook THEN*>

PROCEDURE RgbToColorValue(red, green, blue : CARD8) : ColorValue; MACRO;
BEGIN
    RETURN ORD(red) BOR
           (ORD(green) SHL 8) BOR
           (ORD(blue) SHL 16);
END RgbToColorValue;

PROCEDURE RgbaToColorValue(red, green, blue, alpha : CARD8) : ColorValue; MACRO;
BEGIN
    RETURN ORD(red) BOR
           (ORD(green) SHL 8) BOR
           (ORD(blue) SHL 16) BOR
           (ORD(alpha) SHL 24);
END RgbaToColorValue;

PROCEDURE ColorValueToRgb(colorVal : ColorValue;
                          VAR OUT red, green, blue : CARD8); MACRO;
BEGIN
    red := colorVal BAND 0FFh;
    green := (colorVal SHR 8) BAND 0FFh;
    blue := (colorVal SHR 16) BAND 0FFh;
END ColorValueToRgb;

PROCEDURE ColorValueToRgba(colorVal : ColorValue;
                          VAR OUT red, green, blue, alpha : CARD8); MACRO;
BEGIN
    red := colorVal BAND 0FFh;
    green := (colorVal SHR 8) BAND 0FFh;
    blue := (colorVal SHR 16) BAND 0FFh;
    alpha := (colorVal SHR 24);
END ColorValueToRgba;

<*ELSE*>

PROCEDURE RgbToColorValue(red, green, blue : CARD8) : ColorValue;

PROCEDURE RgbaToColorValue(red, green, blue, alpha : CARD8) : ColorValue;

PROCEDURE ColorValueToRgb(colorVal : ColorValue;
                          VAR OUT red, green, blue : CARD8);

PROCEDURE ColorValueToRgba(colorVal : ColorValue;
                          VAR OUT red, green, blue, alpha : CARD8);

<*END*>

PROCEDURE GetSystemColor(sysColor : SystemColors) : ColorValue;
(* return a color value for the system color *)

PROCEDURE LoadFont(font : FontInfo) : FontHandle;
(* load the font as specified by the parameter font *)
(* returns a valid font handle if successfull, otherwise NIL *)

PROCEDURE DeleteFont(font : FontHandle);
(* remove a previously loaded font *)

PROCEDURE GetTextMetrics(font : FontHandle; VAR OUT metrics : TextMetrics);
(* retrieve information about the font specified in the font parameter *)

PROCEDURE LoadBitmap(name : ARRAY OF CHAR; shared : BOOLEAN) : BitmapHandle;
(*
  Load a bitmap from resource.

  IF shared = TRUE, loaded bitmaps will be cached and on subsequent
  loads the bitmap handle of the first load will be returned.

  You should call DeleteBitmap when you are done using the bitmap.
  If shared = TRUE then the bitmap will not be freed until
  DeleteBitmap is called once for each active Load.
*)

PROCEDURE LoadBitmapFromFile(name : ARRAY OF CHAR) : BitmapHandle;
(*
  as LoadBitmap except the image is loaded from a stand alone file.

  Win32.
    if the file extension is ".bmp" then the normal GDI is used to load the file.
    otherwise Gdi+ is used. any file type supported by GDI+ can be loaded.

  GTK+
    any file type supported by libgdk_pixbuf can be loaded.

  Mac.
    any file type supported by Quicktime can be loaded. basically everything.
    the Mac does have a limit of < 4096 bytes for a single row in the image.
    this limit is imposed by the system CopyBits API.
*)

PROCEDURE CreateBitmap(w : Window; width, height : CARDINAL) : BitmapHandle;
(*
  create a bitmap compatible with the window.
  The bitmap can be used with any Drawable that it is compatible with,
  meaning the color depth.
*)

PROCEDURE GetBitmapSize(bmp : BitmapHandle; VAR OUT width, height : CARDINAL);
(*
   return the width and height of the specified bitmap.
   returns 0 if bmp is not a valid bitmap handle.
*)

PROCEDURE ExtractBitmap(bmp : BitmapHandle;
                        x, y : COORDINATE;
                        width, height : CARDINAL) : BitmapHandle;
(*
    this function creates a new bitmap from a portion of another
    bitmap.
    This can be useful with buttons for toolbars. Since these are
    small bitmaps and there are usually many buttons, it can be
    nice to edit all off the buttons in one larger bitmap.
    This function can be used to extract the individual bitmaps
    from the large bitmap button array.
*)

PROCEDURE DeleteBitmap(bmp : BitmapHandle);
(* delete a previously loaded/created bitmap.
  For shared bitmaps the bitmap will not be freed until
  DeleteBitmap is called once for each active Load.
*)

PROCEDURE CreateDrawContext(w : Window;
                            dcValues : DrawContextValues) : DrawContext;
(* create a new DrawContext. the context will be compatigble with
   the passed Window, w. You can use the context with other windows
   as long as the windows use the same color depth.
   Note that you can only draw on a DrawClient, so the window should be
   a toplevel window with a DrawClient or a DrawClient ChildWindow.
*)

PROCEDURE DestroyDrawContext(VAR INOUT dc : DrawContext);
(* dispose of a previously created DrawContext.
   The context must not be currently selected into any Drawable.
*)

PROCEDURE SetDrawContextValues(dc : DrawContext;
                               dcValues : DrawContextValues);
(* set the values associated with the DrawContext. *)

PROCEDURE GetDrawContextValues(dc : DrawContext; VAR OUT dcValues : DrawContextValues);
(* get the values associated with the DrawContext. *)

PROCEDURE SetForegroundColor(dc : DrawContext; color : ColorValue);
(* set the foreground color used for painting *)

PROCEDURE SetBackgroundColor(dc : DrawContext; color : ColorValue);
(* set the background color used for painting *)

PROCEDURE SetFont(dc : DrawContext; font : FontHandle);
(* set the font as the font used for painting text *)

PROCEDURE SetTextExtraSpacing(dc : DrawContext; extra : INTEGER);
(* this alters the normal character spacing of the text written
   a positive value adds space (pixels) between each character drawn
   a negative value removes space.
*)

PROCEDURE SetTextDrawOrigin(dc : DrawContext; origin : TextDrawOrigin);
(*
  Sets the text origin of text drawing operations.
  See the comments at the TextDrawOrigin type declaration.
*)

PROCEDURE SetLineWidth(dc : DrawContext; width : CARDINAL);
(* set the line width *)

PROCEDURE SetLineStyle(dc : DrawContext; style : LineStyles);
(* set the line style *)

PROCEDURE SetLineAttributes(dc : DrawContext;
                            style : LineStyles;
                            join : JoinStyles;
                            endCap : EndCaps;
                            width : CARDINAL);
(* set all line attributes *)

PROCEDURE SetDrawFunction(dc : DrawContext; func : DrawFunctions);
(* the the draw function *)

PROCEDURE BeginPaint(w : Window; dc : DrawContext) : Drawable;
(* use this to obtain a Drawable for the specific window.
   Note that you can only draw on a DrawClient, so the window should be
   a toplevel window with a DrawClient or a DrawClient ChildWindow.

   the DrawContext, dc, is selected into the returned Drawable.
   when you are finished painting you must call EndPaint which releases
   any system resources allocated by this call.

   if dc = NIL, then the default context is used.

   this call will automatically hide the text caret if active.

   when you receive a PAINT message you can use the Drawable passed
   in the paint message, therefore you do not need, and should not use, this call in that
   circumstance.
*)

PROCEDURE EndPaint(w : Window);
(* call this when you are done painting to a window.
  this call is the book end to the BeginPaint call.
  The Drawable returned by the BeginPaint call is invalid after this call.
  Any DrawContext selected into the Drawable is automatically deselected.
  This call will show the text caret if the window has an active caret.
*)

PROCEDURE CreateOffscreenDrawable(w : Window;
                                  width, height : CARDINAL;
                                  context : DrawContext) : Drawable;
(* create a Drawable where all draw operations are drawing into
   a offscreen bitmap.  The Drawable is compatible with the given window.

   The size of the Drawable is width and height. If width or height are
   zero then the Drawable size for that dimension is set to the current size
   of the client area of the Window.
*)

PROCEDURE CreateBitmapDrawable(bmp : BitmapHandle; context : DrawContext) : Drawable;
(* create a Drawable where all draw operations are drawing into the specified bitmap.
   The size of this drawable is the size of the bitmap.

   Use this to draw onto the bitmap itself, or to draw the bitmap onto other
   drawables. A simple API exists for drawing a bitmap to a drawable without
   creating a bitmap drawable.
*)

PROCEDURE CreateRgbDrawable(width, height : CARDINAL; context : DrawContext) : Drawable;
(* creates an RGB buffer drawable. the RGB data is translated to/from native bitmap
   format automatically.

   width, height = the width and height in pixels of the drawable.

   this Drawable exists primarily for interfacing external image editing libraries
   with display Drawables.
   Applications which render RGB images will also find use of this Drawable.
   For normal drawing and displaying you might be better off with a bitmap.

   the drawable internally maintains a system specific bitmap and RGB buffer.
   when you copy RGB pixels into the drawable the bitmap is not necessarily updated
   immediately. the bitmap is updated when the bitmap needs to be used.
   likewise most "Draw..." APIs utilize the bitmap, and the RGB values are not updated
   immediately. they are updated when the RGB data needs to be accessed.
   you can forcibly serialize the bitmap and RGB buffer update by using
   the call SyncRgbDrawable.
*)

PROCEDURE GetDrawableSize(draw : Drawable; VAR OUT width, height : CARDINAL);
(* return the width and height of the drawable in pixels *)

PROCEDURE DestroyDrawable(draw : Drawable);
(*
  Delete a previously created Drawable.
  Do not use this call with a Drawable returned by BeginPaint or the Drawable
  passed in the WSM_PAINT message.
*)

PROCEDURE SelectDrawContext(draw : Drawable; context : DrawContext);
(* associate the DrawContext with the Drawable, draw.
   the previously selected DrawContext is deselected.
*)

PROCEDURE PushDrawContext(draw : Drawable; context : DrawContext) : BOOLEAN;
PROCEDURE PopDrawContext(draw : Drawable);
(*
  allows you to temporarily select a context into a drawable and restore the
  previous context, whatever that was.
  returns TRUE if successful.
  a return of FALSE means the internal stack has overflowed.
  the internal context stack holds four elements.
*)

PROCEDURE CopyPixelRowToRgbDrawable(draw : Drawable;
                                    x, y : CARDINAL;
                                    numPixels : CARDINAL;
                                    pixels : ADDRESS;
                                    pixelFormat : RgbPixelFormat) : BOOLEAN;
(* transfer the RGB pixel data to the RgbDrawable.
   you can transfer at most one row of pixels at a time.
   x, y are zero based coordinates into the drawable.
   numPixels is the number of pixels to be copied.
   pixels is the address of the first pixel to be copied.

   RETURNs TRUE if successful.
*)

PROCEDURE CopyPixelRectToRgbDrawable(draw : Drawable;
                                     destX, destY : CARDINAL;
                                     srcX, srcY : CARDINAL;
                                     width, height : CARDINAL;
                                     rowStride : CARDINAL;
                                     pixels : ADDRESS;
                                     pixelFormat : RgbPixelFormat) : BOOLEAN;
(* as CopyPixelRowToRgbDrawable except you are copying a rectangle of pixels
   out of a larger buffer.
   rowStride = the address width of each row of pixels.
   pixels = the address of the 0,0 pixel.
   all coordinates are assumed to be zero based.
   destX, destY are coordinates within the drawable.
   srcX,srcY are coordinates in the source RGB buffer.
   width,height is the width and height in pixels of the rectangle to copy.

   pixel addresses are computed as
   pixelAddress = (y * rowStride) + (x * SIZE(Pixel))
   RETURNs TRUE if successful.
*)

PROCEDURE GetRgbDrawablePixelRow(draw : Drawable;
                                 x, y : CARDINAL;
                                 numPixels : CARDINAL;
                                 pixels : ADDRESS;
                                 pixelFormat : RgbPixelFormat) : CARDINAL;
(* the reverse of CopyPixelsToRgbDrawable.
   x, y are zero based coordinates into the drawable.
   numPixels is the number of pixels to be fetched.
   RETURNs the number of pixels copied. this might be less than the requested number
   of pixels if the coordinates are out of range with the requested pixel count.
   if the pixel format request an alpha channel then it will always be opaque.
*)

PROCEDURE SyncRgbDrawable(draw : Drawable);
(*  see CreateRgbDrawable *)

PROCEDURE GetTextWidth(draw : Drawable;
                       text : ARRAY OF CHAR;
                       length : CARDINAL) : CARDINAL;
(* this calls returns the width of the text in pixels when drawn.
   the number of characters measured is length.
   if length = 0 the the number of characters measured is LENGTH(text)
   the font currently selected for drawing is used for the measurement.
   The SetTextExtraSpacing API procedure affects this call.
*)

PROCEDURE DrawText(draw : Drawable;
                   x, y : COORDINATE;
                   text : ARRAY OF CHAR;
                   length : CARDINAL);
(* draw text at the coordinates x, y
 length = the number of characters drawn
 if length = 0 then the number of characters draw is LENGTH(text)
 the text is drawn in the foreground color.
 the text is drawn transparently over the background.
*)

PROCEDURE DrawTextRect(draw : Drawable;
                       x, y : COORDINATE;
                       text : ARRAY OF CHAR;
                       length : CARDINAL;
                       rect : wsRECT;
                       flags : DrawTextOptionSet);
(* draw text at the coordinates x, y
   length = the number of characters drawn
   if length = 0 then the number of characters drawn is LENGTH(text).
   the text is drawn in the foreground color.
   the rectangle specifies the rectangle that is used for clipping and/or filling.
   flags specifies options for drawing.
*)

PROCEDURE DrawPixel(draw : Drawable; x, y : COORDINATE; color : ColorValue);
(* draw a pixel a tht given coordinates in the given color *)

PROCEDURE DrawLine(draw : Drawable;
                   x1, y1, x2, y2 : COORDINATE);
(* draw a line from x1,y1 to x2,y2 in the current foreground color
   and line attributes.
*)

PROCEDURE DrawLines(draw : Drawable; points : ARRAY OF wsPOINT);
(* draw a series of connected lines starting at the first point
   and ending at the last point.
   the line is drawn in the current foreground color, and line attributes.
*)

PROCEDURE DrawRectangle(draw : Drawable;
                        x, y : COORDINATE;
                        width, height : CARDINAL;
                        filled : BOOLEAN);
(* draw the rectangle with the foreground color.
   if filled = FALSE  then the rectangle outline is drawn with
   the current line attributes.
   example x=0,y=0,width=20,height=20
   the coordinates of the drawn rectangle are
   upper left (0, 0), and lower right (19, 19)
*)

PROCEDURE EraseRectangle(draw : Drawable;
                         x, y : COORDINATE;
                         width, height : CARDINAL);
(* as DrawRectangle, except the rectangle is filled with the background color.*)

PROCEDURE DrawPie(draw : Drawable;
                  x, y : COORDINATE;
                  radius : CARDINAL;
                  startAngle, arcAngle : REAL;
                  filled : BOOLEAN);
(* draw a pie slice within in the foreground color.
   x, y define the center of the circle the pie slice is a part of.
   radius is the radius of the circle.
   startAngle and arcAngle define the size of the pie slice.
   a startAngle value of zero begins at the 3 o'clock position and increasing
   values go in the counter clockwise direction.
   the angle values are specified in degrees.
   width is the number of degrees of the pie slice and must be <= 360.0.
   if filled = FALSE then the pie outline is drawn with
   the current line attributes.
*)

PROCEDURE DrawBitmap(destDraw : Drawable;
                     destX, destY : COORDINATE;
                     bmp : BitmapHandle);
PROCEDURE DrawBitmapRect(destDraw : Drawable;
                         destX, destY : COORDINATE;
                         bmp : BitmapHandle;
                         srcX, srcY : COORDINATE;
                         width, height : CARDINAL);
(* draw the bitmap onto the destination drawable. *)

PROCEDURE CopyDrawableArea(destDraw : Drawable;
                           destX, destY : COORDINATE;
                           srcDraw : Drawable;
                           srcX, srcY : COORDINATE;
                           width, height : CARDINAL);
(* this call copies a reqion from one drawable to another.
   you may use the same drawable for both the source and destination.

   For a window as the source, it should not be clipped,
   otherwise you may be copying other windows.
   See the ClientAreaIsClipped API call.
   The UpdateWindow API call can be useful before issuing this call with Window
   drawables as the source.
*)

PROCEDURE ScaleDrawableArea(destDraw : Drawable;
                            destX, destY : COORDINATE;
                            destWidth, destHeight : CARDINAL;
                            srcDraw : Drawable;
                            srcX, srcY : COORDINATE;
                            srcWidth, srcHeight : CARDINAL;
                            interp : PixelInterpolation);
(* like CopyDrawableArea except the the destination rectangle can be a different
   size than the soruce rectangle. the image is expanded if the destination rectangle
   is larger than the source. the image is compressed is the destination rectangle
   is smaller than the source.

   Win32. InterpLowQuality uses the StretchBlt API.
          Gdi+ is used for all other interpolation settings. if Gdi+ is not available
          then you get InterpLowQuality scaling.
*)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

PROCEDURE DisplayHelp(w : Window;
                      command : HelpCommand;
                      helpFile : ARRAY OF CHAR;
                      helpIndex : CARDINAL) : BOOLEAN;
(* call the operating system help program
   helpFile = the file specification of the help file to be opened
   helpIndex = help topic number within the given help file
   command = what you want the help program to do
       HelpTopic        open help to a specific topic.
       HelpContents     open help in table of contents
                        (Win32 only. only 'hlp' and 'chm' help files support this.)
                        helpIndex is ignored in this case


   Win32.
   All features are available.
   On Windows you can use WinHelp (.hlp), HTML help (.chm) or any other file type
       which is registered with the OS. For example HTML files (.htm, .html).

   GTK+
   command and helpIndex are ignored.
   helpFile is assumed to be an HTML file and an HTML browser is executed for
   the specified file.
*)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

PROCEDURE ListClientInsertItem(w : Window; item : ListClientInsertRec) : INTEGER;
(* insert a new item into the list.
   returns the index position of the inserted location.
   returns -1 if the insert failed.
*)

PROCEDURE ListClientSetItem(w : Window;
                            row, column : CARDINAL;
                            text : ARRAY OF CHAR;
                            image : CARDINAL);
(* set the contents of a specific row and column.
   the use of the text and image parameters depends on the column content type.
   ColumnText
       text must be null terminated.
       image is ignored.
   ColumnBitmap
       text is ignored.
   ColumnBitmapText
       text must be null terminated.
*)

PROCEDURE ListClientGetItem(w : Window;
                            row, column : CARDINAL;
                            VAR OUT text : ARRAY OF CHAR;
                            VAR OUT image : CARDINAL);
(* get the contents of a specific row and column. see ListClientSetItem *)

PROCEDURE ListClientGetItemData(w : Window; row : CARDINAL) : ADDRESS;
(* fetch the user defined data for the specified row. *)

PROCEDURE ListClientSetItemData(w : Window; row : CARDINAL; data : ADDRESS);
(* set the user defined data for the specified row. *)

PROCEDURE ListClientFindItemByData(w : Window; data : ADDRESS) : INTEGER;
(* find an item in the list by comparing with the user data item
   you previosly set.
   If you insert/delete items the index position returned at the time of
   insertion may be invalid.
   If the list is sorted then the index position can change at any time so you cannot
   rely on the index position returned at the time of insertion.

   RETURNs -1 if the item is not found, otherwise the current index position of the item.
*)

PROCEDURE ListClientGetSelectionCount(w : Window) : CARDINAL;
(* return the number of selected items in the list.
   a single selection list will always return 0 or 1.
*)

PROCEDURE ListClientGetSelectedItems(w : Window;
                                     VAR OUT items : ARRAY OF CARDINAL) : CARDINAL;
(* get the items selected in the list.
   the return value is the number of items placed into the items array.
   if more items are selected than positions avaialble in the items array then
   some selected items are lost.
*)

PROCEDURE ListClientSetSelectedItem(w : Window; sel : CARDINAL) : BOOLEAN;
(* the the specified row to the selected state. *)

PROCEDURE ListClientRemoveItem(w : Window; item : CARDINAL);
(* remove the specified item from the list *)

PROCEDURE ListClientRemoveAllItems(w : Window);
(* remove all items from the list *)

PROCEDURE ListClientFreezeDisplay(w : Window; yes : BOOLEAN);
(* yes = TRUE = causes the window to not redraw itself when an item is added/removed
                from the list. this is useful when adding/removing a number of items.
  yes = FALSE = causes the window to refresh its display at this call, and it will
                continue to update its display as items are added/removed.
*)

PROCEDURE ListClientGetColumnWidth(w : Window; column : CARDINAL) : INTEGER;
(* return the width of the specified column. returns -1 if and error occurs.
   an error can be that the column number was invalid.
   a column size of zero means the column is hidden.
*)

PROCEDURE ListClientSetColumnWidth(w : Window; column : CARDINAL; width : INTEGER);
(* set the column width.
   width = -1 = the column will be autosized to the contents of the column.
   otherwise the width is in pixels.
*)

PROCEDURE ListClientSetSortColumn(w : Window; column : INTEGER; dir : SortDirection);
(* sets the sort column and direction and resorts the list based on the new information.
   a column < 0 indicates that sorting is no longer performed.
*)

PROCEDURE ListClientGetSortColumn(w : Window;
                                  VAR OUT column : INTEGER;
                                  VAR OUT dir : SortDirection);
(* gets the current sort column and direction. *)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

PROCEDURE TreeClientInsertNode(w : Window; item : TreeClientInsertRec) : TreeClientNode;
(* insert a new item into the list.
   returns the index position of the inserted location.
   returns -1 if the insert failed.
*)

PROCEDURE TreeClientSetNodeText(w : Window;
                                node : TreeClientNode;
                                text : ARRAY OF CHAR);
(* set the text of a specific node. text must be null terminated. *)

PROCEDURE TreeClientGetNodeText(w : Window;
                                node : TreeClientNode;
                                VAR OUT text : ARRAY OF CHAR);
(* get the text of a specific node. *)

PROCEDURE TreeClientGetNodeData(w : Window; node : TreeClientNode) : ADDRESS;
(* fetch the user defined data for the specified node. *)

PROCEDURE TreeClientSetNodeData(w : Window; node : TreeClientNode; data : ADDRESS);
(* set the user defined data for the specified node. *)

PROCEDURE TreeClientGetSelectedNode(w : Window) : TreeClientNode;
(* get the selected item selected in the tree.
   NIL is returned if no node is currently selected.
*)

PROCEDURE TreeClientSetSelectedNode(w : Window; sel : TreeClientNode) : BOOLEAN;
(* the the specified item to the selected state. *)

PROCEDURE TreeClientExpandNode(w : Window;
                               node : TreeClientNode;
                               yes : BOOLEAN) : BOOLEAN;
(* if yes = TRUE then expand the specified node if possible.
   otherwise collapse the node.
*)

PROCEDURE TreeClientSortNode(w : Window;
                             node : TreeClientNode;
                             recurse : BOOLEAN);
(* sorts the children of the specified node. if recurse = TRUE then all nodes which
   are decendents of the specified node will be sorted.
*)

PROCEDURE TreeClientRemoveNode(w : Window; node : TreeClientNode);
(* remove the specified node from the tree *)

PROCEDURE TreeClientRemoveAllNodes(w : Window);
(* remove all content from the tree *)

PROCEDURE TreeClientFreezeDisplay(w : Window; yes : BOOLEAN);
(* yes = TRUE = causes the window to not redraw itself when an item is added/removed
                from the tree. this is useful when adding/removing a number of items.
  yes = FALSE = causes the window to refresh its display at this call, and it will
                continue to update its display as items are added/removed.
*)

PROCEDURE TreeClientRootNode(w : Window) : TreeClientNode;
PROCEDURE TreeClientGetChildNode(w : Window; node : TreeClientNode) : TreeClientNode;
PROCEDURE TreeClientGetParentNode(w : Window; node : TreeClientNode) : TreeClientNode;
PROCEDURE TreeClientNextSiblingNode(w : Window; node : TreeClientNode) : TreeClientNode;
PROCEDURE TreeClientPrevSiblingNode(w : Window; node : TreeClientNode) : TreeClientNode;
PROCEDURE TreeClientNodeIsVisible(w : Window; node : TreeClientNode) : BOOLEAN;
(* basically the proceduure names are self expanatory *)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

(* ---------------------------------------- *)
(* for the following APIs accessing controls.
   w = a ChildWindow of client type FormClient, or
       a Toplevel window with a FormClient.

   ctrlId = the id number identifying the control.

   input string parameters MUST be null terminated.
*)

PROCEDURE AddFormControls(w : Window; controls : ARRAY OF ControlProperties);
(*
   create a series of new controls in the FormClient window w.
   controls = the various controls to be displayed in the FormClient.
*)

PROCEDURE FormToPixel(w : Window; VAR INOUT x, y : COORDINATE);
PROCEDURE PixelToForm(w : Window; VAR INOUT x, y : COORDINATE);
(* utility procedures to convert to/from form/pixel coordinates. *)

PROCEDURE RemoveControl(w : Window; ctrlId : CARDINAL) : BOOLEAN;
(* returns TRUE if successful *)

PROCEDURE RemoveAllControls(w : Window);
(* obvious *)

PROCEDURE StartFormEditMode(w : Window;
                            usePopupMenu : BOOLEAN;
                            popupMenu : ARRAY OF CHAR;
                            newControlProc : NewControlProc;
                            propProc : ControlPropertiesProc;
                            exitProc : ControlEndEditProc);
(*
  usePopupMenu = TRUE the form editor will enable use of the popup menu.
                 the popup menu is activated via a right click.
                 on the Mac you use an option click if you do not have a two button
                 mouse.

  menu = the popup menu used by the form editor if usePopupMenu = TRUE.
         if menu = "" then a default menu is used which supports all functions.

  propProc = a procedure which is called when the user double clicks on a
               control. Here you can display a dialog which allows the user to modify
               some or all of the attributes of the control.

               the current control properties are passed in the ControlProperties
               parameter.
               to change the control properties simply change the fields in the
               control.

               For TopLevelWindow forms you can edit the form caption title.
                   this is editied like a normal control.
                   it is identitied as a TextLabel control with an
                   id number of MAX(CARDINAL). therefore you cannot
                   have a TextLabel with such an id number and
                   support form editing of the form title.

               if propProc returns TRUE then changes in the ControlProperties
               parameter will take effect. otherwise any changes are ignored.

    newControlProc = a procedure which is called when the user creates a new
                control from the context menu.
                some initial default values are set for the control.
                with this procedure you are given the opportunity to set the
                initial values of the control by changing the values in the
                ControlProperties parameter.

    for both propProc and newControlProc
           you cannot change the control type field.

           if you change any of the StringData fields you should call
           DisposeStringData with the current value before assigning a new value
           otherwise the old value will be leaked (memory leak).

           memory fields in the ControlProperties data structure are deallocated
           by this module, therefore your memory allocations should be comparible
           with this module. this module exports APIs to manipulate the StringData
           type and generaic memory allocation functions.

    exitProc = called when the user wants to end editing.
                you can use this to call EndFormEditMode and retrieve any changes
                the user may have made by using GetControlProperties.

    the internal form editor supports selection of single controls by clicking on them
    with the left mouse button.
    multiple controls can be selected by using a Shift+Click, or by dragging a rectangle
    surrounding the controls to be selected.

    a selected control is displayed with a surrounding hatch pattern and six
    "drag handles" which are used to resize the control.

    for multiple selections one control is the primary selection and the others
    are secondary selections. the primary selection has white drag handles and the
    others have black drag handles. you can change the primary selection within
    a multiple selection by clicking the desired control.
    you can clear a multiple selection by clicking on a blank area in the form. the
    primary selection will remain selected.

    with single selections you can size and/or move the control.
    with multiple selections you can only move the controls. all selected controls
    move together maintaining their positional relationship.

    moving a control into a page of a MultiPage control binds that control to the
        active page of the control. moving a control out of a page will unbind the
        control from the page.

    double clicking on a control opens the control properties dialog.

    the Tab, Shift_Tab keys cycle through the controls. This cycle displays the tab
    order of the controls.

    pressing the delete key deletes the the selected control.

    menuCommands
        the form editor supports various editing actions which are selected via
        a popup context menu. you control what actions are available by what you
        place in the context menu. you must use the ids provided by this module
        as the menu identifiers for the specific actions.
*)

PROCEDURE ExecuteFormEditorMenuCommand(w : Window; menuId : CARDINAL);
(* this API lets you put form editor menu actions on your application menubar.
   the menu id command numbers for each action supported are listed in the DEF file.
   this API does nothing unless the ForClient is currently in edit mode.
*)

PROCEDURE EnableFormEditorMenuItems(w : Window);
(* you use this procedure to enable/disable menu items on your menubar. the popup
   automatically handles this.

   the menu items are assumed to be on the menu for the Toplevel Window of "w".
*)

PROCEDURE EndFormEditMode(w : Window) : BOOLEAN;
(* the name says it all
   returns TRUE is any changes were made to the form.
*)

PROCEDURE GetControlCount(w : Window; includeContainerChildren : BOOLEAN) : CARDINAL;
(* w must be a toplevel window with a FormClient as its client, or a child window.
   returns the number of controls in the form.
   if includeContainerChildren = FALSE, then the value returned does not include
       controls contained within container controls (MultiPage, GroupBox).
       this can be useful to allocate an array big enough to use with the
       GetControlInfo API.
   otherwise the value returned includes all controls in the form.
*)

PROCEDURE GetControlInfo(w : Window; VAR OUT controls : ARRAY OF ControlProperties);
PROCEDURE DisposeControlInfo(VAR INOUT controls : ARRAY OF ControlProperties);
(*
  return control information on controls in the FormCient window.
  useful when using the form edit mode.

  any StringData pointers have been allocated and should be deallocated when no
  longer needed.
  this also holds true for the ListBox lb_ColumnInfo field.
  DisposeControlInfo is a handle call to do this for you.
*)

PROCEDURE ControlSetEditLimit(w : Window; ctrlId : CARDINAL; limit : CARDINAL);
(*
  for use with TextEdit and ComboBox controls.
  set the maximum number of characters a user is allowed to enter into
  the control.
  a value of zero defines an operating system defined default limit.
*)

PROCEDURE ControlSetEditable(w : Window; ctrlId : CARDINAL; yes : BOOLEAN);
(*
  for use with TextEdit and SpinButton controls.
  yes = the control is user editable
*)

PROCEDURE ControlSetTipText(w : Window; ctrlId : CARDINAL; text : ARRAY OF CHAR);
PROCEDURE ControlGetTipText(w : Window; ctrlId : CARDINAL; VAR OUT text : ARRAY OF CHAR);
(* get or set the tooltip text of the control. *)

PROCEDURE ControlSetText(w : Window; ctrlId : CARDINAL; text : ARRAY OF CHAR);
PROCEDURE ControlGetText(w : Window; ctrlId : CARDINAL; VAR OUT text : ARRAY OF CHAR);
(*
    for use with the following controls.
        PushButton, ToggleButton, CheckBox, RadioButton:
        DropDownList: = GetText = text of selected item for GetText.
                        SetText = change the selection by matching the given text
                                  to the list.
        ComboBox:
        TextEdit:
        TextLabel:
        ListBox: = GetText = text of selected item for GetText.
                   SetText = change the selection by matching the given text
                             to the list.

*)

PROCEDURE ControlGetTextLength(w : Window; ctrlId : CARDINAL) : INTEGER;
(* -1 (< 0), means the text length is indeterminate. *)

PROCEDURE ControlSetNumericValue(w : Window; ctrlId : CARDINAL; num : INTEGER);
PROCEDURE ControlGetNumericValue(w : Window;
                                 ctrlId : CARDINAL;
                                 VAR OUT num : INTEGER) : BOOLEAN;
(*
  primarily for use on SpiButton controls but you can use the "set" API on
  edit controls and text labels.

  GetNumericValue may return FALSE if the control text is not a valid number.
*)

PROCEDURE ControlSetSelectedItem(w : Window;
                                 ctrlId : CARDINAL;
                                 sel : CARDINAL) : BOOLEAN;
PROCEDURE ControlGetSelectedItem(w : Window; ctrlId : CARDINAL) : INTEGER;
(* for use with ListBox, DropDownList, ComboBox and MultiPage controls.
   -1 (< 0), = no selection. otherwise selection is zero based.
*)

PROCEDURE ControlGetSelectedItemCount(w : Window; ctrlId : CARDINAL) : CARDINAL;
(* for use with a MultiSelect ListBox.
   get the number of selected items in the list.
*)

PROCEDURE ControlGetSelectedItems(w : Window;
                                  ctrlId : CARDINAL;
                                  VAR OUT items : ARRAY OF CARDINAL) : CARDINAL;
(* for use with a MultiSelect ListBox.
   return an array of the selected iteem indexes.
   the return value is the number of items stored in the array.
*)

PROCEDURE ControlSetButtonState(w : Window;
                                ctrlId : CARDINAL;
                                checked : BOOLEAN);
PROCEDURE ControlGetButtonState(w : Window; ctrlId : CARDINAL) : BOOLEAN;
(* for CheckBox, TRUE = checked.
   for ToggleButton, TRUE = pressed/down
   for PushButton, for Set, TRUE = simulate a mouse click. FALSE is ignored.
                   for Get, this always results in FALSE.
   for RadioButton, for Set, checked = TRUE, is just like using SetRadioGroup.
                             check = FALSE is ignored.
                    for Get, returns the button state. TRUE = checked.
*)

PROCEDURE ControlSetDefaultButton(w : Window; ctrlId : CARDINAL);
(* only for PushButton controls. sets the default push button. *)

PROCEDURE ControlSetRadioGroup(w : Window; group : CARDINAL; ctrlId : CARDINAL);
(* ctrlId = the radio button in the group which should be checked.
   if the button identified by ctrlId is not in the group, "group" then
   no action is taken.
*)

PROCEDURE ControlGetRadioGroup(w : Window; group : CARDINAL) : CARDINAL;
(* returns the id number of the checked radio button of the specified group *)

PROCEDURE ControlAppendItem(w : Window;
                            ctrlId : CARDINAL;
                            text : ARRAY OF CHAR) : INTEGER;
(* for use with ListBox, DropDownList and ComboBox controls.
   adds a new item to the end of the list of items.
   if the ListBox has multiple columns, then this call places the text
   in the first column.
   the return value is the index position of the added item.
   index positions are zero based.
*)

PROCEDURE ControlAppendItemColumns(w : Window;
                                   ctrlId : CARDINAL;
                                   strs : ARRAY OF StringData) : INTEGER;
(* for use with multi column ListBox controls.
   adds a new item to the end of the list of items.
   the return value is the index position of the added item.
   index positions are zero based.
*)

PROCEDURE ControlInsertItem(w : Window;
                            ctrlId : CARDINAL;
                            position : CARDINAL;
                            text : ARRAY OF CHAR) : INTEGER;
(* for use with ListBox, DropDownList and ComboBox controls.
   inserts an item into the specified position.
   if the ListBox has multiple columns, then this call places the text
   in the first column.
   the return value is the index position of the added item.
   index positions are zero based.
*)

PROCEDURE ControlInsertItemColumns(w : Window;
                                   ctrlId : CARDINAL;
                                   position : CARDINAL;
                                   strs : ARRAY OF StringData) : INTEGER;
(* for use with multi column ListBox controls.
   inserts a new item into the specified position.
   the return value is the index position of the added item.
   index positions are zero based.
*)

PROCEDURE ControlSetItemText(w : Window;
                             ctrlId : CARDINAL;
                             item, column : CARDINAL;
                             text : ARRAY OF CHAR);
PROCEDURE ControlGetItemText(w : Window;
                             ctrlId : CARDINAL;
                             item, column : CARDINAL;
                             VAR OUT text : ARRAY OF CHAR);
(* for use with ListBox, ColumnListBox, DropDownList and ComboBox.
   sets/gets the text of a specific column.
   item = the "row" index position. zero based.
   column = the column to place the text. zero based. ignored if not applicable.
*)

PROCEDURE ControlGetItemCount(w : Window; ctrlId : CARDINAL) : CARDINAL;
(* returns the number of items in a ListBox, DropDownList or ComboBox *)

PROCEDURE ControlRemoveItem(w : Window; ctrlId : CARDINAL; item : CARDINAL);
(* for use with ListBox, DropDownList and ComboBox controls.
   item = the position index of the item to remove.
   index positions are zero based.
*)

PROCEDURE ControlGetItemData(w : Window; ctrlId : CARDINAL; item : CARDINAL) : ADDRESS;
(* applicable to ListBox controls.
   fetch the user defined data for the specified row.
*)

PROCEDURE ControlSetItemData(w : Window;
                             ctrlId : CARDINAL;
                             item : CARDINAL;
                             data : ADDRESS);
(* applicable to ListBox controls.
   set the user defined data for the specified row.
*)

PROCEDURE ControlFindItemByData(w : Window; ctrlId : CARDINAL; data : ADDRESS) : INTEGER;
(* applicable to ListBox controls.
   find an item in the list by comparing with the user data item
   you previosly set.
   If you insert/delete items the index position returned at the time of
   insertion may be invalid.
   If the list is sorted then the index position can change at any time so you cannot
   rely on the index position returned at the time of insertion.

   RETURNs -1 if the item is not found, otherwise the current index position of the item.
*)

PROCEDURE ControlRemoveAllItems(w : Window; ctrlId : CARDINAL);
(* for use with ListBox, DropDownList and ComboBox controls *)

PROCEDURE ControlSetColumnWidth(w : Window;
                                ctrlId : CARDINAL;
                                column : INTEGER;
                                width : INTEGER);
(* for use with multi column ListBox controls.
   if width < 0 then the column width will be set optimally for the existing text
   in the list column and header.
   the width is in form Units.
   if column < 0 then all columns of the control are given the specified width.
*)

PROCEDURE ControlAppendText(w : Window;
                            ctrlId : CARDINAL;
                            text : ARRAY OF CHAR);
(* for use with multi line TextEdit controls.
   appends the given text at the end of the text in the control.
*)

PROCEDURE ControlAppendLine(w : Window;
                            ctrlId : CARDINAL;
                            text : ARRAY OF CHAR);
(* for use with multi line TextEdit controls.
   appends the given text and a end of line at the end of the text in the control.
*)

PROCEDURE ControlGetLineCount(w : Window; ctrlId : CARDINAL) : CARDINAL;
(* for use with multi line TextEdit controls.
   returns the number of lines of text in the control.
*)

PROCEDURE ControlGetLineLength(w : Window;
                               ctrlId : CARDINAL;
                               lineNum : CARDINAL) : CARDINAL;
(* for use with multi line TextEdit controls.
   returns the length if characters of the specified line in the control.
   the first line of text is line number 1.
*)

PROCEDURE ControlGetLineText(w : Window;
                             ctrlId : CARDINAL;
                             lineNum : CARDINAL;
                             VAR OUT text : ARRAY OF CHAR);
(* for use with multi line TextEdit controls.
   gets the text of the specified line in the control.
   the first line of text is line number 1.
*)

PROCEDURE ControlSetLineText(w : Window;
                             ctrlId : CARDINAL;
                             lineNum : CARDINAL;
                             text : ARRAY OF CHAR);
(* for use with multi line TextEdit controls.
   sets the text of the specified line in the control.
   the first line of text is line number 1.
*)

PROCEDURE ControlRemoveLine(w : Window;
                            ctrlId : CARDINAL;
                            lineNum : CARDINAL);
(* for use with multi line TextEdit controls.
   removes the line of text from the control.
   the first line of text is line number 1.
*)

PROCEDURE ControlPositionCaret(w : Window; ctrlId : CARDINAL; lineNum, column : CARDINAL);
(* for use with multi line TextEdit controls.
   positions the text caret and ensures that the text caret is visible within the control
   window. this is useful when you are adding/removing text from the control.
   lineNum = MAX(CARDINAL) will always position to the last line.
*)

PROCEDURE ControlRedraw(w : Window; ctrlId : CARDINAL; yes : BOOLEAN);
(* yes = TRUE the control will redraw itself when its contents change.
   you use this call when making numerous changes to a control to improve
   performance by disabling redraws until you are done changing the control.

   only applicable to ListBox and ComboBox controls.
*)

PROCEDURE ControlEnable(w : Window; ctrlId : CARDINAL; yes : BOOLEAN);
(* yes = TRUE the control is enabled, otherwise disabled *)

PROCEDURE ControlShow(w : Window; ctrlId : CARDINAL; yes : BOOLEAN);
(* yes = TRUE the control is visible, otherwise hidden *)

PROCEDURE ControlSetFocus(w : Window; ctrlId : CARDINAL);
(* set the input focus to the specified control *)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

PROCEDURE Beep(beep : Beeps);
(* make a sound on the computer.
   beep = various sound signatures.
          typically the specific sound that is made is controlled by the user,
          if the underlying system supports such things.
          if not then all beeps will sound the same...just a simple beep.
*)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

(* functions that export native operating system handles/values.
   these functions are not part of the WinShell API.
   they are here to allow "special" actions to be performed when necessary
   and to allow someone to encapsulate additional functionality in a
   different module.
*)

PROCEDURE GetWindowHandle(w : Window) : ADDRESS;
(* get the operating system handle for specified toplevel window.
   Win32 - a window handle. HWND
   GTK - a Widget handle. specifically pGtkWindow.
   Mac - a window handle. WindowRef.
*)

PROCEDURE GetClientHandle(w : Window) : ADDRESS;
(* get the operating system handle for the client "window"
   of the specified window.
   Win32 - a window handle. HWND
        ListClient => ListView
        TreeClient => TreeView
        TabClient => Tab Control
   GTK - a Widget handle.
        DrawClient => pGtkDrawingArea
        ListClient => pGtkCList
        TreeClient => pGtkCTree
        FormClient => pGtkFixed
        TabClient => pGtkNotebook
        SplitterClient => pGtkHPaned or pGtkVPaned
   Mac - a control handle. ControlRef.
        DrawClient => User Pane
        ListClient => DataBrowser
        TreeClient => DataBrowser
        FormClient => User Pane
        TabClient => Tab Control
        SplitterClient => User Pane
*)

PROCEDURE GetDrawableHandle(draw : Drawable) : ADDRESS;
(* for Win32 - return the HDC handle.
   for GTK - return the GDK drawable handle.
   for Mac - return the port handle.
*)

PROCEDURE CreateExternalWindowHandle(wnd : ADDRESS) : Window;
(* this API has one use. to be able to have a window external to this module
   be the parent window of a WinShell window.
   the handle is automatically disposed by this module.

   wnd should be an operating system toplevel window handle.
*)

<*IF StonyBrook THEN*>
%IF WIN32 %THEN
PROCEDURE SetModelessDialog(wnd : ADDRESS; add : BOOLEAN) : BOOLEAN;
(* This procedure is here to support DlgShell in Win32
   wnd = the operating system window handle of the modeless dialog
   add = TRUE then you are adding a new dialog to the message loop
         FALSE then you are remove a dialog from the message loop
   returns TRUE if successful
*)
%ELSIF UNIX %THEN
PROCEDURE FocusedWindowEvent(w : Window; yes : BOOLEAN);
(* here for DlgShell and BasicDialogs to support WinShell with focus
   notifications. WinShell uses this to simulate the WSM_ACTIVATEAPP
   message.
   yes = Focus in event
   no = Focus out event

   w = NIL, means than WinShell.MainWindow will be the window used, otherwise
   the toplevel window of "w" will be the window that receives the message.
*)
%END
<*END*>

END WinShell.

(***************************************************************************)
(*                                                                         *)
(*                     Copyright (C) 1992-2004                             *)
(*                        by Stony Brook Software                          *)
(*                                                                         *)
(*                          All rights reserved.                           *)
(*                                                                         *)
(***************************************************************************)
DEFINITION MODULE TextWindows;
(* this module is its own self contained system built on top of WinShell *)
(* for convenience  this module re-exports most WinShell symbols by the *)
(* same name as they exist in WinShell *)
(* this module provides for very high level windows that display text *)
(* within their client area *)
(* this module fully automates painting and scroll bars for text windows *)
(* manual control is available for applications where automatic control *)
(* is not suitable *)

(*
   For automatic control this module defines a virtual coordinate system.
   For the purposes of this description we will use the analogy of a text
   editor, something you should be familiar with. Also we will only discuss
   the Y or vertical coordinate. The width or X coordinate operates precisely
   the same way as the Y.
   We have a text editor using this module. We open a file with 5000 lines
   of text. Also assume that the window is sized such that 25 lines of text
   can be displayed. Our virtual coordinate range for this file is 0..4999.
   We set a virtual coordinate range by using the SetScrollRangeAllowed API.
   With this module our text editor never knows what exactly is being
   displayed in the window or exactly where the text caret(cursor) is
   positioned. It can inquire about this but there is no need.
   We open the file and put the text caret at position 0, 0.
   When we first open the file we will receive a paint message for coordinates
   0..24. If the user scrolls the window down one line we will get a paint
   message for coordinate 25. You should get the idea what is going on here.
   The text caret is still at position 0, 0 which is no longer visible in the
   window since the user scrolled the window down one line and the window
   is now displaying the coordinates 1..25. The text window already has the text for
   coordinates 1..24 buffered so it simply scrolls its text buffer and asks you to paint
   the text for coordinate 25.
   Lets say the user performed a text search and we need to display the
   matched text to the user. We simply set the text caret position to the
   proper virtual coordinate, lets say line 2000 column 1, and then tell
   the text window system to make sure the text caret is visible the
   window. That will cause the window to scroll in the proper direction to the
   proper virtual coordinates and you will receive any paint messages necessary to
   display the text in that coordinate area. for example, if the coordinate is already
   visible then no scrolling will occur.
   The basic point here is that once a virtual coordinate is set up the
   text window asks you to paint certain coordinates, and it worries about
   what and where that information is displayed in the window. You have
   available to you certain API calls to make a given coordinate/range visible
   within the window if/when necessary.

   The chain of command here is the user tells the text window what to do,
   and the text window tells your code what to do.
*)
(*
  this module operates with three coordinate systems overlaid on top of
  each other.
  Virtual space >= Screen buffer space >= Visible window space
  this module maintains a "screen buffer" for each window to hold any text
  painted to minimize paint requests to your code when the operating system
  is asking the window to paint. this screen buffer can be a fixed size or
  it can assume whatever size fits within the visible area of the window.
  if the screen buffer is variable in size then in essence you fold down to
  two coordinate systems since the screen buffer and window are exactly the
  same size and at the same position.
  You only need to worry about the virtual coordinate space, but you should
  know something about the others to use a few of the API calls in this module.
  The screen buffer is basically a sliding window into the virtual coordinate
  space. The visible window is a sliding window into the screen buffer
  coordinate space.

  If manual scrolling is used then these coordinate spaces have no real
  meaning since nothing ever moves in the coordinate space. You are always
  at the top of the coordinate space. You have to maintain your own
  information about where you are currently displaying in your "document".
*)

<*/NOPACK*>

FROM SYSTEM IMPORT
    ADDRESS, CAST;

IMPORT WinShell;

TYPE
    (* text windows simply re-exports WinShell types and constants *)
    (* for convenience *)

    WindowTypes         = WinShell.WindowTypes;
    COORDINATE          = WinShell.COORDINATE;
    twPOINT             = WinShell.wsPOINT;
    twRECT              = WinShell.wsRECT;
    KeyStateType        = WinShell.KeyStateType;
    KeyStateSet         = WinShell.KeyStateSet;
    CloseModes          = WinShell.CloseModes;
    MouseButton         = WinShell.MouseButton;
    MouseEventType      = WinShell.MouseEventType;
    MouseStateType      = WinShell.MouseStateType;
    MouseStateSet       = WinShell.MouseStateSet;
    ScrollDirection     = WinShell.ScrollDirection;
    ScrollClass         = WinShell.ScrollClass;

    ScrollRange         = COORDINATE[0..MAX(COORDINATE)];

    SizeType            = WinShell.SizeType;
    WinAttr             = WinShell.WinAttr;
    WinAttrSet          = WinShell.WinAttrSet;

CONST
    TOOLBAR_SEPARATOR   = WinShell.TOOLBAR_SEPARATOR;

TYPE
    StdToolbarBitmaps   = WinShell.StdToolbarBitmaps;
    ToolbarButtonTypes  = WinShell.ToolbarButtonTypes;
    ToolbarButtonInfo   = WinShell.ToolbarButtonInfo;

    SpecialKeys         = WinShell.SpecialKeys;
    ResponseType        = WinShell.ResponseType;

    ClipboardFormat     = WinShell.ClipboardFormat;
    HelpCommand         = WinShell.HelpCommand;
    MenuHandle          = WinShell.MenuHandle;
    FontInfo            = WinShell.FontInfo;
    FontWeights         = WinShell.FontWeights;
    CharacterSets       = WinShell.CharacterSets;
    PrintDriverInfo     = WinShell.PrintDriverInfo;

    CursorTypes         = WinShell.CursorTypes;
    CaretTypes          = WinShell.CaretTypes;
    DisplayModes        = WinShell.DisplayModes;
    Beeps               = WinShell.Beeps;
    WindowDisplayInfo   = WinShell.WindowDisplayInfo;

CONST
    NormalWindow        = WinShell.NormalWindow;
    NormalChildWindow   = WinShell.NormalChildWindow;

    AddVScrollBar       = WinAttrSet{WinShell.WA_VSCROLL,
                                     WinShell.WA_VSCROLLTRACK};
    AddHScrollBar       = WinAttrSet{WinShell.WA_HSCROLL,
                                     WinShell.WA_HSCROLLTRACK};
    AddScrollBars       = AddHScrollBar + AddVScrollBar;
    AddStatusLine       = WinAttrSet{WinShell.WA_STATUSLINE};
    AddSplitPos2        = WinShell.AddSplitPos2;

TYPE
    TextWindow;

    ScreenAttribute     = CARDINAL16;(* magic cookie *)

    Cell = (* the format of an individual text character cell *)
        RECORD
        ch      : CHAR;
        attr    : ScreenAttribute;
        END;

    TextWindowsMsg      = (
                            TWM_CREATE,
                            TWM_GAINFOCUS,
                            TWM_LOSEFOCUS,
                            TWM_ACTIVATEAPP,
                            TWM_DEACTIVATEAPP,
                            TWM_MOUSE,
                            TWM_KEY,
                            TWM_CLOSE,
                            TWM_MENU,
                            TWM_MENUSELECT,
                            TWM_MENUSTART,
                            TWM_MENUEND,
                            TWM_TAB_ACTIVE,
                            TWM_PAINT,
                            TWM_SIZE,
                            TWM_POSITIONCHANGED,
                            TWM_SCROLL,
                            TWM_NOTIFYSCROLL,
                            TWM_TIMER,
                            TWM_USER
                          );

(******************** Message Definitions ************************************
    TWM_CREATE          same as WinShell
    TWM_GAINFOCUS       same as WinShell
    TWM_LOSEFOCUS       same as WinShell
    TWM_TABACTIVE       same as WinShell
    WSM_ACTIVATEAPP     same as WinShell
    WSM_DEACTIVATEAPP   same as WinShell
    TWM_KEY             same as WinShell
    TWM_CLOSE           same as WinShell
    TWM_MENU            same as WinShell
    TWM_MENUSELECT      same as WinShell
    TWM_STARTMENU       same as WinShell
    TWM_ENDMENU         same as WinShell
    TWM_TIMER           same as WinShell
    TWM_USER            same as WinShell
    TWM_SCROLL          same as WinShell
    TWM_POSITIONCHANGED same as WinShell

    TWM_MOUSE           this window received a mouse event
        m_pos = Window Coordinates of click in text cells, not pixels
        m_button = Which button the event is for
        m_event = the type of event
        m_state = the state of various other keys at the time of the mouse event
        m_wheel = the mouse wheel movement. positive is forward towards the front
                of the mouse. This value is scroll increments.
                1 = one scroll increment

    TWM_PAINT           this window needs repainting
        paintRect = rectangle of region that needs to be painted
               this is in text cells, not pixels

    TWM_SIZE            the size of this window is/has changed
        sizeType = as WinShell
        wasMinimized = as WinShell
        width = the new width in text cells, not pixels
        height = the new height in text cells, not pixels

            for variable buffer windows the size is changing and a
                paint message will follow this message
            for fixed buffer windows the size has changed
                can be used to set the page size

    TWM_NOTIFYSCROLL    notification that the window has automatically
                        scrolled in some way.

*****************************************************************************)

    TWMessageRec =
        RECORD
        CASE msg : TextWindowsMsg OF
        TWM_GAINFOCUS, TWM_LOSEFOCUS,
        TWM_MENUSTART, TWM_MENUEND,
        TWM_ACTIVATEAPP, TWM_DEACTIVATEAPP,
        TWM_TAB_ACTIVE,
        TWM_NOTIFYSCROLL:
            (* no data for these *)
        |
        TWM_CREATE:
            createParam : ADDRESS;
        |
        TWM_MOUSE:
            m_pos       : twPOINT;
            m_wheel     : INTEGER;
            m_button    : MouseButton;
            m_event     : MouseEventType;
            m_state     : MouseStateSet;
        |
        TWM_KEY:
            k_count     : CARDINAL;
            k_special   : SpecialKeys;
            k_state     : KeyStateSet;
            k_ch        : CHAR;
        |
        TWM_CLOSE:
            closeMode   : CloseModes;
        |
        TWM_MENUSELECT,
        TWM_MENU:
            menuId      : INTEGER;
            accel       : BOOLEAN; (* used only with MENU *)
        |
        TWM_PAINT:
            paintRect   : twRECT;
        |
        TWM_SIZE:
            sizeType            : SizeType;
            width               : COORDINATE;
            height              : COORDINATE;
            wasMinimized        : BOOLEAN;
        |
        TWM_POSITIONCHANGED:
            windowPos   : WinShell.wsPOINT;
        |
        TWM_SCROLL:
            scrollDir   : ScrollDirection;
            scrollClass : ScrollClass;
            scrollPos   : ScrollRange;
        |
        TWM_TIMER:
            timerId     : CARDINAL;
        |
        TWM_USER:
            userId      : CARDINAL;
            userData: ADDRESS;
        END;
    END;

    TextWindowProcedure = PROCEDURE(TextWindow, TWMessageRec) : ResponseType;

    (* colors available in a text window *)
    Colors      = (
                    Black,
                    Blue,
                    Green,
                    Cyan,
                    Red,
                    Purple,
                    Brown,
                    DarkGray,
                    LightGray,
                    LightBlue,
                    LightGreen,
                    LightCyan,
                    LightRed,
                    Magenta,
                    Yellow,
                    White
                );

    (* font styles available in a text window *)
    FontStyles = (FsItalic, FsBold);
    FontStyleSet = PACKEDSET OF FontStyles;

    ColorValue  = WinShell.ColorValue;
    ColorTable = ARRAY Colors OF ColorValue;

CONST
    NormalFont  = FontStyleSet{};
    BoldFont    = FontStyleSet{FsBold};
    ItalicFont  = FontStyleSet{FsItalic};

    NullTextWnd = CAST(TextWindowProcedure, NIL);

VAR
    StartupDisplayMode  : DisplayModes;(* same as WinShell *)
    DefaultFontInfo     : FontInfo;(* the default font that a text window
                                      will use *)

%IF DLL %THEN
<*/EXPORTALL/PROPAGATEEXCEPTIONALL/COPYATTRIBUTES*>
%END

PROCEDURE WinShellToTextWindowMessage(wmsg : WinShell.MessageRec;
                                      VAR OUT msg : TWMessageRec) : BOOLEAN;
(* convert a WinShell message to a TextWindow message *)
(* not all message types can be converted *)
(* returns TRUE if successful *)

PROCEDURE CreateWindow(parent : WinShell.Window;
                       name : ARRAY OF CHAR;
                       menu : ARRAY OF CHAR;
                       icon : ARRAY OF CHAR;
                       x, y : COORDINATE;
                       xSize, ySize : COORDINATE;
                       xBuffer, yBuffer : COORDINATE;
                       gutter : BOOLEAN;
                       font : FontInfo;
                       background : ScreenAttribute;
                       windowType : WindowTypes;
                       wndProc : TextWindowProcedure;
                       attribs : WinAttrSet;
                       createParam : ADDRESS) : TextWindow;
(* create a new window *)
(* parent = as WinShell  *)
(* name = as WinShell  *)
(* menu = the menu for the window. Can be "". *)
(* icon =  as WinShell *)
(* attribs = as WinShell *)
(* wndProc = the window procedure *)
(* createParam = an arbitrary value you can use to pass information
                 to the window procedure of the window. this value is
                 passed in the WSM_CREATE message. *)
(* font = the font to use for this window *)
(* background = the background color for this window *)
(* gutter = TRUE then the text window will always have a blank "gutter"
            on the left edge of the text window.
            FALSE the text will start at the left edge of the client area.
            *)
(* x, y = only applicable for Toplevel windows.
          the initial screen coordinates for the window to be displayed
          if a parameter is -1 then the operating system will choose
          a default location for that coordinate. *)
(* xSize, ySize = only applicable for Toplevel windows.
                  the initial width and height in character cells
                  if -1 then a system default size will be used *)
(* xBuffer, yBuffer = the size of the screen buffer. the window can never
                      be larger than the screen buffer. if either xBuffer
                      or yBuffer is -1 the screen buffer is a variable size
                      and is sized to the number of cells the window client
                      area currently is capable displaying.
                      the "normal" mode is to use a variable size buffer (-1).
                      if you are creating a ChildWindow then you should use a variable
                      buffer since you do not have control over the size of the window.
                      *)
(* returns the window handle if successfull, otherwise NIL*)

PROCEDURE SplitWindow(tw : TextWindow;
                      wndProc : WinShell.WindowProcedure;
                      splitY : BOOLEAN;
                      VAR OUT splitter : WinShell.Window);
(*
  tw can be a toplevel window or a child window.
  if splitY = TRUE the the window will be split into a top and bottom halves.

  on return
  tw becomes a child window of the newly created splitter.
  splitter has a clientType of SplitterClient.
      wndProc is the window procedure for this window.
*)

PROCEDURE UnsplitWindow(splitter : WinShell.Window; keepChild : TextWindow);
(*
   splitter must have a client type of SplitterClient.
   keepChild must currently be a child of the splitter window.
   If splitter is a top level window then keepChild becomes a top level window.
   Otherwise, keepChild becomes a child of the splitters parent.
   splitter is invalid after this call.
*)

PROCEDURE ConvertTabChildToTopLevel(tw : TextWindow) : BOOLEAN;
(* convert the Tab child window to a Toplevel window.
   if the frame window has a toolbar and/or statusline the new
   toplevel window will create copies of these for itself.
*)

PROCEDURE CycleActiveTabChild(tw : TextWindow; direction : INTEGER);
(*
  tw must be an Tab child window.
  if direction > 0 then the next tab child becomes the active child window.
  if direction < 0 then the previous tab child becomes the active child window.
*)

PROCEDURE CloseWindow(tw : TextWindow; mode : CloseModes) : BOOLEAN;
(* close an existing window.
   mode = CM_REQUEST you are requesting that the window close.
          for example this can give a window a change to prompt for saving any
          unsaved changes and possibly aborting the close.
   mode = CM_DICTATE the window *WILL* be closed
   returns TRUE if the window is closing *)

PROCEDURE IsTextWindow(tw : TextWindow) : BOOLEAN;
(* is the window handle passed in tw a valid window handle
   for example a window might have been closed and a copy of the window
   handle an application had stored somewhere may no longer be valid
   returns TRUE if the window handle is a valid text window *)

PROCEDURE GetTextWindowType(tw : TextWindow) : WindowTypes;
(* return the WindowType of the window *)

PROCEDURE SetWindowBackground(tw : TextWindow;
                              background : ScreenAttribute);
(* set the background color for the specified window *)

PROCEDURE GetWindowFont(tw : TextWindow; VAR OUT font : FontInfo);
(* get the font that is currently used by this window *)

PROCEDURE SetWindowFont(tw : TextWindow; font : FontInfo) : BOOLEAN;
(* set the font to be used for this window.
   returns TRUE if successful *)

PROCEDURE SetScrollRangeAllowed(tw : TextWindow;
                                which : WinAttr;
                                range : ScrollRange);
(* set the scroll range for the horizontal or vertical scroll bar
   range is the upper end of the scroll range. the lower end is always zero. *)

PROCEDURE SetScrollRangesAllowed(tw : TextWindow;
                                 rangeX, rangeY : ScrollRange);
(* set the scroll range for both the horizontal and vertical scroll bar.
   rangeX and rangeY respectively.
   rangeX and rangeY are the upper end of the scroll range. the lower end is
   always zero. *)

PROCEDURE SetPageSize(tw : TextWindow; x, y : ScrollRange);
(* set the granularity in character cells that a PAGE scroll operation should move.
   typically the page size is the visible dimension of the window minus one or
   two coordinates of overlap so that part of the previous page is visible on the
   new page.
*)

PROCEDURE SetAutoScroll(tw : TextWindow; on : BOOLEAN);
(* windows are created with the scroll bars handled automatically
   by this module, use this to disable and handle scroll bars manually
   on = TRUE then scroll bars are handled by this module
             you will never receive a TWM_SCROLL message
             you will receive TWM_SCROLLNOTIFY messages when this module
             automatically scrolls the window
        FALSE then you will receive TWM_SCROLL messages and should perform
              appropriate actions for the messages
              you will not receive TWM_NOTIFYSCROLL messages *)

PROCEDURE SetMinClientSize(tw : TextWindow; x, y : COORDINATE);
(* set the minimum size in character cells the specified window
   will be allowed to assume *)

PROCEDURE GetClientSize(tw : TextWindow; VAR OUT x, y : COORDINATE);
(* get the current size of the text area in character cells of the specified window *)

PROCEDURE SetClientSize(tw : TextWindow; x, y : COORDINATE);
(* set the current size of the text area in character cells of the specified window *)

PROCEDURE SnapWindowToFont(tw : TextWindow; on : BOOLEAN);
(* TRUE = window client area will be sized so that only full characters will be shown.
   FALSE = the bottom and/or right may have partial characters shown *)

PROCEDURE ResizeScreen(tw : TextWindow; xSize, ySize : COORDINATE) : BOOLEAN;
(* resize the screen buffer for the specified window
   if the window was create with -1 buffer size values this call has no
   effect. therefore only use this call on windows with fixed screen buffers
   returns TRUE if successful *)

PROCEDURE RedirectMessage(tw : TextWindow; msg : TWMessageRec);
(* this call simply passes the message to the window specified
   the window should be of the same thread as the window that received
   the message originally. Everything should work if not, but problems
   may occur. *)

PROCEDURE ScrollWindow(tw : TextWindow;
                       dir : ScrollDirection;
                       class  : ScrollClass;
                       pos : ScrollRange;
                       amount : COORDINATE);
(* scroll the window by the specified amount an direction.
   typically you would use this API when receiving keyboard input such as the
   up/down arrow keys and/or the PageUp/Down keys.

   dir can be LEFT, RIGHT, UP or DOWN
   class can be LINE, PAGE, ABSOLUTE or EXTREME
   pos is only used with a class of ABSOLUTE
   amount is used with LINE and PAGE and specifies how may scrolls to do
   ABSOLUTE is used with UP or LEFT and pos. Where pos specifies a
            absolute virtual coordinate for the upper left coordinate
            of the text window
   EXTREME is used with an ScrollDirection and position the screen
           at the extreme edge of the virtual coordinate space
*)

PROCEDURE ScrollBuffer(tw : TextWindow;
                       dir : ScrollDirection;
                       amount : CARDINAL);
(* scroll the data held in the screen buffer.
   you only use this if you are handling scrolling manually.

   the virtual coordinates of the screen buffer will not change.
   in manual scrolling the coordinates of the screen buffer never
   changes since it is your code that is handling this.
   use this call when performing manual scrolling.
   this call simply moves the data in the screen buffer and generates a
   paint message to fill in the resulting empty space
*)

PROCEDURE MoveCaretTo(tw : TextWindow; x, y : COORDINATE);
(* move the caret to the specified location in character cells
   a window need not have a caret for this function to work.
   the position is remembered and is used if/when the caret is turned on *)

PROCEDURE GetCaretPos(tw : TextWindow; VAR OUT x, y : COORDINATE);
(* get the current position of the text caret *)

PROCEDURE IsCaretVisible(tw : TextWindow) : BOOLEAN;
(* is the caret visible (where the user can see it) within the current window display.
   returns TRUE if the caret is visible
   manual scrolling windows have no use for this call *)

PROCEDURE MakeCaretVisible(tw : TextWindow);
(* make sure the caret is visible within the current window display.
   any necessary scroll actions will be performed.
   manual scrolling windows have no use for this call *)

PROCEDURE ComposeAttribute(fore, back : Colors;
                           style : FontStyleSet) : ScreenAttribute;
(* combine the various screen components into a screen attribute *)

PROCEDURE DecomposeAttribute(sc : ScreenAttribute;
                             VAR OUT fore, back : Colors;
                             VAR OUT style : FontStyleSet);
(* break a screen attribute into its various components *)

PROCEDURE PutStringAt(tw : TextWindow;
                      x, y : COORDINATE;
                      str : ARRAY OF CHAR;
                      a : ScreenAttribute);
(* write the string at the specified position in character cells
   output will be clipped if the text is/extends outside the screen buffer
   x, y = the coordinates of the first character of the string to paint
   str = the string to paint
   a = the screen attribute to use when painting the text *)

PROCEDURE PutAttrAt(tw : TextWindow;
                    x, y : COORDINATE;
                    attr : ARRAY OF ScreenAttribute);
(* write the attributes at the specified position in character cells
   the text remains unaltered, only the attribute is written
   output will be clipped if the attributes are outside the screen buffer
   x, y = the coordinates of the first character of the string to paint
   attr = the attribute string to paint. the HIGH bound of the array
          determines the number of attributes to paint *)

PROCEDURE WriteString(tw : TextWindow;
                      str : ARRAY OF CHAR;
                      a : ScreenAttribute);
(* write the string at the specified position in character cells
   output will be clipped if the text is/extends outside the screen buffer
   str = the string to paint
   a = the screen attribute to use when painting the text
   the text is written at the current caret position, and the x caret
   position is advanced by the length of the string. *)

PROCEDURE WriteStringAt(tw : TextWindow;
                        x, y : COORDINATE;
                        str : ARRAY OF CHAR;
                        a : ScreenAttribute);
(* this call has the same effect as *)
(*
    MoveCaretTo(tw, x, y);
    WriteString(tw, str, a);
*)

PROCEDURE WriteCellsAt(tw : TextWindow;
                       x, y : COORDINATE;
                       s : ARRAY OF Cell);
(* this call is like PutStringAt except you are writing whole character
   rather than a string all with the same attribute.
   the number of cells to write is determined by the HIGH bound of the
   array of cells passed *)

PROCEDURE WriteCells(tw : TextWindow; s : ARRAY OF Cell);
(* this call is like WriteCellsAt except output is to the current caret position *)

PROCEDURE WriteLn(tw : TextWindow);
(* place the caret at the beginning of the screen buffer for the
   X coordinate and advance the Y coordinate by one position
   may cause the screen to scroll if the Y coordinate is at the bottom
   of the screen buffer
   the caret position is advanced by this call *)

PROCEDURE EraseToEOL(tw : TextWindow; a : ScreenAttribute);
(* erase to the end of the screen buffer with spaces and the attribute
   specified from the current caret position
   the caret position is advanced by the call *)

PROCEDURE ChangeAttr(tw : TextWindow;
                     y, x1, x2 : COORDINATE;
                     a : ScreenAttribute);
(* change the attributes from coordinate x1 to x2 on coordinate y.
   output will be clipped if the range is/extends outside the screen buffer *)

PROCEDURE ReadBufferString(tw : TextWindow;
                           y, x1, x2 : COORDINATE;
                           VAR OUT str : ARRAY OF CHAR);
(* read data from the screen buffer maintained for the specified window.
   read from coordinate y from coordinate x1 to x2.
   place the data into the parameter string.
   if x1..x2 is larger than the size of str then the range x1..x2 is reduced
   to the size of str
   the string will be null terminated if x1..x2 is smaller than the size
   the parameter str *)

PROCEDURE RepaintRect(tw : TextWindow; rect : twRECT);
(* send yourself a TWM_PAINT message for the specified rectangle
   the rectangle will be clipped to the size of the screen buffer if necessary *)

PROCEDURE RepaintScreen(tw : TextWindow);
(* send yourself a TWM_PAINT message for the entire screen buffer *)

PROCEDURE MakeRowVisible(tw : TextWindow; y : COORDINATE);
(* make the specified row, y coordinate, visible in the display window
   you may receive TWM_PAINT, TWM_SCROLL or TWM_NOTIFYSCROLL messages as a
   result of this call.
   manual scrolling windows have no use for this call *)

PROCEDURE IsRectVisible(tw : TextWindow; theRect : twRECT) : BOOLEAN;
(* returns TRUE if the entire specified rectangle visible in the window.
   manual scrolling windows have no use for this call *)

PROCEDURE MakeRectVisible(tw : TextWindow; theRect : twRECT);
(* make the specified rectangle visible in the window.
   you may receive TWM_PAINT, TWM_SCROLL or TWM_NOTIFYSCROLL messages as a
   result of this call.
   if the rectange is larger than the current window size then as much
   of the rectangle that can be made visible will be made visible
   manual scrolling windows have no use for this call *)

PROCEDURE GetVisibleRect(tw : TextWindow; VAR OUT theRect : twRECT);
(* retrieve the rectangle currently visible in the window in virtual coordinates.
   manual scrolling windows have no use for this call *)

PROCEDURE GetBufferRect(tw : TextWindow; VAR OUT theRect : twRECT);
(* retrieve the rectangle of the screen buffer in virtual coordinates.
   manual scrolling windows have no use for this call *)

PROCEDURE EraseScreen(tw : TextWindow; a : ScreenAttribute);
(* Erase the entire screen buffer with spaces and the given attribute *)

PROCEDURE EraseRect(tw : TextWindow; rect : twRECT; a : ScreenAttribute);
(* Erase the specified region with spaces and the specified attribute.
   output will be clipped if the rectangle is/extends outside the screen buffer *)

PROCEDURE Xpos(tw : TextWindow) : COORDINATE;
(* the X coordinate of the caret position in virtual coordinates *)

PROCEDURE Ypos(tw : TextWindow) : COORDINATE;
(* the Y coordinate of the caret position in virtual coordinates *)

PROCEDURE Xorg(tw : TextWindow) : COORDINATE;
(* the X coordinate of the upper left corner of the screen buffer *)
(* in virtual coordinates *)
(* manual scrolling windows have no use for this call *)

PROCEDURE Yorg(tw : TextWindow) : COORDINATE;
(* the Y coordinate of the upper left corner of the screen buffer *)
(* in virtual coordinates *)
(* manual scrolling windows have no use for this call *)

PROCEDURE Xmax(tw : TextWindow) : COORDINATE;
(* the highest X coordinate of the screen buffer in virtual coordinates *)

PROCEDURE Ymax(tw : TextWindow) : COORDINATE;
(* the highest Y coordinate of the screen buffer in virtual coordinates *)

(* conversion routines to and from Virtual and Buffer coordinates *)
(* for example if you had an absolute screen coordinate and you wanted *)
(* to convert that to a text cell coordinate you would *)
(*
    WinShell.ScreenToClient(GetWinShellHandle(tw), pt);
    ClientToBuffer(tw, pt);
    BufferToVirtual(tw, pt);
*)
(* if you had a text window virtual coordinate and you wanted a screen pixel *)
(*
    VirtualToBuffer(tw, pt);
    BufferToClient(tw, pt);
    WinShell.ClientToScreen(GetWinShellHandle(tw), pt);
*)

PROCEDURE VirtualToBuffer(tw : TextWindow; VAR INOUT pt : twPOINT);

PROCEDURE BufferToVirtual(tw : TextWindow; VAR INOUT pt : twPOINT);

PROCEDURE ClientToBuffer(tw : TextWindow; VAR INOUT pt : twPOINT);
(* client pixel coordinates to text cell buffer coordinates *)

PROCEDURE BufferToClient(tw : TextWindow; VAR INOUT pt : twPOINT);
(* text cell buffer coordinates to client pixel coordinates *)

PROCEDURE GetColorTable(VAR OUT table : ColorTable);
(* get the table of colors used by this module
   the table associates the color enumeration this module uses
   with the RGB color information the corresponding to the enumeration *)

PROCEDURE PaintOff(tw : TextWindow);
(* function for turning off the updating of the display per "write/put" call.
   this will increase display updating performance.
   Off and On calls can be nested, thus you must turn painting On for every Off.
   Whenever a window receives a TWM_PAINT message painting is automatically
   turned off for the duration of the PAINT message. *)

PROCEDURE PaintOn(tw : TextWindow);
(* reverses a PaintOff call *)

PROCEDURE FlushPaint(tw : TextWindow);
(* if painting is OFF, flush all pending paint updates to the screen.
   if painting is ON this call has no effect *)

PROCEDURE IsPaintOn(tw : TextWindow) : BOOLEAN;
(* returns TRUE if paint updates is currently on for the specified window *)

PROCEDURE GetWinShellHandle(tw : TextWindow) : WinShell.Window;
(* get the WinShell window handle for the text window in question *)

PROCEDURE FindTextWindow(w : WinShell.Window) : TextWindow;
(* find the text window associated with the WinShell handle *)

(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)
(*-------------------------------------------------------------------*)

(* Stuff TextWindows simply re-exports from WinShell. *)
(* these procedures take a text window handle and just transfer the *)
(* call to the appropriate WinShell procedure of the same name *)
(* coordinates and sizes are in pixels for these calls, not character cells *)
(* as "native" TextWindows API calls *)

PROCEDURE Beep(beep : Beeps);

PROCEDURE SetDisplayMode(tw : TextWindow; dispMode : DisplayModes);

PROCEDURE GetDisplayMode(tw : TextWindow) : DisplayModes;

PROCEDURE SetWindowEnable(tw : TextWindow; enabled : BOOLEAN);

PROCEDURE IsMinimized(tw : TextWindow) : BOOLEAN;

PROCEDURE IsMaximized(tw : TextWindow) : BOOLEAN;

PROCEDURE SetWindowTitle(tw : TextWindow; title : ARRAY OF CHAR);

PROCEDURE SendUserMessage(tw : TextWindow;
                          userId : CARDINAL; userData : ADDRESS);
PROCEDURE PostUserMessage(tw : TextWindow;
                          userId : CARDINAL; userData : ADDRESS);

PROCEDURE IsUserMessageWaiting(tw : TextWindow) : BOOLEAN;

PROCEDURE CaretOn(tw : TextWindow);

PROCEDURE CaretOff(tw : TextWindow);

PROCEDURE ShowCaret(tw : TextWindow);

PROCEDURE HideCaret(tw : TextWindow);

PROCEDURE SetCaretType(tw : TextWindow; ct : CaretTypes);

PROCEDURE SetScrollBarPos(tw : TextWindow;
                          which : WinAttr;
                          pos : ScrollRange);

PROCEDURE SetWindowData(tw : TextWindow;
                        index : CARDINAL;
                        data : ADDRESS) : BOOLEAN;
PROCEDURE SetWindowDataNum(tw : TextWindow;
                           index : CARDINAL;
                           data : CARDINAL) : BOOLEAN;

PROCEDURE GetWindowData(tw : TextWindow;
                        index : CARDINAL) : ADDRESS;
PROCEDURE GetWindowDataNum(tw : TextWindow;
                           index : CARDINAL) : CARDINAL;

PROCEDURE GetWindowSize(tw : TextWindow; VAR OUT width, height : COORDINATE);

PROCEDURE SetWindowSize(tw : TextWindow; width, height : COORDINATE);

PROCEDURE GetWindowPos(tw : TextWindow; VAR OUT x, y : COORDINATE);

PROCEDURE SetWindowPos(tw : TextWindow; x, y : COORDINATE);

PROCEDURE CascadeWindow(cascadeThis, onThis : TextWindow);

PROCEDURE SetWindowIsBusy(tw : TextWindow; busy : BOOLEAN);

PROCEDURE GetWindowDisplayInfo(tw : TextWindow; VAR OUT info : WindowDisplayInfo);

PROCEDURE SetWindowDisplayInfo(tw : TextWindow; info : WindowDisplayInfo);

PROCEDURE SetScrollDisableWhenNone(tw : TextWindow; yesH, yesV : BOOLEAN);

PROCEDURE SetActiveTabChild(tw : TextWindow);

PROCEDURE SetTabChildPosition(tw : TextWindow; index : CARDINAL);

PROCEDURE GetForegroundWindow() : TextWindow;

PROCEDURE SetForegroundWindow(tw : TextWindow);

PROCEDURE CreateStatusLine(tw : TextWindow; fmt : ARRAY OF INTEGER) : BOOLEAN;

PROCEDURE RemoveStatusLine(tw :TextWindow);

PROCEDURE SetStatusFormat(tw :TextWindow; fmt : ARRAY OF INTEGER);

PROCEDURE WriteStatusField(tw :TextWindow;
                           field : CARDINAL;
                           text : ARRAY OF CHAR);

PROCEDURE SetWindowIcon(tw : TextWindow; icon : ARRAY OF CHAR) : BOOLEAN;

PROCEDURE SetWindowCursor(tw : TextWindow; typ : CursorTypes);

PROCEDURE SetWindowMenu(tw : TextWindow; menu : ARRAY OF CHAR) : BOOLEAN;

PROCEDURE SetMenuItemEnable(tw : TextWindow; id : CARDINAL; state : BOOLEAN);

PROCEDURE GetMenuItemEnable(tw : TextWindow; id : CARDINAL) : BOOLEAN;

PROCEDURE SetMenuItemCheck(tw : TextWindow; id : CARDINAL; state : BOOLEAN);

PROCEDURE GetMenuItemCheck(tw : TextWindow; id : CARDINAL) : BOOLEAN;

PROCEDURE SetMenuItemRadioCheck(tw : TextWindow;
                                first, last, set : CARDINAL);

PROCEDURE GetMenuItemRadioCheck(tw : TextWindow;
                                first, last : CARDINAL) : CARDINAL;

PROCEDURE GetWindowMenu(tw : TextWindow) : MenuHandle;

PROCEDURE LoadMenu(tw : TextWindow;
                   menuId : ARRAY OF CHAR;
                   popup : BOOLEAN) : MenuHandle;

PROCEDURE AppendMenuItemStr(tw : TextWindow;
                            menuH : MenuHandle;
                            str : ARRAY OF CHAR;
                            id : CARDINAL) : BOOLEAN;

PROCEDURE AppendMenuItemSeparator(tw : TextWindow; menuH : MenuHandle) : BOOLEAN;

PROCEDURE DeleteMenuItemPosition(menuH : MenuHandle; pos : CARDINAL) : BOOLEAN;

PROCEDURE PopupMenuHandle(tw : TextWindow;
                          menuH : MenuHandle;
                          button : MouseButton;
                          x, y : COORDINATE);

PROCEDURE PopupMenu(tw : TextWindow;
                    menuId : ARRAY OF CHAR;
                    button : MouseButton;
                    x, y : COORDINATE);

PROCEDURE SetTimer(tw : TextWindow; timerId : CARDINAL; interval : CARDINAL);

PROCEDURE KillTimer(tw : TextWindow; timerId : CARDINAL);

PROCEDURE OpenClipboard(tw : TextWindow) : BOOLEAN;

PROCEDURE CloseClipboard(tw : TextWindow);

PROCEDURE EmptyClipboard(tw : TextWindow) : BOOLEAN;

PROCEDURE ClipboardFormatAvailable(fmt : ClipboardFormat) : BOOLEAN;

PROCEDURE AllocClipboardMemory(size : CARDINAL) : ADDRESS;

PROCEDURE UnlockClipboardMemory;

PROCEDURE SetClipboard(fmt : ClipboardFormat) : BOOLEAN;

PROCEDURE GetClipboard(fmt : ClipboardFormat) : ADDRESS;

PROCEDURE CreateToolbar(tw : TextWindow;
                        buttons : ARRAY OF ToolbarButtonInfo;
                        hasText : BOOLEAN;
                        hasHelp : BOOLEAN;
                        canCustomize : BOOLEAN) : BOOLEAN;

PROCEDURE DestroyToolbar(tw : TextWindow);

PROCEDURE SetToolbarButtons(tw : TextWindow; fmt : ARRAY OF CARDINAL);

PROCEDURE GetToolbarButtons(tw : TextWindow;
                            VAR OUT fmt : ARRAY OF CARDINAL) : CARDINAL;

PROCEDURE IsToolbarButtonShown(tw : TextWindow; index : CARDINAL) : BOOLEAN;

PROCEDURE IsToolbarButtonDown(tw : TextWindow; index : CARDINAL) : BOOLEAN;

PROCEDURE IsToolbarButtonEnabled(tw : TextWindow; index : CARDINAL) : BOOLEAN;

PROCEDURE ShowToolbarButton(tw : TextWindow;
                            index : CARDINAL;
                            show : BOOLEAN) : BOOLEAN;

PROCEDURE ToggleToolbarButton(tw : TextWindow;
                              index : CARDINAL;
                              down : BOOLEAN) : BOOLEAN;

PROCEDURE EnableToolbarButton(tw : TextWindow;
                              index : CARDINAL;
                              enable : BOOLEAN) : BOOLEAN;

PROCEDURE DisplayHelp(tw : TextWindow;
                      command : HelpCommand;
                      helpFile : ARRAY OF CHAR;
                      helpIndex : CARDINAL) : BOOLEAN;

END TextWindows.

First understand that the Microsoft documentation is written for C 
programmers. Then understand that the C language is not a strongly typed 
language. NULL in the Windows declarations is the value 0. in WINX there are 
various constants that type NULL to various Windows pointer types, but in 
this case nothing for PVOID. You can use NIL in Modula-2. The value for NIL 
in Modula-2 is a numerical value of zero. So you can use NIL in this 
instance or you can add a NULL_PVOID to WINX with all the other typed 
declarations of NULL_ and use that. Your choice.

Norman 

(* ==================================================================================== *)
DEFINITION MODULE IOConsts;
(* Types and constants for input/output modules *)
TYPE
    (* This type is used to classify the result of an input operation *)
    ReadResults =
    (
     notKnown,          (* no data read result is set *)
     allRight,          (* data is as expected or as required *)
     outOfRange,        (* data cannot be represented *)
     wrongFormat,       (* data not in expected format *)
     endOfLine,         (* end of line seen before expected data *)
     endOfInput         (* end of input seen before expected data *)
    );
END IOConsts.

(* ==================================================================================== *)
DEFINITION MODULE ChanConsts;
  (* Common types and values for channel open requests and results *)
TYPE
  ChanFlags =        (* Request flags possibly given when a channel is opened *)
  ( readFlag,        (* input operations are requested/available *)
    writeFlag,       (* output operations are requested/available *)
    oldFlag,         (* a file may/must/did exist before the channel is opened *)
    textFlag,        (* text operations are requested/available *)
    rawFlag,         (* raw operations are requested/available *)
    interactiveFlag, (* interactive use is requested/applies *)
    echoFlag         (* echoing by interactive device on removal of characters from input stream requested/applies *)
  );
  FlagSet = SET OF ChanFlags;
CONST                          (* Singleton values of FlagSet, to allow for example, read + write *)
  read  = FlagSet{readFlag};   (* input operations are requested/available *)
  write = FlagSet{writeFlag}; (* output operations are requested/available *)
  old   = FlagSet{oldFlag};     (* a file may/must/did exist before the channel is opened *)
  text  = FlagSet{textFlag};   (* text operations are requested/available *)
  raw   = FlagSet{rawFlag};     (* raw operations are requested/available *)
  interactive = FlagSet{interactiveFlag}; (* interactive use is requested/applies *)
  echo  = FlagSet{echoFlag};   (* echoing by interactive device on removal of characters from input stream requested/applies *)
TYPE
  OpenResults =        (* Possible results of open requests *)
    (opened,           (* the open succeeded as requested *)
     wrongNameFormat,  (* given name is in the wrong format for the implementation *)
     wrongFlags,       (* given flags include a value that does not apply to the device *)
     tooManyOpen,      (* this device cannot support any more open channels *)
     outOfChans,       (* no more channels can be allocated *)
     wrongPermissions, (* file or directory permissions do not allow request *)
     noRoomOnDevice,   (* storage limits on the device prevent the open *)
     noSuchFile,       (* a needed file does not exist *)
     fileExists,       (* a file of the given name already exists when a new one is required *)
     wrongFileType,    (* the file is of the wrong type to support the required operations *)
     noTextOperations, (* text operations have been requested, but are not supported *)
     noRawOperations,  (* raw operations have been requested, but are not supported *)
     noMixedOperations,(* text and raw operations have been requested, but they are not supported in combination *)
     alreadyOpen,      (* the source/destination is already open for operations not supported in combination with the requested operations *)
     otherProblem      (* open failed for some other reason *)
    );
END ChanConsts.
