(*
 * Copyright (c) 1985-2000, Microsoft Corp. All rights reserved.             *
 *)
(* Conversion from Microsoft WIN32 SDK C source to Modula-2 source *)
(* Copyright (c) 2009, ADW Software. All rights reserved. *)

DEFINITION MODULE WIN32;
(*****************************************************************************
Differences in naming from what the NT documentation has
SIZE is called WSIZE
FLOAT IS CALLED WFLOAT
INT is called WINT
PROC is called WPROC
*****************************************************************************)

FROM SYSTEM IMPORT
    %IF Bits64 %THEN
    ASSERT, OFFS,
    %END
    ADDRESS, CAST, LOC, ADRCARD, ADRINT;

<*/CALLS:WINDOWSCALL/DLLDEF*>
<*/NOHIGH*>
<*/ALIGN:8/NOPACK*>

TYPE
    (* Handles *)
    (* THESE ARE USED TO GET STRICT TYPE CHECKING ON HANDLES
    HSTR                =  POINTER TO RECORD END;
    *)

    HDESK               =  POINTER TO RECORD END;
    HENHMETAFILE        =  POINTER TO RECORD END;
    HWINSTA             =  POINTER TO RECORD END;
    HKL                 =  POINTER TO RECORD END;
    HSTR                =  POINTER TO RECORD END;
    HTASK               =  POINTER TO RECORD END;
    HRSRC               =  POINTER TO RECORD END;
    HDC                 =  POINTER TO RECORD END;
    HGLRC               =  POINTER TO RECORD END;(*95*)
    HCOLORSPACE         =  POINTER TO RECORD END;(*95*)
    HGDIOBJ             =  POINTER TO RECORD END;
    HBITMAP             =  POINTER TO RECORD END;
    HPEN                =  POINTER TO RECORD END;
    HBRUSH              =  POINTER TO RECORD END;
    HRGN                =  POINTER TO RECORD END;
    HFONT               =  POINTER TO RECORD END;
    HPALETTE            =  POINTER TO RECORD END;
    HMETAFILE           =  POINTER TO RECORD END;
    HWND                =  POINTER TO RECORD END;
    HMENU               =  POINTER TO RECORD END;
    HICON               =  POINTER TO RECORD END;
    HDWP                =  POINTER TO RECORD END;
    HACCEL              =  POINTER TO RECORD END;
    HHOOK               =  POINTER TO RECORD END;
    HDRVR               =  POINTER TO RECORD END;
    HMODULE             =  POINTER TO RECORD END;
    HINSTANCE           =  POINTER TO RECORD END;
    HCURSOR             =  POINTER TO RECORD END;
    HMETAFILEPICT       =  POINTER TO RECORD END;
    HKEY                =  POINTER TO RECORD END;
    HMF                 =  POINTER TO RECORD END;
    HEMF                =  POINTER TO RECORD END;
    HCONTEXT            =  POINTER TO RECORD END;
    HMONITOR            =  POINTER TO RECORD END;
    HTERMINAL           =  POINTER TO RECORD END;
    HWINEVENTHOOK       =  POINTER TO RECORD END;

CONST
(*
    PointerToArraySize  = 512; (*Stony Brook defined constant *)
*)
    PointerToArraySize  = 4096; (*ADW defined constant *)
TYPE
    PUCHAR               = POINTER TO ARRAY [0..PointerToArraySize-1] OF UCHAR;
    PSZ                  = POINTER TO ARRAY [0..PointerToArraySize-1] OF ACHAR;

CONST
    ANYSIZE_ARRAY               = 1;
    MAX_PATH                    = 260;
    NULL                        = 0;
    EXCEPTION_MAXIMUM_PARAMETERS= 15;
    NLS_VALID_LOCALE_MASK       = 000fffffH;

TYPE
    PVOID                = ADDRESS;
    SHORT                = INTEGER16;
    LONG                 = INTEGER32;
    WCHAR                = UCHAR;
    DWORD                = CARDINAL;
    DWORD64              = CARDINAL64;
    BOOL                 = DWORDBOOL;
    BYTE                 = CARDINAL8;
    WORD                 = CARDINAL16;

    ULONG                = CARDINAL32;
    PULONG               = POINTER TO ULONG;
    USHORT               = CARDINAL16;
    PUSHORT              = POINTER TO USHORT;

    LPVOID               = ADDRESS;
    LPCVOID              = LPVOID;
    WINT                 = INTEGER;
    UINT                 = CARDINAL;
    UINT32               = CARDINAL32;
    UINT16               = CARDINAL16;
    HANDLE               = ADDRESS;

    PBOOL                = POINTER TO BOOL;
    LPBOOL               = PBOOL;
    PBYTE                = POINTER TO CARDINAL8;
    LPBYTE               = PBYTE;
    PINT                 = POINTER TO WINT;
    LPINT                = PINT;
    PWORD                = POINTER TO WORD;
    LPWORD               = PWORD;
    LPLONG               = POINTER TO LONG;
    PDWORD               = POINTER TO DWORD;
    LPDWORD              = PDWORD;
    PUINT                = POINTER TO UINT;
    PHANDLE              = POINTER TO HANDLE;

    (* always the size of a pointer *)
    INT_PTR              = ADRINT;
    UINT_PTR             = ADRCARD;

    (* always the size of a pointer *)
    LONG_PTR             = ADRINT;
    ULONG_PTR            = ADRCARD;
    DWORD_PTR            = ULONG_PTR;

    SIZE_T               = ULONG_PTR;
    SSIZE_T              = LONG_PTR;

    %IF Bits64 %THEN
    PVOID64              = ADDRESS;
    %ELSE
    PVOID64              = CARDINAL64;
    %END
    LPCVOID64           = PVOID64;

TYPE
    PWCHAR               = POINTER TO WCHAR;
    LPWCH                = PWCHAR;
    PWCH                 = PWCHAR;
    LPCWCH               = PWCHAR;
    PCWCH                = PWCHAR;

    PWSTR                = POINTER TO ARRAY [0..PointerToArraySize-1] OF WCHAR;
    NWPSTR               = PWSTR;
    LPWSTR               = PWSTR;
    LPCWSTR              = PWSTR;
    PCWSTR               = PWSTR;

    PCHAR                = POINTER TO ACHAR;
    LPCH                 = PCHAR;
    PCH                  = PCHAR;
    LPCCH                = PCHAR;
    PCCH                 = PCHAR;

    PSTR                 = POINTER TO ARRAY [0..PointerToArraySize-1] OF ACHAR;
    LPSTR                = PSTR;
    LPCSTR               = PSTR;
    PCSTR                = PSTR;

    TBYTE                = WCHAR;
    PTBYTE               = POINTER TO ARRAY [0..PointerToArraySize-1] OF WCHAR;

%IF UNICODE %THEN
    TCHAR                = UCHAR;

    LP                   = LPWSTR;
    LPTCH                = LPWSTR;
    PTCH                 = LPWSTR;
    PTSTR                = LPWSTR;
    LPTSTR               = LPWSTR;
    LPCTSTR              = LPCWSTR;

%ELSE
    TCHAR                = ACHAR;

    LP                   = LPSTR;
    LPTCH                = LPSTR;
    PTCH                 = LPSTR;
    PTSTR                = LPSTR;
    LPTSTR               = LPSTR;
    LPCTSTR              = LPCSTR;
%END

    PTCHAR               = POINTER TO TCHAR;

    PSHORT               = POINTER TO SHORT;
    PLONG                = POINTER TO LONG;
    CCHAR                = ACHAR;
    LCID                 = DWORD;
    PLCID                = PDWORD;
    LANGID               = WORD;
    WFLOAT               = REAL;
    PFLOAT               = POINTER TO WFLOAT;
    LPFLOAT              = PFLOAT;

    (* changed to unsigned so compatible with hex error constants *)
    HRESULT              = ULONG;
    SCODE                = ULONG;
    PSCODE               = POINTER TO SCODE;

CONST
    APPLICATION_ERROR_MASK= 020000000h;
    ERROR_SEVERITY_SUCCESS= 000000000h;
    ERROR_SEVERITY_INFORMATIONAL= 040000000h;
    ERROR_SEVERITY_WARNING= 080000000h;
    ERROR_SEVERITY_ERROR = 0C0000000h;

    UNICODE_NULL         = CAST(UCHAR,0);

    ROTFLAGS_REGISTRATIONKEEPSALIVE     = 1;

    MEMCTX_TASK         = 1;
    MEMCTX_SHARED       = 2;
    MEMCTX_MACSYSTEM    = 3;
    MEMCTX_UNKNOWN      = -1;
    MEMCTX_SAME         = -2;

    CLSCTX_INPROC_SERVER        = 1;
    CLSCTX_INPROC_HANDLER       = 2;
    CLSCTX_LOCAL_SERVER         = 4;
    CLSCTX_INPROC_SERVER16      = 8;

    MSHLFLAGS_NORMAL            = 0;
    MSHLFLAGS_TABLESTRONG       = 1;
    MSHLFLAGS_TABLEWEAK         = 2;

    MSHCTX_LOCAL                = 0;
    MSHCTX_NOSHAREDMEM          = 1;
    MSHCTX_DIFFERENTMACHINE     = 2;
    MSHCTX_INPROC               = 3;

    DVASPECT_CONTENT            = 1;
    DVASPECT_THUMBNAIL          = 2;
    DVASPECT_ICON               = 4;
    DVASPECT_DOCPRINT           = 8;

    STGC_DEFAULT                                = 0;
    STGC_OVERWRITE                              = 1;
    STGC_ONLYIFCURRENT                          = 2;
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE     = 4;

    STGMOVE_MOVE        = 0;
    STGMOVE_COPY        = 1;

    STATFLAG_DEFAULT    = 0;
    STATFLAG_NONAME     = 1;

TYPE
    LONGLONG             = INTEGER64;
    ULONGLONG            = CARDINAL64;
    DWORDLONG            = CARDINAL64;
    PLONGLONG            = POINTER TO LONGLONG;
    PULONGLONG           = POINTER TO ULONGLONG;
    PDWORDLONG           = POINTER TO DWORDLONG;
    LARGE_INTEGER        = LONGLONG;
    ULARGE_INTEGER       = ULONGLONG;

    LUID                 = LARGE_INTEGER;
    PLARGE_INTEGER       = POINTER TO LARGE_INTEGER;
    PULARGE_INTEGER      = POINTER TO ULARGE_INTEGER;

    PLUID                = POINTER TO LUID;

    USN                  = LONGLONG;

    PBOOLEAN             = POINTER TO BOOLEAN;

    LIST_ENTRY = RECORD
          Flink          : POINTER TO LIST_ENTRY;
          Blink          : POINTER TO LIST_ENTRY;
    END;

    PLIST_ENTRY          = POINTER TO LIST_ENTRY;
    PRLIST_ENTRY         = POINTER TO LIST_ENTRY;

    PSINGLE_LIST_ENTRY   = POINTER TO SINGLE_LIST_ENTRY;
    SINGLE_LIST_ENTRY = RECORD
          Next           : PSINGLE_LIST_ENTRY;
    END;

    GUID = RECORD
          Data1          : ULONG;
          Data2          : USHORT;
          Data3          : USHORT;
          Data4          : ARRAY [0..8 - 1] OF BYTE;
    END;
    LPGUID      = POINTER TO GUID;

    UUID                 = GUID;
    IID                  = GUID;
    CLSID                = GUID;
    FMTID                = GUID;

    LPIID                = POINTER TO IID;
    LPCLSID              = POINTER TO CLSID;
    REFGUID              = POINTER TO GUID;
    REFIID               = POINTER TO IID;
    REFCLSID             = POINTER TO CLSID;
    REFFMTID             = POINTER TO FMTID;

    OBJECTID = RECORD
        Lineage         : GUID;
        Uniquifier      : DWORD;
    END;

PROCEDURE INIT_GUID(VAR guid : GUID;
                    l : ULONG;
                    w1 : USHORT;
                    w2 : USHORT;
                    b1, b2, b3, b4, b5, b6, b7, b8 : BYTE) [Invariant];

CONST
    MINCHAR              = MIN(CHAR)(*080h*);
    MAXCHAR              = MAX(CHAR)(*07fh*);
    MINSHORT             = MIN(SHORT);
    MAXSHORT             = MAX(SHORT);
    MINLONG              = MIN(LONG);
    MAXLONG              = MAX(LONG);
    MAXBYTE              = MAX(BYTE);
    MAXWORD              = MAX(WORD);
    MAXDWORD             = MAX(DWORD);

    EXCEPTION_NONCONTINUABLE    = 1h;
    EXCEPTION_UNWINDING         = 00002h;
    EXCEPTION_EXIT_UNWIND       = 00004h;
    EXCEPTION_STACK_INVALID     = 00008h;
    EXCEPTION_NESTED_CALL       = 00010h;
    EXCEPTION_TARGET_UNWIND     = 00020h;
    EXCEPTION_COLLIDED_UNWIND   = 00040h;
    EXCEPTION_UNWIND             = 00066h;

TYPE
    EXCEPTION_DISPOSITION = (ExceptionContinueExecution,
                             ExceptionContinueSearch,
                             ExceptionNestedException,
                             ExceptionCollidedUnwind) BIG;

    PEXCEPTION_RECORD = POINTER TO EXCEPTION_RECORD;
    EXCEPTION_RECORD = RECORD
        ExceptionCode : DWORD;
        ExceptionFlags : DWORD;
        ExceptionRecord : PEXCEPTION_RECORD;
        ExceptionAddress : PVOID;
        NumberParameters : DWORD;
        %IF Bits64 %THEN
        unusedAlignment  : DWORD;
        %END
        ExceptionInformation : ARRAY [0..EXCEPTION_MAXIMUM_PARAMETERS-1] OF ULONG_PTR;
    END;

    EXCEPTION_ROUTINE = PROCEDURE(PEXCEPTION_RECORD,
                                  PVOID,
                                  PCONTEXT,
                                  PDISPATCHER_CONTEXT) : EXCEPTION_DISPOSITION;

%IF IA32 %THEN
CONST
    SIZE_OF_80387_REGISTERS     = 80;


    CONTEXT_i386            = 010000h;
    CONTEXT_i486            = 010000h;

    CONTEXT_CONTROL         = CONTEXT_i386 BOR 00000001h;
    CONTEXT_INTEGER         = CONTEXT_i386 BOR 00000002h;
    CONTEXT_SEGMENTS        = CONTEXT_i386 BOR 00000004h;
    CONTEXT_FLOATING_POINT  = CONTEXT_i386 BOR 00000008h;
    CONTEXT_DEBUG_REGISTERS = CONTEXT_i386 BOR 00000010h;

    CONTEXT_FULL            = CONTEXT_CONTROL BOR
                              CONTEXT_SEGMENTS BOR
                              CONTEXT_INTEGER;

TYPE
    FLOATING_SAVE_AREA = RECORD
          ControlWord    : DWORD;
          StatusWord     : DWORD;
          TagWord        : DWORD;
          ErrorOffset    : DWORD;
          ErrorSelector  : DWORD;
          DataOffset     : DWORD;
          DataSelector   : DWORD;
          RegisterArea   : ARRAY [0..SIZE_OF_80387_REGISTERS - 1] OF BYTE;
          Cr0NpxState    : DWORD;
    END;
    PFLOATING_SAVE_AREA  = POINTER TO FLOATING_SAVE_AREA;

    CONTEXT              = RECORD
        ContextFlags         : DWORD;

        (* CONTEXT_DEBUG_REGISTERS *)
        Dr0                  : DWORD;
        Dr1                  : DWORD;
        Dr2                  : DWORD;
        Dr3                  : DWORD;
        Dr6                  : DWORD;
        Dr7                  : DWORD;

        (* CONTEXT_FLOATING_POINT *)
        FloatSave            : FLOATING_SAVE_AREA;

        (* CONTEXT_SEGMENTS *)
        SegGs                : DWORD;
        SegFs                : DWORD;
        SegEs                : DWORD;
        SegDs                : DWORD;

        (* CONTEXT_INTEGER *)
        Edi                  : DWORD;
        Esi                  : DWORD;
        Ebx                  : DWORD;
        Edx                  : DWORD;
        Ecx                  : DWORD;
        Eax                  : DWORD;

        (* CONTEXT_CONTROL *)
        Ebp                  : DWORD;
        Eip                  : DWORD;
        SegCs                : DWORD;
        EFlags               : DWORD;
        Esp                  : DWORD;
        SegSs                : DWORD;
    END;
    PCONTEXT = POINTER TO CONTEXT;

    DISPATCHER_CONTEXT =
    RECORD
    END;
    PDISPATCHER_CONTEXT = POINTER TO DISPATCHER_CONTEXT;

%ELSIF AMD64 %THEN
(* Define 128-bit 16-byte aligned xmm register type.*)
    M128A =
    RECORD [ALIGN 16]
    Low         : CARDINAL64;
    High        : INTEGER64;
    END;
    PM128A      = POINTER TO M128A;


(* Format of data for 32-bit fxsave/fxrstor instructions.*)
    XMM_SAVE_AREA32 =
    RECORD
    ControlWord         : WORD;
    StatusWord          : WORD;
    TagWord             : BYTE;
    Reserved1           : BYTE;
    ErrorOpcode         : WORD;
    ErrorOffset         : DWORD;
    ErrorSelector       : WORD;
    Reserved2           : WORD;
    DataOffset          : DWORD;
    DataSelector        : WORD;
    Reserved3           : WORD;
    MxCsr               : DWORD;
    MxCsr_Mask          : DWORD;
    FloatRegisters      : ARRAY [0..7] OF M128A;
    XmmRegisters        : ARRAY [0..15] OF M128A;
    Reserved4           : ARRAY [0..95] OF BYTE;
    END;
    PXMM_SAVE_AREA32 = POINTER TO PXMM_SAVE_AREA32;

CONST
    LEGACY_SAVE_AREA_LENGTH = SIZE(XMM_SAVE_AREA32);

    CONTEXT_AMD64           = 0100000h;

    CONTEXT_CONTROL                     = CONTEXT_AMD64 BOR 01h;
    CONTEXT_INTEGER                     = CONTEXT_AMD64 BOR 02h;
    CONTEXT_SEGMENTS                    = CONTEXT_AMD64 BOR 04h;
    CONTEXT_FLOATING_POINT              = CONTEXT_AMD64 BOR 08h;
    CONTEXT_DEBUG_REGISTERS             = CONTEXT_AMD64 BOR 010h;

    CONTEXT_FULL                        = CONTEXT_CONTROL BOR CONTEXT_INTEGER BOR CONTEXT_FLOATING_POINT;

    CONTEXT_ALL                         = CONTEXT_CONTROL BOR
                                          CONTEXT_INTEGER BOR
                                          CONTEXT_SEGMENTS BOR
                                          CONTEXT_FLOATING_POINT BOR CONTEXT_DEBUG_REGISTERS;

    CONTEXT_EXCEPTION_ACTIVE            = 08000000h;
    CONTEXT_SERVICE_ACTIVE              = 010000000h;
    CONTEXT_EXCEPTION_REQUEST           = 040000000h;
    CONTEXT_EXCEPTION_REPORTING         = 080000000h;

TYPE
(*
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//
// The flags field within this record controls the contents of a CONTEXT
// record.
//
// If the context record is used as an input parameter, then for each
// portion of the context record controlled by a flag whose value is
// set, it is assumed that that portion of the context record contains
// valid context. If the context record is being used to modify a threads
// context, then only that portion of the threads context is modified.
//
// If the context record is used as an output parameter to capture the
// context of a thread, then only those portions of the thread's context
// corresponding to set flags will be returned.
//
// CONTEXT_CONTROL specifies SegSs, Rsp, SegCs, Rip, and EFlags.
//
// CONTEXT_INTEGER specifies Rax, Rcx, Rdx, Rbx, Rbp, Rsi, Rdi, and R8-R15.
//
// CONTEXT_SEGMENTS specifies SegDs, SegEs, SegFs, and SegGs.
//
// CONTEXT_DEBUG_REGISTERS specifies Dr0-Dr3 and Dr6-Dr7.
//
// CONTEXT_MMX_REGISTERS specifies the floating point and extended registers
//     Mm0/St0-Mm7/St7 and Xmm0-Xmm15).
*)

    ANON_FPP_REC =
    RECORD
    CASE : BOOLEAN OF
    FALSE:
        FltSave : XMM_SAVE_AREA32;
    |
    TRUE:
        Header  : ARRAY [0..1] OF M128A;
        Legacy  : ARRAY [0..7] OF M128A;
        Xmm0,
        Xmm1,
        Xmm2,
        Xmm3,
        Xmm4,
        Xmm5,
        Xmm6,
        Xmm7,
        Xmm8,
        Xmm9,
        Xmm10,
        Xmm11,
        Xmm12,
        Xmm13,
        Xmm14,
        Xmm15   : M128A;
    END;
    END;

    CONTEXT =
    RECORD
    (*
    // Register parameter home addresses.
    //
    // N.B. These fields are for convience - they could be used to extend the
    //      context record in the future.
    *)

    P1Home              : DWORD64;
    P2Home              : DWORD64;
    P3Home              : DWORD64;
    P4Home              : DWORD64;
    P5Home              : DWORD64;
    P6Home              : DWORD64;

    (*
    // Control flags.
    *)

    ContextFlags        : DWORD;
    MxCsr               : DWORD;

    (*
    // Segment Registers and processor flags.
    *)

    SegCs               : WORD;
    SegDs               : WORD;
    SegEs               : WORD;
    SegFs               : WORD;
    SegGs               : WORD;
    SegSs               : WORD;
    EFlags              : DWORD;

    (*
    // Debug registers
    *)

    Dr0                 : DWORD64;
    Dr1                 : DWORD64;
    Dr2                 : DWORD64;
    Dr3                 : DWORD64;
    Dr6                 : DWORD64;
    Dr7                 : DWORD64;

    (*
    // Integer registers.
    *)

    Rax                 : DWORD64;
    Rcx                 : DWORD64;
    Rdx                 : DWORD64;
    Rbx                 : DWORD64;
    Rsp                 : DWORD64;
    Rbp                 : DWORD64;
    Rsi                 : DWORD64;
    Rdi                 : DWORD64;
    R8                  : DWORD64;
    R9                  : DWORD64;
    R10                 : DWORD64;
    R11                 : DWORD64;
    R12                 : DWORD64;
    R13                 : DWORD64;
    R14                 : DWORD64;
    R15                 : DWORD64;

    (*
    // Program counter.
    *)

    Rip                 : DWORD64;

    (*
    // Floating point state. 16-byte aligned
    *)

    fpp                : ANON_FPP_REC;

    (*
    // Vector registers. 16-byte aligned
    *)

    VectorRegister      : ARRAY [0..25] OF M128A;
    VectorControl       : DWORD64;

    (*
    // Special debug control registers.
    *)

    DebugControl        : DWORD64;
    LastBranchToRip     : DWORD64;
    LastBranchFromRip   : DWORD64;
    LastExceptionToRip  : DWORD64;
    LastExceptionFromRip        : DWORD64;
    END;
    PCONTEXT = POINTER TO CONTEXT;

    ASSERT(OFFS(CONTEXT.fpp) REM 16 = 0);
    ASSERT(OFFS(CONTEXT.VectorRegister) REM 16 = 0);

TYPE
    RUNTIME_FUNCTION =
        RECORD
            BeginAddress        : ULONG;
            EndAddress          : ULONG;
            UnwindData          : ULONG;
        END;
    PRUNTIME_FUNCTION = POINTER TO RUNTIME_FUNCTION;

CONST
    UNW_FLAG_NHANDLER   = 00h;
    UNW_FLAG_EHANDLER   = 01h;
    UNW_FLAG_UHANDLER   = 02h;
    UNW_FLAG_CHAININFO  = 04h;

TYPE
    UnwindOpcodes = (
                     UWOP_PUSH_NONVOL,
                     UWOP_ALLOC_LARGE,
                     UWOP_ALLOC_SMALL,
                     UWOP_SET_FPREG,
                     UWOP_SAVE_NONVOL,
                     UWOP_SAVE_NONVOL_FAR,
                     UWOP_SAVE_XMM,
                     UWOP_SAVE_XMM_FAR,
                     UWOP_SAVE_XMM128,
                     UWOP_SAVE_XMM128_FAR,
                     UWOP_PUSH_MACHFRAME
                    );

    UNWIND_CODE =
    RECORD
        CASE : BOOLEAN OF
        FALSE:
            CodeOffset      : CARDINAL8;
            BITFIELDS
            UnwindOp        : UnwindOpcodes BY 4;
            OpInfo          : CARDINAL8 BY 4;
            END;
        |
        TRUE:
            FrameOffset     : CARDINAL16;
        END;
    END;

    EXCEPTION_DATA_ARRAY        = ARRAY [0..7] OF CARDINAL32;(* variable length *)
    UNWIND_CODE_ARRAY           = ARRAY [0..31] OF UNWIND_CODE;(* variable length, always even *)

    UNWIND_INFO =
    RECORD
        BITFIELDS
            Version             : CARDINAL8 BY 3;
            Flags               : CARDINAL8 BY 5;
        END;
        SizeOfProlog            : CARDINAL8;
        CountOfCodes            : CARDINAL8;
        BITFIELDS
            FrameRegister       : CARDINAL8 BY 4;
            FrameOffset         : CARDINAL8 BY 4;
        END;

        (* variable length
        UnwindCode              : ARRAY [0..0] OF UNWIND_CODE;*)

        (* optional
        CASE : BOOLEAN OF
        FALSE:
            (* UNW_FLAG_EHANDLER *)
            ExceptionHandler        : ULONG;
        |
        TRUE:
            (* UNW_FLAG_CHAININFO *)
            FunctionEntry           : ULONG;
        END;

        (* UNW_FLAG_EHANDLER *)
        ExceptionData               : EXCEPTION_DATA_ARRAY;
        *)
    END;
    PUNWIND_INFO        = POINTER TO UNWIND_INFO;

CONST
    UNWIND_HISTORY_TABLE_SIZE   = 12;

TYPE
    UNWIND_HISTORY_TABLE_ENTRY =
        RECORD
        ImageBase       : CARDINAL64;
        FunctionEntry   : PRUNTIME_FUNCTION;
        END;
    PUNWIND_HISTORY_TABLE_ENTRY = POINTER TO UNWIND_HISTORY_TABLE_ENTRY;

CONST
    UNWIND_HISTORY_TABLE_NONE   = 0;
    UNWIND_HISTORY_TABLE_GLOBAL = 1;
    UNWIND_HISTORY_TABLE_LOCAL  = 2;

TYPE
    UNWIND_HISTORY_TABLE =
        RECORD
        Count                   : ULONG;
        Search                  : CARDINAL8;
        RaiseStatusIndex        : CARDINAL8;
        Unwind                  : BOOL8;
        Exception               : BOOL8;
        LowAddress              : CARDINAL64;
        HighAddress             : CARDINAL64;
        Entry                   : ARRAY [0..UNWIND_HISTORY_TABLE_SIZE-1] OF UNWIND_HISTORY_TABLE_ENTRY;
       END;
    PUNWIND_HISTORY_TABLE       = POINTER TO UNWIND_HISTORY_TABLE;

    DISPATCHER_CONTEXT =
    RECORD
    ControlPc           : CARDINAL64;
    ImageBase           : CARDINAL64;
    FunctionEntry       : PRUNTIME_FUNCTION;
    EstablisherFrame    : CARDINAL64;
    TargetIp            : CARDINAL64;
    ContextRecord       : PCONTEXT;
    LanguageHandler     : EXCEPTION_ROUTINE;
    HandlerData         : PVOID;
    HistoryTable        : PUNWIND_HISTORY_TABLE;
    ScopeIndex          : ULONG;
    END;
    PDISPATCHER_CONTEXT = POINTER TO DISPATCHER_CONTEXT;

    PULONG64    = POINTER TO CARDINAL64;

    KNONVOLATILE_CONTEXT_POINTERS =
    RECORD
        FloatingContext : ARRAY [0..15] OF PM128A;

        Rax,
        Rcx,
        Rdx,
        Rbx,
        Rsp,
        Rbp,
        Rsi,
        Rdi,
        R8,
        R9,
        R10,
        R11,
        R12,
        R13,
        R14,
        R15     : PULONG64;
    END;
    PKNONVOLATILE_CONTEXT_POINTERS = POINTER TO KNONVOLATILE_CONTEXT_POINTERS;
%ELSE
    fix me
%END

PROCEDURE RtlUnwind(targetFrame, targetIp : PVOID;
                    exceptionRecord : PEXCEPTION_RECORD;
                    retVal : PVOID);

%IF AMD64 %THEN
PROCEDURE RtlUnwindEx(targetFrame, targetIp : PVOID;
                      exceptionRecord : PEXCEPTION_RECORD;
                      retVal : PVOID;
                      VAR INOUT origContext : CONTEXT;
                      history : PUNWIND_HISTORY_TABLE);

PROCEDURE RtlVirtualUnwind(HandlerType : ULONG;
                           ImageBase : CARDINAL64;
                           ControlPC : CARDINAL64;
                           FunctionEntry : PRUNTIME_FUNCTION;
                           VAR INOUT ContextRecord : CONTEXT;
                           VAR OUT HandlerData : ADDRESS;
                           VAR OUT EstablisherFrame : CARDINAL64;
                           (*INOUT OPTIONAL*)ContextPointers : PKNONVOLATILE_CONTEXT_POINTERS
                         ) : EXCEPTION_ROUTINE;

PROCEDURE RtlLookupFunctionEntry(ControlPc : CARDINAL64;
                                 VAR OUT ImageBase : CARDINAL64;
                                 HistoryTable : (*INOUT*) PUNWIND_HISTORY_TABLE
                                ) : PRUNTIME_FUNCTION;

PROCEDURE RtlRestoreContext(ContextRecord : CONTEXT;
                            (*optional*)ExceptionRecord : PEXCEPTION_RECORD) [NEVERRETURNS];

PROCEDURE RtlCaptureContext(VAR OUT ContextRecord : CONTEXT);
%END

CONST
    EXCEPTION_EXECUTE_HANDLER= 1;
    EXCEPTION_CONTINUE_SEARCH= 0;
    EXCEPTION_CONTINUE_EXECUTION= -1 ;

    LANG_NEUTRAL         = 000h;
    LANG_ALBANIAN        = 01ch;
    LANG_ARABIC          = 001h;
    LANG_AFRIKAANS       = 036h;
    LANG_BASQUE          = 02dh;
    LANG_BAHASA          = 021h;
    LANG_BULGARIAN       = 002h;
    LANG_BYELORUSSIAN    = 023h;
    LANG_CATALAN         = 003h;
    LANG_CHINESE         = 004h;
    LANG_CROATIAN        = 01ah;
    LANG_CZECH           = 005h;
    LANG_DANISH          = 006h;
    LANG_DUTCH           = 013h;
    LANG_ENGLISH         = 009h;
    LANG_ESTONIAN        = 025h;
    LANG_FAEROESE        = 038h;
    LANG_FARSI           = 029h;
    LANG_FINNISH         = 00bh;
    LANG_FRENCH          = 00ch;
    LANG_GERMAN          = 007h;
    LANG_GREEK           = 008h;
    LANG_HEBREW          = 00dh;
    LANG_HUNGARIAN       = 00eh;
    LANG_ICELANDIC       = 00fh;
    LANG_INDONESIAN      = 021h;
    LANG_ITALIAN         = 010h;
    LANG_JAPANESE        = 011h;
    LANG_KOREAN          = 012h;
    LANG_LATVIAN         = 026h;
    LANG_LITHUANIAN      = 027h;
    LANG_NORWEGIAN       = 014h;
    LANG_POLISH          = 015h;
    LANG_PORTUGUESE      = 016h;
    LANG_RHAETO_ROMAN    = 017h;
    LANG_ROMANIAN        = 018h;
    LANG_RUSSIAN         = 019h;
    LANG_SERBO_CROATIAN  = 01ah;
    LANG_SLOVAK          = 01bh;
    LANG_SLOVENIAN       = 024h;
    LANG_SORBIAN         = 02eh;
    LANG_SPANISH         = 00ah;
    LANG_SWEDISH         = 01dh;
    LANG_THAI            = 01eh;
    LANG_TURKISH         = 01fh;
    LANG_URDU            = 020h;
    LANG_UKRAINIAN       = 022h;

    SUBLANG_NEUTRAL      = 000h;
    SUBLANG_DEFAULT      = 001h;
    SUBLANG_SYS_DEFAULT  = 002h;
    SUBLANG_ARABIC                   = 001h;
    SUBLANG_ARABIC_IRAQ              = 002h;
    SUBLANG_ARABIC_EGYPT             = 003h;
    SUBLANG_ARABIC_LIBYA             = 004h;
    SUBLANG_ARABIC_ALGERIA           = 005h;
    SUBLANG_ARABIC_MOROCCO           = 006h;
    SUBLANG_ARABIC_TUNISIA           = 007h;
    SUBLANG_ARABIC_OMAN              = 008h;
    SUBLANG_ARABIC_YEMEN             = 009h;
    SUBLANG_ARABIC_SYRIA             = 010h;
    SUBLANG_ARABIC_JORDAN            = 011h;
    SUBLANG_ARABIC_LEBANON           = 012h;
    SUBLANG_ARABIC_KUWAIT            = 013h;
    SUBLANG_ARABIC_UAE               = 014h;
    SUBLANG_ARABIC_BAHRAIN           = 015h;
    SUBLANG_ARABIC_QATAR             = 016h;

    SUBLANG_CHINESE_TRADITIONAL      = 001h;
    SUBLANG_CHINESE_SIMPLIFIED       = 002h;
    SUBLANG_CHINESE_HONGKONG         = 003h;
    SUBLANG_CHINESE_SINGAPORE        = 004h;

    SUBLANG_DUTCH        = 001h;
    SUBLANG_DUTCH_BELGIAN= 002h;
    SUBLANG_ENGLISH_US   = 001h;
    SUBLANG_ENGLISH_UK   = 002h;
    SUBLANG_ENGLISH_AUS  = 003h;
    SUBLANG_ENGLISH_CAN  = 004h;
    SUBLANG_ENGLISH_NZ   = 005h;
    SUBLANG_ENGLISH_EIRE = 006h;
    SUBLANG_ENGLISH_SAFRICA     = 07h;
    SUBLANG_ENGLISH_JAMAICA     = 08h;
    SUBLANG_ENGLISH_CARRIBEAN   = 09h;
    SUBLANG_FRENCH              = 001h;
    SUBLANG_FRENCH_BELGIAN      = 002h;
    SUBLANG_FRENCH_CANADIAN     = 003h;
    SUBLANG_FRENCH_SWISS        = 004h;
    SUBLANG_FRENCH_LUXEMBOURG   = 005h;
    SUBLANG_GERMAN              = 001h;
    SUBLANG_GERMAN_SWISS        = 002h;
    SUBLANG_GERMAN_AUSTRIAN     = 003h;
    SUBLANG_GERMAN_LUXEMBOURG   = 004h;
    SUBLANG_GERMAN_LIECHTENSTEIN= 005h;
    SUBLANG_ITALIAN             = 001h;
    SUBLANG_ITALIAN_SWISS       = 002h;

    SUBLANG_KOREAN              = 001h;
    SUBLANG_KOREAN_JOHAB        = 002h;

    SUBLANG_NORWEGIAN_BOKMAL    = 001h;
    SUBLANG_NORWEGIAN_NYNORSK   = 002h;
    SUBLANG_PORTUGUESE          = 002h;
    SUBLANG_PORTUGUESE_BRAZILIAN= 001h;
    SUBLANG_SERBO_CROATIAN_CYRILLIC= 002h;
    SUBLANG_SERBO_CROATIAN_LATIN= 001h;
    SUBLANG_SPANISH             = 001h;
    SUBLANG_SPANISH_MEXICAN     = 002h;
    SUBLANG_SPANISH_MODERN      = 003h;
    SUBLANG_SPANISH_GUATEMALA   = 004h;
    SUBLANG_SPANISH_COSTARICA   = 005h;
    SUBLANG_SPANISH_PANAMA      = 006h;
    SUBLANG_SPANISH_DOMINICAN   = 007h;
    SUBLANG_SPANISH_VENEZUELA   = 008h;
    SUBLANG_SPANISH_COLOMBIA    = 009h;
    SUBLANG_SPANISH_PERU        = 010h;
    SUBLANG_SPANISH_ARGENTINA   = 011h;
    SUBLANG_SPANISH_ECUADOR     = 012h;
    SUBLANG_SPANISH_CHILE       = 013h;
    SUBLANG_SPANISH_URUGUAY     = 014h;
    SUBLANG_SPANISH_PARAGUAY    = 015h;
    SUBLANG_SPANISH_BOLIVIA     = 016h;

    SORT_DEFAULT                = 0;

    SORT_JAPANESE_XJIS          = 0;
    SORT_JAPANESE_UNICODE       = 1;

    SORT_CHINESE_BIG5           = 0;
    SORT_CHINESE_UNICODE        = 1;

    SORT_KOREAN_KSC             = 0;
    SORT_KOREAN_UNICODE         = 1;

CONST
    STATUS_WAIT_0               = 00000000h;
    STATUS_ABANDONED_WAIT_0     = 00000080h;
    STATUS_USER_APC             = 000000C0h;
    STATUS_TIMEOUT              = 00000102h;
    STATUS_PENDING              = 00000103h;
    STATUS_SEGMENT_NOTIFICATION = 40000005h;
    STATUS_GUARD_PAGE_VIOLATION = 80000001h;
    STATUS_DATATYPE_MISALIGNMENT= 80000002h;
    STATUS_BREAKPOINT           = 80000003h;
    STATUS_SINGLE_STEP          = 80000004h;
    STATUS_ACCESS_VIOLATION     = 0C0000005h;
    STATUS_IN_PAGE_ERROR        = 0C0000006h;
    STATUS_NO_MEMORY            = 0C0000017h;
    STATUS_ILLEGAL_INSTRUCTION  = 0C000001Dh;
    STATUS_NONCONTINUABLE_EXCEPTION     = 0C0000025h;
    STATUS_INVALID_DISPOSITION  = 0C0000026h;
    STATUS_ARRAY_BOUNDS_EXCEEDED        = 0C000008Ch;
    STATUS_FLOAT_DENORMAL_OPERAND       = 0C000008Dh;
    STATUS_FLOAT_DIVIDE_BY_ZERO         = 0C000008Eh;
    STATUS_FLOAT_INEXACT_RESULT      = 0C000008Fh;
    STATUS_FLOAT_INVALID_OPERATION    = 0C0000090h;
    STATUS_FLOAT_OVERFLOW       = 0C0000091h;
    STATUS_FLOAT_STACK_CHECK    = 0C0000092h;
    STATUS_FLOAT_UNDERFLOW      = 0C0000093h;
    STATUS_INTEGER_DIVIDE_BY_ZERO    = 0C0000094h;
    STATUS_INTEGER_OVERFLOW     = 0C0000095h;
    STATUS_PRIVILEGED_INSTRUCTION    = 0C0000096h;
    STATUS_STACK_OVERFLOW       = 0C00000FDh;
    STATUS_CONTROL_C_EXIT       = 0C000013Ah;
    STATUS_INVALID_HANDLE       = 0C0000008h;

    MAXIMUM_WAIT_OBJECTS        = 64;
    MAXIMUM_SUSPEND_COUNT       = MAXCHAR;

TYPE
    KSPIN_LOCK           = ULONG_PTR;

TYPE
    Bytes = RECORD
          BaseMid        : BYTE;
          Flags1         : BYTE;
          Flags2         : BYTE;
          BaseHi         : BYTE;
    END;

    Bits = DWORD;

    HighWord = RECORD
        CASE : CARDINAL OF
          0 : bytes      : Bytes;
          |
          1 : bits       : Bits;
          ELSE
        END;
    END;

    LDT_ENTRY =
    RECORD
        LimitLow        : WORD;
        BaseLow         : WORD;
        BITFIELDS
        BaseMid         : DWORD BY 8;
        Type            : DWORD BY 5;
        Dpl             : DWORD BY 2;
        Pres            : DWORD BY 1;
        LimitHi         : DWORD BY 4;
        Sys             : DWORD BY 1;
        LongMode        : DWORD BY 1;
        Default_Big     : DWORD BY 1;
        Granularity     : DWORD BY 1;
        BaseHi          : DWORD BY 8;
        END;
    END;
    PLDT_ENTRY           = POINTER TO LDT_ENTRY;


TYPE
    EXCEPTION_POINTERS = RECORD
          ExceptionRecord : PEXCEPTION_RECORD;
          ContextRecord  : PCONTEXT;
    END;
    PEXCEPTION_POINTERS  = POINTER TO EXCEPTION_POINTERS;

CONST
    DELETE      = 00010000h;
    READ_CONTROL= 00020000h;
    WRITE_DAC  = 00040000h;
    WRITE_OWNER = 00080000h;
    SYNCHRONIZE = 00100000h;
    STANDARD_RIGHTS_REQUIRED    = 000F0000h;
    STANDARD_RIGHTS_READ        = READ_CONTROL;
    STANDARD_RIGHTS_WRITE       = READ_CONTROL;
    STANDARD_RIGHTS_EXECUTE     = READ_CONTROL;
    STANDARD_RIGHTS_ALL         = 001F0000h;
    SPECIFIC_RIGHTS_ALL         = 0000FFFFh;
    ACCESS_SYSTEM_SECURITY      = 01000000h;
    MAXIMUM_ALLOWED             = 02000000h;
    GENERIC_READ                = 80000000h;
    GENERIC_WRITE               = 40000000h;
    GENERIC_EXECUTE             = 20000000h;
    GENERIC_ALL                 = 10000000h;

    PROCESS_TERMINATE           = 0001h;
    PROCESS_CREATE_THREAD       = 0002h;
    PROCESS_VM_OPERATION        = 0008h;
    PROCESS_VM_READ             = 0010h;
    PROCESS_VM_WRITE            = 0020h;
    PROCESS_DUP_HANDLE          = 0040h;
    PROCESS_CREATE_PROCESS      = 0080h;
    PROCESS_SET_QUOTA           = 0100h;
    PROCESS_SET_INFORMATION     = 0200h;
    PROCESS_QUERY_INFORMATION   = 0400h;
    PROCESS_ALL_ACCESS          = STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR 0FFFh;
    THREAD_TERMINATE            = 0001h;
    THREAD_SUSPEND_RESUME       = 0002h;
    THREAD_GET_CONTEXT          = 0008h;
    THREAD_SET_CONTEXT          = 0010h;
    THREAD_SET_INFORMATION      = 0020h;
    THREAD_QUERY_INFORMATION    = 0040h;
    THREAD_SET_THREAD_TOKEN     = 0080h;
    THREAD_IMPERSONATE          = 0100h;
    THREAD_DIRECT_IMPERSONATION = 0200h;
    THREAD_ALL_ACCESS           = STANDARD_RIGHTS_REQUIRED BOR
                                  SYNCHRONIZE BOR 03FFh;
    TLS_MINIMUM_AVAILABLE       = 64;
    THREAD_BASE_PRIORITY_LOWRT  = 15;
    THREAD_BASE_PRIORITY_MAX    = 2;
    THREAD_BASE_PRIORITY_MIN    = -2;
    THREAD_BASE_PRIORITY_IDLE   = -15;

TYPE
    QUOTA_LIMITS = RECORD
        PagedPoolLimit          : SIZE_T;
        NonPagedPoolLimit       : SIZE_T;
        MinimumWorkingSetSize   : SIZE_T;
        MaximumWorkingSetSize   : SIZE_T;
        PagefileLimit           : SIZE_T;
        TimeLimit               : LARGE_INTEGER;
    END;
    PQUOTA_LIMITS       =  POINTER TO QUOTA_LIMITS;

CONST
    EVENT_MODIFY_STATE   = 00002h;
    EVENT_ALL_ACCESS    = (STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR 3);
    MUTANT_QUERY_STATE   = 00001h;
    MUTANT_ALL_ACCESS   = (STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR MUTANT_QUERY_STATE);
    MUTEX_MODIFY_STATE   = MUTANT_QUERY_STATE;
    MUTEX_ALL_ACCESS     = MUTANT_ALL_ACCESS;
    SEMAPHORE_MODIFY_STATE= 00002h;
    SEMAPHORE_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR 3);
    TIME_ZONE_ID_UNKNOWN = 0;
    TIME_ZONE_ID_STANDARD= 1;
    TIME_ZONE_ID_DAYLIGHT= 2;

    PROCESSOR_INTEL_386         = 386;
    PROCESSOR_INTEL_486         = 486;
    PROCESSOR_INTEL_PENTIUM     = 586;
    PROCESSOR_INTEL_860         = 860;
    PROCESSOR_MIPS_R2000        = 2000;
    PROCESSOR_MIPS_R3000        = 3000;
    PROCESSOR_MIPS_R4000        = 4000;
    PROCESSOR_ALPHA_21064       = 21064;
    PROCESSOR_PPC_601           = 601;
    PROCESSOR_PPC_603           = 603;
    PROCESSOR_PPC_604           = 604;
    PROCESSOR_PPC_620           = 620;

    PROCESSOR_ARCHITECTURE_INTEL        = 0;
    PROCESSOR_ARCHITECTURE_MIPS         = 1;
    PROCESSOR_ARCHITECTURE_ALPHA        = 2;
    PROCESSOR_ARCHITECTURE_PPC          = 3;
    PROCESSOR_ARCHITECTURE_UNKNOWN      = 0FFFFh;

TYPE
    MEMORY_BASIC_INFORMATION = RECORD
          BaseAddress    : PVOID;
          AllocationBase : PVOID;
          AllocationProtect: DWORD;
          RegionSize     : SIZE_T;
          State          : DWORD;
          Protect        : DWORD;
          Type           : DWORD;
    END;
    PMEMORY_BASIC_INFORMATION= POINTER TO MEMORY_BASIC_INFORMATION;

CONST
    SECTION_QUERY        = 00001h;
    SECTION_MAP_WRITE    = 00002h;
    SECTION_MAP_READ     = 00004h;
    SECTION_MAP_EXECUTE  = 00008h;
    SECTION_EXTEND_SIZE  = 00010h;

    SECTION_ALL_ACCESS  = STANDARD_RIGHTS_REQUIRED BOR
                          SECTION_QUERY BOR
                          SECTION_MAP_WRITE BOR
                          SECTION_MAP_READ BOR
                          SECTION_MAP_EXECUTE BOR
                          SECTION_EXTEND_SIZE;
    PAGE_NOACCESS        = 001h;
    PAGE_READONLY        = 002h;
    PAGE_READWRITE       = 004h;
    PAGE_WRITECOPY       = 008h;
    PAGE_EXECUTE         = 010h;
    PAGE_EXECUTE_READ    = 020h;
    PAGE_EXECUTE_READWRITE= 040h;
    PAGE_EXECUTE_WRITECOPY= 080h;
    PAGE_GUARD           = 0100h;
    PAGE_NOCACHE         = 0200h;
    MEM_COMMIT           = 01000h;
    MEM_RESERVE          = 02000h;
    MEM_DECOMMIT         = 04000h;
    MEM_RELEASE          = 08000h;
    MEM_FREE             = 010000h;
    MEM_PRIVATE          = 020000h;
    MEM_MAPPED           = 040000h;
    MEM_TOP_DOWN         = 0100000h;
    SEC_FILE             = 0800000h;
    SEC_IMAGE            = 01000000h;
    SEC_RESERVE          = 04000000h;
    SEC_COMMIT           = 08000000h;
    SEC_NOCACHE          = 010000000h;
    MEM_IMAGE            = SEC_IMAGE;

    FILE_READ_DATA       = 0001h;
    FILE_LIST_DIRECTORY  = 0001h;
    FILE_WRITE_DATA      = 0002h;
    FILE_ADD_FILE        = 0002h;
    FILE_APPEND_DATA     = 0004h;
    FILE_ADD_SUBDIRECTORY= 0004h;
    FILE_CREATE_PIPE_INSTANCE= 0004h;
    FILE_READ_EA         = 0008h;
    FILE_WRITE_EA        = 0010h;
    FILE_EXECUTE         = 0020h;
    FILE_TRAVERSE        = 0020h;
    FILE_DELETE_CHILD    = 0040h;
    FILE_READ_ATTRIBUTES = 0080h;
    FILE_WRITE_ATTRIBUTES= 0100h;
    FILE_READ_PROPERTIES = FILE_READ_EA;
    FILE_WRITE_PROPERTIES= FILE_WRITE_EA;

    FILE_ALL_ACCESS  = STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR 01FFh;
    FILE_GENERIC_READ = STANDARD_RIGHTS_READ BOR FILE_READ_DATA BOR
                        FILE_READ_ATTRIBUTES BOR FILE_READ_EA BOR
                        SYNCHRONIZE;

    FILE_GENERIC_WRITE= STANDARD_RIGHTS_WRITE BOR FILE_WRITE_DATA BOR
                                   FILE_WRITE_ATTRIBUTES BOR
                                   FILE_WRITE_EA BOR FILE_APPEND_DATA BOR
                                   SYNCHRONIZE;

    FILE_GENERIC_EXECUTE = STANDARD_RIGHTS_EXECUTE BOR FILE_READ_ATTRIBUTES BOR
                                 FILE_EXECUTE BOR SYNCHRONIZE;

    FILE_SHARE_READ             = 000000001h;
    FILE_SHARE_WRITE            = 000000002h;
    FILE_ATTRIBUTE_READONLY     = 000000001h;
    FILE_ATTRIBUTE_HIDDEN       = 000000002h;
    FILE_ATTRIBUTE_SYSTEM       = 000000004h;
    FILE_ATTRIBUTE_DIRECTORY    = 000000010h;
    FILE_ATTRIBUTE_ARCHIVE      = 000000020h;
    FILE_ATTRIBUTE_NORMAL       = 000000080h;
    FILE_ATTRIBUTE_TEMPORARY    = 000000100h;
    FILE_ATTRIBUTE_ATOMIC_WRITE = 000000200h;
    FILE_ATTRIBUTE_XACTION_WRITE= 000000400h;
    FILE_ATTRIBUTE_COMPRESSED   = 000000800h;
    FILE_ATTRIBUTE_ENCRYPTED            = 00000040h;
    FILE_ATTRIBUTE_SPARSE_FILE          = 00000200h;
    FILE_ATTRIBUTE_REPARSE_POINT        = 00000400h;
    FILE_ATTRIBUTE_OFFLINE              = 00001000h;
    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  = 00002000h;

    FILE_NOTIFY_CHANGE_FILE_NAME= 000000001h;
    FILE_NOTIFY_CHANGE_DIR_NAME = 000000002h;
    FILE_NOTIFY_CHANGE_ATTRIBUTES= 000000004h;
    FILE_NOTIFY_CHANGE_SIZE     = 000000008h;
    FILE_NOTIFY_CHANGE_LAST_WRITE= 000000010h;
    FILE_NOTIFY_CHANGE_SECURITY = 000000100h;
    MAILSLOT_NO_MESSAGE         = -1;
    MAILSLOT_WAIT_FOREVER       = -1;
    FILE_CASE_SENSITIVE_SEARCH  = 000000001h;
    FILE_CASE_PRESERVED_NAMES   = 000000002h;
    FILE_UNICODE_ON_DISK        = 000000004h;
    FILE_PERSISTENT_ACLS        = 000000008h;
    FILE_FILE_COMPRESSION       = 000000010h;
    FILE_VOLUME_IS_COMPRESSED   = 000008000h;
    IO_COMPLETION_MODIFY_STATE  = 2h;
    IO_COMPLETION_ALL_ACCESS    = STANDARD_RIGHTS_REQUIRED BOR
                                  SYNCHRONIZE BOR 3;

    DUPLICATE_CLOSE_SOURCE      = 000000001h;
    DUPLICATE_SAME_ACCESS       = 000000002h;
    FILE_MAP_COPY               = SECTION_QUERY;
    FILE_MAP_WRITE              = SECTION_MAP_WRITE;
    FILE_MAP_READ               = SECTION_MAP_READ;
    FILE_MAP_ALL_ACCESS         = SECTION_ALL_ACCESS;

TYPE
    PACCESS_TOKEN        = PVOID;
    PSECURITY_DESCRIPTOR = PVOID;
    PSID                 = PVOID;
    ACCESS_MASK          = DWORD;
    PACCESS_MASK         = POINTER TO ACCESS_MASK;

    GENERIC_MAPPING = RECORD
          GenericRead    : ACCESS_MASK;
          GenericWrite   : ACCESS_MASK;
          GenericExecute : ACCESS_MASK;
          GenericAll     : ACCESS_MASK;
    END;
    PGENERIC_MAPPING     = POINTER TO GENERIC_MAPPING;

    <*/PUSH/ALIGN:4/NOPACK*>
    LUID_AND_ATTRIBUTES = RECORD
          Luid           : LUID;
          Attributes     : DWORD;
    END;
    <*/POP*>
    PLUID_AND_ATTRIBUTES = POINTER TO LUID_AND_ATTRIBUTES;

    <*/PUSH/NOWARN:A*>
    LUID_AND_ATTRIBUTES_ARRAY= ARRAY [0..ANYSIZE_ARRAY - 1] OF LUID_AND_ATTRIBUTES;
    <*/POP*>
    PLUID_AND_ATTRIBUTES_ARRAY= POINTER TO LUID_AND_ATTRIBUTES_ARRAY;

    SID_IDENTIFIER_AUTHORITY = RECORD
          Value          : ARRAY [0..6 - 1] OF BYTE;
    END;
    PSID_IDENTIFIER_AUTHORITY= POINTER TO SID_IDENTIFIER_AUTHORITY;

    SID = RECORD
          Revision       : BYTE;
          SubAuthorityCount: BYTE;
          IdentifierAuthority: SID_IDENTIFIER_AUTHORITY;
          SubAuthority   : ARRAY [0..ANYSIZE_ARRAY - 1] OF DWORD;
    END;
    PISID                = POINTER TO SID;


CONST
    SID_REVISION                        = 1;
    SID_MAX_SUB_AUTHORITIES             = 15;
    SID_RECOMMENDED_SUB_AUTHORITIES     = 1;

TYPE
    SID_NAME_USE        = (SidTypeUser = 1,
                           SidTypeGroup, SidTypeDomain, SidTypeAlias,
                           SidTypeWellKnownGroup, SidTypeDeletedAccount,
                           SidTypeInvalid, SidTypeUnknown) BIG;
    PSID_NAME_USE       = POINTER TO SID_NAME_USE;
    SID_AND_ATTRIBUTES  = RECORD
          Sid            : PSID;
          Attributes     : DWORD;
    END;
    PSID_AND_ATTRIBUTES = POINTER TO SID_AND_ATTRIBUTES;


    SID_AND_ATTRIBUTES_ARRAY = ARRAY [0..ANYSIZE_ARRAY - 1] OF SID_AND_ATTRIBUTES;
    PSID_AND_ATTRIBUTES_ARRAY= POINTER TO SID_AND_ATTRIBUTES_ARRAY;
CONST
    SECURITY_NULL_SID_AUTHORITY  : ARRAY [0..5] OF BYTE = {0,0,0,0,0,0};
    SECURITY_WORLD_SID_AUTHORITY : ARRAY [0..5] OF BYTE = {0,0,0,0,0,1};
    SECURITY_LOCAL_SID_AUTHORITY : ARRAY [0..5] OF BYTE = {0,0,0,0,0,2};
    SECURITY_CREATOR_SID_AUTHORITY: ARRAY [0..5] OF BYTE = {0,0,0,0,0,3};
    SECURITY_NON_UNIQUE_AUTHORITY : ARRAY [0..5] OF BYTE = {0,0,0,0,0,4};
    SECURITY_NT_AUTHORITY         : ARRAY [0..5] OF BYTE = {0,0,0,0,0,5};
    SECURITY_NULL_RID           = 0;
    SECURITY_WORLD_RID          = 0;
    SECURITY_LOCAL_RID          = 0;
    SECURITY_CREATOR_OWNER_RID  = 0;
    SECURITY_CREATOR_GROUP_RID  =1;
    SECURITY_DIALUP_RID         = 1;
    SECURITY_NETWORK_RID        = 2;
    SECURITY_BATCH_RID          = 3;
    SECURITY_INTERACTIVE_RID    = 4;
    SECURITY_LOGON_IDS_RID      = 5;
    SECURITY_SERVICE_RID        = 6;
    SECURITY_ANONYMOUS_LOGON_RID= 7;

CONST
    SECURITY_LOGON_IDS_RID_COUNT                = 3;
    SECURITY_LOCAL_SYSTEM_RID                   = 00000012h;
    SECURITY_NT_NON_UNIQUE                      = 00000015h;
    SECURITY_BUILTIN_DOMAIN_RID                 = 00000020h;
    DOMAIN_USER_RID_ADMIN                       = 000001F4h;
    DOMAIN_USER_RID_GUEST                       = 000001F5h;
    DOMAIN_GROUP_RID_ADMINS                     = 00000200h;
    DOMAIN_GROUP_RID_USERS                      = 00000201h;
    DOMAIN_GROUP_RID_GUESTS                     = 00000202h;

    DOMAIN_ALIAS_RID_ADMINS                     = 00000220h;
    DOMAIN_ALIAS_RID_USERS                      = 00000221h;
    DOMAIN_ALIAS_RID_GUESTS                     = 00000222h;
    DOMAIN_ALIAS_RID_POWER_USERS                = 00000223h;
    DOMAIN_ALIAS_RID_ACCOUNT_OPS                = 00000224h;
    DOMAIN_ALIAS_RID_SYSTEM_OPS                 = 00000225h;
    DOMAIN_ALIAS_RID_PRINT_OPS                  = 00000226h;
    DOMAIN_ALIAS_RID_BACKUP_OPS                 = 00000227h;
    DOMAIN_ALIAS_RID_REPLICATOR                 = 00000228h;
    SYSTEM_LUID                                 = 03E7h;
    SE_GROUP_MANDATORY                          = 1;
    SE_GROUP_ENABLED_BY_DEFAULT                 = 2;
    SE_GROUP_ENABLED                            = 4;
    SE_GROUP_OWNER                              = 8;
    SE_GROUP_LOGON_ID                   = 0C0000000h;
    ACL_REVISION         = 2;
    ACL_REVISION1        = 1;
    ACL_REVISION2        = 2;

TYPE
    ACL = RECORD
          AclRevision    : BYTE;
          Sbz1           : BYTE;
          AclSize        : WORD;
          AceCount       : WORD;
          Sbz2           : WORD;
    END;
    PACL                 = POINTER TO ACL;

    ACE_HEADER = RECORD
          AceType        : BYTE;
          AceFlags       : BYTE;
          AceSize        : WORD;
    END;
    PACE_HEADER          = POINTER TO ACE_HEADER;

CONST
    ACCESS_ALLOWED_ACE_TYPE     = 0;
    ACCESS_DENIED_ACE_TYPE      = 1;
    SYSTEM_AUDIT_ACE_TYPE       = 2;
    SYSTEM_ALARM_ACE_TYPE       = 3;
    OBJECT_INHERIT_ACE          = 1;
    CONTAINER_INHERIT_ACE       = 2;
    NO_PROPAGATE_INHERIT_ACE    = 4;
    INHERIT_ONLY_ACE            = 8;
    VALID_INHERIT_FLAGS         = 0Fh;
    SUCCESSFUL_ACCESS_ACE_FLAG  = 040h;
    FAILED_ACCESS_ACE_FLAG      = 080h;

TYPE
    ACCESS_ALLOWED_ACE = RECORD
          Header         : ACE_HEADER;
          Mask           : ACCESS_MASK;
          SidStart       : DWORD;
    END;
    PACCESS_ALLOWED_ACE  = POINTER TO ACCESS_ALLOWED_ACE;

    ACCESS_DENIED_ACE = RECORD
          Header         : ACE_HEADER;
          Mask           : ACCESS_MASK;
          SidStart       : DWORD;
    END;
    PACCESS_DENIED_ACE   = POINTER TO ACCESS_DENIED_ACE;

    SYSTEM_AUDIT_ACE = RECORD
          Header         : ACE_HEADER;
          Mask           : ACCESS_MASK;
          SidStart       : DWORD;
    END;
    PSYSTEM_AUDIT_ACE    = POINTER TO SYSTEM_AUDIT_ACE;

    SYSTEM_ALARM_ACE = RECORD
          Header         : ACE_HEADER;
          Mask           : ACCESS_MASK;
          SidStart       : DWORD;
    END;
    PSYSTEM_ALARM_ACE    = POINTER TO SYSTEM_ALARM_ACE;

    ACL_INFORMATION_CLASS = (dummy, AclRevisionInformation, AclSizeInformation) BIG;
    ACL_REVISION_INFORMATION = RECORD
          AclRevision    : DWORD;
    END;
    PACL_REVISION_INFORMATION= POINTER TO ACL_REVISION_INFORMATION;

    ACL_SIZE_INFORMATION = RECORD
          AceCount       : DWORD;
          AclBytesInUse  : DWORD;
          AclBytesFree   : DWORD;
    END;
    PACL_SIZE_INFORMATION= POINTER TO ACL_SIZE_INFORMATION;

CONST
    SECURITY_DESCRIPTOR_REVISION= (1);
    SECURITY_DESCRIPTOR_REVISION1= (1);
    SECURITY_DESCRIPTOR_MIN_LENGTH= (20);

TYPE
    SECURITY_DESCRIPTOR_CONTROL= WORD;
    PSECURITY_DESCRIPTOR_CONTROL= POINTER TO SECURITY_DESCRIPTOR_CONTROL;

CONST
    SE_OWNER_DEFAULTED   = (0001);
    SE_GROUP_DEFAULTED   = (0002);
    SE_DACL_PRESENT      = (0004);
    SE_DACL_DEFAULTED    = (0008);
    SE_SACL_PRESENT      = (0010);
    SE_SACL_DEFAULTED    = (0020);
    SE_SELF_RELATIVE     = (8000);

TYPE
    SECURITY_DESCRIPTOR = RECORD
          Revision       : BYTE;
          Sbz1           : BYTE;
          Control        : SECURITY_DESCRIPTOR_CONTROL;
          Owner          : PSID;
          Group          : PSID;
          Sacl           : PACL;
          Dacl           : PACL;
    END;
    PISECURITY_DESCRIPTOR= POINTER TO SECURITY_DESCRIPTOR;

CONST
    SE_PRIVILEGE_ENABLED_BY_DEFAULT     = 1;
    SE_PRIVILEGE_ENABLED                = 2;
    SE_PRIVILEGE_USED_FOR_ACCESS        = 80000000h;
    PRIVILEGE_SET_ALL_NECESSARY         = 1;

TYPE
    <*/PUSH/NOWARN:A*>
    PRIVILEGE_SET = RECORD
          PrivilegeCount : DWORD;
          Control        : DWORD;
          Privilege      : ARRAY [0..ANYSIZE_ARRAY - 1] OF LUID_AND_ATTRIBUTES;
    END;
    <*/POP*>
    PPRIVILEGE_SET       = POINTER TO PRIVILEGE_SET;

CONST
    SE_CREATE_TOKEN_NAME              = "SeCreateTokenPrivilege";
    SE_ASSIGNPRIMARYTOKEN_NAME        = "SeAssignPrimaryTokenPrivilege";
    SE_LOCK_MEMORY_NAME               = "SeLockMemoryPrivilege";
    SE_INCREASE_QUOTA_NAME            = "SeIncreaseQuotaPrivilege";
    SE_UNSOLICITED_INPUT_NAME         = "SeUnsolicitedInputPrivilege";
    SE_TCB_NAME                       = "SeTcbPrivilege";
    SE_SECURITY_NAME                  = "SeSecurityPrivilege";
    SE_TAKE_OWNERSHIP_NAME            = "SeTakeOwnershipPrivilege";
    SE_LOAD_DRIVER_NAME               = "SeLoadDriverPrivilege";
    SE_SYSTEM_PROFILE_NAME            = "SeSystemProfilePrivilege";
    SE_SYSTEMTIME_NAME                = "SeSystemtimePrivilege";
    SE_PROF_SINGLE_PROCESS_NAME       = "SeProfileSingleProcessPrivilege";
    SE_INC_BASE_PRIORITY_NAME         = "SeIncreaseBasePriorityPrivilege";
    SE_CREATE_PAGEFILE_NAME           = "SeCreatePagefilePrivilege";
    SE_CREATE_PERMANENT_NAME          = "SeCreatePermanentPrivilege";
    SE_BACKUP_NAME                    = "SeBackupPrivilege";
    SE_RESTORE_NAME                   = "SeRestorePrivilege";
    SE_SHUTDOWN_NAME                  = "SeShutdownPrivilege";
    SE_DEBUG_NAME                     = "SeDebugPrivilege";
    SE_AUDIT_NAME                     = "SeAuditPrivilege";
    SE_SYSTEM_ENVIRONMENT_NAME        = "SeSystemEnvironmentPrivilege";
    SE_CHANGE_NOTIFY_NAME             = "SeChangeNotifyPrivilege";
    SE_REMOTE_SHUTDOWN_NAME           = "SeRemoteShutdownPrivilege";

    SECURITY_DYNAMIC_TRACKING  =        TRUE;
    SECURITY_STATIC_TRACKING   =        FALSE;


TYPE
    SECURITY_IMPERSONATION_LEVEL = (SecurityAnonymous,
                                    SecurityIdentification,
                                    SecurityImpersonation,
                                    SecurityDelegation) BIG;
    PSECURITY_IMPERSONATION_LEVEL= POINTER TO SECURITY_IMPERSONATION_LEVEL;

    SECURITY_CONTEXT_TRACKING_MODE      = BOOLEAN;
    PSECURITY_CONTEXT_TRACKING_MODE     = POINTER TO BOOLEAN;

    SECURITY_QUALITY_OF_SERVICE         = RECORD
          Length                : DWORD;
          ImpersonationLevel    : SECURITY_IMPERSONATION_LEVEL;
          ContextTrackingMode   : SECURITY_CONTEXT_TRACKING_MODE;
          EffectiveOnly         : BOOLEAN;
    END;
    PSECURITY_QUALITY_OF_SERVICE = POINTER TO SECURITY_QUALITY_OF_SERVICE;

    SE_IMPERSONATION_STATE = RECORD
          Token          : PACCESS_TOKEN;
          CopyOnOpen     : BOOLEAN;
          EffectiveOnly  : BOOLEAN;
          Level          : SECURITY_IMPERSONATION_LEVEL;
    END;
    PSE_IMPERSONATION_STATE= POINTER TO SE_IMPERSONATION_STATE;

CONST
    SECURITY_MAX_IMPERSONATION_LEVEL    = SecurityDelegation;
    DEFAULT_IMPERSONATION_LEVEL         = SecurityImpersonation;

    TOKEN_ASSIGN_PRIMARY = 0001h;
    TOKEN_DUPLICATE      = 0002h;
    TOKEN_IMPERSONATE    = 0004h;
    TOKEN_QUERY          = 0008h;
    TOKEN_QUERY_SOURCE   = 0010h;
    TOKEN_ADJUST_PRIVILEGES= 0020h;
    TOKEN_ADJUST_GROUPS  = 0040h;
    TOKEN_ADJUST_DEFAULT = 0080h;
    TOKEN_ALL_ACCESS    = STANDARD_RIGHTS_REQUIRED BOR
                         TOKEN_ASSIGN_PRIMARY BOR
                         TOKEN_DUPLICATE BOR
                         TOKEN_IMPERSONATE BOR
                         TOKEN_QUERY BOR
                         TOKEN_QUERY_SOURCE BOR
                         TOKEN_ADJUST_PRIVILEGES BOR
                         TOKEN_ADJUST_GROUPS BOR
                         TOKEN_ADJUST_DEFAULT;
    TOKEN_READ          = STANDARD_RIGHTS_READ BOR TOKEN_QUERY;
    TOKEN_WRITE         = STANDARD_RIGHTS_WRITE BOR
                         TOKEN_ADJUST_PRIVILEGES BOR
                         TOKEN_ADJUST_GROUPS BOR
                         TOKEN_ADJUST_DEFAULT;
    TOKEN_EXECUTE       = STANDARD_RIGHTS_EXECUTE;

TYPE
    TOKEN_TYPE           = (TokenPrimary, TokenImpersonation) BIG;
    PTOKEN_TYPE          = POINTER TO TOKEN_TYPE;

    TOKEN_INFORMATION_CLASS = (TokenUser, TokenGroups, TokenPrivileges, TokenOwner, TokenPrimaryGroup, TokenDefaultDacl, TokenSource, TokenType, TokenImpersonationLevel, TokenStatistics) BIG;
    PTOKEN_INFORMATION_CLASS= POINTER TO TOKEN_INFORMATION_CLASS;

    TOKEN_USER = RECORD
          User           : SID_AND_ATTRIBUTES;
    END;
    PTOKEN_USER          = POINTER TO TOKEN_USER;

    TOKEN_GROUPS = RECORD
          GroupCount     : DWORD;
          Groups         : ARRAY [0..ANYSIZE_ARRAY - 1] OF SID_AND_ATTRIBUTES;
    END;
    PTOKEN_GROUPS        = POINTER TO TOKEN_GROUPS;

    <*/PUSH/NOWARN:A*>
    TOKEN_PRIVILEGES = RECORD
          PrivilegeCount : DWORD;
          Privileges     : ARRAY [0..ANYSIZE_ARRAY - 1] OF LUID_AND_ATTRIBUTES;
    END;
    <*/POP*>
    PTOKEN_PRIVILEGES    = POINTER TO TOKEN_PRIVILEGES;


    TOKEN_OWNER = RECORD
          Owner          : PSID;
    END;
    PTOKEN_OWNER         = POINTER TO TOKEN_OWNER;

    TOKEN_PRIMARY_GROUP = RECORD
          PrimaryGroup   : PSID;
    END;
    PTOKEN_PRIMARY_GROUP = POINTER TO TOKEN_PRIMARY_GROUP;

    TOKEN_DEFAULT_DACL = RECORD
          DefaultDacl    : PACL;
    END;
    PTOKEN_DEFAULT_DACL  = POINTER TO TOKEN_DEFAULT_DACL;

CONST
    TOKEN_SOURCE_LENGTH  = 8;

TYPE
    TOKEN_SOURCE = RECORD
          SourceName     : ARRAY [0..TOKEN_SOURCE_LENGTH - 1] OF ACHAR;
          SourceIdentifier: LUID;
    END;
    PTOKEN_SOURCE        = POINTER TO TOKEN_SOURCE;


    TOKEN_STATISTICS = RECORD
          TokenId        : LUID;
          AuthenticationId: LUID;
          ExpirationTime : LARGE_INTEGER;
          TokenType      : TOKEN_TYPE;
          ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL;
          DynamicCharged : DWORD;
          DynamicAvailable: DWORD;
          GroupCount     : DWORD;
          PrivilegeCount : DWORD;
          ModifiedId     : LUID;
    END;
    PTOKEN_STATISTICS    = POINTER TO TOKEN_STATISTICS;

    TOKEN_CONTROL = RECORD
          TokenId        : LUID;
          AuthenticationId: LUID;
          ModifiedId     : LUID;
          TokenSource    : TOKEN_SOURCE;
    END;
    PTOKEN_CONTROL       = POINTER TO TOKEN_CONTROL;

    SECURITY_INFORMATION = DWORD;
    PSECURITY_INFORMATION= POINTER TO SECURITY_INFORMATION;
CONST
    OWNER_SECURITY_INFORMATION  = 1;
    GROUP_SECURITY_INFORMATION  = 2;
    DACL_SECURITY_INFORMATION   = 4;
    SACL_SECURITY_INFORMATION   = 8;


(* Start of PE|COFF image stuff, all byte aligned *)
<*/PUSH/PACK*>

CONST
    IMAGE_DOS_SIGNATURE  = 05A4Dh;
    IMAGE_OS2_SIGNATURE  = 0454Eh;
    IMAGE_OS2_SIGNATURE_LE= 0454Ch;
    IMAGE_VXD_SIGNATURE  = 0454Ch;
    IMAGE_NT_SIGNATURE   = 000004550h;

TYPE
    IMAGE_DOS_HEADER = RECORD
          e_magic        : WORD;
          e_cblp         : WORD;
          e_cp           : WORD;
          e_crlc         : WORD;
          e_cparhdr      : WORD;
          e_minalloc     : WORD;
          e_maxalloc     : WORD;
          e_ss           : WORD;
          e_sp           : WORD;
          e_csum         : WORD;
          e_ip           : WORD;
          e_cs           : WORD;
          e_lfarlc       : WORD;
          e_ovno         : WORD;
          e_res          : ARRAY [0..4 - 1] OF WORD;
          e_oemid        : WORD;
          e_oeminfo      : WORD;
          e_res2         : ARRAY [0..10 - 1] OF WORD;
          e_lfanew       : LONG;
    END;
    PIMAGE_DOS_HEADER    = POINTER TO IMAGE_DOS_HEADER;

    IMAGE_OS2_HEADER = RECORD
          ne_magic       : WORD;
          ne_ver         : ACHAR;
          ne_rev         : ACHAR;
          ne_enttab      : WORD;
          ne_cbenttab    : WORD;
          ne_crc         : LONG;
          ne_flags       : WORD;
          ne_autodata    : WORD;
          ne_heap        : WORD;
          ne_stack       : WORD;
          ne_csip        : LONG;
          ne_sssp        : LONG;
          ne_cseg        : WORD;
          ne_cmod        : WORD;
          ne_cbnrestab   : WORD;
          ne_segtab      : WORD;
          ne_rsrctab     : WORD;
          ne_restab      : WORD;
          ne_modtab      : WORD;
          ne_imptab      : WORD;
          ne_nrestab     : LONG;
          ne_cmovent     : WORD;
          ne_align       : WORD;
          ne_cres        : WORD;
          ne_exetyp      : BYTE;
          ne_flagsothers : BYTE;
          ne_pretthunks  : WORD;
          ne_psegrefbytes: WORD;
          ne_swaparea    : WORD;
          ne_expver      : WORD;
    END;
    PIMAGE_OS2_HEADER    = POINTER TO IMAGE_OS2_HEADER;

    IMAGE_FILE_HEADER = RECORD
          Machine        : WORD;
          NumberOfSections: WORD;
          TimeDateStamp  : DWORD;
          PointerToSymbolTable: DWORD;
          NumberOfSymbols: DWORD;
          SizeOfOptionalHeader: WORD;
          Characteristics: WORD;
    END;
    PIMAGE_FILE_HEADER   = POINTER TO IMAGE_FILE_HEADER;

    IMAGE_VXD_HEADER = RECORD
        e32_magic       : WORD;
        e32_border      : BYTE;
        e32_worder      : BYTE;
        e32_level       : DWORD;
        e32_cpu         : WORD;
        e32_os          : WORD;
        e32_ver         : DWORD;
        e32_mflags      : DWORD;
        e32_mpages      : DWORD;
        e32_startobj    : DWORD;
        e32_eip         : DWORD;
        e32_stackobj    : DWORD;
        e32_esp         : DWORD;
        e32_pagesize    : DWORD;
        e32_lastpagesize: DWORD;
        e32_fixupsize   : DWORD;
        e32_fixupsum    : DWORD;
        e32_ldrsize     : DWORD;
        e32_ldrsum      : DWORD;
        e32_objtab      : DWORD;
        e32_objcnt      : DWORD;
        e32_objmap      : DWORD;
        e32_itermap             : DWORD;
        e32_rsrctab             : DWORD;
        e32_rsrccnt             : DWORD;
        e32_restab              : DWORD;
        e32_enttab              : DWORD;
        e32_dirtab              : DWORD;
        e32_dircnt              : DWORD;
        e32_fpagetab            : DWORD;
        e32_frectab             : DWORD;
        e32_impmod              : DWORD;
        e32_impmodcnt           : DWORD;
        e32_impproc             : DWORD;
        e32_pagesum             : DWORD;
        e32_datapage            : DWORD;
        e32_preload             : DWORD;
        e32_nrestab             : DWORD;
        e32_cbnrestab           : DWORD;
        e32_nressum             : DWORD;
        e32_autodata            : DWORD;
        e32_debuginfo           : DWORD;
        e32_debuglen            : DWORD;
        e32_instpreload         : DWORD;
        e32_instdemand          : DWORD;
        e32_heapsize            : DWORD;
        e32_res3                : ARRAY [0..12-1] OF BYTE;
        e32_winresoff           : DWORD;
        e32_winreslen           : DWORD;
        e32_devid               : WORD;
        e32_ddkver              : WORD;
  END;
  PIMAGE_VXD_HEADER     = POINTER TO IMAGE_VXD_HEADER;

CONST
    IMAGE_SIZEOF_FILE_HEADER            = 20;
    IMAGE_FILE_RELOCS_STRIPPED          = 00001h;
    IMAGE_FILE_EXECUTABLE_IMAGE         = 00002h;
    IMAGE_FILE_LINE_NUMS_STRIPPED       = 00004h;
    IMAGE_FILE_LOCAL_SYMS_STRIPPED      = 00008h;
    IMAGE_FILE_AGGRESIVE_WS_TRIM        = 00010h;
    IMAGE_FILE_LARGE_ADDRESS_AWARE      = 00020h;
    IMAGE_FILE_BYTES_REVERSED_LO        = 00080h;
    IMAGE_FILE_32BIT_MACHINE            = 00100h;
    IMAGE_FILE_DEBUG_STRIPPED           = 00200h;
    IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP  = 00400h;
    IMAGE_FILE_NET_RUN_FROM_SWAP        = 00800h;
    IMAGE_FILE_SYSTEM                   = 01000h;
    IMAGE_FILE_DLL                      = 02000h;
    IMAGE_FILE_UP_SYSTEM_ONLY           = 04000h;
    IMAGE_FILE_BYTES_REVERSED_HI        = 08000h;

    IMAGE_FILE_MACHINE_UNKNOWN  = 0;
    IMAGE_FILE_MACHINE_I860     = 014dh;
    IMAGE_FILE_MACHINE_I386     = 014ch;
    IMAGE_FILE_MACHINE_R3000    = 0162h;
    IMAGE_FILE_MACHINE_R4000    = 0166h;
    IMAGE_FILE_MACHINE_R10000   = 0168h;
    IMAGE_FILE_MACHINE_ALPHA    = 0184h;
    IMAGE_FILE_MACHINE_POWERPC  = 01f0h;
    IMAGE_FILE_MACHINE_IA64     = 0200h;
    IMAGE_FILE_MACHINE_AMD64    = 08664h;
    IMAGE_FILE_MACHINE_ALPHA64  = 00284h;
    IMAGE_FILE_MACHINE_AXP64    = IMAGE_FILE_MACHINE_ALPHA64;
    IMAGE_FILE_MACHINE_CEE      = 0C0EEh;

TYPE
    IMAGE_DATA_DIRECTORY = RECORD
          VirtualAddress : DWORD;
          Size           : DWORD;
    END;
    PIMAGE_DATA_DIRECTORY = POINTER TO IMAGE_DATA_DIRECTORY;

CONST
    IMAGE_NUMBEROF_DIRECTORY_ENTRIES= 16;

TYPE
    IMAGE_OPTIONAL_HEADER32 = RECORD
          Magic          : WORD;
          MajorLinkerVersion: BYTE;
          MinorLinkerVersion: BYTE;
          SizeOfCode     : DWORD;
          SizeOfInitializedData: DWORD;
          SizeOfUninitializedData: DWORD;
          AddressOfEntryPoint: DWORD;
          BaseOfCode     : DWORD;
          BaseOfData     : DWORD;
          ImageBase      : DWORD;
          SectionAlignment: DWORD;
          FileAlignment  : DWORD;
          MajorOperatingSystemVersion: WORD;
          MinorOperatingSystemVersion: WORD;
          MajorImageVersion: WORD;
          MinorImageVersion: WORD;
          MajorSubsystemVersion: WORD;
          MinorSubsystemVersion: WORD;
          Reserved1      : DWORD;
          SizeOfImage    : DWORD;
          SizeOfHeaders  : DWORD;
          CheckSum       : DWORD;
          Subsystem      : WORD;
          DllCharacteristics: WORD;
          SizeOfStackReserve: DWORD;
          SizeOfStackCommit: DWORD;
          SizeOfHeapReserve: DWORD;
          SizeOfHeapCommit: DWORD;
          LoaderFlags    : DWORD;
          NumberOfRvaAndSizes: DWORD;
          DataDirectory  : ARRAY [0..IMAGE_NUMBEROF_DIRECTORY_ENTRIES - 1] OF IMAGE_DATA_DIRECTORY;
    END;

    IMAGE_OPTIONAL_HEADER64 = RECORD
          Magic          : WORD;
          MajorLinkerVersion: BYTE;
          MinorLinkerVersion: BYTE;
          SizeOfCode     : DWORD;
          SizeOfInitializedData: DWORD;
          SizeOfUninitializedData: DWORD;
          AddressOfEntryPoint: DWORD;
          BaseOfCode     : DWORD;
          ImageBase      : ULONGLONG;
          SectionAlignment: DWORD;
          FileAlignment  : DWORD;
          MajorOperatingSystemVersion: WORD;
          MinorOperatingSystemVersion: WORD;
          MajorImageVersion: WORD;
          MinorImageVersion: WORD;
          MajorSubsystemVersion: WORD;
          MinorSubsystemVersion: WORD;
          Win32VersionValue: DWORD;
          SizeOfImage    : DWORD;
          SizeOfHeaders  : DWORD;
          CheckSum       : DWORD;
          Subsystem      : WORD;
          DllCharacteristics: WORD;
          SizeOfStackReserve,
          SizeOfStackCommit,
          SizeOfHeapReserve,
          SizeOfHeapCommit: ULONGLONG;
          LoaderFlags    : DWORD;
          NumberOfRvaAndSizes: DWORD;
          DataDirectory  : ARRAY [0..IMAGE_NUMBEROF_DIRECTORY_ENTRIES - 1] OF IMAGE_DATA_DIRECTORY;
    END;

    %IF Bits32 %THEN
    IMAGE_OPTIONAL_HEADER = IMAGE_OPTIONAL_HEADER32;
    %ELSE
    IMAGE_OPTIONAL_HEADER = IMAGE_OPTIONAL_HEADER64;
    %END

    PIMAGE_OPTIONAL_HEADER= POINTER TO IMAGE_OPTIONAL_HEADER;

    IMAGE_ROM_OPTIONAL_HEADER = RECORD
        Magic                   : WORD;
        MajorLinkerVersion      : BYTE;
        MinorLinkerVersion      : BYTE;
        SizeOfCode              : DWORD;
        SizeOfInitializedData   : DWORD;
        SizeOfUninitializedData : DWORD;
        AddressOfEntryPoint     : DWORD;
        BaseOfCode              : DWORD;
        BaseOfData              : DWORD;
        BaseOfBss               : DWORD;
        GprMask                 : DWORD;
        CprMask                 : ARRAY [0..4-1] OF DWORD;
        GpValue                 : DWORD;
    END;
    PIMAGE_ROM_OPTIONAL_HEADER  = POINTER TO IMAGE_ROM_OPTIONAL_HEADER;

CONST
    IMAGE_SIZEOF_ROM_OPTIONAL_HEADER    = 56;
    IMAGE_SIZEOF_STD_OPTIONAL_HEADER    = 28;
    IMAGE_SIZEOF_NT_OPTIONAL_HEADER32     = 224;
    IMAGE_SIZEOF_NT_OPTIONAL_HEADER64     = 240;
    %IF Bits32 %THEN
    IMAGE_SIZEOF_NT_OPTIONAL_HEADER     = IMAGE_SIZEOF_NT_OPTIONAL_HEADER32;
    %ELSE
    IMAGE_SIZEOF_NT_OPTIONAL_HEADER     = IMAGE_SIZEOF_NT_OPTIONAL_HEADER64;
    %END

    IMAGE_NT_OPTIONAL_HDR32_MAGIC       = 010bh;
    IMAGE_NT_OPTIONAL_HDR64_MAGIC       = 020bh;
    %IF Bits32 %THEN
    IMAGE_NT_OPTIONAL_HDR_MAGIC       = IMAGE_NT_OPTIONAL_HDR32_MAGIC;
    %ELSE
    IMAGE_NT_OPTIONAL_HDR_MAGIC       = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
    %END
    IMAGE_ROM_OPTIONAL_HDR_MAGIC        = 0107h;

TYPE
    IMAGE_ROM_HEADERS = RECORD
        FileHeader      : IMAGE_FILE_HEADER;
        OptionalHeader  : IMAGE_ROM_OPTIONAL_HEADER;
    END;
    PIMAGE_ROM_HEADERS  = POINTER TO IMAGE_ROM_HEADERS;

    IMAGE_NT_HEADERS = RECORD
          Signature      : DWORD;
          FileHeader     : IMAGE_FILE_HEADER;
          OptionalHeader : IMAGE_OPTIONAL_HEADER;
    END;
    PIMAGE_NT_HEADERS    = POINTER TO IMAGE_NT_HEADERS;

CONST
    IMAGE_SUBSYSTEM_UNKNOWN     = 0;
    IMAGE_SUBSYSTEM_NATIVE      = 1;
    IMAGE_SUBSYSTEM_WINDOWS_GUI = 2;
    IMAGE_SUBSYSTEM_WINDOWS_CUI = 3;
    IMAGE_SUBSYSTEM_OS2_CUI     = 5;
    IMAGE_SUBSYSTEM_POSIX_CUI   = 7;
    IMAGE_LIBRARY_PROCESS_INIT  = 1;
    IMAGE_LIBRARY_PROCESS_TERM  = 2;
    IMAGE_LIBRARY_THREAD_INIT   = 4;
    IMAGE_LIBRARY_THREAD_TERM   = 8;
    IMAGE_LOADER_FLAGS_BREAK_ON_LOAD= 000000001h;
    IMAGE_LOADER_FLAGS_DEBUG_ON_LOAD= 000000002h;
    IMAGE_DIRECTORY_ENTRY_EXPORT        = 0;
    IMAGE_DIRECTORY_ENTRY_IMPORT        = 1;
    IMAGE_DIRECTORY_ENTRY_RESOURCE      = 2;
    IMAGE_DIRECTORY_ENTRY_EXCEPTION     = 3;
    IMAGE_DIRECTORY_ENTRY_SECURITY      = 4;
    IMAGE_DIRECTORY_ENTRY_BASERELOC     = 5;
    IMAGE_DIRECTORY_ENTRY_DEBUG         = 6;
    IMAGE_DIRECTORY_ENTRY_COPYRIGHT     = 7;
    IMAGE_DIRECTORY_ENTRY_GLOBALPTR     = 8;
    IMAGE_DIRECTORY_ENTRY_TLS           = 9;
    IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   = 10;
    IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT  = 11;
    IMAGE_DIRECTORY_ENTRY_IAT           = 12;

    IMAGE_SIZEOF_SHORT_NAME     = 8;

TYPE
    Misc1 = RECORD
        CASE : CARDINAL OF
          0 : PhysicalAddress: DWORD;
          |
          1 : VirtualSize: DWORD;
          ELSE
        END;
    END;

    IMAGE_SECTION_HEADER = RECORD
          Name           : ARRAY [0..IMAGE_SIZEOF_SHORT_NAME - 1] OF BYTE;
          a              : Misc1;
          VirtualAddress : DWORD;
          SizeOfRawData  : DWORD;
          PointerToRawData: DWORD;
          PointerToRelocations: DWORD;
          PointerToLinenumbers: DWORD;
          NumberOfRelocations: WORD;
          NumberOfLinenumbers: WORD;
          Characteristics: DWORD;
    END;
    PIMAGE_SECTION_HEADER= POINTER TO IMAGE_SECTION_HEADER;


CONST
    IMAGE_SIZEOF_SECTION_HEADER= 40;
    IMAGE_SCN_TYPE_REGULAR= 000000000h;
    IMAGE_SCN_TYPE_DUMMY = 000000001h;
    IMAGE_SCN_TYPE_NO_LOAD= 000000002h;
    IMAGE_SCN_TYPE_GROUPED= 000000004h;
    IMAGE_SCN_TYPE_NO_PAD= 000000008h;
    IMAGE_SCN_TYPE_COPY  = 000000010h;
    IMAGE_SCN_CNT_CODE   = 000000020h;
    IMAGE_SCN_CNT_INITIALIZED_DATA= 000000040h;
    IMAGE_SCN_CNT_UNINITIALIZED_DATA= 000000080h;
    IMAGE_SCN_LNK_OTHER  = 000000100h;
    IMAGE_SCN_LNK_INFO   = 000000200h;
    IMAGE_SCN_LNK_OVERLAY= 000000400h;
    IMAGE_SCN_LNK_REMOVE = 000000800h;
    IMAGE_SCN_LNK_COMDAT = 000001000h;
    IMAGE_SCN_LNK_NRELOC_OVFL = 01000000h;

    IMAGE_SCN_ALIGN_1BYTES= 000100000h;
    IMAGE_SCN_ALIGN_2BYTES= 000200000h;
    IMAGE_SCN_ALIGN_4BYTES= 000300000h;
    IMAGE_SCN_ALIGN_8BYTES= 000400000h;
    IMAGE_SCN_ALIGN_16BYTES= 000500000h;
    IMAGE_SCN_ALIGN_32BYTES= 000600000h;
    IMAGE_SCN_ALIGN_64BYTES= 000700000h;

    IMAGE_SCN_MEM_FARDATA    = 000008000h;
    IMAGE_SCN_MEM_DISCARDABLE= 002000000h;
    IMAGE_SCN_MEM_NOT_CACHED= 004000000h;
    IMAGE_SCN_MEM_NOT_PAGED= 008000000h;
    IMAGE_SCN_MEM_PURGEABLE  = 000020000h;
    IMAGE_SCN_MEM_16BIT      = 000020000h;
    IMAGE_SCN_MEM_LOCKED     = 000040000h;
    IMAGE_SCN_MEM_PRELOAD    = 000080000h;

    IMAGE_SCN_MEM_SHARED = 010000000h;
    IMAGE_SCN_MEM_EXECUTE= 020000000h;
    IMAGE_SCN_MEM_READ   = 040000000h;
    IMAGE_SCN_MEM_WRITE  = 080000000h;

TYPE
    Name = RECORD
          Short          : DWORD;
          Long           : DWORD;
    END;

    N = RECORD
        CASE : CARDINAL OF
          0 : ShortName  : ARRAY [0..8 - 1] OF BYTE;
          |
          1 : Name       : Name;
          |
          2 : LongName   : ARRAY [0..2 - 1] OF PBYTE;
          ELSE
        END;
    END;

    IMAGE_SYMBOL = RECORD
          Name           : ARRAY [0..7] OF ACHAR;
          Value          : DWORD;
          SectionNumber  : SHORT;
          Type           : WORD;
          StorageClass   : BYTE;
          NumberOfAuxSymbols: BYTE;
    END;
    PIMAGE_SYMBOL        = POINTER TO IMAGE_SYMBOL;

CONST
    IMAGE_SIZEOF_SYMBOL  = 18;
    IMAGE_SYM_UNDEFINED = 0;
    IMAGE_SYM_ABSOLUTE  = -1;
    IMAGE_SYM_DEBUG      = -2;
    IMAGE_SYM_TYPE_NULL  = 0;
    IMAGE_SYM_TYPE_VOID  = 1;
    IMAGE_SYM_TYPE_CHAR  = 2;
    IMAGE_SYM_TYPE_SHORT = 3;
    IMAGE_SYM_TYPE_INT   = 4;
    IMAGE_SYM_TYPE_LONG  = 5;
    IMAGE_SYM_TYPE_FLOAT = 6;
    IMAGE_SYM_TYPE_DOUBLE= 7;
    IMAGE_SYM_TYPE_STRUCT= 8;
    IMAGE_SYM_TYPE_UNION = 9;
    IMAGE_SYM_TYPE_ENUM  = 10;
    IMAGE_SYM_TYPE_MOE   = 11;
    IMAGE_SYM_TYPE_BYTE  = 12;
    IMAGE_SYM_TYPE_WORD  = 13;
    IMAGE_SYM_TYPE_UINT  = 14;
    IMAGE_SYM_TYPE_DWORD = 15;
    IMAGE_SYM_TYPE_PCODE = 08000h;

    IMAGE_SYM_DTYPE_NULL = 0;
    IMAGE_SYM_DTYPE_POINTER     = 1;
    IMAGE_SYM_DTYPE_FUNCTION    = 2;
    IMAGE_SYM_DTYPE_ARRAY       = 3;
    IMAGE_SYM_CLASS_END_OF_FUNCTION     = -1;
    IMAGE_SYM_CLASS_NULL        = 0;
    IMAGE_SYM_CLASS_AUTOMATIC   = 1;
    IMAGE_SYM_CLASS_EXTERNAL    = 2;
    IMAGE_SYM_CLASS_STATIC      = 3;
    IMAGE_SYM_CLASS_REGISTER    = 4;
    IMAGE_SYM_CLASS_EXTERNAL_DEF= 5;
    IMAGE_SYM_CLASS_LABEL       = 6;
    IMAGE_SYM_CLASS_UNDEFINED_LABEL     = 7;
    IMAGE_SYM_CLASS_MEMBER_OF_STRUCT    = 8;
    IMAGE_SYM_CLASS_ARGUMENT            = 9;
    IMAGE_SYM_CLASS_STRUCT_TAG          = 10;
    IMAGE_SYM_CLASS_MEMBER_OF_UNION     = 11;
    IMAGE_SYM_CLASS_UNION_TAG           = 12;
    IMAGE_SYM_CLASS_TYPE_DEFINITION     = 13;
    IMAGE_SYM_CLASS_UNDEFINED_STATIC    = 14;
    IMAGE_SYM_CLASS_ENUM_TAG            = 15;
    IMAGE_SYM_CLASS_MEMBER_OF_ENUM      = 16;
    IMAGE_SYM_CLASS_REGISTER_PARAM      = 17;
    IMAGE_SYM_CLASS_BIT_FIELD           = 18;
    IMAGE_SYM_CLASS_FAR_EXTERNAL        = 44h;
    IMAGE_SYM_CLASS_BLOCK               = 100;
    IMAGE_SYM_CLASS_FUNCTION            = 101;
    IMAGE_SYM_CLASS_END_OF_STRUCT       = 102;
    IMAGE_SYM_CLASS_FILE                = 103;
    IMAGE_SYM_CLASS_SECTION             = 104;
    IMAGE_SYM_CLASS_WEAK_EXTERNAL       = 105;
    N_BTMASK             = 017;
    N_TMASK              = 060;
    N_TMASK1             = 0300;
    N_TMASK2             = 0360;
    N_BTSHFT             = 4;
    N_TSHIFT             = 2;
TYPE
    LnSz = RECORD
          Linenumber     : WORD;
          Size           : WORD;
    END;

    Misc2 = RECORD
        CASE : CARDINAL OF
          0 : LnSz       : LnSz;
          |
          1 : TotalSize  : DWORD;
          ELSE
        END;
    END;

    Function = RECORD
          PointerToLinenumber: DWORD;
          PointerToNextFunction: DWORD;
    END;

    Array = RECORD
          Dimension      : ARRAY [0..4 - 1] OF WORD;
    END;

    FcnAry = RECORD
        CASE : CARDINAL OF
          0 : Function   : Function;
          |
          1 : Array      : Array;
          ELSE
        END;
    END;

    Sym = RECORD
          TagIndex       : DWORD;
          Misc           : Misc2;
          FcnAry         : FcnAry;
          TvIndex        : WORD;
    END;

    File = RECORD
          Name           : ARRAY [0..IMAGE_SIZEOF_SYMBOL - 1] OF BYTE;
    END;

    Section = RECORD
          Length         : DWORD;
          NumberOfRelocations: WORD;
          NumberOfLinenumbers: WORD;
          CheckSum       : DWORD;
          Number         : SHORT;
          Selection      : BYTE;
    END;

    SymStruct = RECORD
        TagIndex                : DWORD;
        CASE : BOOLEAN OF
        TRUE :
                Linenumber      : WORD;
                Size            : WORD;
        |
        FALSE :
                TotalSize : DWORD;
        END;
        CASE :BOOLEAN OF
        TRUE :
            PointerToLinenumber         : DWORD;
            PointerToNextFunction       : DWORD;
        |
        FALSE  :
            Dimension                   : ARRAY [0..4-1] OF WORD;
        END;
        TvIndex         : WORD;
    END;
    SectionStruct = RECORD
        Length                  : DWORD;
        NumberOfRelocations     : WORD;
        NumberOfLinenumbers     : WORD;
        CheckSum                : DWORD;
        Number                  : SHORT;
        Selection               : BYTE;
    END;

    IMAGE_AUX_SYMBOL = RECORD
        Sym     : SymStruct;
        Name    : ARRAY [0..IMAGE_SIZEOF_SYMBOL-1] OF BYTE;
        Section : SectionStruct;
    END;
    PIMAGE_AUX_SYMBOL   = POINTER TO IMAGE_AUX_SYMBOL;

CONST
    IMAGE_SIZEOF_AUX_SYMBOL             = 18;
    IMAGE_COMDAT_SELECT_UNKNOWN         = 0;
    IMAGE_COMDAT_SELECT_NODUPLICATES    = 1;
    IMAGE_COMDAT_SELECT_ANY             = 2;
    IMAGE_COMDAT_SELECT_SAME_SIZE       = 3;
    IMAGE_COMDAT_SELECT_EXACT_MATCH     = 4;
    IMAGE_COMDAT_SELECT_ASSOCIATIVE     = 5;
    IMAGE_COMDAT_SELECT_LARGEST         = 6;
    IMAGE_COMDAT_SELECT_NEWEST          = 7;

    IMAGE_WEAK_EXTERN_SEARCH_UNKNOWN    = 0;
    IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY  = 1;
    IMAGE_WEAK_EXTERN_SEARCH_LIBRARY    = 2;
    IMAGE_WEAK_EXTERN_SEARCH_ALIAS      = 3;

TYPE
    IMAGE_RELOCATION = RECORD
          VirtualAddress : DWORD;
          SymbolTableIndex: DWORD;
          Type           : WORD;
    END;
    PIMAGE_RELOCATION    = POINTER TO IMAGE_RELOCATION;

CONST
    IMAGE_SIZEOF_RELOCATION= 10;
    IMAGE_REL_I860_ABSOLUTE= 0;
    IMAGE_REL_I860_DIR32 = 06;
    IMAGE_REL_I860_DIR32NB= 07;
    IMAGE_REL_I860_SECTION= 012;
    IMAGE_REL_I860_SECREL= 013;

    IMAGE_REL_I860_PAIR  = 034;
    IMAGE_REL_I860_HIGH  = 036;
    IMAGE_REL_I860_LOW0  = 037;
    IMAGE_REL_I860_LOW1  = 040;
    IMAGE_REL_I860_LOW2  = 041;
    IMAGE_REL_I860_LOW3  = 042;
    IMAGE_REL_I860_LOW4  = 043;
    IMAGE_REL_I860_SPLIT0= 044;
    IMAGE_REL_I860_SPLIT1= 045;
    IMAGE_REL_I860_SPLIT2= 046;
    IMAGE_REL_I860_HIGHADJ= 047;
    IMAGE_REL_I860_BRADDR= 050;

    IMAGE_REL_I386_ABSOLUTE= 0;
    IMAGE_REL_I386_DIR16 = 01;
    IMAGE_REL_I386_REL16 = 02;
    IMAGE_REL_I386_DIR32 = 06;
    IMAGE_REL_I386_DIR32NB= 07;
    IMAGE_REL_I386_SEG12 = 010;
    IMAGE_REL_I386_SECTION= 012;
    IMAGE_REL_I386_SECREL= 011;
    IMAGE_REL_I386_REL32 = 020;

    IMAGE_REL_MIPS_ABSOLUTE= 0;
    IMAGE_REL_MIPS_REFHALF= 01;
    IMAGE_REL_MIPS_REFWORD= 02;
    IMAGE_REL_MIPS_JMPADDR= 03;
    IMAGE_REL_MIPS_REFHI = 04;
    IMAGE_REL_MIPS_REFLO = 05;
    IMAGE_REL_MIPS_GPREL = 06;
    IMAGE_REL_MIPS_LITERAL= 07;
    IMAGE_REL_MIPS_SECTION      = 10;
    IMAGE_REL_MIPS_SECREL       = 11;
    IMAGE_REL_MIPS_SECRELLO     = 12;
    IMAGE_REL_MIPS_SECRELHI     = 13;
    IMAGE_REL_MIPS_REFWORDNB    = 22;
    IMAGE_REL_MIPS_PAIR         = 25;

    IMAGE_REL_ALPHA_ABSOLUTE= 00h;
    IMAGE_REL_ALPHA_REFLONG= 01h;
    IMAGE_REL_ALPHA_REFQUAD= 02h;
    IMAGE_REL_ALPHA_GPREL32= 03h;
    IMAGE_REL_ALPHA_LITERAL= 04h;
    IMAGE_REL_ALPHA_LITUSE= 05h;
    IMAGE_REL_ALPHA_GPDISP= 06h;
    IMAGE_REL_ALPHA_BRADDR= 07h;
    IMAGE_REL_ALPHA_HINT = 08h;
    IMAGE_REL_ALPHA_INLINE_REFLONG= 09h;
    IMAGE_REL_ALPHA_REFHI       = 0Ah;
    IMAGE_REL_ALPHA_REFLO       = 0Bh;
    IMAGE_REL_ALPHA_PAIR        = 0Ch;
    IMAGE_REL_ALPHA_MATCH       = 0Dh;
    IMAGE_REL_ALPHA_SECTION     = 0Eh;
    IMAGE_REL_ALPHA_SECREL      = 0Fh;
    IMAGE_REL_ALPHA_SECRELLO    = 11h;
    IMAGE_REL_ALPHA_SECRELHI    = 12h;

    IMAGE_REL_ALPHA_REFLONGNB= 010h;

    (* IBM PowerPC relocation types. *)

    IMAGE_REL_PPC_ABSOLUTE = 0000h;  (* NOP *)
    IMAGE_REL_PPC_ADDR64 = 0001h;  (* 64-bit address *)
    IMAGE_REL_PPC_ADDR32 = 0002h;  (* 32-bit address *)
    IMAGE_REL_PPC_ADDR24 = 0003h;  (* 26-bit address, shifted left 2 (branch absolute) *)
    IMAGE_REL_PPC_ADDR16 = 0004h;  (* 16-bit address *)
    IMAGE_REL_PPC_ADDR14   = 0005h;  (* 16-bit address, shifted left 2 (load doubleword) *)
    IMAGE_REL_PPC_REL24    = 0006h;  (* 26-bit PC-relative offset, shifted left 2 (branch relative) *)
    IMAGE_REL_PPC_REL14    = 0007h;  (* 16-bit PC-relative offset, shifted left 2 (br cond relative) *)
    IMAGE_REL_PPC_TOCREL16 = 0008h;  (* 16-bit offset from TOC base *)
    IMAGE_REL_PPC_TOCREL14 = 0009h;  (* 16-bit offset from TOC base, shifted left 2 (load doubleword) *)

    IMAGE_REL_PPC_ADDR32NB = 000Ah;  (* 32-bit addr w/o image base *)
    IMAGE_REL_PPC_SECREL   = 000Bh;  (* va of containing section (as in an image sectionhdr) *)
    IMAGE_REL_PPC_SECTION  = 000Ch;  (* sectionheader number *)
    IMAGE_REL_PPC_IFGLUE   = 000Dh;  (* substitute TOC restore instruction iff symbol is glue code *)
    IMAGE_REL_PPC_IMGLUE   = 000Eh;  (* symbol is glue code; virtual address is TOC restore instruction *)
    IMAGE_REL_PPC_SECREL16 = 000Fh;  (* va of containing section (limited to 16 bits) *)
    IMAGE_REL_PPC_REFHI    = 0010h;
    IMAGE_REL_PPC_REFLO    = 0011h;
    IMAGE_REL_PPC_PAIR     = 0012h;

    IMAGE_REL_PPC_TYPEMASK = 00FFh;  (* mask to isolate above values in IMAGE_RELOCATION.Type *)

    (* Flag bits in IMAGE_RELOCATION.TYPE *)

    IMAGE_REL_PPC_NEG      = 0100h;  (* subtract reloc value rather th;an adding it *)
    IMAGE_REL_PPC_BRTAKEN  = 0200h;  (* fix branch prediction bit to predict branch taken *)
    IMAGE_REL_PPC_BRNTAKEN = 0400h;  (* fix branch prediction bit to predict branch not taken *)
    IMAGE_REL_PPC_TOCDEFN  = 0800h;  (* toc slot defined in file (or, data in toc) *)

(*
// X86-64 relocations
*)
    IMAGE_REL_AMD64_ABSOLUTE    = 00000h;  (* Reference is absolute, no relocation is necessary*)
    IMAGE_REL_AMD64_ADDR64      = 00001h;  (* 64-bit address (VA).*)
    IMAGE_REL_AMD64_ADDR32      = 00002h;  (* 32-bit address (VA).*)
    IMAGE_REL_AMD64_ADDR32NB    = 00003h;  (* 32-bit address w/o image base (RVA).*)
    IMAGE_REL_AMD64_REL32       = 00004h;  (* 32-bit relative address from byte following reloc*)
    IMAGE_REL_AMD64_REL32_1     = 00005h;  (* 32-bit relative address from byte distance 1 from reloc*)
    IMAGE_REL_AMD64_REL32_2     = 00006h;  (* 32-bit relative address from byte distance 2 from reloc*)
    IMAGE_REL_AMD64_REL32_3     = 00007h;  (* 32-bit relative address from byte distance 3 from reloc*)
    IMAGE_REL_AMD64_REL32_4     = 00008h;  (* 32-bit relative address from byte distance 4 from reloc*)
    IMAGE_REL_AMD64_REL32_5     = 00009h;  (* 32-bit relative address from byte distance 5 from reloc*)
    IMAGE_REL_AMD64_SECTION     = 0000Ah;  (* Section index*)
    IMAGE_REL_AMD64_SECREL      = 0000Bh;  (* 32 bit offset from base of section containing target*)
    IMAGE_REL_AMD64_SECREL7     = 0000Ch;  (* 7 bit unsigned offset from base of section containing target*)
    IMAGE_REL_AMD64_TOKEN       = 0000Dh;  (* 32 bit metadata token*)

TYPE
    IMAGE_BASE_RELOCATION = RECORD
          VirtualAddress : DWORD;
          SizeOfBlock    : DWORD;
    END;
    PIMAGE_BASE_RELOCATION= POINTER TO IMAGE_BASE_RELOCATION;

CONST
    IMAGE_SIZEOF_BASE_RELOCATION= 8;
    IMAGE_REL_BASED_ABSOLUTE= 0;
    IMAGE_REL_BASED_HIGH = 1;
    IMAGE_REL_BASED_LOW  = 2;
    IMAGE_REL_BASED_HIGHLOW= 3;
    IMAGE_REL_BASED_HIGHADJ= 4;
    IMAGE_REL_BASED_MIPS_JMPADDR= 5;
    IMAGE_REL_BASED_I860_BRADDR= 6;
    IMAGE_REL_BASED_I860_SPLIT= 7;

TYPE
    IMAGE_LINENUMBER = RECORD
        VirtualAddress  : DWORD;
        Linenumber      : WORD;
    END;
    PIMAGE_LINENUMBER   = POINTER TO IMAGE_LINENUMBER;

CONST
    IMAGE_SIZEOF_LINENUMBER              = 6;

TYPE
    Type = RECORD
        CASE : CARDINAL OF
          0 : SymbolTableIndex: DWORD;
          |
          1 : VirtualAddress: DWORD;
          ELSE
        END;
    END;

CONST
    IMAGE_ARCHIVE_START_SIZE             = 8;
    IMAGE_ARCHIVE_START                  = "!<arch>" + CHR(10);
    IMAGE_ARCHIVE_END                    = "`" + CHR(10);
    IMAGE_ARCHIVE_PAD                    = CHR(10);
    IMAGE_ARCHIVE_LINKER_MEMBER          = "/               ";
    IMAGE_ARCHIVE_LONGNAMES_MEMBER       = "//              ";

TYPE
    IMAGE_ARCHIVE_MEMBER_HEADER = RECORD
          Name           : ARRAY [0..16 - 1] OF BYTE;
          Date           : ARRAY [0..12 - 1] OF BYTE;
          UserID         : ARRAY [0..6 - 1] OF BYTE;
          GroupID        : ARRAY [0..6 - 1] OF BYTE;
          Mode           : ARRAY [0..8 - 1] OF BYTE;
          Size           : ARRAY [0..10 - 1] OF BYTE;
          EndHeader      : ARRAY [0..2 - 1] OF BYTE;
    END;
    PIMAGE_ARCHIVE_MEMBER_HEADER= POINTER TO IMAGE_ARCHIVE_MEMBER_HEADER;

CONST
    IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR= 60;

TYPE
    IMAGE_EXPORT_DIRECTORY = RECORD
          Characteristics: DWORD;
          TimeDateStamp  : DWORD;
          MajorVersion   : WORD;
          MinorVersion   : WORD;
          Name           : DWORD;
          Base           : DWORD;
          NumberOfFunctions: DWORD;
          NumberOfNames  : DWORD;
          AddressOfFunctions: DWORD;
          AddressOfNames : DWORD;
          AddressOfNameOrdinals: DWORD;
    END;
    PIMAGE_EXPORT_DIRECTORY= POINTER TO IMAGE_EXPORT_DIRECTORY;

    IMAGE_IMPORT_BY_NAME = RECORD
          Hint           : WORD;
          Name           : ARRAY [0..1 - 1] OF BYTE;
    END;
    PIMAGE_IMPORT_BY_NAME= POINTER TO IMAGE_IMPORT_BY_NAME;

    IMAGE_IMPORT_DESCRIPTOR  = RECORD
        Characteristics         : DWORD;
        TimeDateStamp           : DWORD;
        ForwarderChain          : DWORD;
        Name                    : DWORD;
        FirstThunk              : PVOID;
    END;
    IMAGE_BOUND_IMPORT_DESCRIPTOR = RECORD
        TimeDateStamp                   : DWORD;
        OffsetModuleName                : WORD;
        NumberOfModuleForwarderRefs     : WORD;
    END;
    LPIMAGE_BOUND_IMPORT_DESCRIPTOR     = POINTER TO IMAGE_BOUND_IMPORT_DESCRIPTOR;

    IMAGE_BOUND_FORWARDER_REF = RECORD
        TimeDateStamp                   : DWORD;
        OffsetModuleName                : WORD;
        Reserved                        : WORD;
    END;
    PIMAGE_BOUND_FORWARDER_REF          = POINTER TO IMAGE_BOUND_FORWARDER_REF;


CONST
    IMAGE_ORDINAL_FLAG   = 080000000h;

TYPE
    PIMAGE_TLS_CALLBACK  = PROCEDURE(PVOID, DWORD, PVOID) [EXPORT];
    IMAGE_TLS_DIRECTORY = RECORD
          StartAddressOfRawData: DWORD;
          EndAddressOfRawData: DWORD;
          AddressOfIndex : PDWORD;
          AddressOfCallBacks: POINTER TO PIMAGE_TLS_CALLBACK;
          SizeOfZeroFill : DWORD;
          Characteristics: DWORD;
    END;
    PIMAGE_TLS_DIRECTORY = POINTER TO IMAGE_TLS_DIRECTORY;

    IMAGE_RESOURCE_DIRECTORY = RECORD
          Characteristics: DWORD;
          TimeDateStamp  : DWORD;
          MajorVersion   : WORD;
          MinorVersion   : WORD;
          NumberOfNamedEntries: WORD;
          NumberOfIdEntries: WORD;
    END;
    PIMAGE_RESOURCE_DIRECTORY= POINTER TO IMAGE_RESOURCE_DIRECTORY;

CONST
    IMAGE_RESOURCE_NAME_IS_STRING= 080000000h;
    IMAGE_RESOURCE_DATA_IS_DIRECTORY= 080000000h;

TYPE
    IMAGE_RESOURCE_DIRECTORY_ENTRY = RECORD
          Name           : DWORD;
          OffsetToData   : DWORD;
    END;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY= POINTER TO IMAGE_RESOURCE_DIRECTORY_ENTRY;

    IMAGE_RESOURCE_DIRECTORY_STRING = RECORD
          Length         : WORD;
          NameString     : ARRAY [0..1 - 1] OF ACHAR;
    END;
    PIMAGE_RESOURCE_DIRECTORY_STRING= POINTER TO IMAGE_RESOURCE_DIRECTORY_STRING;

    IMAGE_RESOURCE_DIR_STRING_U = RECORD
          Length         : WORD;
          NameString     : ARRAY [0..1 - 1] OF WCHAR;
    END;
    PIMAGE_RESOURCE_DIR_STRING_U= POINTER TO IMAGE_RESOURCE_DIR_STRING_U;

    IMAGE_RESOURCE_DATA_ENTRY = RECORD
          OffsetToData   : DWORD;
          Size           : DWORD;
          CodePage       : DWORD;
          Reserved       : DWORD;
    END;
    PIMAGE_RESOURCE_DATA_ENTRY= POINTER TO IMAGE_RESOURCE_DATA_ENTRY;

    IMAGE_LOAD_CONFIG_DIRECTORY = RECORD
          Characteristics: DWORD;
          TimeDateStamp  : DWORD;
          MajorVersion   : WORD;
          MinorVersion   : WORD;
          GlobalFlagsClear: DWORD;
          GlobalFlagsSet : DWORD;
          CriticalSectionDefaultTimeout: DWORD;
          DeCommitFreeBlockThreshold: DWORD;
          DeCommitTotalFreeThreshold: DWORD;
          Reserved       : ARRAY [0..8 - 1] OF DWORD;
    END;
    PIMAGE_LOAD_CONFIG_DIRECTORY= POINTER TO IMAGE_LOAD_CONFIG_DIRECTORY;

    IMAGE_RUNTIME_FUNCTION_ENTRY = RECORD
          BeginAddress   : DWORD;
          EndAddress     : DWORD;
          ExceptionHandler: PVOID;
          HandlerData    : PVOID;
          PrologEndAddress: DWORD;
    END;
    PIMAGE_RUNTIME_FUNCTION_ENTRY= POINTER TO IMAGE_RUNTIME_FUNCTION_ENTRY;

    IMAGE_DEBUG_DIRECTORY = RECORD
          Characteristics: DWORD;
          TimeDateStamp  : DWORD;
          MajorVersion   : WORD;
          MinorVersion   : WORD;
          Type           : DWORD;
          SizeOfData     : DWORD;
          AddressOfRawData: DWORD;
          PointerToRawData: DWORD;
    END;
    PIMAGE_DEBUG_DIRECTORY= POINTER TO IMAGE_DEBUG_DIRECTORY;

CONST
    IMAGE_DEBUG_TYPE_UNKNOWN            = 0;
    IMAGE_DEBUG_TYPE_COFF               = 1;
    IMAGE_DEBUG_TYPE_CODEVIEW           = 2;
    IMAGE_DEBUG_TYPE_FPO                = 3;
    IMAGE_DEBUG_TYPE_MISC               = 4;
    IMAGE_DEBUG_TYPE_EXCEPTION          = 5;
    IMAGE_DEBUG_TYPE_FIXUP              = 6;
    IMAGE_DEBUG_TYPE_OMAP_TO_SRC        = 7;
    IMAGE_DEBUG_TYPE_OMAP_FROM_SRC      = 8;

TYPE
    IMAGE_COFF_SYMBOLS_HEADER = RECORD
          NumberOfSymbols: DWORD;
          LvaToFirstSymbol: DWORD;
          NumberOfLinenumbers: DWORD;
          LvaToFirstLinenumber: DWORD;
          RvaToFirstByteOfCode: DWORD;
          RvaToLastByteOfCode: DWORD;
          RvaToFirstByteOfData: DWORD;
          RvaToLastByteOfData: DWORD;
    END;
    PIMAGE_COFF_SYMBOLS_HEADER= POINTER TO IMAGE_COFF_SYMBOLS_HEADER;

CONST
    FRAME_FPO            = 0;
    FRAME_TRAP           = 1;
    FRAME_TSS            = 2;
    FRAME_NONFPO         = 3;

TYPE
    FPO_DATA = RECORD
        ulOffStart      : DWORD;
        cbProcSize      : DWORD;
        cdwLocals       : DWORD;
        cdwParams       : WORD;
        w1              : WORD;
        w2              : WORD;
    END;
    PFPO_DATA   = POINTER TO FPO_DATA;

CONST
    SIZEOF_RFPO_DATA     = 16;
    IMAGE_DEBUG_MISC_EXENAME= 1;

TYPE
    IMAGE_DEBUG_MISC = RECORD
          DataType       : DWORD;
          Length         : DWORD;
          Unicode        : BOOLEAN;
          Reserved       : ARRAY [0..3 - 1] OF BYTE;
          Data           : ARRAY [0..1 - 1] OF BYTE;
    END;
    PIMAGE_DEBUG_MISC    = POINTER TO IMAGE_DEBUG_MISC;

    IMAGE_FUNCTION_ENTRY = RECORD
        StartingAddress         : DWORD;
        EndingAddress           : DWORD;
        EndOfPrologue           : DWORD;
    END;
    PIMAGE_FUNCTION_ENTRY       = POINTER TO IMAGE_FUNCTION_ENTRY;

    IMAGE_SEPARATE_DEBUG_HEADER = RECORD
          Signature      : WORD;
          Flags          : WORD;
          Machine        : WORD;
          Characteristics: WORD;
          TimeDateStamp  : DWORD;
          CheckSum       : DWORD;
          ImageBase      : DWORD;
          SizeOfImage    : DWORD;
          NumberOfSections: DWORD;
          ExportedNamesSize: DWORD;
          DebugDirectorySize: DWORD;
          Reserved       : ARRAY [0..3 - 1] OF DWORD;
    END;
    PIMAGE_SEPARATE_DEBUG_HEADER= POINTER TO IMAGE_SEPARATE_DEBUG_HEADER;

CONST
    IMAGE_SEPARATE_DEBUG_SIGNATURE= 04944h;

<*/POP*>
(* end of PE|COFF image stuff *)

CONST
    HEAP_NO_SERIALIZE           = 000000001h;
    HEAP_GROWABLE               = 000000002h;
    HEAP_GENERATE_EXCEPTIONS    = 000000004h;
    HEAP_ZERO_MEMORY            = 000000008h;
    HEAP_REALLOC_IN_PLACE_ONLY  = 000000010h;
    HEAP_TAIL_CHECKING_ENABLED  = 000000020h;
    HEAP_FREE_CHECKING_ENABLED  = 000000040h;
    HEAP_DISABLE_COALESCE_ON_FREE= 000000080h;
    HEAP_CREATE_ALIGN_16         = 000010000h;
    HEAP_CREATE_ENABLE_TRACING   = 000020000h;
    HEAP_MAXIMUM_TAG             = 00FFFh;
    HEAP_PSEUDO_TAG_FLAG         = 08000h;
    HEAP_TAG_SHIFT               = 16;

    IS_TEXT_UNICODE_ASCII16               = 0001h;
    IS_TEXT_UNICODE_REVERSE_ASCII16       = 0010h;

    IS_TEXT_UNICODE_STATISTICS            = 0002h;
    IS_TEXT_UNICODE_REVERSE_STATISTICS    = 0020h;

    IS_TEXT_UNICODE_CONTROLS              = 0004h;
    IS_TEXT_UNICODE_REVERSE_CONTROLS      = 0040h;

    IS_TEXT_UNICODE_SIGNATURE             = 0008h;
    IS_TEXT_UNICODE_REVERSE_SIGNATURE     = 0080h;

    IS_TEXT_UNICODE_ILLEGAL_CHARS         = 0100h;
    IS_TEXT_UNICODE_ODD_LENGTH            = 0200h;
    IS_TEXT_UNICODE_DBCS_LEADBYTE         = 0400h;
    IS_TEXT_UNICODE_NULL_BYTES            = 1000h;

    IS_TEXT_UNICODE_UNICODE_MASK          = 0000Fh;
    IS_TEXT_UNICODE_REVERSE_MASK          = 000F0h;
    IS_TEXT_UNICODE_NOT_UNICODE_MASK      = 00F00h;
    IS_TEXT_UNICODE_NOT_ASCII_MASK        = 0F000h;

    COMPRESSION_FORMAT_NONE          = 0000h;
    COMPRESSION_FORMAT_DEFAULT       = 0001h;
    COMPRESSION_FORMAT_LZNT1         = 0002h;
    COMPRESSION_ENGINE_STANDARD      = 0000h;
    COMPRESSION_ENGINE_MAXIMUM       = 0100h;

TYPE
    RTL_CRITICAL_SECTION_DEBUG = RECORD
          Type           : WORD;
          CreatorBackTraceIndex: WORD;
          CriticalSection: POINTER TO RTL_CRITICAL_SECTION;
          ProcessLocksList: LIST_ENTRY;
          EntryCount     : DWORD;
          ContentionCount: DWORD;
          Spare          : ARRAY [0..1] OF DWORD;
    END;
    PRTL_CRITICAL_SECTION_DEBUG= POINTER TO RTL_CRITICAL_SECTION_DEBUG;

CONST
    RTL_CRITSECT_TYPE    = 0;
    RTL_RESOURCE_TYPE    = 1;

TYPE
    RTL_CRITICAL_SECTION = RECORD
        DebugInfo            : PRTL_CRITICAL_SECTION_DEBUG;
        LockCount            : LONG;
        RecursionCount       : LONG;
        OwningThread         : HANDLE;
        LockSemaphore        : HANDLE;
        SpinCount            : ULONG_PTR;
    END;
    PRTL_CRITICAL_SECTION       =  POINTER TO RTL_CRITICAL_SECTION;

CONST
    DLL_PROCESS_ATTACH   = 1;
    DLL_THREAD_ATTACH    = 2;
    DLL_THREAD_DETACH    = 3;
    DLL_PROCESS_DETACH   = 0;
    EVENTLOG_SEQUENTIAL_READ= 00001h;
    EVENTLOG_SEEK_READ   = 00002h;
    EVENTLOG_FORWARDS_READ= 00004h;
    EVENTLOG_BACKWARDS_READ= 00008h;
    EVENTLOG_SUCCESS     = 00000h;
    EVENTLOG_ERROR_TYPE  = 00001h;
    EVENTLOG_WARNING_TYPE= 00002h;
    EVENTLOG_INFORMATION_TYPE= 00004h;
    EVENTLOG_AUDIT_SUCCESS= 00008h;
    EVENTLOG_AUDIT_FAILURE= 00010h;
    EVENTLOG_START_PAIRED_EVENT= 00001h;
    EVENTLOG_END_PAIRED_EVENT= 00002h;
    EVENTLOG_END_ALL_PAIRED_EVENTS= 00004h;
    EVENTLOG_PAIRED_EVENT_ACTIVE= 00008h;
    EVENTLOG_PAIRED_EVENT_INACTIVE= 00010h;

TYPE
    EVENTLOGRECORD = RECORD
          Length         : DWORD;
          Reserved       : DWORD;
          RecordNumber   : DWORD;
          TimeGenerated  : DWORD;
          TimeWritten    : DWORD;
          EventID        : DWORD;
          EventType      : WORD;
          NumStrings     : WORD;
          EventCategory  : WORD;
          ReservedFlags  : WORD;
          ClosingRecordNumber: DWORD;
          StringOffset   : DWORD;
          UserSidLength  : DWORD;
          UserSidOffset  : DWORD;
          DataLength     : DWORD;
          DataOffset     : DWORD;
    END;
    PEVENTLOGRECORD      = POINTER TO EVENTLOGRECORD;

CONST
    DBG_CONTINUE                = 00010002h;
    DBG_TERMINATE_THREAD        = 40010003h;
    DBG_TERMINATE_PROCESS       = 40010004h;
    DBG_CONTROL_C               = 40010005h;
    DBG_CONTROL_BREAK           = 40010008h;
    DBG_EXCEPTION_NOT_HANDLED   = 80010001h;
    KEY_QUERY_VALUE             = 0001h;
    KEY_SET_VALUE               = 0002h;
    KEY_CREATE_SUB_KEY          = 0004h;
    KEY_ENUMERATE_SUB_KEYS      = 0008h;
    KEY_NOTIFY                  = 0010h;
    KEY_CREATE_LINK             = 0020h;
    KEY_READ    = (
                          STANDARD_RIGHTS_READ BOR
                         KEY_QUERY_VALUE BOR
                         KEY_ENUMERATE_SUB_KEYS BOR
                          KEY_NOTIFY
                          )
                          BAND
                          ( BNOT SYNCHRONIZE );
    KEY_WRITE           = (
                          STANDARD_RIGHTS_WRITE BOR
                          KEY_SET_VALUE BOR
                          KEY_CREATE_SUB_KEY
                          )
                          BAND
                          ( BNOT SYNCHRONIZE );
    KEY_EXECUTE         = KEY_READ BAND (BNOT SYNCHRONIZE );
    KEY_ALL_ACCESS    =
                          (
                          STANDARD_RIGHTS_ALL BOR
                          KEY_QUERY_VALUE BOR
                          KEY_SET_VALUE BOR
                          KEY_CREATE_SUB_KEY BOR
                          KEY_ENUMERATE_SUB_KEYS BOR
                          KEY_NOTIFY BOR
                          KEY_CREATE_LINK
                          )
                          BAND
                          (BNOT SYNCHRONIZE);
    REG_OPTION_RESERVED         = 0;
    REG_OPTION_NON_VOLATILE     = 0;
    REG_OPTION_VOLATILE         = 1;
    REG_OPTION_CREATE_LINK      = 2;
    REG_OPTION_BACKUP_RESTORE  = 4;
    REG_LEGAL_OPTION    = (
                          REG_OPTION_RESERVED BOR
                          REG_OPTION_NON_VOLATILE BOR
                          REG_OPTION_VOLATILE BOR
                          REG_OPTION_CREATE_LINK BOR
                          REG_OPTION_BACKUP_RESTORE
                          );
    REG_CREATED_NEW_KEY         = 1;
    REG_OPENED_EXISTING_KEY     = 2;
    REG_WHOLE_HIVE_VOLATILE     = 1;
    REG_REFRESH_HIVE            = 2;
    REG_NOTIFY_CHANGE_NAME      = 1;
    REG_NOTIFY_CHANGE_ATTRIBUTES= 2;
    REG_NOTIFY_CHANGE_LAST_SET = 4;
    REG_NOTIFY_CHANGE_SECURITY = 8;
    REG_LEGAL_CHANGE_FILTER     = REG_NOTIFY_CHANGE_NAME BOR
                                 REG_NOTIFY_CHANGE_ATTRIBUTES BOR
                                 REG_NOTIFY_CHANGE_LAST_SET BOR
                                 REG_NOTIFY_CHANGE_SECURITY;
    REG_NONE             = 0;
    REG_SZ               = 1;
    REG_EXPAND_SZ        = 2;
    REG_BINARY           = 3;
    REG_DWORD            = 4;
    REG_DWORD_LITTLE_ENDIAN= 4;
    REG_DWORD_BIG_ENDIAN = 5;
    REG_LINK             = 6;
    REG_MULTI_SZ         = 7;
    REG_RESOURCE_LIST    = 8;
    REG_FULL_RESOURCE_DESCRIPTOR        = 9;
    REG_RESOURCE_REQUIREMENTS_LIST      = 10;

    SERVICE_KERNEL_DRIVER               = 000000001h;
    SERVICE_FILE_SYSTEM_DRIVER          = 000000002h;
    SERVICE_ADAPTER                     = 000000004h;
    SERVICE_RECOGNIZER_DRIVER           = 000000008h;
    SERVICE_DRIVER       = (SERVICE_KERNEL_DRIVER BOR
                            SERVICE_FILE_SYSTEM_DRIVER BOR
                            SERVICE_RECOGNIZER_DRIVER);
    SERVICE_WIN32_OWN_PROCESS           = 000000010h;
    SERVICE_WIN32_SHARE_PROCESS         = 000000020h;
    SERVICE_WIN32        = (SERVICE_WIN32_OWN_PROCESS BOR
                            SERVICE_WIN32_SHARE_PROCESS);

    SERVICE_INTERACTIVE_PROCESS    = 000000100h;

    SERVICE_TYPE_ALL     = SERVICE_WIN32 BOR
                           SERVICE_ADAPTER BOR
                           SERVICE_DRIVER BOR
                           SERVICE_INTERACTIVE_PROCESS;

    SERVICE_BOOT_START   = 000000000h;
    SERVICE_SYSTEM_START = 000000001h;
    SERVICE_AUTO_START   = 000000002h;
    SERVICE_DEMAND_START = 000000003h;
    SERVICE_DISABLED     = 000000004h;
    SERVICE_ERROR_IGNORE = 000000000h;
    SERVICE_ERROR_NORMAL = 000000001h;
    SERVICE_ERROR_SEVERE = 000000002h;
    SERVICE_ERROR_CRITICAL= 000000003h;

TYPE
    SERVICE_NODE_TYPE = (DriverType, FileSystemType, Win32ServiceOwnProcess, Win32ServiceShareProcess, AdapterType, RecognizerType) BIG;
    SERVICE_LOAD_TYPE = (BootLoad, SystemLoad, AutoLoad, DemandLoad, DisableLoad) BIG;
    ERROR_CONTROL_TYPE = (IgnoreError, NormalError, SevereError, CriticalError) BIG;

CONST
    TAPE_ERASE_SHORT     = 0;
    TAPE_ERASE_LONG      = 1;

TYPE
    TAPE_ERASE = RECORD
          Type           : DWORD;
          Immediate      : BOOLEAN;
    END;
    PTAPE_ERASE          = POINTER TO TAPE_ERASE;

CONST
    TAPE_LOAD            = 0;
    TAPE_UNLOAD          = 1;
    TAPE_TENSION         = 2;
    TAPE_LOCK            = 3;
    TAPE_UNLOCK          = 4;
    TAPE_FORMAT          = 5;

TYPE
    TAPE_PREPARE = RECORD
          Operation      : DWORD;
          Immediate      : BOOLEAN;
    END;
    PTAPE_PREPARE        = POINTER TO TAPE_PREPARE;

CONST
    TAPE_SETMARKS        = 0;
    TAPE_FILEMARKS       = 1;
    TAPE_SHORT_FILEMARKS = 2;
    TAPE_LONG_FILEMARKS  = 3;

TYPE
    TAPE_WRITE_MARKS = RECORD
          Type           : DWORD;
          Count          : DWORD;
          Immediate      : BOOLEAN;
    END;
    PTAPE_WRITE_MARKS    = POINTER TO TAPE_WRITE_MARKS;

CONST
    TAPE_ABSOLUTE_POSITION= 0;
    TAPE_LOGICAL_POSITION= 1;
    TAPE_PSEUDO_LOGICAL_POSITION= 2;

TYPE
    TAPE_GET_POSITION = RECORD
          Type           : DWORD;
          Partition      : DWORD;
          Offset         : LARGE_INTEGER;
    END;
    PTAPE_GET_POSITION   = POINTER TO TAPE_GET_POSITION;

CONST
    TAPE_REWIND          = 0;
    TAPE_ABSOLUTE_BLOCK  = 1;
    TAPE_LOGICAL_BLOCK   = 2;
    TAPE_PSEUDO_LOGICAL_BLOCK= 3;
    TAPE_SPACE_END_OF_DATA= 4;
    TAPE_SPACE_RELATIVE_BLOCKS= 5;
    TAPE_SPACE_FILEMARKS = 6;
    TAPE_SPACE_SEQUENTIAL_FMKS= 7;
    TAPE_SPACE_SETMARKS  = 8;
    TAPE_SPACE_SEQUENTIAL_SMKS= 9;

TYPE
    TAPE_SET_POSITION = RECORD
          Method         : DWORD;
          Partition      : DWORD;
          Offset         : LARGE_INTEGER;
          Immediate      : BOOLEAN;
    END;
    PTAPE_SET_POSITION   = POINTER TO TAPE_SET_POSITION;

CONST
    TAPE_DRIVE_FIXED     = 000000001h;
    TAPE_DRIVE_SELECT    = 000000002h;
    TAPE_DRIVE_INITIATOR = 000000004h;
    TAPE_DRIVE_ERASE_SHORT= 000000010h;
    TAPE_DRIVE_ERASE_LONG= 000000020h;
    TAPE_DRIVE_ERASE_BOP_ONLY= 000000040h;
    TAPE_DRIVE_ERASE_IMMEDIATE= 000000080h;
    TAPE_DRIVE_TAPE_CAPACITY= 000000100h;
    TAPE_DRIVE_TAPE_REMAINING= 000000200h;
    TAPE_DRIVE_FIXED_BLOCK= 000000400h;
    TAPE_DRIVE_VARIABLE_BLOCK= 000000800h;
    TAPE_DRIVE_WRITE_PROTECT= 000001000h;
    TAPE_DRIVE_EOT_WZ_SIZE= 000002000h;
    TAPE_DRIVE_ECC       = 000010000h;
    TAPE_DRIVE_COMPRESSION= 000020000h;
    TAPE_DRIVE_PADDING   = 000040000h;
    TAPE_DRIVE_REPORT_SMKS= 000080000h;
    TAPE_DRIVE_GET_ABSOLUTE_BLK= 000100000h;
    TAPE_DRIVE_GET_LOGICAL_BLK= 000200000h;
    TAPE_DRIVE_SET_EOT_WZ_SIZE= 000400000h;
    TAPE_DRIVE_RESERVED_BIT= 080000000h;
    TAPE_DRIVE_LOAD_UNLOAD= 080000001h;
    TAPE_DRIVE_TENSION   = 080000002h;
    TAPE_DRIVE_LOCK_UNLOCK= 080000004h;
    TAPE_DRIVE_REWIND_IMMEDIATE= 080000008h;
    TAPE_DRIVE_SET_BLOCK_SIZE= 080000010h;
    TAPE_DRIVE_LOAD_UNLD_IMMED= 080000020h;
    TAPE_DRIVE_TENSION_IMMED= 080000040h;
    TAPE_DRIVE_LOCK_UNLK_IMMED= 080000080h;
    TAPE_DRIVE_SET_ECC   = 080000100h;
    TAPE_DRIVE_SET_COMPRESSION= 080000200h;
    TAPE_DRIVE_SET_PADDING= 080000400h;
    TAPE_DRIVE_SET_REPORT_SMKS= 080000800h;
    TAPE_DRIVE_ABSOLUTE_BLK= 080001000h;
    TAPE_DRIVE_ABS_BLK_IMMED= 080002000h;
    TAPE_DRIVE_LOGICAL_BLK= 080004000h;
    TAPE_DRIVE_LOG_BLK_IMMED= 080008000h;
    TAPE_DRIVE_END_OF_DATA= 080010000h;
    TAPE_DRIVE_RELATIVE_BLKS= 080020000h;
    TAPE_DRIVE_FILEMARKS = 080040000h;
    TAPE_DRIVE_SEQUENTIAL_FMKS= 080080000h;
    TAPE_DRIVE_SETMARKS  = 080100000h;
    TAPE_DRIVE_SEQUENTIAL_SMKS= 080200000h;
    TAPE_DRIVE_REVERSE_POSITION= 080400000h;
    TAPE_DRIVE_SPACE_IMMEDIATE= 080800000h;
    TAPE_DRIVE_WRITE_SETMARKS= 081000000h;
    TAPE_DRIVE_WRITE_FILEMARKS= 082000000h;
    TAPE_DRIVE_WRITE_SHORT_FMKS= 084000000h;
    TAPE_DRIVE_WRITE_LONG_FMKS= 088000000h;
    TAPE_DRIVE_WRITE_MARK_IMMED= 090000000h;
    TAPE_DRIVE_FORMAT    = 0A0000000h;
    TAPE_DRIVE_FORMAT_IMMEDIATE= 0C0000000h;
    TAPE_DRIVE_HIGH_FEATURES= 080000000h;

TYPE
    TAPE_GET_DRIVE_PARAMETERS = RECORD
          ECC            : BOOLEAN;
          Compression    : BOOLEAN;
          DataPadding    : BOOLEAN;
          ReportSetmarks : BOOLEAN;
          DefaultBlockSize: DWORD;
          MaximumBlockSize: DWORD;
          MinimumBlockSize: DWORD;
          MaximumPartitionCount: DWORD;
          FeaturesLow    : DWORD;
          FeaturesHigh   : DWORD;
          EOTWarningZoneSize: DWORD;
    END;
    PTAPE_GET_DRIVE_PARAMETERS= POINTER TO TAPE_GET_DRIVE_PARAMETERS;

    TAPE_SET_DRIVE_PARAMETERS = RECORD
          ECC            : BOOLEAN;
          Compression    : BOOLEAN;
          DataPadding    : BOOLEAN;
          ReportSetmarks : BOOLEAN;
          EOTWarningZoneSize: DWORD;
    END;
    PTAPE_SET_DRIVE_PARAMETERS= POINTER TO TAPE_SET_DRIVE_PARAMETERS;

    TAPE_GET_MEDIA_PARAMETERS = RECORD
          Capacity       : LARGE_INTEGER;
          Remaining      : LARGE_INTEGER;
          BlockSize      : DWORD;
          PartitionCount : DWORD;
          WriteProtected : BOOLEAN;
    END;
    PTAPE_GET_MEDIA_PARAMETERS= POINTER TO TAPE_GET_MEDIA_PARAMETERS;

    TAPE_SET_MEDIA_PARAMETERS = RECORD
          BlockSize      : DWORD;
    END;
    PTAPE_SET_MEDIA_PARAMETERS= POINTER TO TAPE_SET_MEDIA_PARAMETERS;

CONST
    TAPE_FIXED_PARTITIONS= 0;
    TAPE_SELECT_PARTITIONS= 1;
    TAPE_INITIATOR_PARTITIONS= 2;

TYPE
    TAPE_CREATE_PARTITION = RECORD
          Method         : DWORD;
          Count          : DWORD;
          Size           : DWORD;
    END;
    PTAPE_CREATE_PARTITION= POINTER TO TAPE_CREATE_PARTITION;

    WPARAM               = UINT_PTR;
    LPARAM               = LONG_PTR;
    LRESULT              = LONG_PTR;
    ATOM                 = WORD;
    PATOM                = POINTER TO ATOM;
    LPATOM               = POINTER TO ATOM;
    SPHANDLE             = POINTER TO HANDLE;
    LPHANDLE             = POINTER TO HANDLE;
    HGLOBAL              = HANDLE;
    HLOCAL               = HANDLE;
    GLOBALHANDLE         = HANDLE;
    LOCALHANDLE          = HANDLE;
    FARPROC              = PROCEDURE():INTEGER;
    WPROC                = PROCEDURE():INTEGER;
    HFILE                = INTEGER;
    COLORREF             = DWORD;
    LPCOLORREF           = POINTER TO DWORD;

    RemHGLOBAL = RECORD
        fNullHGlobal    : LONG;
        cbData          : ULONG;
        data            : ARRAY [0..0] OF BYTE;
    END;
    LPRemHGLOBAL        = POINTER TO RemHGLOBAL;

    RemHMETAFILE = RECORD
        mm      : LONG;
        xExt    : LONG;
        yExt    : LONG;
        cbData  : ULONG;
        data    : ARRAY [0..1-1] OF BYTE;
    END;

    RemHENHMETAFILE = RECORD
        cbData  : ULONG;
        data    : ARRAY [0..1-1] OF BYTE;
    END;

    RemHBITMAP = RECORD
        cbData  : ULONG;
        data    : ARRAY [0..1-1] OF BYTE;
    END;

    RemHPALETTE = RECORD
        cbData  : ULONG;
        data    : ARRAY [0..1-1] OF BYTE;
    END;

    RemBRUSH =RECORD
        cbData  : ULONG;
        data    : ARRAY [0..1-1] OF BYTE;
    END;

CONST
    HFILE_ERROR          = -1;
    INVALID_ATOM         = CAST(ATOM,0);

TYPE
    RECT = RECORD
          left           : LONG;
          top            : LONG;
          right          : LONG;
          bottom         : LONG;
    END;
    PRECT                = POINTER TO RECT;
    LPRECT               = PRECT;

    RECTL = RECORD
          left           : LONG;
          top            : LONG;
          right          : LONG;
          bottom         : LONG;
    END;
    PRECTL               = POINTER TO RECTL;
    LPRECTL              = PRECTL;

    POINT = RECORD
          x              : LONG;
          y              : LONG;
    END;
    PPOINT               = POINTER TO POINT;
    LPPOINT              = PPOINT;

    POINTL = RECORD
          x              : LONG;
          y              : LONG;
    END;
    PPOINTL              = POINTER TO POINTL;

    WSIZE = RECORD
          cx             : LONG;
          cy             : LONG;
    END;
    PSIZE                = POINTER TO WSIZE;
    LPSIZE               = PSIZE;

    SIZEL                = WSIZE;
    PSIZEL               = POINTER TO WSIZE;

    POINTS = RECORD
          x              : SHORT;
          y              : SHORT;
    END;
    PPOINTS              = POINTER TO POINTS;
    LPPOINTS             = PPOINTS;

CONST
    DM_UPDATE            = 1;
    DM_COPY              = 2;
    DM_PROMPT            = 4;
    DM_MODIFY            = 8;
    DM_IN_BUFFER         = DM_MODIFY;
    DM_IN_PROMPT         = DM_PROMPT;
    DM_OUT_BUFFER        = DM_COPY;
    DM_OUT_DEFAULT       = DM_UPDATE;

    DC_FIELDS            = 1;
    DC_PAPERS            = 2;
    DC_PAPERSIZE         = 3;
    DC_MINEXTENT         = 4;
    DC_MAXEXTENT         = 5;
    DC_BINS              = 6;
    DC_DUPLEX            = 7;
    DC_SIZE              = 8;
    DC_EXTRA             = 9;
    DC_VERSION           = 10;
    DC_DRIVER            = 11;
    DC_BINNAMES          = 12;
    DC_ENUMRESOLUTIONS   = 13;
    DC_FILEDEPENDENCIES  = 14;
    DC_TRUETYPE          = 15;
    DC_PAPERNAMES        = 16;
    DC_ORIENTATION       = 17;
    DC_COPIES            = 18;

    FILE_BEGIN           = 0;
    FILE_CURRENT         = 1;
    FILE_END             = 2;

    INVALID_HANDLE_VALUE = CAST(HANDLE, -1);
    INVALID_FILE_SIZE   = 0FFFFFFFFh;
	INVALID_FILE_ATTRIBUTES = CAST(DWORD,-1);
	INVALID_SET_FILE_POINTER = CAST(DWORD,-1);

    TIME_ZONE_ID_INVALID =0FFFFFFFFh;

    WAIT_FAILED          = 0FFFFFFFFh;
    WAIT_OBJECT_0        = STATUS_WAIT_0;
    WAIT_ABANDONED       = STATUS_ABANDONED_WAIT_0;
    WAIT_ABANDONED_0     = STATUS_ABANDONED_WAIT_0;
    WAIT_TIMEOUT         = STATUS_TIMEOUT;
    WAIT_IO_COMPLETION   = STATUS_USER_APC;
    STILL_ACTIVE         = STATUS_PENDING;

    EXCEPTION_ACCESS_VIOLATION          = STATUS_ACCESS_VIOLATION;
    EXCEPTION_DATATYPE_MISALIGNMENT     = STATUS_DATATYPE_MISALIGNMENT;
    EXCEPTION_BREAKPOINT                = STATUS_BREAKPOINT;
    EXCEPTION_SINGLE_STEP               = STATUS_SINGLE_STEP;
    EXCEPTION_ARRAY_BOUNDS_EXCEEDED     = STATUS_ARRAY_BOUNDS_EXCEEDED;
    EXCEPTION_FLT_DENORMAL_OPERAND      = STATUS_FLOAT_DENORMAL_OPERAND;
    EXCEPTION_FLT_DIVIDE_BY_ZERO        = STATUS_FLOAT_DIVIDE_BY_ZERO;
    EXCEPTION_FLT_INEXACT_RESULT        = STATUS_FLOAT_INEXACT_RESULT;
    EXCEPTION_FLT_INVALID_OPERATION     = STATUS_FLOAT_INVALID_OPERATION;
    EXCEPTION_FLT_OVERFLOW              = STATUS_FLOAT_OVERFLOW;
    EXCEPTION_FLT_STACK_CHECK           = STATUS_FLOAT_STACK_CHECK;
    EXCEPTION_FLT_UNDERFLOW             = STATUS_FLOAT_UNDERFLOW;
    EXCEPTION_INT_DIVIDE_BY_ZERO        = STATUS_INTEGER_DIVIDE_BY_ZERO;
    EXCEPTION_INT_OVERFLOW              = STATUS_INTEGER_OVERFLOW;
    EXCEPTION_PRIV_INSTRUCTION          = STATUS_PRIVILEGED_INSTRUCTION;
    EXCEPTION_IN_PAGE_ERROR             = STATUS_IN_PAGE_ERROR;
    EXCEPTION_ILLEGAL_INSTRUCTION       = STATUS_ILLEGAL_INSTRUCTION;
    EXCEPTION_NONCONTINUABLE_EXCEPTION  = STATUS_NONCONTINUABLE_EXCEPTION;
    EXCEPTION_STACK_OVERFLOW            = STATUS_STACK_OVERFLOW;
    EXCEPTION_INVALID_DISPOSITION       = STATUS_INVALID_DISPOSITION;
    EXCEPTION_GUARD_PAGE                = STATUS_GUARD_PAGE_VIOLATION;
    EXCEPTION_INVALID_HANDLE            = STATUS_INVALID_HANDLE;

    CONTROL_C_EXIT                      = STATUS_CONTROL_C_EXIT;

    FILE_FLAG_WRITE_THROUGH     = 080000000h;
    FILE_FLAG_OVERLAPPED        = 040000000h;
    FILE_FLAG_NO_BUFFERING      = 020000000h;
    FILE_FLAG_RANDOM_ACCESS     = 010000000h;
    FILE_FLAG_SEQUENTIAL_SCAN   = 008000000h;
    FILE_FLAG_DELETE_ON_CLOSE   = 004000000h;
    FILE_FLAG_BACKUP_SEMANTICS  = 002000000h;
    FILE_FLAG_POSIX_SEMANTICS   = 001000000h;
    FILE_FLAG_OPEN_REPARSE_POINT    = 00200000h;
    FILE_FLAG_OPEN_NO_RECALL        = 00100000h;

    CREATE_NEW           = 1;
    CREATE_ALWAYS        = 2;
    OPEN_EXISTING        = 3;
    OPEN_ALWAYS          = 4;
    TRUNCATE_EXISTING    = 5;

(*
 Define possible return codes from the CopyFileEx callback routine
*)

    PROGRESS_CONTINUE   =0;
    PROGRESS_CANCEL     =1;
    PROGRESS_STOP       =2;
    PROGRESS_QUIET      =3;

(*
 Define CopyFileEx callback routine state change values
*)

    CALLBACK_CHUNK_FINISHED         = 00000000;
    CALLBACK_STREAM_SWITCH          = 00000001;

(*
 Define CopyFileEx option flags
*)

    COPY_FILE_FAIL_IF_EXISTS        = 00000001;
    COPY_FILE_RESTARTABLE           = 00000002;
    COPY_FILE_OPEN_SOURCE_FOR_WRITE = 00000004;

    PIPE_ACCESS_INBOUND  = 000000001h;
    PIPE_ACCESS_OUTBOUND = 000000002h;
    PIPE_ACCESS_DUPLEX   = 000000003h;
    PIPE_CLIENT_END      = 000000000h;
    PIPE_SERVER_END      = 000000001h;
    PIPE_WAIT            = 000000000h;
    PIPE_NOWAIT          = 000000001h;
    PIPE_READMODE_BYTE   = 000000000h;
    PIPE_READMODE_MESSAGE= 000000002h;
    PIPE_TYPE_BYTE       = 000000000h;
    PIPE_TYPE_MESSAGE    = 000000004h;
    PIPE_UNLIMITED_INSTANCES    = 255;

    SECURITY_ANONYMOUS          = ORD(SecurityAnonymous) SHL 16;
    SECURITY_IDENTIFICATION     = ORD(SecurityIdentification) SHL 16;
    SECURITY_IMPERSONATION      = ORD(SecurityImpersonation) SHL 16;
    SECURITY_DELEGATION         = ORD(SecurityDelegation) SHL 16;
    SECURITY_CONTEXT_TRACKING   = 000040000h;
    SECURITY_EFFECTIVE_ONLY     = 000080000h;
    SECURITY_SQOS_PRESENT       = 000100000h;
    SECURITY_VALID_SQOS_FLAGS   = 0001F0000h;

TYPE
    OVERLAPPED = RECORD
          Internal       : ULONG_PTR;
          InternalHigh   : ULONG_PTR;
          Offset         : DWORD;
          OffsetHigh     : DWORD;
          hEvent         : HANDLE;
    END;
    LPOVERLAPPED         = POINTER TO OVERLAPPED;

    SECURITY_ATTRIBUTES = RECORD
          nLength        : DWORD;
          lpSecurityDescriptor: LPVOID;
          bInheritHandle : BOOL;
    END;
    PSECURITY_ATTRIBUTES = POINTER TO SECURITY_ATTRIBUTES;
    LPSECURITY_ATTRIBUTES= PSECURITY_ATTRIBUTES;

    PROCESS_INFORMATION = RECORD
          hProcess       : HANDLE;
          hThread        : HANDLE;
          dwProcessId    : DWORD;
          dwThreadId     : DWORD;
    END;
    PPROCESS_INFORMATION = POINTER TO PROCESS_INFORMATION;
    LPPROCESS_INFORMATION= PPROCESS_INFORMATION;

    FILETIME = RECORD
          dwLowDateTime  : DWORD;
          dwHighDateTime : DWORD;
    END;
    PFILETIME            = POINTER TO FILETIME;
    LPFILETIME           = PFILETIME;

    SYSTEMTIME = RECORD
          wYear          : WORD;
          wMonth         : WORD;
          wDayOfWeek     : WORD;
          wDay           : WORD;
          wHour          : WORD;
          wMinute        : WORD;
          wSecond        : WORD;
          wMilliseconds  : WORD;
    END;
    PSYSTEMTIME          = POINTER TO SYSTEMTIME;
    LPSYSTEMTIME         = PSYSTEMTIME;

    PTHREAD_START_ROUTINE       = PROCEDURE(LPVOID) : DWORD [EXPORT];
    LPTHREAD_START_ROUTINE      = PTHREAD_START_ROUTINE;

    PFIBER_START_ROUTINE        = PROCEDURE (LPVOID) [EXPORT];
    LPFIBER_START_ROUTINE       = PFIBER_START_ROUTINE;

    CRITICAL_SECTION            = RTL_CRITICAL_SECTION;
    PCRITICAL_SECTION           = PRTL_CRITICAL_SECTION;
    LPCRITICAL_SECTION          = PRTL_CRITICAL_SECTION;
    CRITICAL_SECTION_DEBUG      = RTL_CRITICAL_SECTION_DEBUG;
    PCRITICAL_SECTION_DEBUG     = PRTL_CRITICAL_SECTION_DEBUG;
    LPCRITICAL_SECTION_DEBUG    = PRTL_CRITICAL_SECTION_DEBUG;
    LPLDT_ENTRY                 = PLDT_ENTRY;

CONST
    SP_SERIALCOMM         = 00000001h;
    PST_UNSPECIFIED       = 00000000h;
    PST_RS232             = 00000001h;
    PST_PARALLELPORT      = 00000002h;
    PST_RS422             = 00000003h;
    PST_RS423             = 00000004h;
    PST_RS449             = 00000005h;
    PST_MODEM             = 00000006h;
    PST_FAX               = 00000021h;
    PST_SCANNER           = 00000022h;
    PST_NETWORK_BRIDGE    = 00000100h;
    PST_LAT               = 00000101h;
    PST_TCPIP_TELNET      = 00000102h;
    PST_X25               = 00000103h;
    PCF_DTRDSR         = 0001h;
    PCF_RTSCTS         = 0002h;
    PCF_RLSD           = 0004h;
    PCF_PARITY_CHECK   = 0008h;
    PCF_XONXOFF        = 0010h;
    PCF_SETXCHAR       = 0020h;
    PCF_TOTALTIMEOUTS  = 0040h;
    PCF_INTTIMEOUTS    = 0080h;
    PCF_SPECIALCHARS   = 0100h;
    PCF_16BITMODE      = 0200h;
    SP_PARITY          = 0001h;
    SP_BAUD            = 0002h;
    SP_DATABITS        = 0004h;
    SP_STOPBITS        = 0008h;
    SP_HANDSHAKING     = 0010h;
    SP_PARITY_CHECK    = 0020h;
    SP_RLSD            = 0040h;
    BAUD_075           = 00000001h;
    BAUD_110           = 00000002h;
    BAUD_134_5         = 00000004h;
    BAUD_150           = 00000008h;
    BAUD_300           = 00000010h;
    BAUD_600           = 00000020h;
    BAUD_1200          = 00000040h;
    BAUD_1800          = 00000080h;
    BAUD_2400          = 00000100h;
    BAUD_4800          = 00000200h;
    BAUD_7200          = 00000400h;
    BAUD_9600          = 00000800h;
    BAUD_14400         = 00001000h;
    BAUD_19200         = 00002000h;
    BAUD_38400         = 00004000h;
    BAUD_56K           = 00008000h;
    BAUD_128K          = 00010000h;
    BAUD_115200        = 00020000h;
    BAUD_57600         = 00040000h;
    BAUD_USER          = 10000000h;
    DATABITS_5        = 0001h;
    DATABITS_6        = 0002h;
    DATABITS_7        = 0004h;
    DATABITS_8        = 0008h;
    DATABITS_16       = 0010h;
    DATABITS_16X      = 0020h;
    STOPBITS_10       = 0001h;
    STOPBITS_15       = 0002h;
    STOPBITS_20       = 0004h;
    PARITY_NONE       = 0100h;
    PARITY_ODD        = 0200h;
    PARITY_EVEN       = 0400h;
    PARITY_MARK       = 0800h;
    PARITY_SPACE      = 1000h;

TYPE
    COMMPROP = RECORD
          wPacketLength  : WORD;
          wPacketVersion : WORD;
          dwServiceMask  : DWORD;
          dwReserved1    : DWORD;
          dwMaxTxQueue   : DWORD;
          dwMaxRxQueue   : DWORD;
          dwMaxBaud      : DWORD;
          dwProvSubType  : DWORD;
          dwProvCapabilities: DWORD;
          dwSettableParams: DWORD;
          dwSettableBaud : DWORD;
          wSettableData  : WORD;
          wSettableStopParity: WORD;
          dwCurrentTxQueue: DWORD;
          dwCurrentRxQueue: DWORD;
          dwProvSpec1    : DWORD;
          dwProvSpec2    : DWORD;
          wcProvChar     : ARRAY [0..1 - 1] OF WCHAR;
    END;
    LPCOMMPROP           = POINTER TO COMMPROP;

CONST
   COMMPROP_INITIALIZED         = 0E73CF52Eh;

TYPE
    CommStatus = ( fCtsHold         (* Tx waiting for CTS signal     *)
                 , fDsrHold         (* Tx waiting for DSR signal     *)
                 , fRlsdHold        (* Tx waiting for DCD signal     *)
                 , fXoffHold        (* Tx waiting, XOFF char recv'd  *)
                 , fXoffSent        (* Tx waiting, XOFF char sent    *)
                 , fEof             (* EOF character sent            *)
                 , fTxim            (* character waiting for Tx      *)
                 ) BIG;
    CommStatusSet = SET OF CommStatus BIG;

    COMSTAT = RECORD
          status         : CommStatusSet;
          cbInQue        : DWORD;
          cbOutQue       : DWORD;
    END;
    LPCOMSTAT            = POINTER TO COMSTAT;

TYPE
    CommFlags = ( fBinary           (* Binary Mode (skip EOF check)  *)
                , fParity           (* Enable parity checking        *)
                , fOutxCtsFlow      (* CTS handshaking on output     *)
                , fOutxDsrFlow      (* DSR handshaking on output     *)
                , fDtrEnable        (* DTR flow control (1 of 2)     *)
                , fDtrHandshake     (* DTR flow control (2 of 2)     *)
                , fDsrSensitivity   (* DSR Sensitivity               *)
                , fTXContinueOnXoff (* Continue TX when Xoff sent    *)
                , fOutX             (* Enable output X-ON/X-OFF      *)
                , fInX              (* Enable input X-ON/X-OFF       *)
                , fErrorChar        (* Enable Err Replacement        *)
                , fNull             (* Enable Null stripping         *)
                , fRtsEnable        (* RTS flow control (1 of 2)     *)
                , fRtsHandshake     (* RTS flow control (2 of 2)     *)
                                    (* set both=>RTS_CONTROL_TOGGLE  *)
                , fAbortOnError     (* Abort all reads and writes    *)
                ) BIG;
    CommFlagSet = SET OF CommFlags BIG;

CONST
    DTR_CONTROL_DISABLE  = CommFlagSet{};
    DTR_CONTROL_ENABLE   = CommFlagSet{fDtrEnable};
    DTR_CONTROL_HANDSHAKE= CommFlagSet{fDtrHandshake};
    (*
    DTR_CONTROL_DISABLE  = 000h;
    DTR_CONTROL_ENABLE   = 001h;
    DTR_CONTROL_HANDSHAKE= 002h;
    *)

    RTS_CONTROL_DISABLE  = CommFlagSet{};
    RTS_CONTROL_ENABLE   = CommFlagSet{fRtsEnable};
    RTS_CONTROL_HANDSHAKE= CommFlagSet{fRtsHandshake};
    RTS_CONTROL_TOGGLE   = CommFlagSet{fRtsEnable, fRtsHandshake};
    (*
    RTS_CONTROL_DISABLE  = 000h;
    RTS_CONTROL_ENABLE   = 001h;
    RTS_CONTROL_HANDSHAKE= 002h;
    RTS_CONTROL_TOGGLE   = 003h;
    *)

TYPE
    DCB = RECORD
          DCBlength      : DWORD;
          BaudRate       : DWORD;
          flags          : CommFlagSet;
          wReserved      : WORD;
          XonLim         : WORD;
          XoffLim        : WORD;
          ByteSize       : BYTE;
          Parity         : BYTE;
          StopBits       : BYTE;
          XonChar        : ACHAR;
          XoffChar       : ACHAR;
          ErrorChar      : ACHAR;
          EofChar        : ACHAR;
          EvtChar        : ACHAR;
          wReserved1     : WORD;
    END;
    LPDCB                = POINTER TO DCB;

TYPE
    COMMTIMEOUTS = RECORD
          ReadIntervalTimeout: DWORD;
          ReadTotalTimeoutMultiplier: DWORD;
          ReadTotalTimeoutConstant: DWORD;
          WriteTotalTimeoutMultiplier: DWORD;
          WriteTotalTimeoutConstant: DWORD;
    END;
    LPCOMMTIMEOUTS       = POINTER TO COMMTIMEOUTS;

    SYSTEM_INFO = RECORD
          (* Obsolete dwOemId        : DWORD; *)
          wProcessorArchitecture     : WORD;
          wReserved                  : WORD;
          dwPageSize                 : DWORD;
          lpMinimumApplicationAddress: LPVOID;
          lpMaximumApplicationAddress: LPVOID;
          dwActiveProcessorMask      : DWORD_PTR;
          dwNumberOfProcessors       : DWORD;
          dwProcessorType            : DWORD;
          dwAllocationGranularity    : DWORD;
          wProcessorLevel            : WORD;
          wProcessorRevision         : WORD;
    END;
    LPSYSTEM_INFO        = POINTER TO SYSTEM_INFO;


CONST
    GMEM_FIXED           = 00000h;
    GMEM_MOVEABLE        = 00002h;
    GMEM_NOCOMPACT       = 00010h;
    GMEM_NODISCARD       = 00020h;
    GMEM_ZEROINIT        = 00040h;
    GMEM_MODIFY          = 00080h;
    GMEM_DISCARDABLE     = 00100h;
    GMEM_NOT_BANKED      = 01000h;
    GMEM_SHARE           = 02000h;
    GMEM_DDESHARE        = 02000h;
    GMEM_NOTIFY          = 04000h;
    GMEM_LOWER           = GMEM_NOT_BANKED;
    GMEM_VALID_FLAGS     = 07F72h;
    GMEM_INVALID_HANDLE  = 08000h;

    GHND                 = (GMEM_MOVEABLE BOR GMEM_ZEROINIT);
    GPTR                 = (GMEM_FIXED BOR GMEM_ZEROINIT);
    GMEM_DISCARDED       = 04000h;
    GMEM_LOCKCOUNT       = 000FFh;

TYPE
    MEMORYSTATUS = RECORD
          dwLength       : DWORD;
          dwMemoryLoad   : DWORD;
          dwTotalPhys    : DWORD;
          dwAvailPhys    : DWORD;
          dwTotalPageFile: DWORD;
          dwAvailPageFile: DWORD;
          dwTotalVirtual : DWORD;
          dwAvailVirtual : DWORD;
    END;
    LPMEMORYSTATUS       = POINTER TO MEMORYSTATUS;

CONST
    LMEM_FIXED           = 00000h;
    LMEM_MOVEABLE        = 00002h;
    LMEM_NOCOMPACT       = 00010h;
    LMEM_NODISCARD       = 00020h;
    LMEM_ZEROINIT        = 00040h;
    LMEM_MODIFY          = 00080h;
    LMEM_DISCARDABLE     = 00F00h;
    LMEM_VALID_FLAGS     = 00F72h;
    LMEM_INVALID_HANDLE  = 08000h;
    LHND                 = (LMEM_MOVEABLE BOR LMEM_ZEROINIT);
    LPTR                 = (LMEM_FIXED BOR LMEM_ZEROINIT);
    NONZEROLHND          = LMEM_MOVEABLE;
    NONZEROLPTR          = LMEM_FIXED;
    LMEM_DISCARDED       = 04000h;
    LMEM_LOCKCOUNT       = 000FFh;
    DEBUG_PROCESS        = 000000001h;
    DEBUG_ONLY_THIS_PROCESS= 000000002h;
    CREATE_SUSPENDED     = 000000004h;
    DETACHED_PROCESS     = 000000008h;

    CREATE_NEW_CONSOLE   = 000000010h;

    NORMAL_PRIORITY_CLASS= 000000020h;
    IDLE_PRIORITY_CLASS  = 000000040h;
    HIGH_PRIORITY_CLASS  = 000000080h;
    REALTIME_PRIORITY_CLASS= 000000100h;

    CREATE_NEW_PROCESS_GROUP    = 000000200h;
    CREATE_UNICODE_ENVIRONMENT  = 000000400h;
    CREATE_SEPARATE_WOW_VDM     = 000000800h;
    CREATE_SHARED_WOW_VDM       = 000001000h;
    CREATE_DEFAULT_ERROR_MODE   = 004000000h;
    CREATE_NO_WINDOW            = 008000000h;
    CREATE_FORCEDOS             = 00002000h;
    BELOW_NORMAL_PRIORITY_CLASS       = 000004000h;(*2k*)
    ABOVE_NORMAL_PRIORITY_CLASS       = 000008000h;(*2k*)

    STACK_SIZE_PARAM_IS_A_RESERVATION = 000010000h;(*XP*)

    PROFILE_USER         = 010000000h;
    PROFILE_KERNEL       = 020000000h;
    PROFILE_SERVER       = 040000000h;

    THREAD_PRIORITY_LOWEST              = THREAD_BASE_PRIORITY_MIN;
    THREAD_PRIORITY_BELOW_NORMAL        = THREAD_PRIORITY_LOWEST + 1;
    THREAD_PRIORITY_NORMAL              = 0;
    THREAD_PRIORITY_HIGHEST             = THREAD_BASE_PRIORITY_MAX;
    THREAD_PRIORITY_ABOVE_NORMAL        = THREAD_PRIORITY_HIGHEST - 1;
    THREAD_PRIORITY_TIME_CRITICAL       = THREAD_BASE_PRIORITY_LOWRT;
    THREAD_PRIORITY_IDLE                = THREAD_BASE_PRIORITY_IDLE;

    THREAD_PRIORITY_ERROR_RETURN= MAXLONG;

    EXCEPTION_DEBUG_EVENT       = 1;

    CREATE_THREAD_DEBUG_EVENT   = 2;
    CREATE_PROCESS_DEBUG_EVENT  = 3;

    EXIT_THREAD_DEBUG_EVENT     = 4;
    EXIT_PROCESS_DEBUG_EVENT    = 5;
    LOAD_DLL_DEBUG_EVENT        = 6;
    UNLOAD_DLL_DEBUG_EVENT      = 7;
    OUTPUT_DEBUG_STRING_EVENT   = 8;
    RIP_EVENT                   = 9;

TYPE
    EXCEPTION_DEBUG_INFO = RECORD
          ExceptionRecord: EXCEPTION_RECORD;
          dwFirstChance  : DWORD;
    END;
    LPEXCEPTION_DEBUG_INFO= POINTER TO EXCEPTION_DEBUG_INFO;

    CREATE_THREAD_DEBUG_INFO = RECORD
          hThread        : HANDLE;
          lpThreadLocalBase: LPVOID;
          lpStartAddress : LPTHREAD_START_ROUTINE;
    END;
    LPCREATE_THREAD_DEBUG_INFO= POINTER TO CREATE_THREAD_DEBUG_INFO;

    CREATE_PROCESS_DEBUG_INFO = RECORD
          hFile          : HANDLE;
          hProcess       : HANDLE;
          hThread        : HANDLE;
          lpBaseOfImage  : LPVOID;
          dwDebugInfoFileOffset: DWORD;
          nDebugInfoSize : DWORD;
          lpThreadLocalBase: LPVOID;
          lpStartAddress : LPTHREAD_START_ROUTINE;
          lpImageName    : LPVOID;
          fUnicode       : WORD;
    END;
    LPCREATE_PROCESS_DEBUG_INFO= POINTER TO CREATE_PROCESS_DEBUG_INFO;

    EXIT_THREAD_DEBUG_INFO = RECORD
          dwExitCode     : DWORD;
    END;
    LPEXIT_THREAD_DEBUG_INFO= POINTER TO EXIT_THREAD_DEBUG_INFO;

    EXIT_PROCESS_DEBUG_INFO = RECORD
          dwExitCode     : DWORD;
    END;
    LPEXIT_PROCESS_DEBUG_INFO= POINTER TO EXIT_PROCESS_DEBUG_INFO;

    LOAD_DLL_DEBUG_INFO = RECORD
          hFile          : HANDLE;
          lpBaseOfDll    : LPVOID;
          dwDebugInfoFileOffset: DWORD;
          nDebugInfoSize : DWORD;
          lpImageName    : LPVOID;
          fUnicode       : WORD;
    END;
    LPLOAD_DLL_DEBUG_INFO= POINTER TO LOAD_DLL_DEBUG_INFO;

    UNLOAD_DLL_DEBUG_INFO = RECORD
          lpBaseOfDll    : LPVOID;
    END;
    LPUNLOAD_DLL_DEBUG_INFO= POINTER TO UNLOAD_DLL_DEBUG_INFO;

    OUTPUT_DEBUG_STRING_INFO = RECORD
          lpDebugStringData: LPSTR;
          fUnicode       : WORD;
          nDebugStringLength: WORD;
    END;
    LPOUTPUT_DEBUG_STRING_INFO= POINTER TO OUTPUT_DEBUG_STRING_INFO;

    RIP_INFO = RECORD
          dwError        : DWORD;
          dwType         : DWORD;
    END;
    LPRIP_INFO           = POINTER TO RIP_INFO;

    DEBUG_EVENT_VARIANT = RECORD
        CASE : CARDINAL OF
        1: Exception : EXCEPTION_DEBUG_INFO ;
        |
        2 : CreateThread : CREATE_THREAD_DEBUG_INFO ;
        |
        3: CreateProcessInfo : CREATE_PROCESS_DEBUG_INFO ;
        |
        4: ExitThread : EXIT_THREAD_DEBUG_INFO ;
        |
        5: ExitProcess : EXIT_THREAD_DEBUG_INFO ;
        |
        6: LoadDll : LOAD_DLL_DEBUG_INFO ;
        |
        7: UnloadDll : UNLOAD_DLL_DEBUG_INFO ;
        |
        8: DebugString : OUTPUT_DEBUG_STRING_INFO ;
        |
        9: RipInfo : RIP_INFO ;
        ELSE
        END;
    END;

    DEBUG_EVENT = RECORD
          dwDebugEventCode: DWORD;
          dwProcessId    : DWORD;
          dwThreadId     : DWORD;
          dbv            : DEBUG_EVENT_VARIANT;
    END;
    LPDEBUG_EVENT        = POINTER TO DEBUG_EVENT;

    LPCONTEXT            = PCONTEXT;
    LPEXCEPTION_RECORD   = PEXCEPTION_RECORD;
    LPEXCEPTION_POINTERS = PEXCEPTION_POINTERS;

CONST
    DRIVE_UNKNOWN        = 0;
    DRIVE_NO_ROOT_DIR    = 1;
    DRIVE_REMOVABLE      = 2;
    DRIVE_FIXED          = 3;
    DRIVE_REMOTE         = 4;
    DRIVE_CDROM          = 5;
    DRIVE_RAMDISK        = 6;
    FILE_TYPE_UNKNOWN    = 00000h;
    FILE_TYPE_DISK       = 00001h;
    FILE_TYPE_CHAR       = 00002h;
    FILE_TYPE_PIPE       = 00003h;
    FILE_TYPE_REMOTE     = 08000h;
    STD_INPUT_HANDLE     = CAST(DWORD, -10);
    STD_OUTPUT_HANDLE   = CAST(DWORD, -11);
    STD_ERROR_HANDLE     = CAST(DWORD, -12);
    NOPARITY             = 0;
    ODDPARITY            = 1;
    EVENPARITY           = 2;
    MARKPARITY           = 3;
    SPACEPARITY          = 4;
    ONESTOPBIT           = 0;
    ONE5STOPBITS         = 1;
    TWOSTOPBITS          = 2;
    IGNORE               = 0;
    INFINITE             = 0FFFFFFFFh;
    CBR_110              = 110;
    CBR_300              = 300;
    CBR_600              = 600;
    CBR_1200             = 1200;
    CBR_2400             = 2400;
    CBR_4800             = 4800;
    CBR_9600             = 9600;
    CBR_14400            = 14400;
    CBR_19200            = 19200;
    CBR_38400            = 38400;
    CBR_56000            = 56000;
    CBR_57600            = 57600;
    CBR_115200           = 115200;
    CBR_128000           = 128000;
    CBR_256000           = 256000;
    CE_RXOVER            = 00001h;
    CE_OVERRUN           = 00002h;
    CE_RXPARITY          = 00004h;
    CE_FRAME             = 00008h;
    CE_BREAK             = 00010h;
    CE_TXFULL            = 00100h;
    CE_PTO               = 00200h;
    CE_IOE               = 00400h;
    CE_DNS               = 00800h;
    CE_OOP               = 01000h;
    CE_MODE              = 08000h;
    IE_BADID             = (-1);
    IE_OPEN              = (-2);
    IE_NOPEN             = (-3);
    IE_MEMORY            = (-4);
    IE_DEFAULT           = (-5);
    IE_HARDWARE          = (-10);
    IE_BYTESIZE          = (-11);
    IE_BAUDRATE          = (-12);
    EV_RXCHAR            = 00001h;
    EV_RXFLAG            = 00002h;
    EV_TXEMPTY           = 00004h;
    EV_CTS               = 00008h;
    EV_DSR               = 00010h;
    EV_RLSD              = 00020h;
    EV_BREAK             = 00040h;
    EV_ERR               = 00080h;
    EV_RING              = 00100h;
    EV_PERR              = 00200h;
    EV_RX80FULL          = 00400h;
    EV_EVENT1            = 00800h;
    EV_EVENT2            = 01000h;
    SETXOFF              = 1;
    SETXON               = 2;
    SETRTS               = 3;
    CLRRTS               = 4;
    SETDTR               = 5;
    CLRDTR               = 6;
    RESETDEV             = 7;
    SETBREAK             = 8;
    CLRBREAK             = 9;
    PURGE_TXABORT        = 00001h;
    PURGE_RXABORT        = 00002h;
    PURGE_TXCLEAR        = 00004h;
    PURGE_RXCLEAR        = 00008h;
    LPTx                 = 080h;
    MS_CTS_ON            = 10h;
    MS_DSR_ON            = 20h;
    MS_RING_ON           = 40h;
    MS_RLSD_ON           = 80h;
    S_QUEUEEMPTY         = 0;
    S_THRESHOLD          = 1;
    S_ALLTHRESHOLD       = 2;
    S_NORMAL             = 0;
    S_LEGATO             = 1;
    S_STACCATO           = 2;
    S_PERIOD512          = 0;
    S_PERIOD1024         = 1;
    S_PERIOD2048         = 2;
    S_PERIODVOICE        = 3;
    S_WHITE512           = 4;
    S_WHITE1024          = 5;
    S_WHITE2048          = 6;
    S_WHITEVOICE         = 7;
    S_SERDVNA            = -1;
    S_SEROFM             = -2;
    S_SERMACT            = -3;
    S_SERQFUL            = -4;
    S_SERBDNT            = -5;
    S_SERDLN             = -6;
    S_SERDCC             = -7;
    S_SERDTP             = -8;
    S_SERDVL             = -9;
    S_SERDMD             = -10;
    S_SERDSH             = -11;
    S_SERDPT             = -12;
    S_SERDFQ             = -13;
    S_SERDDR             = -14;
    S_SERDSR             = -15;
    S_SERDST             = -16;
    NMPWAIT_WAIT_FOREVER = 0ffffffffh;
    NMPWAIT_NOWAIT       = 000000001h;
    NMPWAIT_USE_DEFAULT_WAIT= 000000000h;

    FS_CASE_IS_PRESERVED            = FILE_CASE_PRESERVED_NAMES;
    FS_CASE_SENSITIVE               = FILE_CASE_SENSITIVE_SEARCH;
    FS_UNICODE_STORED_ON_DISK       = FILE_UNICODE_ON_DISK;
    FS_PERSISTENT_ACLS              = FILE_PERSISTENT_ACLS;
    FS_VOL_IS_COMPRESSED            = FILE_VOLUME_IS_COMPRESSED;
    FS_FILE_COMPRESSION             = FILE_FILE_COMPRESSION;

    OF_READ              = 000000000h;
    OF_WRITE             = 000000001h;
    OF_READWRITE         = 000000002h;
    OF_SHARE_COMPAT      = 000000000h;
    OF_SHARE_EXCLUSIVE   = 000000010h;
    OF_SHARE_DENY_WRITE  = 000000020h;
    OF_SHARE_DENY_READ   = 000000030h;
    OF_SHARE_DENY_NONE   = 000000040h;
    OF_PARSE             = 000000100h;
    OF_DELETE            = 000000200h;
    OF_VERIFY            = 000000400h;
    OF_CANCEL            = 000000800h;
    OF_CREATE            = 000001000h;
    OF_PROMPT            = 000002000h;
    OF_EXIST             = 000004000h;
    OF_REOPEN            = 000008000h;
    OFS_MAXPATHNAME      = 128;

TYPE
    OFSTRUCT = RECORD
          cBytes         : BYTE;
          fFixedDisk     : BYTE;
          nErrCode       : WORD;
          Reserved1      : WORD;
          Reserved2      : WORD;
          szPathName     : ARRAY [0..OFS_MAXPATHNAME - 1] OF ACHAR;
    END;
    POFSTRUCT            = POINTER TO OFSTRUCT;
    LPOFSTRUCT           = POFSTRUCT;

PROCEDURE InterlockedIncrement(VAR lpAddend : LONG) : LONG;

PROCEDURE InterlockedDecrement(VAR lpAddend : LONG) : LONG;

PROCEDURE InterlockedExchange(VAR Target : LONG;
                              Value : LONG) : LONG;

(* not Win95 *)
PROCEDURE InterlockedCompareExchange(VAR Destination : LONG;
                                     Exchange : LONG;
                                     Comperand : LONG) : LONG_PTR;

(* not Win95 *)
PROCEDURE InterlockedCompareExchangePointer
            ["_InterlockedCompareExchange@12"]
                (VAR Destination : PVOID;
                 Exchange : PVOID;
                 Comperand : PVOID) : PVOID;

(* not Win95 *)
PROCEDURE InterlockedExchangeAdd(VAR Addend : LONG; Value : LONG) : LONG;

PROCEDURE FreeResource(hResData : HGLOBAL) : BOOL;

PROCEDURE LockResource(hResData : HGLOBAL) : LPVOID;

CONST
    MAXINTATOM           = 0C000h;

PROCEDURE WinMain(hInstance : HINSTANCE;
                  hPrevInstance : HINSTANCE;
                  lpCmdLine : LPSTR;
                  nShowCmd : INTEGER) : INTEGER;

PROCEDURE FreeLibrary(hLibModule : HINSTANCE) : BOOL;

(*95*)
PROCEDURE FreeLibraryAndExitThread(hLibModule : HMODULE;
                                   dwExitCode : DWORD);

(*95*)
PROCEDURE DisableThreadLibraryCalls(hLibModule : HMODULE): BOOL;

PROCEDURE GetProcAddress(hModule : HINSTANCE;
                         lpProcName : ARRAY OF ACHAR) : FARPROC;

PROCEDURE GetVersion() : DWORD;

PROCEDURE GlobalAlloc(uFlags : UINT; dwBytes : SIZE_T) : HGLOBAL;

PROCEDURE GlobalReAlloc(hMem : HGLOBAL; dwBytes : SIZE_T; uFlags : UINT) : HGLOBAL;

PROCEDURE GlobalSize(hMem : HGLOBAL) : SIZE_T;

PROCEDURE GlobalFlags(hMem : HGLOBAL) : UINT;

PROCEDURE GlobalLock(hMem : HGLOBAL) : LPVOID;

PROCEDURE GlobalHandle(pMem : LPCVOID) : HGLOBAL;

PROCEDURE GlobalUnlock(hMem : HGLOBAL) : BOOL;

PROCEDURE GlobalFree(hMem : HGLOBAL) : HGLOBAL;

PROCEDURE GlobalCompact(dwMinFree : SIZE_T) : SIZE_T;

PROCEDURE GlobalFix(hMem : HGLOBAL);

PROCEDURE GlobalUnfix(hMem : HGLOBAL);

PROCEDURE GlobalWire(hMem : HGLOBAL) : LPVOID;

PROCEDURE GlobalUnWire(hMem : HGLOBAL) : BOOL;

PROCEDURE GlobalMemoryStatus(VAR lpBuffer : MEMORYSTATUS);

PROCEDURE LocalAlloc(uFlags : UINT; uBytes : SIZE_T) : HLOCAL;

PROCEDURE LocalReAlloc(hMem : HLOCAL; uBytes : SIZE_T; uFlags : UINT) : HLOCAL;

PROCEDURE LocalLock(hMem : HLOCAL) : LPVOID;

PROCEDURE LocalHandle(pMem : LPCVOID) : HLOCAL;

PROCEDURE LocalUnlock(hMem : HLOCAL) : BOOL;

PROCEDURE LocalSize(hMem : HLOCAL) : SIZE_T;

PROCEDURE LocalFlags(hMem : HLOCAL) : UINT;

PROCEDURE LocalFree(hMem : HLOCAL) : HLOCAL;

PROCEDURE LocalShrink(hMem : HLOCAL; cbNewSize : SIZE_T) : SIZE_T;

PROCEDURE LocalCompact(uMinFree : SIZE_T) : SIZE_T;

PROCEDURE FlushInstructionCache(hProcess : HANDLE;
                                lpBaseAddress : LPCVOID;
                                dwSize : SIZE_T) : BOOL;

PROCEDURE VirtualAlloc(lpAddress : LPVOID;
                       dwSize : SIZE_T;
                       flAllocationType : DWORD;
                       flProtect : DWORD) : LPVOID;

PROCEDURE VirtualFree(lpAddress : LPVOID;
                      dwSize : SIZE_T;
                      dwFreeType : DWORD) : BOOL;

PROCEDURE VirtualProtect(lpAddress : LPVOID;
                         dwSize : SIZE_T;
                         flNewProtect : DWORD;
                         VAR lpflOldProtect : DWORD) : BOOL;

PROCEDURE VirtualQuery(lpAddress : LPCVOID;
                       VAR lpBuffer : MEMORY_BASIC_INFORMATION;
                       dwLength : SIZE_T) : SIZE_T;

PROCEDURE VirtualAllocEx(hProcess : HANDLE;
                         lpAddress : LPVOID;
                         dwSize : SIZE_T;
                         flAllocationType : DWORD;
                         flProtect : DWORD
                         ) : LPVOID;

PROCEDURE VirtualFreeEx(hProcess : HANDLE;
                        lpAddress : LPVOID;
                        dwSize : SIZE_T;
                        dwFreeType : DWORD
                        ) : BOOL;

PROCEDURE VirtualProtectEx(hProcess : HANDLE;
                           lpAddress : LPVOID;
                           dwSize : SIZE_T;
                           flNewProtect : DWORD;
                           VAR lpflOldProtect : DWORD) : BOOL;

PROCEDURE VirtualQueryEx(hProcess : HANDLE;
                         lpAddress : LPCVOID;
                         VAR lpBuffer : MEMORY_BASIC_INFORMATION;
                         dwLength : SIZE_T) : SIZE_T;

PROCEDURE HeapCreate(flOptions : DWORD;
                     dwInitialSize : SIZE_T;
                     dwMaximumSize : SIZE_T) : HANDLE;

PROCEDURE HeapDestroy(hHeap : HANDLE) : BOOL;

PROCEDURE HeapAlloc(hHeap : HANDLE;
                    dwFlags : DWORD;
                    dwBytes : SIZE_T) : LPVOID;

PROCEDURE HeapReAlloc(hHeap : HANDLE;
                      dwFlags : DWORD;
                      lpMem : LPVOID;
                      dwBytes : SIZE_T) : LPVOID;

PROCEDURE HeapFree(hHeap : HANDLE;
                   dwFlags : DWORD;
                   lpMem : LPVOID) : BOOL;

PROCEDURE HeapSize(hHeap : HANDLE;
                   dwFlags : DWORD;
                   lpMem : LPCVOID) : SIZE_T;

PROCEDURE HeapValidate(hHeap : HANDLE;
                   dwFlags : DWORD;
                   lpMem : LPCVOID) : BOOL;

PROCEDURE HeapCompact(hHeap : HANDLE; dwFlags : DWORD) : SIZE_T;

CONST
  LowFragmentationHeap         = 2;

TYPE
  HEAP_INFORMATION_CLASS = (HeapCompatibilityInformation) BIG;

PROCEDURE HeapSetInformation(hHeap : HANDLE;
                             heapInformationClass : HEAP_INFORMATION_CLASS;
                             heapInformation : PVOID;
                             size : DWORD) : BOOL;

PROCEDURE GetProcessHeap() : HANDLE;

PROCEDURE GetProcessHeaps(NumberOfHeaps : DWORD;
                          VAR ProcessHeaps : ARRAY OF HANDLE) : DWORD;

TYPE
    Block = RECORD
        hMem            : HANDLE;
        dwReserved      : ARRAY [0.. 3-1] OF DWORD;
    END;

    Region = RECORD
        dwCommittedSize         : DWORD;
        dwUnCommittedSize       : DWORD;
        lpFirstBlock            : LPVOID;
        lpLastBlock             : LPVOID;
    END;

    PROCESS_HEAP_ENTRY = RECORD
        lpData          : PVOID;
        cbData          : DWORD;
        cbOverhead      : BYTE;
        iRegionIndex    : BYTE;
        wFlags          : WORD;
        CASE : CARDINAL OF
            1 : union1 : Block; |
            2 : union2 : Region;|
            ELSE
        END;
    END;
    PPROCESS_HEAP_ENTRY  = POINTER TO PROCESS_HEAP_ENTRY;
    LPPROCESS_HEAP_ENTRY = PPROCESS_HEAP_ENTRY;

CONST
    PROCESS_HEAP_REGION             = 00001h;
    PROCESS_HEAP_UNCOMMITTED_RANGE  = 00002h;
    PROCESS_HEAP_ENTRY_BUSY         = 00004h;
    PROCESS_HEAP_ENTRY_MOVEABLE     = 00010h;
    PROCESS_HEAP_ENTRY_DDESHARE     = 00020h;

PROCEDURE HeapLock(hHeap : HANDLE) : BOOL;

PROCEDURE HeapUnlock(hHeap : HANDLE) : BOOL;

PROCEDURE HeapWalk(hHeap : HANDLE; lpEntry : LPPROCESS_HEAP_ENTRY) : BOOL;



CONST
    SCS_32BIT_BINARY    = 0;
    SCS_DOS_BINARY      = 1;
    SCS_WOW_BINARY      = 2;
    SCS_PIF_BINARY      = 3;
    SCS_POSIX_BINARY    = 4;
    SCS_OS216_BINARY    = 5;

PROCEDURE GetBinaryTypeA(lpApplicationName : ARRAY OF ACHAR;
                         VAR lpBinaryType : DWORD) : BOOL;

PROCEDURE GetBinaryTypeW(lpApplicationName : ARRAY OF UCHAR;
                         VAR lpBinaryType : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetBinaryType = GetBinaryTypeW;
%ELSE
PROCEDURE GetBinaryType = GetBinaryTypeA;
%END

PROCEDURE GetShortPathNameA(lpszLongPath : ARRAY OF ACHAR;
                            VAR lpszShortPath : ARRAY OF ACHAR;
                            cchBuffer : DWORD
                            ) : DWORD;

PROCEDURE GetShortPathNameW(lpszLongPath : ARRAY OF UCHAR;
                            VAR lpszShortPath : ARRAY OF UCHAR;
                            cchBuffer : DWORD
                            ) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetShortPathName = GetShortPathNameW;
%ELSE
PROCEDURE GetShortPathName = GetShortPathNameA;
%END

PROCEDURE GetLongPathNameA(lpszShortPath : ARRAY OF ACHAR;
                           VAR lpszLongPath : ARRAY OF ACHAR;
                           cchBuffer : DWORD) : DWORD;

PROCEDURE GetLongPathNameW(lpszShortPath : ARRAY OF WCHAR;
                           VAR lpszLongPath : ARRAY OF WCHAR;
                           cchBuffer : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetLongPathName = GetLongPathNameW;
%ELSE
PROCEDURE GetLongPathName = GetLongPathNameA;
%END

PROCEDURE GetProcessAffinityMask(
                                hProcess : HANDLE;
                                VAR lpProcessAffinityMask : DWORD_PTR;
                                VAR lpSystemAffinityMask : DWORD_PTR
                                ) : BOOL;

PROCEDURE SetProcessAffinityMask(hProcess : HANDLE;
                                 dwProcessAffinityMask : DWORD_PTR) : BOOL;

PROCEDURE GetProcessWorkingSetSize(
                                    hProcess : HANDLE;
                                    VAR OUT lpMinimumWorkingSetSize : SIZE_T;
                                    VAR OUT lpMaximumWorkingSetSize : SIZE_T
                                    ) : BOOL;

PROCEDURE SetProcessWorkingSetSize(
                                    hProcess : HANDLE;
                                    dwMinimumWorkingSetSize : SIZE_T;
                                    dwMaximumWorkingSetSize : SIZE_T
                                    ) : BOOL;

PROCEDURE SetThreadAffinityMask(
                                hThread : HANDLE;
                                dwThreadAffinityMask  : DWORD_PTR
                                ) : DWORD_PTR;


(* NT only *)
PROCEDURE SetThreadIdealProcessor(hThread : HANDLE;
                                  dwIdealProcessor : DWORD) : DWORD;

PROCEDURE SetProcessPriorityBoost(hProcess : HANDLE;
                                  bDisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetProcessPriorityBoost(hProcess : HANDLE;
                                  VAR pDisablePriorityBoost : BOOL) : BOOL;

TYPE
    LATENCY_TIME = (LT_DONT_CARE, LT_LOWEST_LATENCY) BIG;

PROCEDURE RequestWakeupLatency(latency : LATENCY_TIME) : BOOL;

PROCEDURE GetProcessTimes(hProcess : HANDLE;
                          VAR lpCreationTime : FILETIME;
                          VAR lpExitTime : FILETIME;
                          VAR lpKernelTime : FILETIME;
                          VAR lpUserTime : FILETIME) : BOOL;

PROCEDURE OpenProcess(dwDesiredAccess : DWORD;
                      bInheritHandle : BOOL;
                      dwProcessId : DWORD) : HANDLE;

PROCEDURE GetCurrentProcess() : HANDLE [INVARIANT];

PROCEDURE GetCurrentProcessId() : DWORD [INVARIANT];

PROCEDURE ExitProcess(uExitCode : UINT);

PROCEDURE TerminateProcess(hProcess : HANDLE; uExitCode : UINT) : BOOL;

PROCEDURE GetExitCodeProcess(hProcess : HANDLE; VAR OUT lpExitCode : DWORD) : BOOL;

PROCEDURE FatalExit(ExitCode : INTEGER);


PROCEDURE GetEnvironmentStringsW() : LPWSTR;

PROCEDURE GetEnvironmentStringsA() : LPSTR;

%IF UNICODE %THEN
PROCEDURE GetEnvironmentStrings = GetEnvironmentStringsW;
%ELSE
PROCEDURE GetEnvironmentStrings = GetEnvironmentStringsA;
%END

PROCEDURE FreeEnvironmentStringsA(a : LPSTR) : BOOL;

PROCEDURE FreeEnvironmentStringsW(a : LPWSTR) : BOOL;

%IF UNICODE %THEN
PROCEDURE FreeEnvironmentStrings = FreeEnvironmentStringsW;
%ELSE
PROCEDURE FreeEnvironmentStrings = FreeEnvironmentStringsA;
%END

PROCEDURE RaiseException(dwExceptionCode : DWORD;
                         dwExceptionFlags : DWORD;
                         nNumberOfArguments : DWORD;
                         lpArguments : ARRAY OF ULONG_PTR) [NEVERRETURNS];

PROCEDURE UnhandledExceptionFilter(VAR INOUT ExceptionInfo : EXCEPTION_POINTERS) : LONG;

TYPE
    PTOP_LEVEL_EXCEPTION_FILTER= PROCEDURE(VAR INOUT EXCEPTION_POINTERS) : LONG [EXPORT];
    LPTOP_LEVEL_EXCEPTION_FILTER= PTOP_LEVEL_EXCEPTION_FILTER;

PROCEDURE SetUnhandledExceptionFilter(lpTopLevelExceptionFilter : LPTOP_LEVEL_EXCEPTION_FILTER) : LPTOP_LEVEL_EXCEPTION_FILTER;

(* NT only *)
PROCEDURE CreateFiber(dwStackSize : SIZE_T;
                      lpStartAddress : LPFIBER_START_ROUTINE;
                      lpParameter : LPVOID) : LPVOID;

(* NT only *)
PROCEDURE DeleteFiber(lpFiber : LPVOID);

(* NT only *)
PROCEDURE ConvertThreadToFiber(lpParameter : LPVOID) : LPVOID;

(* NT only *)
PROCEDURE SwitchToFiber(lpFiber : LPVOID);

(* NT only *)
PROCEDURE SwitchToThread() : BOOL;

PROCEDURE CreateThread(lpThreadAttributes : SECURITY_ATTRIBUTES;
                       dwStackSize : SIZE_T;
                       lpStartAddress : LPTHREAD_START_ROUTINE;
                       lpParameter : LPVOID;
                       dwCreationFlags : DWORD;
                       VAR lpThreadId : DWORD) : HANDLE;

PROCEDURE CreateRemoteThread(hProcess : HANDLE;
                             lpThreadAttributes : SECURITY_ATTRIBUTES;
                             dwStackSize : SIZE_T;
                             lpStartAddress : LPTHREAD_START_ROUTINE;
                             lpParameter : LPVOID;
                             dwCreationFlags : DWORD;
                             VAR lpThreadId : DWORD) : HANDLE;


PROCEDURE OpenThread(dwDesiredAccess : DWORD; dInheritHandle : BOOL; dwThreadId : DWORD) : HANDLE;

PROCEDURE GetCurrentThread() : HANDLE [INVARIANT];

PROCEDURE GetCurrentThreadId() : DWORD [INVARIANT];

PROCEDURE SetThreadPriority(hThread : HANDLE; nPriority : INTEGER) : BOOL;

PROCEDURE GetThreadPriority(hThread : HANDLE) : INTEGER;

PROCEDURE SetThreadPriorityBoost(hThread : HANDLE; bDisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetThreadPriorityBoost(hThread : HANDLE; VAR pDisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetThreadTimes(hThread : HANDLE;
                         VAR lpCreationTime : FILETIME;
                         VAR lpExitTime : FILETIME;
                         VAR lpKernelTime : FILETIME;
                         VAR lpUserTime : FILETIME) : BOOL;

PROCEDURE ExitThread(dwExitCode : DWORD);

PROCEDURE TerminateThread(hThread : HANDLE; dwExitCode : DWORD) : BOOL;

PROCEDURE GetExitCodeThread(hThread : HANDLE; VAR OUT lpExitCode : DWORD) : BOOL;

PROCEDURE GetThreadSelectorEntry(hThread : HANDLE;
                                 dwSelector : DWORD;
                                 VAR OUT lpSelectorEntry : LDT_ENTRY) : BOOL;

TYPE
    EXECUTION_STATE = DWORD;

CONST
    ES_SYSTEM_REQUIRED  = 00000001h;
    ES_DISPLAY_REQUIRED = 00000002h;
    ES_USER_PRESENT     = 00000004h;
    ES_CONTINUOUS       = 80000000h;

PROCEDURE SetThreadExecutionState(esFlags : EXECUTION_STATE) : EXECUTION_STATE;

PROCEDURE GetLastError() : DWORD;

PROCEDURE SetLastError(dwErrCode : DWORD);


CONST
    SLE_ERROR            = 000000001h;
    SLE_MINORERROR       = 000000002h;
    SLE_WARNING          = 000000003h;

PROCEDURE SetLastErrorEx(dwErrCode : DWORD;
                         dwType : DWORD);

PROCEDURE GetOverlappedResult(hFile : HANDLE;
                              lpOverlapped : LPOVERLAPPED;
                              VAR lpNumberOfBytesTransferred : DWORD;
                              bWait : BOOL) : BOOL;

(*95*)
PROCEDURE CreateIoCompletionPort(
    FileHandle : HANDLE;
    ExistingCompletionPort : HANDLE;
    CompletionKey : ULONG_PTR;
    NumberOfConcurrentThreads : DWORD
    ) : HANDLE;

(*95*)
PROCEDURE GetQueuedCompletionStatus(
    CompletionPort : HANDLE;
    VAR lpNumberOfBytesTransferred : DWORD;
    VAR lpCompletionKey : ULONG_PTR;
    VAR lpOverlapped : LPOVERLAPPED;
    dwMilliseconds : DWORD
    ):BOOL;

(*95*)
PROCEDURE PostQueuedCompletionStatus(
                                    CompletionPort : HANDLE;
                                    dwNumberOfBytesTransferred : DWORD;
                                    dwCompletionKey : ULONG_PTR;
                                    VAR lpOverlapped : OVERLAPPED
                                    ) : BOOL;

CONST
    SEM_FAILCRITICALERRORS= 00001h;
    SEM_NOGPFAULTERRORBOX= 00002h;
    SEM_NOALIGNMENTFAULTEXCEPT  = 00004h;  (*95*)
    SEM_NOOPENFILEERRORBOX= 08000h;

PROCEDURE SetDebugErrorLevel(dwLevel : DWORD);

PROCEDURE SetErrorMode(uMode : UINT) : UINT;

PROCEDURE ReadProcessMemory(hProcess : HANDLE;
                            lpBaseAddress : LPCVOID;
                            lpBuffer : LPVOID;
                            nSize : SIZE_T;
                            VAR OUT lpNumberOfBytesRead : SIZE_T) : BOOL;

PROCEDURE WriteProcessMemory(hProcess : HANDLE;
                             lpBaseAddress : LPVOID;
                             lpBuffer : LPVOID;
                             nSize : SIZE_T;
                             VAR OUT lpNumberOfBytesWritten : SIZE_T) : BOOL;

PROCEDURE GetThreadContext(hThread : HANDLE; VAR OUT lpContext : CONTEXT) : BOOL;

PROCEDURE SetThreadContext(hThread : HANDLE; lpContext : CONTEXT) : BOOL;

PROCEDURE SuspendThread(hThread : HANDLE) : DWORD;

PROCEDURE ResumeThread(hThread : HANDLE) : DWORD;

TYPE PAPCFUNC = PROCEDURE(ULONG_PTR) [EXPORT];

(* NT only *)
PROCEDURE QueueUserAPC(pfnAPC : PAPCFUNC;
                       hThread : HANDLE;
                       dwData : ULONG_PTR) : DWORD;

PROCEDURE IsDebuggerPresent() : BOOL;

PROCEDURE DebugBreak();

PROCEDURE WaitForDebugEvent(VAR lpDebugEvent : DEBUG_EVENT;
                            dwMilliseconds : DWORD) : BOOL;

PROCEDURE ContinueDebugEvent(dwProcessId : DWORD;
                             dwThreadId : DWORD;
                             dwContinueStatus : DWORD) : BOOL;

PROCEDURE DebugActiveProcess(dwProcessId : DWORD) : BOOL;

PROCEDURE InitializeCriticalSection(VAR OUT lpCriticalSection : CRITICAL_SECTION);

PROCEDURE EnterCriticalSection(VAR INOUT lpCriticalSection : CRITICAL_SECTION);

PROCEDURE LeaveCriticalSection(VAR INOUT lpCriticalSection : CRITICAL_SECTION);

PROCEDURE DeleteCriticalSection(VAR INOUT lpCriticalSection : CRITICAL_SECTION);

(* NT only *)
PROCEDURE TryEnterCriticalSection(VAR INOUT lpCriticalSection : CRITICAL_SECTION) : BOOL;

(* NT only *)
PROCEDURE InitializeCriticalSectionAndSpinCount(
                        VAR OUT lpCriticalSection : CRITICAL_SECTION;
                        dwSpinCount : DWORD) : BOOL;

(* NT only *)
PROCEDURE SetCriticalSectionSpinCount(
                    VAR INOUT lpCriticalSection : CRITICAL_SECTION;
                    dwSpinCount : DWORD) : DWORD;

PROCEDURE SetEvent(hEvent : HANDLE) : BOOL;

PROCEDURE ResetEvent(hEvent : HANDLE) : BOOL;

PROCEDURE PulseEvent(hEvent : HANDLE) : BOOL;

PROCEDURE ReleaseSemaphore(hSemaphore : HANDLE;
                           lReleaseCount : LONG;
                           lpPreviousCount : LPLONG) : BOOL;

PROCEDURE ReleaseMutex(hMutex : HANDLE) : BOOL;

PROCEDURE WaitForSingleObject(hHandle : HANDLE;
                              dwMilliseconds : DWORD) : DWORD;

PROCEDURE WaitForMultipleObjects(nCount : DWORD;
                                 lpHandles : ARRAY OF HANDLE;
                                 bWaitAll : BOOL;
                                 dwMilliseconds : DWORD) : DWORD;

PROCEDURE Sleep(dwMilliseconds : DWORD);

PROCEDURE LoadResource(hModule : HINSTANCE;
                       hResInfo : HRSRC) : HGLOBAL;

PROCEDURE SizeofResource(hModule : HINSTANCE;
                         hResInfo : HRSRC) : DWORD;

PROCEDURE GlobalDeleteAtom(nAtom : ATOM) : ATOM;

PROCEDURE InitAtomTable(nSize : DWORD) : BOOL;

PROCEDURE DeleteAtom(nAtom : ATOM) : ATOM;

PROCEDURE SetHandleCount(uNumber : UINT) : UINT;

PROCEDURE GetLogicalDrives() : DWORD;

PROCEDURE LockFile(hFile : HANDLE;
                   dwFileOffsetLow : DWORD;
                   dwFileOffsetHigh : DWORD;
                   nNumberOfBytesToLockLow : DWORD;
                   nNumberOfBytesToLockHigh : DWORD) : BOOL;

PROCEDURE UnlockFile(hFile : HANDLE;
                     dwFileOffsetLow : DWORD;
                     dwFileOffsetHigh : DWORD;
                     nNumberOfBytesToUnlockLow : DWORD;
                     nNumberOfBytesToUnlockHigh : DWORD) : BOOL;

PROCEDURE LockFileEx(hFile : HANDLE;
                     dwFlags : DWORD;
                     dwReserved : DWORD;
                     nNumberOfBytesToLockLow : DWORD;
                     nNumberOfBytesToLockHigh : DWORD;
                     lpOverlapped : LPOVERLAPPED) : BOOL;


CONST
    LOCKFILE_FAIL_IMMEDIATELY= 000000001h;
    LOCKFILE_EXCLUSIVE_LOCK= 000000002h;

PROCEDURE UnlockFileEx(hFile : HANDLE;
                       dwReserved : DWORD;
                       nNumberOfBytesToUnlockLow : DWORD;
                       nNumberOfBytesToUnlockHigh : DWORD;
                       lpOverlapped : LPOVERLAPPED) : BOOL;


TYPE
    BY_HANDLE_FILE_INFORMATION = RECORD
          dwFileAttributes: DWORD;
          ftCreationTime : FILETIME;
          ftLastAccessTime: FILETIME;
          ftLastWriteTime: FILETIME;
          dwVolumeSerialNumber: DWORD;
          nFileSizeHigh  : DWORD;
          nFileSizeLow   : DWORD;
          nNumberOfLinks : DWORD;
          nFileIndexHigh : DWORD;
          nFileIndexLow  : DWORD;
    END;
    PBY_HANDLE_FILE_INFORMATION= POINTER TO BY_HANDLE_FILE_INFORMATION;
    LPBY_HANDLE_FILE_INFORMATION= PBY_HANDLE_FILE_INFORMATION;

PROCEDURE GetFileInformationByHandle(hFile : HANDLE;
                                     lpFileInformation : LPBY_HANDLE_FILE_INFORMATION) : BOOL;

PROCEDURE GetFileType(hFile : HANDLE) : DWORD;

PROCEDURE GetFileSize(hFile : HANDLE;
                      VAR lpFileSizeHigh : DWORD) : DWORD;

PROCEDURE GetStdHandle(nStdHandle : DWORD) : HANDLE;

PROCEDURE SetStdHandle(nStdHandle : DWORD;
                       hHandle : HANDLE) : BOOL;

PROCEDURE WriteFile(hFile : HANDLE;
                    lpBuffer : LPCVOID;
                    nNumberOfBytesToWrite : DWORD;
                    VAR lpNumberOfBytesWritten : DWORD;
                    lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE ReadFile(hFile : HANDLE;
                   lpBuffer : LPVOID;
                   nNumberOfBytesToRead : DWORD;
                   VAR lpNumberOfBytesRead : DWORD;
                   lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE FlushFileBuffers(hFile : HANDLE) : BOOL;

PROCEDURE DeviceIoControl(hDevice : HANDLE;
                          dwIoControlCode : DWORD;
                          lpInBuffer : LPVOID;
                          nInBufferSize : DWORD;
                          lpOutBuffer : LPVOID;
                          nOutBufferSize : DWORD;
                          VAR lpBytesReturned : DWORD;
                          lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE GetDevicePowerState(hFile : HANDLE) : BOOL;

PROCEDURE SetEndOfFile(hFile : HANDLE) : BOOL;

PROCEDURE SetFilePointer(hFile : HANDLE;
                         lDistanceToMove : LONG;
                         lpDistanceToMoveHigh : PLONG;
                         dwMoveMethod : DWORD) : DWORD;

PROCEDURE SetFilePointerEx(hFile : HANDLE;
                           nDistanceToMove : LONGLONG;
                           npNewFilePointer : PLONGLONG;
                           dwMoveMethod : DWORD) : BOOLEAN;

PROCEDURE FindClose(hFindFile : HANDLE) : BOOL;

PROCEDURE GetFileTime(hFile : HANDLE;
                      VAR lpCreationTime : FILETIME;
                      VAR lpLastAccessTime : FILETIME;
                      VAR lpLastWriteTime : FILETIME) : BOOL;

PROCEDURE SetFileTime(hFile : HANDLE;
                      lpCreationTime : FILETIME;
                      lpLastAccessTime : FILETIME;
                      lpLastWriteTime : FILETIME) : BOOL;

PROCEDURE CloseHandle(hObject : HANDLE) : BOOL;

PROCEDURE DuplicateHandle(hSourceProcessHandle : HANDLE;
                          hSourceHandle : HANDLE;
                          hTargetProcessHandle : HANDLE;
                          VAR lpTargetHandle : HANDLE;
                          dwDesiredAccess : DWORD;
                          bInheritHandle : BOOL;
                          dwOptions : DWORD) : BOOL;

PROCEDURE GetHandleInformation(hObject : HANDLE; VAR lpdwFlags : DWORD) : BOOL;

PROCEDURE SetHandleInformation(hObject : HANDLE;
                               dwMask : DWORD;
                               dwFlags : DWORD) : BOOL;

CONST
    HANDLE_FLAG_INHERIT                 = 1;
    HANDLE_FLAG_PROTECT_FROM_CLOSE      = 2;

    HINSTANCE_ERROR                     = 32;

PROCEDURE LoadModule(lpModuleName : ARRAY OF ACHAR;
                     lpParameterBlock : LPVOID) : DWORD;

PROCEDURE WinExec(lpCmdLine : ARRAY OF ACHAR;
                  uCmdShow : UINT) : UINT;

TYPE
    COMMCONFIG = RECORD
        dwSize          : DWORD;
        wVersion        : WORD;
        wReserved       : WORD;
        dcb             : DCB;
        dwProviderSubType : DWORD;
        dwProviderOffset : DWORD;
        dwProviderSize  : DWORD;
        wcProviderData  : ARRAY [0..1-1] OF UCHAR;
    END;
    LPCOMMCONFIG =  POINTER TO COMMCONFIG;

PROCEDURE ClearCommBreak(hFile : HANDLE) : BOOL;

PROCEDURE ClearCommError(hFile : HANDLE;
                         VAR lpErrors : DWORD;
                         VAR OUT lpStat : COMSTAT) : BOOL;

PROCEDURE SetupComm(hFile : HANDLE;
                    dwInQueue : DWORD;
                    dwOutQueue : DWORD) : BOOL;

PROCEDURE EscapeCommFunction(hFile : HANDLE;
                             dwFunc : DWORD) : BOOL;

PROCEDURE GetCommConfig(hCommDev : HANDLE;
                        VAR lpCC : COMMCONFIG;
                        VAR lpdwSize : DWORD) : BOOL;

PROCEDURE SetCommConfig(hCommDev : HANDLE;
                        lpCC : COMMCONFIG;
                        dwSize : DWORD) : BOOL;

PROCEDURE GetCommMask(hFile : HANDLE;
                      VAR lpEvtMask : DWORD) : BOOL;

PROCEDURE GetCommProperties(hFile : HANDLE;
                            lpCommProp : LPCOMMPROP) : BOOL;

PROCEDURE GetCommModemStatus(hFile : HANDLE;
                             VAR lpModemStat : DWORD) : BOOL;

PROCEDURE GetCommState(hFile : HANDLE;
                       lpDCB : LPDCB) : BOOL;

PROCEDURE GetCommTimeouts(hFile : HANDLE;
                          lpCommTimeouts : LPCOMMTIMEOUTS) : BOOL;

PROCEDURE PurgeComm(hFile : HANDLE;
                    dwFlags : DWORD) : BOOL;

PROCEDURE SetCommBreak(hFile : HANDLE) : BOOL;

PROCEDURE SetCommMask(hFile : HANDLE;
                      dwEvtMask : DWORD) : BOOL;

PROCEDURE SetCommState(hFile : HANDLE;
                       lpDCB : LPDCB) : BOOL;

PROCEDURE SetCommTimeouts(hFile : HANDLE;
                          lpCommTimeouts : LPCOMMTIMEOUTS) : BOOL;

PROCEDURE TransmitCommChar(hFile : HANDLE;
                           cChar : ACHAR) : BOOL;

PROCEDURE WaitCommEvent(hFile : HANDLE;
                        VAR lpEvtMask : DWORD;
                        lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE SetTapePosition(hDevice : HANDLE;
                          dwPositionMethod : DWORD;
                          dwPartition : DWORD;
                          dwOffsetLow : DWORD;
                          dwOffsetHigh : DWORD;
                          bImmediate : BOOL) : DWORD;

PROCEDURE GetTapePosition(hDevice : HANDLE;
                          dwPositionType : DWORD;
                          VAR lpdwPartition : DWORD;
                          VAR lpdwOffsetLow : DWORD;
                          VAR lpdwOffsetHigh : DWORD) : DWORD;

PROCEDURE PrepareTape(hDevice : HANDLE;
                      dwOperation : DWORD;
                      bImmediate : BOOL) : DWORD;

PROCEDURE EraseTape(hDevice : HANDLE;
                    dwEraseType : DWORD;
                    bImmediate : BOOL) : DWORD;

PROCEDURE CreateTapePartition(hDevice : HANDLE;
                              dwPartitionMethod : DWORD;
                              dwCount : DWORD;
                              dwSize : DWORD) : DWORD;

PROCEDURE WriteTapemark(hDevice : HANDLE;
                        dwTapemarkType : DWORD;
                        dwTapemarkCount : DWORD;
                        bImmediate : BOOL) : DWORD;

PROCEDURE GetTapeStatus(hDevice : HANDLE) : DWORD;

PROCEDURE GetTapeParameters(hDevice : HANDLE;
                            dwOperation : DWORD;
                            VAR lpdwSize : DWORD;
                            lpTapeInformation : LPVOID) : DWORD;


CONST
    GET_TAPE_MEDIA_INFORMATION= 0;
    GET_TAPE_DRIVE_INFORMATION= 1;

PROCEDURE SetTapeParameters(hDevice : HANDLE;
                            dwOperation : DWORD;
                            lpTapeInformation : LPVOID) : DWORD;


CONST
    SET_TAPE_MEDIA_INFORMATION= 0;
    SET_TAPE_DRIVE_INFORMATION= 1;

PROCEDURE Beep(dwFreq : DWORD;
               dwDuration : DWORD) : BOOL;

PROCEDURE OpenSound();

PROCEDURE CloseSound();

PROCEDURE StartSound();

PROCEDURE StopSound();

PROCEDURE WaitSoundState(nState : DWORD) : DWORD;

PROCEDURE SyncAllVoices() : DWORD;

PROCEDURE CountVoiceNotes(nVoice : DWORD) : DWORD;

PROCEDURE GetThresholdEvent() : LPDWORD;

PROCEDURE GetThresholdStatus() : DWORD;

PROCEDURE SetSoundNoise(nSource : DWORD;
                        nDuration : DWORD) : DWORD;

PROCEDURE SetVoiceAccent(nVoice : DWORD;
                         nTempo : DWORD;
                         nVolume : DWORD;
                         nMode : DWORD;
                         nPitch : DWORD) : DWORD;

PROCEDURE SetVoiceEnvelope(nVoice : DWORD;
                           nShape : DWORD;
                           nRepeat : DWORD) : DWORD;

PROCEDURE SetVoiceNote(nVoice : DWORD;
                       nValue : DWORD;
                       nLength : DWORD;
                       nCdots : DWORD) : DWORD;

PROCEDURE SetVoiceQueueSize(nVoice : DWORD;
                            nBytes : DWORD) : DWORD;

PROCEDURE SetVoiceSound(nVoice : DWORD;
                        Frequency : DWORD;
                        nDuration : DWORD) : DWORD;

PROCEDURE SetVoiceThreshold(nVoice : DWORD;
                            nNotes : DWORD) : DWORD;

PROCEDURE MulDiv(nNumber : INTEGER;
                 nNumerator : INTEGER;
                 nDenominator : INTEGER) : INTEGER;

PROCEDURE GetSystemTime(VAR lpSystemTime : SYSTEMTIME);

PROCEDURE GetSystemTimeAsFileTime(VAR lpSystemTimeAsFileTime : FILETIME);

PROCEDURE SetSystemTime(lpSystemTime : SYSTEMTIME) : BOOL;

PROCEDURE GetLocalTime(VAR lpSystemTime : SYSTEMTIME);

PROCEDURE SetLocalTime(lpSystemTime : SYSTEMTIME) : BOOL;

PROCEDURE GetSystemInfo(VAR lpSystemInfo : SYSTEM_INFO);

PROCEDURE IsProcessorFeaturePresent(ProcessorFeature : DWORD) : BOOL;

TYPE
    TIME_ZONE_INFORMATION = RECORD
          Bias           : LONG;
          StandardName   : ARRAY [0..32 - 1] OF WCHAR;
          StandardDate   : SYSTEMTIME;
          StandardBias   : LONG;
          DaylightName   : ARRAY [0..32 - 1] OF WCHAR;
          DaylightDate   : SYSTEMTIME;
          DaylightBias   : LONG;
    END;
    PTIME_ZONE_INFORMATION= POINTER TO TIME_ZONE_INFORMATION;
    LPTIME_ZONE_INFORMATION= PTIME_ZONE_INFORMATION;

(*95*)
PROCEDURE SystemTimeToTzSpecificLocalTime(
    VAR lpTimeZoneInformation : TIME_ZONE_INFORMATION;
    VAR lpUniversalTime : SYSTEMTIME;
    VAR lpLocalTime : SYSTEMTIME
    ) : BOOL;

PROCEDURE GetTimeZoneInformation(VAR lpTimeZoneInformation : TIME_ZONE_INFORMATION) : DWORD;

PROCEDURE SetTimeZoneInformation(lpTimeZoneInformation : TIME_ZONE_INFORMATION) : BOOL;

PROCEDURE SystemTimeToFileTime(lpSystemTime : SYSTEMTIME;
                               VAR lpFileTime : FILETIME) : BOOL;

PROCEDURE FileTimeToLocalFileTime(lpFileTime : FILETIME;
                                  VAR lpLocalFileTime : FILETIME) : BOOL;

PROCEDURE LocalFileTimeToFileTime(lpLocalFileTime : FILETIME;
                                  VAR lpFileTime : FILETIME) : BOOL;

PROCEDURE FileTimeToSystemTime(lpFileTime : FILETIME;
                               VAR lpSystemTime : SYSTEMTIME) : BOOL;

PROCEDURE CompareFileTime(lpFileTime1 : FILETIME;
                          lpFileTime2 : FILETIME) : LONG;

PROCEDURE FileTimeToDosDateTime(lpFileTime : FILETIME;
                                VAR lpFatDate : WORD;
                                VAR lpFatTime : WORD) : BOOL;

PROCEDURE DosDateTimeToFileTime(wFatDate : WORD;
                                wFatTime : WORD;
                                VAR lpFileTime : FILETIME) : BOOL;

PROCEDURE GetTickCount() : DWORD;


PROCEDURE SetSystemTimeAdjustment(
                                    dwTimeAdjustment : DWORD;
                                    bTimeAdjustmentDisabled : BOOL
                                    ) : BOOL;

PROCEDURE GetSystemTimeAdjustment(
                                    VAR lpTimeAdjustment : DWORD;
                                    VAR lpTimeIncrement : DWORD;
                                    VAR lpTimeAdjustmentDisabled : BOOL
                                    ) : BOOL;


PROCEDURE FormatMessageA(
                        dwFlags : DWORD;
                        lpSource : LPCVOID;
                        dwMessageId : DWORD;
                        dwLanguageId : DWORD;
                        VAR lpBuffer : ARRAY OF ACHAR;
                        nSize : DWORD;
                        Arguments : PCHAR
                        ) : DWORD;

PROCEDURE FormatMessageW(
                        dwFlags : DWORD;
                        lpSource : LPCVOID;
                        dwMessageId : DWORD;
                        dwLanguageId : DWORD;
                        VAR lpBuffer : ARRAY OF UCHAR;
                        nSize : DWORD;
                        Arguments : PCHAR
                        ) : DWORD;

%IF UNICODE %THEN
PROCEDURE FormatMessage = FormatMessageW;
%ELSE
PROCEDURE FormatMessage = FormatMessageA;
%END

CONST
    FORMAT_MESSAGE_ALLOCATE_BUFFER= 000000100h;
    FORMAT_MESSAGE_IGNORE_INSERTS= 000000200h;
    FORMAT_MESSAGE_FROM_STRING= 000000400h;
    FORMAT_MESSAGE_FROM_HMODULE= 000000800h;
    FORMAT_MESSAGE_FROM_SYSTEM= 000001000h;
    FORMAT_MESSAGE_ARGUMENT_ARRAY= 000002000h;
    FORMAT_MESSAGE_MAX_WIDTH_MASK= 0000000FFh;

TYPE
    MESSAGE_RESOURCE_ENTRY = RECORD
        Length          : WORD;
        Flags           : WORD;
        Text            : ARRAY [0..1-1] OF BYTE;
    END;
    PMESSAGE_RESOURCE_ENTRY = POINTER TO MESSAGE_RESOURCE_ENTRY;

CONST
    MESSAGE_RESOURCE_UNICODE    = 1;

TYPE
    MESSAGE_RESOURCE_BLOCK = RECORD
        LowId           : DWORD;
        HighId          : DWORD;
        OffsetToEntries : DWORD;
    END;
    PMESSAGE_RESOURCE_BLOCK = POINTER TO MESSAGE_RESOURCE_BLOCK;

    MESSAGE_RESOURCE_DATA = RECORD
        NumberOfBlocks          : DWORD;
        Blocks                  : ARRAY [0..1-1] OF MESSAGE_RESOURCE_BLOCK;
    END;
    PMESSAGE_RESOURCE_DATA      = POINTER TO MESSAGE_RESOURCE_DATA;

PROCEDURE CreatePipe(VAR read : HANDLE;
                     VAR write : HANDLE;
                     attr : SECURITY_ATTRIBUTES;
                     size : DWORD) : BOOL;

PROCEDURE ConnectNamedPipe(hNamedPipe : HANDLE;
                           lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE DisconnectNamedPipe(hNamedPipe : HANDLE) : BOOL;

PROCEDURE SetNamedPipeHandleState(hNamedPipe : HANDLE;
                                  VAR lpMode : DWORD;
                                  VAR lpMaxCollectionCount : DWORD;
                                  VAR lpCollectDataTimeout : DWORD) : BOOL;

PROCEDURE GetNamedPipeInfo(hNamedPipe : HANDLE;
                           VAR lpFlags : DWORD;
                           VAR lpOutBufferSize : DWORD;
                           VAR lpInBufferSize : DWORD;
                           VAR lpMaxInstances : DWORD) : BOOL;

PROCEDURE PeekNamedPipe(hNamedPipe : HANDLE;
                        lpBuffer : LPVOID;
                        nBufferSize : DWORD;
                        VAR lpBytesRead : DWORD;
                        VAR lpTotalBytesAvail : DWORD;
                        VAR lpBytesLeftThisMessage : DWORD) : BOOL;

PROCEDURE TransactNamedPipe(hNamedPipe : HANDLE;
                            lpInBuffer : LPVOID;
                            nInBufferSize : DWORD;
                            lpOutBuffer : LPVOID;
                            nOutBufferSize : DWORD;
                            VAR lpBytesRead : DWORD;
                            lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE CreateMailslotA(lpName : ARRAY OF ACHAR;
                          nMaxMessageSize : DWORD;
                          lReadTimeout : DWORD;
                          lpSecurityAttributes : SECURITY_ATTRIBUTES) : HANDLE;

PROCEDURE CreateMailslotW(lpName : ARRAY OF UCHAR;
                          nMaxMessageSize : DWORD;
                          lReadTimeout : DWORD;
                          lpSecurityAttributes : SECURITY_ATTRIBUTES) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateMailslot = CreateMailslotW;
%ELSE
PROCEDURE CreateMailslot = CreateMailslotA;

%END

PROCEDURE GetMailslotInfo(hMailslot : HANDLE;
                          VAR lpMaxMessageSize : DWORD;
                          VAR lpNextSize : DWORD;
                          VAR lpMessageCount : DWORD;
                          VAR lpReadTimeout : DWORD) : BOOL;

PROCEDURE SetMailslotInfo(hMailslot : HANDLE;
                          lReadTimeout : DWORD) : BOOL;

PROCEDURE MapViewOfFile(hFileMappingObject : HANDLE;
                        dwDesiredAccess : DWORD;
                        dwFileOffsetHigh : DWORD;
                        dwFileOffsetLow : DWORD;
                        dwNumberOfBytesToMap : SIZE_T) : LPVOID;

PROCEDURE MapViewOfFileVlm(hFileMappingObject : HANDLE;
                           dwDesiredAccess : DWORD;
                           ulOffset : DWORDLONG;
                           ulNumberOfBytesToMap : DWORDLONG;
                           lpBaseAddress : PVOID64) : PVOID64;

PROCEDURE UnmapViewOfFileVlm(lpBaseAddress : PVOID64) : BOOL;

PROCEDURE FlushViewOfFile(lpBaseAddress : LPCVOID;
                          dwNumberOfBytesToFlush : SIZE_T) : BOOL;

PROCEDURE UnmapViewOfFile(lpBaseAddress : LPVOID) : BOOL;

(*
 File Encryption API
*)

PROCEDURE EncryptFileA(lpFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE EncryptFileW(lpFileName : ARRAY OF WCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE EncryptFile = EncryptFileW;
%ELSE
PROCEDURE EncryptFile = EncryptFileA;
%END

PROCEDURE DecryptFileA(lpFileName : ARRAY OF ACHAR;
                       dwReserved : DWORD) : BOOL;

PROCEDURE DecryptFileW(lpFileName : ARRAY OF WCHAR;
                       dwReserved : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE DecryptFile = DecryptFileW;
%ELSE
PROCEDURE DecryptFile = DecryptFileA;
%END

(*
 Currently defined recovery flags
*)

CONST
    EFS_USE_RECOVERY_KEYS  = 1h;

TYPE
    PFE_EXPORT_FUNC = PROCEDURE(VAR ARRAY OF LOC, PVOID, ULONG) : DWORD [EXPORT];
    PFE_IMPORT_FUNC = PROCEDURE(VAR ARRAY OF LOC, PVOID, ULONG) : DWORD [EXPORT];


(*
  OpenRaw flag values
*)
CONST
    CREATE_FOR_IMPORT  =(1);
    CREATE_FOR_DIR     =(2);


PROCEDURE OpenRawA(lpFileName  : ARRAY OF ACHAR;
                   ulFlags : ULONG;
                   VAR pvContext  : PVOID) : DWORD;

PROCEDURE OpenRawW(lpFileName  : ARRAY OF WCHAR;
                   ulFlags : ULONG;
                   VAR pvContext  : PVOID) : DWORD;

%IF UNICODE %THEN
PROCEDURE OpenRaw = OpenRawW;
%ELSE
PROCEDURE OpenRaw = OpenRawA;
%END

PROCEDURE ReadRaw(pfExportCallback : PFE_EXPORT_FUNC;
                  pvCallbackContext : PVOID;
                  pvContext : PVOID) : DWORD;

PROCEDURE WriteRaw(pfExportCallback : PFE_IMPORT_FUNC;
                   pvCallbackContext : PVOID;
                   pvContext : PVOID) : DWORD;

PROCEDURE CloseRaw(pvContext : PVOID);

TYPE
    RECOVERY_AGENT_INFORMATIONA = RECORD
    NextEntryOffset : DWORD;
    AgentNameLength : DWORD;
    AgentInformation : ARRAY [0..1-1] OF ACHAR;
    END;
    LPRECOVERY_AGENT_INFORMATIONA = POINTER TO RECOVERY_AGENT_INFORMATIONA;

    RECOVERY_AGENT_INFORMATIONW = RECORD
    NextEntryOffset : DWORD;
    AgentNameLength : DWORD;
    AgentInformation : ARRAY [0..1-1] OF WCHAR;
    END;
    LPRECOVERY_AGENT_INFORMATIONW = POINTER TO RECOVERY_AGENT_INFORMATIONW;

%IF UNICODE %THEN
    RECOVERY_AGENT_INFORMATION = RECOVERY_AGENT_INFORMATIONW;
    LPRECOVERY_AGENT_INFORMATION = LPRECOVERY_AGENT_INFORMATIONW;
%ELSE
    RECOVERY_AGENT_INFORMATION = RECOVERY_AGENT_INFORMATIONA;
    LPRECOVERY_AGENT_INFORMATION = LPRECOVERY_AGENT_INFORMATIONA;
%END

PROCEDURE QueryRecoveryAgentsA(lpFileName : ARRAY OF ACHAR;
     VAR OUT AgentCount : DWORD;
     VAR OUT RecoveryAgentInformation : RECOVERY_AGENT_INFORMATIONA) : DWORD;

PROCEDURE QueryRecoveryAgentsW(lpFileName : ARRAY OF WCHAR;
     VAR OUT AgentCount : DWORD;
     VAR OUT RecoveryAgentInformation : RECOVERY_AGENT_INFORMATIONW) : DWORD;

%IF UNICODE %THEN
PROCEDURE QueryRecoveryAgents = QueryRecoveryAgentsW;
%ELSE
PROCEDURE QueryRecoveryAgents = QueryRecoveryAgentsA;
%END

PROCEDURE lstrcmpA(lpString1 : ARRAY OF ACHAR;
                   lpString2 : ARRAY OF ACHAR) : INTEGER;

PROCEDURE lstrcmpW(lpString1 : ARRAY OF UCHAR;
                   lpString2 : ARRAY OF UCHAR) : INTEGER;

%IF UNICODE %THEN
PROCEDURE lstrcmp = lstrcmpW;
%ELSE
PROCEDURE lstrcmp = lstrcmpA;
%END

PROCEDURE lstrcmpiA(lpString1 : ARRAY OF ACHAR;
                    lpString2 : ARRAY OF ACHAR) : INTEGER;

PROCEDURE lstrcmpiW(lpString1 : ARRAY OF UCHAR;
                    lpString2 : ARRAY OF UCHAR) : INTEGER;

%IF UNICODE %THEN
PROCEDURE lstrcmpi = lstrcmpiW;
%ELSE
PROCEDURE lstrcmpi = lstrcmpiA;
%END

PROCEDURE lstrcpynA(
                    VAR lpString1 : ARRAY OF ACHAR;
                    lpString2 : ARRAY OF ACHAR;
                    iMaxLength : WINT
                    ) : LPSTR;

PROCEDURE lstrcpynW(
                    VAR lpString1 : ARRAY OF UCHAR;
                    lpString2 : ARRAY OF UCHAR;
                    iMaxLength : WINT
                    ) : LPWSTR;
%IF UNICODE %THEN
PROCEDURE lstrcpyn = lstrcpynW;
%ELSE
PROCEDURE lstrcpyn = lstrcpynA;
%END

PROCEDURE lstrcpyA(VAR lpString1 : ARRAY OF ACHAR;
                   lpString2 : ARRAY OF ACHAR) : LPSTR;

PROCEDURE lstrcpyW(VAR lpString1 : ARRAY OF UCHAR;
                   lpString2 : ARRAY OF UCHAR) : LPWSTR;

%IF UNICODE %THEN
PROCEDURE lstrcpy = lstrcpyW;
%ELSE
PROCEDURE lstrcpy = lstrcpyA;
%END

PROCEDURE lstrcatA(VAR lpString1 : ARRAY OF ACHAR;
                   lpString2 : ARRAY OF ACHAR) : LPSTR;

PROCEDURE lstrcatW(VAR lpString1 : ARRAY OF UCHAR;
                   lpString2 : ARRAY OF UCHAR) : LPWSTR;

%IF UNICODE %THEN
PROCEDURE lstrcat = lstrcatW;
%ELSE
PROCEDURE lstrcat = lstrcatA;
%END

PROCEDURE lstrlenA(lpString : ARRAY OF ACHAR) : INTEGER;

PROCEDURE lstrlenW(lpString : ARRAY OF UCHAR) : INTEGER;

%IF UNICODE %THEN
PROCEDURE lstrlen = lstrlenW;
%ELSE
PROCEDURE lstrlen = lstrlenA;
%END

PROCEDURE OpenFile(lpFileName : ARRAY OF ACHAR;
                   VAR lpReOpenBuff : OFSTRUCT;
                   uStyle : UINT) : HFILE;

PROCEDURE _lopen(lpPathName : ARRAY OF ACHAR;
                 iReadWrite : INTEGER) : HFILE;

PROCEDURE _lcreat(lpPathName : ARRAY OF ACHAR;
                  iAttribute : INTEGER) : HFILE;

PROCEDURE _lread(hFile : HFILE;
                 VAR lpBuffer : ARRAY OF LOC;
                 uBytes : UINT) : UINT;

PROCEDURE _lwrite(hFile : HFILE;
                  lpBuffer : ARRAY OF LOC;
                  uBytes : UINT) : UINT;

PROCEDURE _hread(hFile : HFILE;
                 VAR lpBuffer : ARRAY OF LOC;
                 lBytes : INTEGER) : INTEGER;

PROCEDURE _hwrite(hFile : HFILE;
                  lpBuffer : ARRAY OF LOC;
                  lBytes : INTEGER) : INTEGER;

PROCEDURE _lclose(hFile : HFILE) : HFILE;

PROCEDURE _llseek(hFile : HFILE;
                  lOffset : LONG;
                  iOrigin : INTEGER) : LONG;

(*95*)
PROCEDURE IsTextUnicode(
                        lpBuffer : ADDRESS;
                        cb : WINT;
                        VAR lpi : WINT
                        ) :  BOOL;

CONST
    TLS_OUT_OF_INDEXES = 0FFFFFFFFh;

PROCEDURE TlsAlloc() : DWORD;

PROCEDURE TlsGetValue(dwTlsIndex : DWORD) : LPVOID;

PROCEDURE TlsSetValue(dwTlsIndex : DWORD;
                      lpTlsValue : LPVOID) : BOOL;

PROCEDURE TlsFree(dwTlsIndex : DWORD) : BOOL;

TYPE
    LPOVERLAPPED_COMPLETION_ROUTINE= PROCEDURE (DWORD, DWORD, LPOVERLAPPED) [EXPORT];

PROCEDURE SleepEx(dwMilliseconds : DWORD;
                  bAlertable : BOOL) : DWORD;

PROCEDURE WaitForSingleObjectEx(hHandle : HANDLE;
                                dwMilliseconds : DWORD;
                                bAlertable : BOOL) : DWORD;

PROCEDURE WaitForMultipleObjectsEx(nCount : DWORD;
                                   lpHandles : ARRAY OF HANDLE;
                                   bWaitAll : BOOL;
                                   dwMilliseconds : DWORD;
                                   bAlertable : BOOL) : DWORD;

(* NT only *)
PROCEDURE SignalObjectAndWait(hObjectToSignal : HANDLE;
                              hObjectToWaitOn : HANDLE;
                              dwMilliseconds : DWORD;
                              bAlertable : BOOL) : DWORD;

PROCEDURE ReadFileEx(hFile : HANDLE;
                     lpBuffer : LPVOID;
                     nNumberOfBytesToRead : DWORD;
                     lpOverlapped : LPOVERLAPPED;
                     lpCompletionRoutine : LPOVERLAPPED_COMPLETION_ROUTINE) : BOOL;

PROCEDURE WriteFileEx(hFile : HANDLE;
                      lpBuffer : LPCVOID;
                      nNumberOfBytesToWrite : DWORD;
                      lpOverlapped : LPOVERLAPPED;
                      lpCompletionRoutine : LPOVERLAPPED_COMPLETION_ROUTINE) : BOOL;

PROCEDURE BackupRead(hFile : HANDLE;
                     lpBuffer : LPBYTE;
                     nNumberOfBytesToRead : DWORD;
                     VAR lpNumberOfBytesRead : DWORD;
                     bAbort : BOOL;
                     bProcessSecurity : BOOL;
                     VAR lpContext : LPVOID) : BOOL;

PROCEDURE BackupSeek(hFile : HANDLE;
                     dwLowBytesToSeek : DWORD;
                     dwHighBytesToSeek : DWORD;
                     VAR lpdwLowByteSeeked : DWORD;
                     VAR lpdwHighByteSeeked : DWORD;
                     VAR lpContext : LPVOID) : BOOL;

PROCEDURE BackupWrite(hFile : HANDLE;
                      lpBuffer : LPBYTE;
                      nNumberOfBytesToWrite : DWORD;
                      VAR lpNumberOfBytesWritten : DWORD;
                      bAbort : BOOL;
                      bProcessSecurity : BOOL;
                      VAR lpContext : LPVOID) : BOOL;


TYPE
    WIN32_STREAM_ID = RECORD
          dwStreamId     : DWORD;
          dwStreamAttributes: DWORD;
          Size           : LARGE_INTEGER;
          dwStreamNameSize: DWORD;
          cStreamName    : ARRAY [0..ANYSIZE_ARRAY - 1] OF WCHAR;
    END;
    LPWIN32_STREAM_ID    = POINTER TO WIN32_STREAM_ID;

CONST
    BACKUP_INVALID       = 000000000h;
    BACKUP_DATA          = 000000001h;
    BACKUP_EA_DATA       = 000000002h;
    BACKUP_SECURITY_DATA = 000000003h;
    BACKUP_ALTERNATE_DATA= 000000004h;
    BACKUP_LINK          = 000000005h;
    BACKUP_PROPERTY_DATA = 000000006h;
    BACKUP_OBJECT_ID        = 00000007h;
    BACKUP_REPARSE_DATA     = 00000008h;
    BACKUP_SPARSE_BLOCK     = 00000009h;

    STREAM_NORMAL_ATTRIBUTE     = 00000h;
    STREAM_MODIFIED_WHEN_READ   = 00001h;
    STREAM_CONTAINS_SECURITY    = 00002h;
    STREAM_CONTAINS_PROPERTIES  = 00004h;
    STREAM_SPARSE_ATTRIBUTE     = 00000008h;

(*
 Define segement buffer structure for scatter/gather read/write.
*)

TYPE
    FILE_SEGMENT_ELEMENT = RECORD
    CASE : BOOLEAN OF
    FALSE: Buffer : PVOID64;|
    TRUE: Alignment : ULONGLONG;
    END;
    END;
    PFILE_SEGMENT_ELEMENT = POINTER TO FILE_SEGMENT_ELEMENT;

PROCEDURE ReadFileScatter(hFile : HANDLE;
                          aSegmentArray : ARRAY OF FILE_SEGMENT_ELEMENT;
                          nNumberOfBytesToRead : DWORD;
                          lpReserved : LPDWORD;
                          lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE WriteFileGather(hFile : HANDLE;
                          aSegmentArray : ARRAY OF FILE_SEGMENT_ELEMENT;
                          nNumberOfBytesToWrite : DWORD;
                          lpReserved : LPDWORD;
                          lpOverlapped : LPOVERLAPPED) : BOOL;

CONST
    STARTF_USESHOWWINDOW = 000000001h;
    STARTF_USESIZE       = 000000002h;
    STARTF_USEPOSITION   = 000000004h;
    STARTF_USECOUNTCHARS = 000000008h;
    STARTF_USEFILLATTRIBUTE= 000000010h;
    STARTF_RUNFULLSCREEN   = 000000020h;
    STARTF_FORCEONFEEDBACK = 000000040h;
    STARTF_FORCEOFFFEEDBACK= 000000080h;
    STARTF_USESTDHANDLES   = 000000100h;
    STARTF_USEHOTKEY       = 000000200h;(*95*)


TYPE
    STARTUPINFOA = RECORD
          cb             : DWORD;
          lpReserved     : LPSTR;
          lpDesktop      : LPSTR;
          lpTitle        : LPSTR;
          dwX            : DWORD;
          dwY            : DWORD;
          dwXSize        : DWORD;
          dwYSize        : DWORD;
          dwXCountChars  : DWORD;
          dwYCountChars  : DWORD;
          dwFillAttribute: DWORD;
          dwFlags        : DWORD;
          wShowWindow    : WORD;
          cbReserved2    : WORD;
          lpReserved2    : LPBYTE;
          hStdInput      : HANDLE;
          hStdOutput     : HANDLE;
          hStdError      : HANDLE;
    END;
    LPSTARTUPINFOA       = POINTER TO STARTUPINFOA;

    STARTUPINFOW = RECORD
          cb             : DWORD;
          lpReserved     : LPWSTR;
          lpDesktop      : LPWSTR;
          lpTitle        : LPWSTR;
          dwX            : DWORD;
          dwY            : DWORD;
          dwXSize        : DWORD;
          dwYSize        : DWORD;
          dwXCountChars  : DWORD;
          dwYCountChars  : DWORD;
          dwFillAttribute: DWORD;
          dwFlags        : DWORD;
          wShowWindow    : WORD;
          cbReserved2    : WORD;
          lpReserved2    : LPBYTE;
          hStdInput      : HANDLE;
          hStdOutput     : HANDLE;
          hStdError      : HANDLE;
    END;
    LPSTARTUPINFOW       = POINTER TO STARTUPINFOW;

    %IF UNICODE %THEN
    STARTUPINFO          = STARTUPINFOW;
    LPSTARTUPINFO        = LPSTARTUPINFOW;
    %ELSE
    STARTUPINFO          = STARTUPINFOA;
    LPSTARTUPINFO        = LPSTARTUPINFOA;
    %END

CONST
    SHUTDOWN_NORETRY     = 000000001h;

TYPE
    WIN32_FIND_DATAA = RECORD
          dwFileAttributes: DWORD;
          ftCreationTime : FILETIME;
          ftLastAccessTime: FILETIME;
          ftLastWriteTime: FILETIME;
          nFileSizeHigh  : DWORD;
          nFileSizeLow   : DWORD;
          dwReserved0    : DWORD;
          dwReserved1    : DWORD;
          cFileName      : ARRAY [0..MAX_PATH - 1] OF ACHAR;
          cAlternateFileName: ARRAY [0..14 - 1] OF ACHAR;
    END;
    PWIN32_FIND_DATAA    = POINTER TO WIN32_FIND_DATAA;
    LPWIN32_FIND_DATAA   = PWIN32_FIND_DATAA;

    WIN32_FIND_DATAW = RECORD
          dwFileAttributes: DWORD;
          ftCreationTime : FILETIME;
          ftLastAccessTime: FILETIME;
          ftLastWriteTime: FILETIME;
          nFileSizeHigh  : DWORD;
          nFileSizeLow   : DWORD;
          dwReserved0    : DWORD;
          dwReserved1    : DWORD;
          cFileName      : ARRAY [0..MAX_PATH - 1] OF WCHAR;
          cAlternateFileName: ARRAY [0..14 - 1] OF WCHAR;
    END;
    PWIN32_FIND_DATAW    = POINTER TO WIN32_FIND_DATAW;
    LPWIN32_FIND_DATAW   = PWIN32_FIND_DATAW;

%IF UNICODE %THEN
    WIN32_FIND_DATA      = WIN32_FIND_DATAW;
    PWIN32_FIND_DATA     = PWIN32_FIND_DATAW;
%ELSE
    WIN32_FIND_DATA      = WIN32_FIND_DATAA;
    PWIN32_FIND_DATA     = PWIN32_FIND_DATAA;
%END
    LPWIN32_FIND_DATA    = PWIN32_FIND_DATA;

    WIN32_FILE_ATTRIBUTE_DATA = RECORD
    dwFileAttributes    :DWORD;
    ftCreationTime      : FILETIME;
    ftLastAccessTime    : FILETIME;
    ftLastWriteTime     : FILETIME;
    nFileSizeHigh       : DWORD;
    nFileSizeLow        : DWORD;
    END;
    LPWIN32_FILE_ATTRIBUTE_DATA = POINTER TO WIN32_FILE_ATTRIBUTE_DATA;

PROCEDURE CreateMutexA(lpMutexAttributes : SECURITY_ATTRIBUTES;
                       bInitialOwner : BOOL;
                       lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateMutexW(lpMutexAttributes : SECURITY_ATTRIBUTES;
                       bInitialOwner : BOOL;
                       lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateMutex = CreateMutexW;
%ELSE
PROCEDURE CreateMutex = CreateMutexA;
%END

PROCEDURE OpenMutexA(dwDesiredAccess : DWORD;
                     bInheritHandle : BOOL;
                     lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenMutexW(dwDesiredAccess : DWORD;
                     bInheritHandle : BOOL;
                     lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenMutex = OpenMutexW;
%ELSE
PROCEDURE OpenMutex = OpenMutexA;
%END

PROCEDURE CreateEventA(lpEventAttributes : SECURITY_ATTRIBUTES;
                       bManualReset : BOOL;
                       bInitialState : BOOL;
                       lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateEventW(lpEventAttributes : SECURITY_ATTRIBUTES;
                       bManualReset : BOOL;
                       bInitialState : BOOL;
                       lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateEvent = CreateEventW;
%ELSE
PROCEDURE CreateEvent = CreateEventA;
%END

PROCEDURE OpenEventA(dwDesiredAccess : DWORD;
                     bInheritHandle : BOOL;
                     lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenEventW(dwDesiredAccess : DWORD;
                     bInheritHandle : BOOL;
                     lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenEvent = OpenEventW;
%ELSE
PROCEDURE OpenEvent = OpenEventA;
%END

PROCEDURE CreateSemaphoreA(lpSemaphoreAttributes : SECURITY_ATTRIBUTES;
                           lInitialCount : LONG;
                           lMaximumCount : LONG;
                           lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateSemaphoreW(lpSemaphoreAttributes : SECURITY_ATTRIBUTES;
                           lInitialCount : LONG;
                           lMaximumCount : LONG;
                           lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateSemaphore = CreateSemaphoreW;
%ELSE
PROCEDURE CreateSemaphore = CreateSemaphoreA;
%END

PROCEDURE OpenSemaphoreA(dwDesiredAccess : DWORD;
                         bInheritHandle : BOOL;
                         lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenSemaphoreW(dwDesiredAccess : DWORD;
                         bInheritHandle : BOOL;
                         lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenSemaphore = OpenSemaphoreW;
%ELSE
PROCEDURE OpenSemaphore = OpenSemaphoreA;
%END

TYPE PTIMERAPCROUTINE   = PROCEDURE((*lpArgToCompletionRoutine*)LPVOID,
                                    (*dwTimerLowValue*)DWORD,
                                    (*dwTimerHighValue*)DWORD) [EXPORT];

PROCEDURE CreateWaitableTimerA(lpTimerAttributes : SECURITY_ATTRIBUTES;
                               bManualReset : BOOL;
                               lpTimerName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateWaitableTimerW(lpTimerAttributes : SECURITY_ATTRIBUTES;
                               bManualReset : BOOL;
                               lpTimerName : ARRAY OF WCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateWaitableTimer = CreateWaitableTimerW;
%ELSE
PROCEDURE CreateWaitableTimer = CreateWaitableTimerA;
%END

PROCEDURE OpenWaitableTimerA(dwDesiredAccess : DWORD;
                             bInheritHandle : BOOL;
                             lpTimerName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenWaitableTimerW(dwDesiredAccess : DWORD;
                             bInheritHandle : BOOL;
                             lpTimerName : ARRAY OF WCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenWaitableTimer = OpenWaitableTimerW;
%ELSE
PROCEDURE OpenWaitableTimer = OpenWaitableTimerA;
%END

PROCEDURE SetWaitableTimer(hTimer : HANDLE;
                           VAR lpDueTime : LARGE_INTEGER;
                           lPeriod : LONG;
                           pfnCompletionRoutine : PTIMERAPCROUTINE;
                           lpArgToCompletionRoutine : LPVOID;
                           fResume : BOOL) : BOOL;

PROCEDURE CancelWaitableTimer(hTimer : HANDLE) : BOOL;

PROCEDURE CreateFileMappingA(hFile : HANDLE;
                             lpFileMappingAttributes : SECURITY_ATTRIBUTES;
                             flProtect : DWORD;
                             dwMaximumSizeHigh : DWORD;
                             dwMaximumSizeLow : DWORD;
                             lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateFileMappingW(hFile : HANDLE;
                             lpFileMappingAttributes : SECURITY_ATTRIBUTES;
                             flProtect : DWORD;
                             dwMaximumSizeHigh : DWORD;
                             dwMaximumSizeLow : DWORD;
                             lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateFileMapping = CreateFileMappingW;
%ELSE
PROCEDURE CreateFileMapping = CreateFileMappingA;
%END

PROCEDURE OpenFileMappingA(dwDesiredAccess : DWORD;
                           bInheritHandle : BOOL;
                           lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenFileMappingW(dwDesiredAccess : DWORD;
                           bInheritHandle : BOOL;
                           lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenFileMapping = OpenFileMappingW;
%ELSE
PROCEDURE OpenFileMapping = OpenFileMappingA;
%END

PROCEDURE GetLogicalDriveStringsA(nBufferLength : DWORD;
                                  VAR lpBuffer : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetLogicalDriveStringsW(nBufferLength : DWORD;
                                  VAR lpBuffer : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetLogicalDriveStrings = GetLogicalDriveStringsW;
%ELSE
PROCEDURE GetLogicalDriveStrings = GetLogicalDriveStringsA;
%END

PROCEDURE LoadLibraryA(lpLibFileName : ARRAY OF ACHAR) : HINSTANCE;

PROCEDURE LoadLibraryW(lpLibFileName : ARRAY OF UCHAR) : HINSTANCE;

%IF UNICODE %THEN
PROCEDURE LoadLibrary = LoadLibraryW;
%ELSE
PROCEDURE LoadLibrary = LoadLibraryA;
%END

PROCEDURE LoadLibraryExA(lpLibFileName : ARRAY OF ACHAR;
                         hFile : HANDLE;
                         dwFlags : DWORD) : HINSTANCE;

PROCEDURE LoadLibraryExW(lpLibFileName : ARRAY OF UCHAR;
                         hFile : HANDLE;
                         dwFlags : DWORD) : HINSTANCE;
%IF UNICODE %THEN
PROCEDURE LoadLibraryEx = LoadLibraryExW;
%ELSE
PROCEDURE LoadLibraryEx = LoadLibraryExA;
%END

CONST
    DONT_RESOLVE_DLL_REFERENCES         = 000000001h;
    LOAD_LIBRARY_AS_DATAFILE            = 000000002h;
    LOAD_WITH_ALTERED_SEARCH_PATH       = 000000008h;

PROCEDURE GetModuleFileNameA(hModule : HINSTANCE;
                             VAR lpFilename : ARRAY OF ACHAR;
                             nSize : DWORD) : DWORD;

PROCEDURE GetModuleFileNameW(hModule : HINSTANCE;
                             VAR lpFilename : ARRAY OF UCHAR;
                             nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetModuleFileName = GetModuleFileNameW;
%ELSE
PROCEDURE GetModuleFileName = GetModuleFileNameA;
%END

PROCEDURE GetModuleHandleA(lpModuleName : ARRAY OF ACHAR) : HMODULE;

PROCEDURE GetModuleHandleW(lpModuleName : ARRAY OF UCHAR) : HMODULE;

%IF UNICODE %THEN
PROCEDURE GetModuleHandle = GetModuleHandleW;
%ELSE
PROCEDURE GetModuleHandle = GetModuleHandleA;
%END

PROCEDURE CreateProcessA(lpApplicationName : ARRAY OF ACHAR;
                         lpCommandLine : ARRAY OF ACHAR;
                         lpProcessAttributes : SECURITY_ATTRIBUTES;
                         lpThreadAttributes : SECURITY_ATTRIBUTES;
                         bInheritHandles : BOOL;
                         dwCreationFlags : DWORD;
                         lpEnvironment : LPVOID;
                         lpCurrentDirectory : ARRAY OF ACHAR;
                         lpStartupInfo : STARTUPINFOA;
                         VAR lpProcessInformation : PROCESS_INFORMATION) : BOOL;

PROCEDURE CreateProcessW(lpApplicationName : ARRAY OF UCHAR;
                         lpCommandLine : ARRAY OF UCHAR;
                         lpProcessAttributes : SECURITY_ATTRIBUTES;
                         lpThreadAttributes : SECURITY_ATTRIBUTES;
                         bInheritHandles : BOOL;
                         dwCreationFlags : DWORD;
                         lpEnvironment : LPVOID;
                         lpCurrentDirectory : ARRAY OF UCHAR;
                         lpStartupInfo : STARTUPINFOW;
                         VAR lpProcessInformation : PROCESS_INFORMATION) : BOOL;
%IF UNICODE %THEN
PROCEDURE CreateProcess = CreateProcessW;
%ELSE
PROCEDURE CreateProcess = CreateProcessA;
%END

PROCEDURE SetProcessShutdownParameters(dwLevel : DWORD;
                                       dwFlags : DWORD) : BOOL;

PROCEDURE GetProcessShutdownParameters(VAR lpdwLevel : DWORD;
                                       VAR lpdwFlags : DWORD) : BOOL;

PROCEDURE GetProcessVersion(ProcessId : DWORD) : DWORD;

PROCEDURE FatalAppExitA(uAction : UINT;
                        lpMessageText : ARRAY OF ACHAR);

PROCEDURE FatalAppExitW(uAction : UINT;
                        lpMessageText : ARRAY OF UCHAR);

%IF UNICODE %THEN
PROCEDURE FatalAppExit = FatalAppExitW;
%ELSE
PROCEDURE FatalAppExit = FatalAppExitA;
%END

PROCEDURE GetStartupInfoA(VAR lpStartupInfo : STARTUPINFOA);

PROCEDURE GetStartupInfoW(VAR lpStartupInfo : STARTUPINFOW);

%IF UNICODE %THEN
PROCEDURE GetStartupInfo = GetStartupInfoW;
%ELSE
PROCEDURE GetStartupInfo = GetStartupInfoA;
%END

PROCEDURE GetCommandLineA() : LPSTR;

PROCEDURE GetCommandLineW() : LPWSTR;

%IF UNICODE %THEN
PROCEDURE GetCommandLine = GetCommandLineW;
%ELSE
PROCEDURE GetCommandLine = GetCommandLineA;
%END

PROCEDURE GetEnvironmentVariableA(lpName : ARRAY OF ACHAR;
                                  VAR lpBuffer : ARRAY OF ACHAR;
                                  nSize : DWORD) : DWORD;

PROCEDURE GetEnvironmentVariableW(lpName : ARRAY OF UCHAR;
                                  VAR lpBuffer : ARRAY OF UCHAR;
                                  nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetEnvironmentVariable = GetEnvironmentVariableW;
%ELSE
PROCEDURE GetEnvironmentVariable = GetEnvironmentVariableA;
%END

PROCEDURE SetEnvironmentVariableA(lpName : ARRAY OF ACHAR;
                                  lpValue : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetEnvironmentVariableW(lpName : ARRAY OF UCHAR;
                                  lpValue : ARRAY OF UCHAR) : BOOL;
%IF UNICODE %THEN
PROCEDURE SetEnvironmentVariable = SetEnvironmentVariableW;
%ELSE
PROCEDURE SetEnvironmentVariable = SetEnvironmentVariableA;
%END

PROCEDURE ExpandEnvironmentStringsA(lpSrc : ARRAY OF ACHAR;
                                    VAR lpDst : ARRAY OF ACHAR;
                                    nSize : DWORD) : DWORD;

PROCEDURE ExpandEnvironmentStringsW(lpSrc : ARRAY OF UCHAR;
                                    VAR lpDst : ARRAY OF UCHAR;
                                    nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE ExpandEnvironmentStrings = ExpandEnvironmentStringsW;
%ELSE
PROCEDURE ExpandEnvironmentStrings = ExpandEnvironmentStringsA;
%END

PROCEDURE OutputDebugStringW(lpOutputString : ARRAY OF UCHAR);

PROCEDURE OutputDebugStringA(lpOutputString : ARRAY OF ACHAR);

%IF UNICODE %THEN
PROCEDURE OutputDebugString = OutputDebugStringW;
%ELSE
PROCEDURE OutputDebugString = OutputDebugStringA;
%END

PROCEDURE FindResourceA(hModule : HINSTANCE;
                        lpName : ARRAY OF ACHAR;
                        lpType : ARRAY OF ACHAR) : HRSRC;

PROCEDURE FindResourceW(hModule : HINSTANCE;
                        lpName : ARRAY OF UCHAR;
                        lpType : ARRAY OF UCHAR) : HRSRC;

%IF UNICODE %THEN
PROCEDURE FindResource = FindResourceW;
%ELSE
PROCEDURE FindResource = FindResourceA;
%END

PROCEDURE FindResourceExA(hModule : HINSTANCE;
                          lpType : ARRAY OF ACHAR;
                          lpName : ARRAY OF ACHAR;
                          wLanguage : WORD) : HRSRC;

PROCEDURE FindResourceExW(hModule : HINSTANCE;
                          lpType : ARRAY OF UCHAR;
                          lpName : ARRAY OF UCHAR;
                          wLanguage : WORD) : HRSRC;

%IF UNICODE %THEN
PROCEDURE FindResourceEx = FindResourceExW;
%ELSE
PROCEDURE FindResourceEx = FindResourceExA;
%END

TYPE
    ENUMRESTYPEPROCA      = PROCEDURE(HMODULE,
                                      ARRAY OF ACHAR,
                                      LONG_PTR) : BOOL [EXPORT];
    ENUMRESTYPEPROCW      = PROCEDURE(HMODULE,
                                      ARRAY OF UCHAR,
                                      LONG_PTR) : BOOL [EXPORT];

    ENUMRESNAMEPROCA      = PROCEDURE(HMODULE,
                                      ARRAY OF ACHAR,
                                      ARRAY OF ACHAR,
                                      LONG_PTR) : BOOL [EXPORT];
    ENUMRESNAMEPROCW      = PROCEDURE(HMODULE,
                                      ARRAY OF UCHAR,
                                      ARRAY OF UCHAR,
                                      LONG_PTR) : BOOL [EXPORT];

    ENUMRESLANGPROCA      = PROCEDURE(HMODULE,
                                      ARRAY OF ACHAR,
                                      ARRAY OF ACHAR,
                                      WORD,
                                      LONG_PTR) : BOOL [EXPORT];
    ENUMRESLANGPROCW      = PROCEDURE(HMODULE,
                                      ARRAY OF UCHAR,
                                      ARRAY OF UCHAR,
                                      WORD,
                                      LONG_PTR) : BOOL [EXPORT];

%IF UNICODE %THEN
    ENUMRESTYPEPROC     = ENUMRESTYPEPROCW;
    ENUMRESNAMEPROC     = ENUMRESNAMEPROCW;
    ENUMRESLANGPROC     = ENUMRESLANGPROCW;
%ELSE
    ENUMRESTYPEPROC     = ENUMRESTYPEPROCA;
    ENUMRESNAMEPROC     = ENUMRESNAMEPROCA;
    ENUMRESLANGPROC     = ENUMRESLANGPROCA;
%END

PROCEDURE EnumResourceTypesA(hModule : HINSTANCE;
                             lpEnumFunc : ENUMRESTYPEPROCA;
                             lParam : LONG_PTR) : BOOL;

PROCEDURE EnumResourceTypesW(hModule : HINSTANCE;
                             lpEnumFunc : ENUMRESTYPEPROCW;
                             lParam : LONG_PTR) : BOOL;

%IF UNICODE %THEN
PROCEDURE EnumResourceTypes = EnumResourceTypesW;
%ELSE
PROCEDURE EnumResourceTypes = EnumResourceTypesA;
%END

PROCEDURE EnumResourceNamesA(hModule : HINSTANCE;
                             lpType : ARRAY OF ACHAR;
                             lpEnumFunc : ENUMRESNAMEPROCA;
                             lParam : LONG_PTR) : BOOL;

PROCEDURE EnumResourceNamesW(hModule : HINSTANCE;
                             lpType : ARRAY OF UCHAR;
                             lpEnumFunc : ENUMRESNAMEPROCW;
                             lParam : LONG_PTR) : BOOL;

%IF UNICODE %THEN
PROCEDURE EnumResourceNames = EnumResourceNamesW;
%ELSE
PROCEDURE EnumResourceNames = EnumResourceNamesA;
%END

PROCEDURE EnumResourceLanguagesA(hModule : HINSTANCE;
                                 lpType : ARRAY OF ACHAR;
                                 lpName : ARRAY OF ACHAR;
                                 lpEnumFunc : ENUMRESLANGPROCA;
                                 lParam : LONG_PTR) : BOOL;

PROCEDURE EnumResourceLanguagesW(hModule : HINSTANCE;
                                 lpType : ARRAY OF UCHAR;
                                 lpName : ARRAY OF UCHAR;
                                 lpEnumFunc : ENUMRESLANGPROCW;
                                 lParam : LONG_PTR) : BOOL;

%IF UNICODE %THEN
PROCEDURE EnumResourceLanguages = EnumResourceLanguagesW;
%ELSE
PROCEDURE EnumResourceLanguages = EnumResourceLanguagesA;
%END

PROCEDURE BeginUpdateResourceA(pFileName : ARRAY OF ACHAR;
                               bDeleteExistingResources : BOOL) : HANDLE;

PROCEDURE BeginUpdateResourceW(pFileName : ARRAY OF UCHAR;
                               bDeleteExistingResources : BOOL) : HANDLE;

%IF UNICODE %THEN
PROCEDURE BeginUpdateResource = BeginUpdateResourceW;
%ELSE
PROCEDURE BeginUpdateResource = BeginUpdateResourceA;
%END

PROCEDURE UpdateResourceA(hUpdate : HANDLE;
                          lpType : ARRAY OF ACHAR;
                          lpName : ARRAY OF ACHAR;
                          wLanguage : WORD;
                          lpData : LPVOID;
                          cbData : DWORD) : BOOL;

PROCEDURE UpdateResourceW(hUpdate : HANDLE;
                          lpType : ARRAY OF UCHAR;
                          lpName : ARRAY OF UCHAR;
                          wLanguage : WORD;
                          lpData : LPVOID;
                          cbData : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE UpdateResource = UpdateResourceW;
%ELSE
PROCEDURE UpdateResource = UpdateResourceA;
%END

PROCEDURE EndUpdateResourceA(hUpdate : HANDLE;
                             fDiscard : BOOL) : BOOL;

PROCEDURE EndUpdateResourceW(hUpdate : HANDLE;
                             fDiscard : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE EndUpdateResource = EndUpdateResourceW;
%ELSE
PROCEDURE EndUpdateResource = EndUpdateResourceA;
%END

PROCEDURE GlobalAddAtomA(lpString : ARRAY OF ACHAR) : ATOM;

PROCEDURE GlobalAddAtomW(lpString : ARRAY OF UCHAR) : ATOM;

%IF UNICODE %THEN
PROCEDURE GlobalAddAtom = GlobalAddAtomW;
%ELSE
PROCEDURE GlobalAddAtom = GlobalAddAtomA;
%END

PROCEDURE GlobalFindAtomA(lpString : ARRAY OF ACHAR) : ATOM;

PROCEDURE GlobalFindAtomW(lpString : ARRAY OF UCHAR) : ATOM;

%IF UNICODE %THEN
PROCEDURE GlobalFindAtom = GlobalFindAtomW;
%ELSE
PROCEDURE GlobalFindAtom = GlobalFindAtomA;
%END

PROCEDURE GlobalGetAtomNameA(nAtom : ATOM;
                             VAR lpBuffer : ARRAY OF ACHAR;
                             nSize : INTEGER) : UINT;

PROCEDURE GlobalGetAtomNameW(nAtom : ATOM;
                             VAR lpBuffer : ARRAY OF UCHAR;
                             nSize : INTEGER) : UINT;

%IF UNICODE %THEN
PROCEDURE GlobalGetAtomName = GlobalGetAtomNameW;
%ELSE
PROCEDURE GlobalGetAtomName = GlobalGetAtomNameA;
%END

PROCEDURE AddAtomA(lpString : ARRAY OF ACHAR) : ATOM;

PROCEDURE AddAtomW(lpString : ARRAY OF UCHAR) : ATOM;

%IF UNICODE %THEN
PROCEDURE AddAtom = AddAtomW;
%ELSE
PROCEDURE AddAtom = AddAtomA;
%END

PROCEDURE FindAtomA(lpString : ARRAY OF ACHAR) : ATOM;

PROCEDURE FindAtomW(lpString : ARRAY OF UCHAR) : ATOM;

%IF UNICODE %THEN
PROCEDURE FindAtom = FindAtomW;
%ELSE
PROCEDURE FindAtom = FindAtomA;
%END

PROCEDURE GetAtomNameA(nAtom : ATOM;
                       VAR lpBuffer : ARRAY OF ACHAR;
                       nSize : INTEGER) : UINT;

PROCEDURE GetAtomNameW(nAtom : ATOM;
                       VAR lpBuffer : ARRAY OF UCHAR;
                       nSize : INTEGER) : UINT;

%IF UNICODE %THEN
PROCEDURE GetAtomName = GetAtomNameW;
%ELSE
PROCEDURE GetAtomName = GetAtomNameA;
%END

PROCEDURE GetProfileIntA(lpAppName : ARRAY OF ACHAR;
                         lpKeyName : ARRAY OF ACHAR;
                         nDefault : WINT) : UINT;

PROCEDURE GetProfileIntW(lpAppName : ARRAY OF UCHAR;
                         lpKeyName : ARRAY OF UCHAR;
                         nDefault : WINT) : UINT;

%IF UNICODE %THEN
PROCEDURE GetProfileInt = GetProfileIntW;
%ELSE
PROCEDURE GetProfileInt = GetProfileIntA;
%END

PROCEDURE GetProfileStringA(lpAppName : ARRAY OF ACHAR;
                            lpKeyName : ARRAY OF ACHAR;
                            lpDefault : ARRAY OF ACHAR;
                            VAR lpReturnedString : ARRAY OF ACHAR;
                            nSize : DWORD) : DWORD;

PROCEDURE GetProfileStringW(lpAppName : ARRAY OF UCHAR;
                            lpKeyName : ARRAY OF UCHAR;
                            lpDefault : ARRAY OF UCHAR;
                            VAR lpReturnedString : ARRAY OF UCHAR;
                            nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetProfileString = GetProfileStringW;
%ELSE
PROCEDURE GetProfileString = GetProfileStringA;
%END

PROCEDURE WriteProfileStringA(lpAppName : ARRAY OF ACHAR;
                              lpKeyName : ARRAY OF ACHAR;
                              lpString : ARRAY OF ACHAR) : BOOL;

PROCEDURE WriteProfileStringW(lpAppName : ARRAY OF UCHAR;
                              lpKeyName : ARRAY OF UCHAR;
                              lpString : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE WriteProfileString = WriteProfileStringW;
%ELSE
PROCEDURE WriteProfileString = WriteProfileStringA;
%END

PROCEDURE GetProfileSectionA(lpAppName : ARRAY OF ACHAR;
                             VAR lpReturnedString : ARRAY OF ACHAR;
                             nSize : DWORD) : DWORD;

PROCEDURE GetProfileSectionW(lpAppName : ARRAY OF UCHAR;
                             VAR lpReturnedString : ARRAY OF UCHAR;
                             nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetProfileSection = GetProfileSectionW;
%ELSE
PROCEDURE GetProfileSection = GetProfileSectionA;
%END

PROCEDURE WriteProfileSectionA(lpAppName : ARRAY OF ACHAR;
                               lpString : ARRAY OF ACHAR) : BOOL;

PROCEDURE WriteProfileSectionW(lpAppName : ARRAY OF UCHAR;
                               lpString : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE WriteProfileSection = WriteProfileSectionW;
%ELSE
PROCEDURE WriteProfileSection = WriteProfileSectionA;
%END

PROCEDURE GetPrivateProfileIntA(lpAppName : ARRAY OF ACHAR;
                                lpKeyName : ARRAY OF ACHAR;
                                nDefault : WINT;
                                lpFileName : ARRAY OF ACHAR) : UINT;

PROCEDURE GetPrivateProfileIntW(lpAppName : ARRAY OF UCHAR;
                                lpKeyName : ARRAY OF UCHAR;
                                nDefault : WINT;
                                lpFileName : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileInt = GetPrivateProfileIntW;
%ELSE
PROCEDURE GetPrivateProfileInt = GetPrivateProfileIntA;
%END

PROCEDURE GetPrivateProfileStringA(lpAppName : ARRAY OF ACHAR;
                                   lpKeyName : ARRAY OF ACHAR;
                                   lpDefault : ARRAY OF ACHAR;
                                   VAR lpReturnedString : ARRAY OF ACHAR;
                                   nSize : DWORD;
                                   lpFileName : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetPrivateProfileStringW(lpAppName : ARRAY OF UCHAR;
                                   lpKeyName : ARRAY OF UCHAR;
                                   lpDefault : ARRAY OF UCHAR;
                                   VAR lpReturnedString : ARRAY OF UCHAR;
                                   nSize : DWORD;
                                   lpFileName : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileString = GetPrivateProfileStringW;
%ELSE
PROCEDURE GetPrivateProfileString = GetPrivateProfileStringA;
%END

PROCEDURE WritePrivateProfileStringA(lpAppName : ARRAY OF ACHAR;
                                     lpKeyName : ARRAY OF ACHAR;
                                     lpString : ARRAY OF ACHAR;
                                     lpFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE WritePrivateProfileStringW(lpAppName : ARRAY OF UCHAR;
                                     lpKeyName : ARRAY OF UCHAR;
                                     lpString : ARRAY OF UCHAR;
                                     lpFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE WritePrivateProfileString = WritePrivateProfileStringW;
%ELSE
PROCEDURE WritePrivateProfileString = WritePrivateProfileStringA;
%END


PROCEDURE GetPrivateProfileSectionNamesA(
                                    VAR lpszReturnBuffer : ARRAY OF ACHAR;
                                    nSize : DWORD;
                                    lpFileName : ARRAY OF ACHAR
                                    ) : DWORD;

PROCEDURE GetPrivateProfileSectionNamesW(
                                    VAR lpszReturnBuffer : ARRAY OF UCHAR;
                                    nSize : DWORD;
                                    lpFileName : ARRAY OF UCHAR
                                    ) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesW;
%ELSE
PROCEDURE GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesA;
%END

PROCEDURE GetPrivateProfileStructA(
    lpszSection : ARRAY OF ACHAR;
    lpszKey : ARRAY OF ACHAR;
    lpStruct : LPVOID;
    uSizeStruct : UINT;
    szFile : ARRAY OF ACHAR
    ) : BOOL;

PROCEDURE GetPrivateProfileStructW(
    lpszSection : ARRAY OF UCHAR;
    lpszKey : ARRAY OF UCHAR;
    lpStruct : LPVOID;
    uSizeStruct : UINT;
    szFile : ARRAY OF UCHAR
    ) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileStruct = GetPrivateProfileStructW;
%ELSE
PROCEDURE GetPrivateProfileStruct = GetPrivateProfileStructA;
%END

PROCEDURE WritePrivateProfileStructA(
    lpszSection : ARRAY OF ACHAR;
    lpszKey : ARRAY OF ACHAR;
    lpStruct : LPVOID;
    uSizeStruct : UINT;
    szFile : ARRAY OF ACHAR
    ) : BOOL;

PROCEDURE WritePrivateProfileStructW(
    lpszSection : ARRAY OF UCHAR;
    lpszKey : ARRAY OF UCHAR;
    lpStruct : LPVOID;
    uSizeStruct : UINT;
    szFile : ARRAY OF UCHAR
    ) : BOOL;

%IF UNICODE %THEN
PROCEDURE WritePrivateProfileStruct = WritePrivateProfileStructW;
%ELSE
PROCEDURE WritePrivateProfileStruct = WritePrivateProfileStructA;
%END


PROCEDURE GetPrivateProfileSectionA(lpAppName : ARRAY OF ACHAR;
                                    VAR lpReturnedString : ARRAY OF ACHAR;
                                    nSize : DWORD;
                                    lpFileName : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetPrivateProfileSectionW(lpAppName : ARRAY OF UCHAR;
                                    VAR lpReturnedString : ARRAY OF UCHAR;
                                    nSize : DWORD;
                                    lpFileName : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileSection = GetPrivateProfileSectionW;
%ELSE
PROCEDURE GetPrivateProfileSection = GetPrivateProfileSectionA;
%END

PROCEDURE WritePrivateProfileSectionA(lpAppName : ARRAY OF ACHAR;
                                      lpString : ARRAY OF ACHAR;
                                      lpFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE WritePrivateProfileSectionW(lpAppName : ARRAY OF UCHAR;
                                      lpString : ARRAY OF UCHAR;
                                      lpFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE WritePrivateProfileSection = WritePrivateProfileSectionW;
%ELSE
PROCEDURE WritePrivateProfileSection = WritePrivateProfileSectionA;
%END

PROCEDURE GetDriveTypeA(lpRootPathName : ARRAY OF ACHAR) : UINT;

PROCEDURE GetDriveTypeW(lpRootPathName : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE GetDriveType = GetDriveTypeW;
%ELSE
PROCEDURE GetDriveType = GetDriveTypeA;
%END

PROCEDURE GetSystemDirectoryA(VAR lpBuffer : ARRAY OF ACHAR;
                              uSize : UINT) : UINT;

PROCEDURE GetSystemDirectoryW(VAR lpBuffer : ARRAY OF UCHAR;
                              uSize : UINT) : UINT;

%IF UNICODE %THEN
PROCEDURE GetSystemDirectory = GetSystemDirectoryW;
%ELSE
PROCEDURE GetSystemDirectory = GetSystemDirectoryA;
%END

PROCEDURE GetTempPathA(nBufferLength : DWORD;
                       VAR lpBuffer : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetTempPathW(nBufferLength : DWORD;
                       VAR lpBuffer : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetTempPath = GetTempPathW;
%ELSE
PROCEDURE GetTempPath = GetTempPathA;
%END

PROCEDURE GetTempFileNameA(lpPathName : ARRAY OF ACHAR;
                           lpPrefixString : ARRAY OF ACHAR;
                           uUnique : UINT;
                           VAR lpTempFileName : ARRAY OF ACHAR) : UINT;

PROCEDURE GetTempFileNameW(lpPathName : ARRAY OF UCHAR;
                           lpPrefixString : ARRAY OF UCHAR;
                           uUnique : UINT;
                           VAR lpTempFileName : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE GetTempFileName = GetTempFileNameW;
%ELSE
PROCEDURE GetTempFileName = GetTempFileNameA;
%END


PROCEDURE GetWindowsDirectoryA(VAR lpBuffer : ARRAY OF ACHAR;
                               uSize : UINT) : UINT;

PROCEDURE GetWindowsDirectoryW(VAR lpBuffer : ARRAY OF UCHAR;
                               uSize : UINT) : UINT;

%IF UNICODE %THEN
PROCEDURE GetWindowsDirectory = GetWindowsDirectoryW;
%ELSE
PROCEDURE GetWindowsDirectory = GetWindowsDirectoryA;
%END

PROCEDURE SetCurrentDirectoryA(lpPathName : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetCurrentDirectoryW(lpPathName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetCurrentDirectory = SetCurrentDirectoryW;
%ELSE
PROCEDURE SetCurrentDirectory = SetCurrentDirectoryA;
%END

PROCEDURE GetCurrentDirectoryA(nBufferLength : DWORD;
                               VAR lpBuffer : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetCurrentDirectoryW(nBufferLength : DWORD;
                               VAR lpBuffer : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetCurrentDirectory = GetCurrentDirectoryW;
%ELSE
PROCEDURE GetCurrentDirectory = GetCurrentDirectoryA;
%END

PROCEDURE GetDiskFreeSpaceA(lpRootPathName : ARRAY OF ACHAR;
                            VAR lpSectorsPerCluster : DWORD;
                            VAR lpBytesPerSector : DWORD;
                            VAR lpNumberOfFreeClusters : DWORD;
                            VAR TotalNumberOfClusters : DWORD) : BOOL;

PROCEDURE GetDiskFreeSpaceW(lpRootPathName : ARRAY OF UCHAR;
                            VAR lpSectorsPerCluster : DWORD;
                            VAR lpBytesPerSector : DWORD;
                            VAR lpNumberOfFreeClusters : DWORD;
                            VAR lpTotalNumberOfClusters : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetDiskFreeSpace = GetDiskFreeSpaceW;
%ELSE
PROCEDURE GetDiskFreeSpace = GetDiskFreeSpaceA;
%END

PROCEDURE GetDiskFreeSpaceExA(
                    lpDirectoryName : ARRAY OF ACHAR;
                    VAR lpFreeBytesAvailableToCaller : ULARGE_INTEGER;
                    VAR lpTotalNumberOfBytes : ULARGE_INTEGER;
                    VAR lpTotalNumberOfFreeBytes : ULARGE_INTEGER) : BOOL;

PROCEDURE GetDiskFreeSpaceExW(
                    lpDirectoryName : ARRAY OF WCHAR;
                    VAR lpFreeBytesAvailableToCaller : ULARGE_INTEGER;
                    VAR lpTotalNumberOfBytes : ULARGE_INTEGER;
                    VAR lpTotalNumberOfFreeBytes : ULARGE_INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetDiskFreeSpaceEx = GetDiskFreeSpaceExW;
%ELSE
PROCEDURE GetDiskFreeSpaceEx = GetDiskFreeSpaceExA;
%END

PROCEDURE CreateDirectoryA(lpPathName : ARRAY OF ACHAR;
                           lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

PROCEDURE CreateDirectoryW(lpPathName : ARRAY OF UCHAR;
                           lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

%IF UNICODE %THEN
PROCEDURE CreateDirectory = CreateDirectoryW;
%ELSE
PROCEDURE CreateDirectory = CreateDirectoryA;
%END

PROCEDURE CreateDirectoryExA(lpTemplateDirectory : ARRAY OF ACHAR;
                             lpNewDirectory : ARRAY OF ACHAR;
                             lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

PROCEDURE CreateDirectoryExW(lpTemplateDirectory : ARRAY OF UCHAR;
                             lpNewDirectory : ARRAY OF UCHAR;
                             lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

%IF UNICODE %THEN
PROCEDURE CreateDirectoryEx = CreateDirectoryExW;
%ELSE
PROCEDURE CreateDirectoryEx = CreateDirectoryExA;
%END

PROCEDURE RemoveDirectoryA(lpPathName : ARRAY OF ACHAR) : BOOL;

PROCEDURE RemoveDirectoryW(lpPathName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE RemoveDirectory = RemoveDirectoryW;
%ELSE
PROCEDURE RemoveDirectory = RemoveDirectoryA;
%END

PROCEDURE GetFullPathNameA(lpFileName : ARRAY OF ACHAR;
                           nBufferLength : DWORD;
                           VAR lpBuffer : ARRAY OF ACHAR;
                           VAR lpFilePart : LPSTR) : DWORD;

PROCEDURE GetFullPathNameW(lpFileName : ARRAY OF UCHAR;
                           nBufferLength : DWORD;
                           VAR lpBuffer : ARRAY OF UCHAR;
                           VAR lpFilePart : LPWSTR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetFullPathName = GetFullPathNameW;
%ELSE
PROCEDURE GetFullPathName = GetFullPathNameA;
%END

CONST
    DDD_RAW_TARGET_PATH  = 000000001h;
    DDD_REMOVE_DEFINITION= 000000002h;
    DDD_EXACT_MATCH_ON_REMOVE= 000000004h;
    DDD_NO_BROADCAST_SYSTEM     = 00000008h;

PROCEDURE DefineDosDeviceA(dwFlags : DWORD;
                           lpDeviceName : ARRAY OF ACHAR;
                           lpTargetPath : ARRAY OF ACHAR) : BOOL;

PROCEDURE DefineDosDeviceW(dwFlags : DWORD;
                           lpDeviceName : ARRAY OF UCHAR;
                           lpTargetPath : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE DefineDosDevice = DefineDosDeviceW;
%ELSE
PROCEDURE DefineDosDevice = DefineDosDeviceA;
%END

PROCEDURE QueryDosDeviceA(lpDeviceName : ARRAY OF ACHAR;
                          VAR lpTargetPath : ARRAY OF ACHAR;
                          ucchMax : DWORD) : DWORD;

PROCEDURE QueryDosDeviceW(lpDeviceName : ARRAY OF UCHAR;
                          VAR lpTargetPath : ARRAY OF UCHAR;
                          ucchMax : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE QueryDosDevice = QueryDosDeviceW;
%ELSE
PROCEDURE QueryDosDevice = QueryDosDeviceA;
%END

PROCEDURE CreateFileA(lpFileName : ARRAY OF ACHAR;
                      dwDesiredAccess : DWORD;
                      dwShareMode : DWORD;
                      lpSecurityAttributes : SECURITY_ATTRIBUTES;
                      dwCreationDisposition : DWORD;
                      dwFlagsAndAttributes : DWORD;
                      hTemplateFile : HANDLE) : HANDLE;

PROCEDURE CreateFileW(lpFileName : ARRAY OF UCHAR;
                      dwDesiredAccess : DWORD;
                      dwShareMode : DWORD;
                      lpSecurityAttributes : SECURITY_ATTRIBUTES;
                      dwCreationDisposition : DWORD;
                      dwFlagsAndAttributes : DWORD;
                      hTemplateFile : HANDLE) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateFile = CreateFileW;
%ELSE
PROCEDURE CreateFile = CreateFileA;
%END

PROCEDURE SetFileAttributesA(lpFileName : ARRAY OF ACHAR;
                             dwFileAttributes : DWORD) : BOOL;

PROCEDURE SetFileAttributesW(lpFileName : ARRAY OF UCHAR;
                             dwFileAttributes : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetFileAttributes = SetFileAttributesW;
%ELSE
PROCEDURE SetFileAttributes = SetFileAttributesA;
%END

PROCEDURE GetFileAttributesA(lpFileName : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetFileAttributesW(lpFileName : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetFileAttributes = GetFileAttributesW;
%ELSE
PROCEDURE GetFileAttributes = GetFileAttributesA;
%END

TYPE
    GET_FILEEX_INFO_LEVELS = (GetFileExInfoStandard,
                              GetFileExMaxInfoLevel) BIG;

PROCEDURE GetFileAttributesExA(lpFileName : ARRAY OF ACHAR;
                               fInfoLevelId : GET_FILEEX_INFO_LEVELS;
                               VAR lpFileInformation : ARRAY OF LOC) : BOOL;

PROCEDURE GetFileAttributesExW(lpFileName : ARRAY OF WCHAR;
                               fInfoLevelId : GET_FILEEX_INFO_LEVELS;
                               VAR lpFileInformation : ARRAY OF LOC) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetFileAttributesEx = GetFileAttributesExW;
%ELSE
PROCEDURE GetFileAttributesEx = GetFileAttributesExA;
%END

PROCEDURE GetCompressedFileSizeA(lpFileName : ARRAY OF ACHAR;
                                 VAR lpFileSizeHigh : DWORD) : DWORD;

PROCEDURE GetCompressedFileSizeW(lpFileName : ARRAY OF UCHAR;
                                 VAR lpFileSizeHigh : DWORD) : DWORD;
%IF UNICODE %THEN
PROCEDURE GetCompressedFileSize = GetCompressedFileSizeW;
%ELSE
PROCEDURE GetCompressedFileSize = GetCompressedFileSizeA;
%END

PROCEDURE DeleteFileA(lpFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE DeleteFileW(lpFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE DeleteFile = DeleteFileW;
%ELSE
PROCEDURE DeleteFile = DeleteFileA;
%END

TYPE
    FINDEX_INFO_LEVELS = (
                          FindExInfoStandard,
                          FindExInfoMaxInfoLevel) BIG;

    FINDEX_SEARCH_OPS = (FindExSearchNameMatch,
                         FindExSearchLimitToDirectories,
                         FindExSearchLimitToDevices,
                         FindExSearchMaxSearchOp) BIG;

CONST
    FIND_FIRST_EX_CASE_SENSITIVE   = 00000001h;

(* NT only *)
PROCEDURE FindFirstFileExA(lpFileName : ARRAY OF ACHAR;
                           fInfoLevelId : FINDEX_INFO_LEVELS;
                           VAR lpFindFileData : ARRAY OF LOC;
                           fSearchOp : FINDEX_SEARCH_OPS;
                           lpSearchFilter : LPVOID;
                           dwAdditionalFlags : DWORD) : HANDLE;

(* NT only *)
PROCEDURE FindFirstFileExW(lpFileName : ARRAY OF WCHAR;
                           fInfoLevelId : FINDEX_INFO_LEVELS;
                           VAR lpFindFileData : ARRAY OF LOC;
                           fSearchOp : FINDEX_SEARCH_OPS;
                           lpSearchFilter : LPVOID;
                           dwAdditionalFlags : DWORD) : HANDLE;

%IF UNICODE %THEN
(* NT only *)
PROCEDURE FindFirstFileEx = FindFirstFileExW;
%ELSE
(* NT only *)
PROCEDURE FindFirstFileEx = FindFirstFileExA;
%END

PROCEDURE FindFirstFileA(lpFileName : ARRAY OF ACHAR;
                         VAR lpFindFileData : WIN32_FIND_DATAA) : HANDLE;

PROCEDURE FindFirstFileW(lpFileName : ARRAY OF UCHAR;
                         VAR lpFindFileData : WIN32_FIND_DATAW) : HANDLE;

%IF UNICODE %THEN
PROCEDURE FindFirstFile = FindFirstFileW;
%ELSE
PROCEDURE FindFirstFile = FindFirstFileA;
%END

PROCEDURE FindNextFileA(hFindFile : HANDLE;
                        VAR lpFindFileData : WIN32_FIND_DATAA) : BOOL;

PROCEDURE FindNextFileW(hFindFile : HANDLE;
                        VAR lpFindFileData : WIN32_FIND_DATAW) : BOOL;

%IF UNICODE %THEN
PROCEDURE FindNextFile = FindNextFileW;
%ELSE
PROCEDURE FindNextFile = FindNextFileA;
%END

PROCEDURE SearchPathA(lpPath : ARRAY OF ACHAR;
                      lpFileName : ARRAY OF ACHAR;
                      lpExtension : ARRAY OF ACHAR;
                      nBufferLength : DWORD;
                      VAR lpBuffer : ARRAY OF ACHAR;
                      VAR lpFilePart : LPSTR) : DWORD;

PROCEDURE SearchPathW(lpPath : ARRAY OF UCHAR;
                      lpFileName : ARRAY OF UCHAR;
                      lpExtension : ARRAY OF UCHAR;
                      nBufferLength : DWORD;
                      VAR lpBuffer : ARRAY OF UCHAR;
                      VAR lpFilePart : LPWSTR) : DWORD;

%IF UNICODE %THEN
PROCEDURE SearchPath = SearchPathW;
%ELSE
PROCEDURE SearchPath = SearchPathA;
%END

PROCEDURE CopyFileA(lpExistingFileName : ARRAY OF ACHAR;
                    lpNewFileName : ARRAY OF ACHAR;
                    bFailIfExists : BOOL) : BOOL;

PROCEDURE CopyFileW(lpExistingFileName : ARRAY OF UCHAR;
                    lpNewFileName : ARRAY OF UCHAR;
                    bFailIfExists : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE CopyFile = CopyFileW;
%ELSE
PROCEDURE CopyFile = CopyFileA;
%END

TYPE
    LPPROGRESS_ROUTINE  = PROCEDURE(
    LARGE_INTEGER(*TotalFileSize*),
    LARGE_INTEGER(*TotalBytesTransferred*),
    LARGE_INTEGER(*StreamSize*),
    LARGE_INTEGER(*StreamBytesTransferred*),
    DWORD(*dwStreamNumber*),
    DWORD(*dwCallbackReason*),
    HANDLE(*hSourceFile*),
    HANDLE(*hDestinationFile*),
    LPVOID(*lpData*)
    ) : DWORD [EXPORT];

(* NT only *)
PROCEDURE CopyFileExA(lpExistingFileName : ARRAY OF ACHAR;
                      lpNewFileName : ARRAY OF ACHAR;
                      lpProgressRoutine : LPPROGRESS_ROUTINE;
                      lpData : LPVOID;
                      VAR pbCancel : BOOL;
                      dwCopyFlags : DWORD) : BOOL;

(* NT only *)
PROCEDURE CopyFileExW(lpExistingFileName : ARRAY OF WCHAR;
                      lpNewFileName : ARRAY OF WCHAR;
                      lpProgressRoutine : LPPROGRESS_ROUTINE;
                      lpData : LPVOID;
                      VAR pbCancel : BOOL;
                      dwCopyFlags : DWORD) : BOOL;

%IF UNICODE %THEN
(* NT only *)
PROCEDURE CopyFileEx = CopyFileExW;
%ELSE
(* NT only *)
PROCEDURE CopyFileEx = CopyFileExA;
%END

PROCEDURE MoveFileA(lpExistingFileName : ARRAY OF ACHAR;
                    lpNewFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE MoveFileW(lpExistingFileName : ARRAY OF UCHAR;
                    lpNewFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE MoveFile = MoveFileW;
%ELSE
PROCEDURE MoveFile = MoveFileA;
%END

PROCEDURE MoveFileExA(lpExistingFileName : ARRAY OF ACHAR;
                      lpNewFileName : ARRAY OF ACHAR;
                      dwFlags : DWORD) : BOOL;

PROCEDURE MoveFileExW(lpExistingFileName : ARRAY OF UCHAR;
                      lpNewFileName : ARRAY OF UCHAR;
                      dwFlags : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE MoveFileEx = MoveFileExW;
%ELSE
PROCEDURE MoveFileEx = MoveFileExA;
%END

(* NT only *)
PROCEDURE MoveFileWithProgressA(lpExistingFileName : ARRAY OF ACHAR;
                                lpNewFileName : ARRAY OF ACHAR;
                                lpProgressRoutine : LPPROGRESS_ROUTINE;
                                lpData : LPVOID;
                                dwFlags : DWORD) : BOOL;

(* NT only *)
PROCEDURE MoveFileWithProgressW(lpExistingFileName : ARRAY OF WCHAR;
                                lpNewFileName : ARRAY OF WCHAR;
                                lpProgressRoutine : LPPROGRESS_ROUTINE;
                                lpData : LPVOID;
                                dwFlags : DWORD) : BOOL;
%IF UNICODE %THEN
(* NT only *)
PROCEDURE MoveFileWithProgress = MoveFileWithProgressW;
%ELSE
(* NT only *)
PROCEDURE MoveFileWithProgress = MoveFileWithProgressA;
%END

CONST
    MOVEFILE_REPLACE_EXISTING= 000000001h;
    MOVEFILE_COPY_ALLOWED= 000000002h;
    MOVEFILE_DELAY_UNTIL_REBOOT= 000000004h;
    MOVEFILE_WRITE_THROUGH          = 00000008h;
    MOVEFILE_CREATE_HARDLINK        = 00000010h;(* NT only *)
    MOVEFILE_FAIL_IF_NOT_TRACKABLE  = 00000020h;(* NT only *)

(*
 API call to create hard links.
*)

(* NT only *)
PROCEDURE CreateHardLinkA(lpFileName : ARRAY OF ACHAR;
                          lpExistingFileName : ARRAY OF ACHAR;
                          lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

(* NT only *)
PROCEDURE CreateHardLinkW(lpFileName : ARRAY OF WCHAR;
                          lpExistingFileName : ARRAY OF WCHAR;
                          lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;
%IF UNICODE %THEN
(* NT only *)
PROCEDURE CreateHardLink = CreateHardLinkW;
%ELSE
(* NT only *)
PROCEDURE CreateHardLink = CreateHardLinkA;
%END

PROCEDURE CreateNamedPipeA(lpName : ARRAY OF ACHAR;
                           dwOpenMode : DWORD;
                           dwPipeMode : DWORD;
                           nMaxInstances : DWORD;
                           nOutBufferSize : DWORD;
                           nInBufferSize : DWORD;
                           nDefaultTimeOut : DWORD;
                           lpSecurityAttributes : SECURITY_ATTRIBUTES) : HANDLE;

PROCEDURE CreateNamedPipeW(lpName : ARRAY OF UCHAR;
                           dwOpenMode : DWORD;
                           dwPipeMode : DWORD;
                           nMaxInstances : DWORD;
                           nOutBufferSize : DWORD;
                           nInBufferSize : DWORD;
                           nDefaultTimeOut : DWORD;
                           lpSecurityAttributes : SECURITY_ATTRIBUTES) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateNamedPipe = CreateNamedPipeW;
%ELSE
PROCEDURE CreateNamedPipe = CreateNamedPipeA;
%END

PROCEDURE GetNamedPipeHandleStateA(hNamedPipe : HANDLE;
                                   VAR lpState : DWORD;
                                   VAR lpCurInstances : DWORD;
                                   VAR lpMaxCollectionCount : DWORD;
                                   VAR LpCollectDataTimeout : DWORD;
                                   VAR lpUserName : ARRAY OF ACHAR;
                                   nMaxUserNameSize : DWORD) : BOOL;

PROCEDURE GetNamedPipeHandleStateW(hNamedPipe : HANDLE;
                                   VAR lpState : DWORD;
                                   VAR lpCurInstances : DWORD;
                                   VAR lpMaxCollectionCount : DWORD;
                                   VAR lpCollectDataTimeout : DWORD;
                                   VAR lpUserName : ARRAY OF UCHAR;
                                   nMaxUserNameSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetNamedPipeHandleState = GetNamedPipeHandleStateW;
%ELSE
PROCEDURE GetNamedPipeHandleState = GetNamedPipeHandleStateA;
%END

PROCEDURE CallNamedPipeA(lpNamedPipeName : ARRAY OF ACHAR;
                         lpInBuffer : LPVOID;
                         nInBufferSize : DWORD;
                         lpOutBuffer : LPVOID;
                         nOutBufferSize : DWORD;
                         VAR lpBytesRead : DWORD;
                         nTimeOut : DWORD) : BOOL;

PROCEDURE CallNamedPipeW(lpNamedPipeName : ARRAY OF UCHAR;
                         lpInBuffer : LPVOID;
                         nInBufferSize : DWORD;
                         lpOutBuffer : LPVOID;
                         nOutBufferSize : DWORD;
                         VAR lpBytesRead : DWORD;
                         nTimeOut : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE CallNamedPipe = CallNamedPipeW;
%ELSE
PROCEDURE CallNamedPipe = CallNamedPipeA;
%END

PROCEDURE WaitNamedPipeA(lpNamedPipeName : ARRAY OF ACHAR;
                         nTimeOut : DWORD) : BOOL;

PROCEDURE WaitNamedPipeW(lpNamedPipeName : ARRAY OF UCHAR;
                         nTimeOut : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE WaitNamedPipe = WaitNamedPipeW;
%ELSE
PROCEDURE WaitNamedPipe = WaitNamedPipeA;
%END

PROCEDURE SetVolumeLabelA(lpRootPathName : ARRAY OF ACHAR;
                          lpVolumeName : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetVolumeLabelW(lpRootPathName : ARRAY OF UCHAR;
                          lpVolumeName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetVolumeLabel = SetVolumeLabelW;
%ELSE
PROCEDURE SetVolumeLabel = SetVolumeLabelA;
%END

PROCEDURE SetFileApisToOEM();

(*95*)
PROCEDURE SetFileApisToANSI();

(*95*)
PROCEDURE AreFileApisANSI() : BOOL;


PROCEDURE GetVolumeInformationA(lpRootPathName : ARRAY OF ACHAR;
                                VAR lpVolumeNameBuffer : ARRAY OF ACHAR;
                                nVolumeNameSize : DWORD;
                                VAR lpVolumeSerialNumber : DWORD;
                                VAR lpMaximumComponentLength : DWORD;
                                VAR lpFileSystemFlags : DWORD;
                                VAR lpFileSystemNameBuffer : ARRAY OF ACHAR;
                                nFileSystemNameSize : DWORD) : BOOL;

PROCEDURE GetVolumeInformationW(lpRootPathName : ARRAY OF UCHAR;
                                VAR lpVolumeNameBuffer : ARRAY OF UCHAR;
                                nVolumeNameSize : DWORD;
                                VAR lpVolumeSerialNumber : DWORD;
                                VAR lpMaximumComponentLength : DWORD;
                                VAR lpFileSystemFlags : DWORD;
                                VAR lpFileSystemNameBuffer : ARRAY OF UCHAR;
                                nFileSystemNameSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetVolumeInformation = GetVolumeInformationW;
%ELSE
PROCEDURE GetVolumeInformation = GetVolumeInformationA;
%END

PROCEDURE CancelIo(hFile : HANDLE) : BOOL;

PROCEDURE ClearEventLogA(hEventLog : HANDLE;
                         lpBackupFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE ClearEventLogW(hEventLog : HANDLE;
                         lpBackupFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE ClearEventLog = ClearEventLogW;
%ELSE
PROCEDURE ClearEventLog = ClearEventLogA;
%END

PROCEDURE BackupEventLogA(hEventLog : HANDLE;
                          lpBackupFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE BackupEventLogW(hEventLog : HANDLE;
                          lpBackupFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE BackupEventLog = BackupEventLogW;
%ELSE
PROCEDURE BackupEventLog = BackupEventLogA;
%END

PROCEDURE CloseEventLog(hEventLog : HANDLE) : BOOL;

PROCEDURE DeregisterEventSource(hEventLog : HANDLE) : BOOL;

(*95*)
PROCEDURE NotifyChangeEventLog(
                                hEventLog : HANDLE;
                                hEvent : HANDLE
                                ) : BOOL;

PROCEDURE GetNumberOfEventLogRecords(hEventLog : HANDLE;
                                     NumberOfRecords : PDWORD) : BOOL;

PROCEDURE GetOldestEventLogRecord(hEventLog : HANDLE;
                                  OldestRecord : PDWORD) : BOOL;

PROCEDURE OpenEventLogA(lpUNCServerName : ARRAY OF ACHAR;
                        lpSourceName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenEventLogW(lpUNCServerName : ARRAY OF UCHAR;
                        lpSourceName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenEventLog = OpenEventLogW;
%ELSE
PROCEDURE OpenEventLog = OpenEventLogA;
%END

PROCEDURE RegisterEventSourceA(lpUNCServerName : ARRAY OF ACHAR;
                               lpSourceName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE RegisterEventSourceW(lpUNCServerName : ARRAY OF UCHAR;
                               lpSourceName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE RegisterEventSource = RegisterEventSourceW;
%ELSE
PROCEDURE RegisterEventSource = RegisterEventSourceA;
%END

PROCEDURE OpenBackupEventLogA(lpUNCServerName : ARRAY OF ACHAR;
                              lpFileName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenBackupEventLogW(lpUNCServerName : ARRAY OF UCHAR;
                              lpFileName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenBackupEventLog = OpenBackupEventLogW;
%ELSE
PROCEDURE OpenBackupEventLog = OpenBackupEventLogA;
%END

PROCEDURE ReadEventLogA(hEventLog : HANDLE;
                        dwReadFlags : DWORD;
                        dwRecordOffset : DWORD;
                        lpBuffer : LPVOID;
                        nNumberOfBytesToRead : DWORD;
                        VAR pnBytesRead : DWORD;
                        VAR pnMinNumberOfBytesNeeded : DWORD) : BOOL;

PROCEDURE ReadEventLogW(hEventLog : HANDLE;
                        dwReadFlags : DWORD;
                        dwRecordOffset : DWORD;
                        lpBuffer : LPVOID;
                        nNumberOfBytesToRead : DWORD;
                        VAR pnBytesRead : DWORD;
                        VAR pnMinNumberOfBytesNeeded : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE ReadEventLog = ReadEventLogW;
%ELSE
PROCEDURE ReadEventLog = ReadEventLogA;
%END

PROCEDURE ReportEventA(hEventLog : HANDLE;
                       wType : WORD;
                       wCategory : WORD;
                       dwEventID : DWORD;
                       lpUserSid : PSID;
                       wNumStrings : WORD;
                       dwDataSize : DWORD;
                       lpStrings : ARRAY OF LPSTR;
                       lpRawData : LPVOID) : BOOL;

PROCEDURE ReportEventW(hEventLog : HANDLE;
                       wType : WORD;
                       wCategory : WORD;
                       dwEventID : DWORD;
                       lpUserSid : PSID;
                       wNumStrings : WORD;
                       dwDataSize : DWORD;
                       lpStrings : ARRAY OF LPWSTR;
                       lpRawData : LPVOID) : BOOL;

%IF UNICODE %THEN
PROCEDURE ReportEvent = ReportEventW;
%ELSE
PROCEDURE ReportEvent = ReportEventA;
%END

PROCEDURE DuplicateToken(ExistingTokenHandle : HANDLE;
                         ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL;
                         DuplicateTokenHandle : PHANDLE) : BOOL;

PROCEDURE GetKernelObjectSecurity(Handle : HANDLE;
                                  RequestedInformation : SECURITY_INFORMATION;
                                  pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                  nLength : DWORD;
                                  VAR lpnLengthNeeded : DWORD) : BOOL;

PROCEDURE ImpersonateNamedPipeClient(hNamedPipe : HANDLE) : BOOL;

PROCEDURE ImpersonateSelf(ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL) : BOOL;

PROCEDURE RevertToSelf() : BOOL;

PROCEDURE SetThreadToken(VAR Thread : HANDLE; Token : HANDLE) : BOOL;

PROCEDURE AccessCheck(pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                      ClientToken : HANDLE;
                      DesiredAccess : DWORD;
                      GenericMapping : PGENERIC_MAPPING;
                      PrivilegeSet : PPRIVILEGE_SET;
                      VAR PrivilegeSetLength : DWORD;
                      VAR GrantedAccess : DWORD;
                      AccessStatus : LPBOOL) : BOOL;


(*               Object Type list for AccessCheckByType               *)

TYPE
    OBJECT_TYPE_LIST = RECORD
    Level       : WORD;
    Sbz         : WORD;
    ObjectType  : REFGUID;
    END;
    POBJECT_TYPE_LIST = POINTER TO OBJECT_TYPE_LIST;

(*
 DS values for Level
*)
CONST
    ACCESS_OBJECT_GUID       =0;
    ACCESS_PROPERTY_SET_GUID =1;
    ACCESS_PROPERTY_GUID     =2;

    ACCESS_MAX_LEVEL         =4;

(* NT only *)
PROCEDURE AccessCheckByType (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                             PrincipalSelfSid : PSID;
                             ClientToken : HANDLE;
                             DesiredAccess : DWORD;
                             ObjectTypeList : OBJECT_TYPE_LIST;
                             ObjectTypeListLength : DWORD;
                             GenericMapping : GENERIC_MAPPING;
                             PrivilegeSet : PRIVILEGE_SET;
                             VAR PrivilegeSetLength : DWORD;
                             VAR GrantedAccess : DWORD;
                             VAR AccessStatus : BOOL) : BOOL;

(* NT only *)
PROCEDURE AccessCheckByTypeResultList (
                            pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                            PrincipalSelfSid : PSID;
                            ClientToken : HANDLE;
                            DesiredAccess : DWORD;
                            ObjectTypeList: OBJECT_TYPE_LIST;
                            ObjectTypeListLength : DWORD;
                            GenericMapping : GENERIC_MAPPING;
                            PrivilegeSet : PRIVILEGE_SET;
                            VAR PrivilegeSetLength : DWORD;
                            VAR GrantedAccessList : DWORD;
                            VAR AccessStatusList  : DWORD) : BOOL;


PROCEDURE OpenProcessToken(ProcessHandle : HANDLE;
                           DesiredAccess : DWORD;
                           TokenHandle : PHANDLE) : BOOL;

PROCEDURE OpenThreadToken(ThreadHandle : HANDLE;
                          DesiredAccess : DWORD;
                          OpenAsSelf : BOOL;
                          TokenHandle : PHANDLE) : BOOL;

PROCEDURE GetTokenInformation(TokenHandle : HANDLE;
                              TokenInformationClass : TOKEN_INFORMATION_CLASS;
                              TokenInformation : LPVOID;
                              TokenInformationLength : DWORD;
                              ReturnLength : PDWORD) : BOOL;

PROCEDURE SetTokenInformation(TokenHandle : HANDLE;
                              TokenInformationClass : TOKEN_INFORMATION_CLASS;
                              TokenInformation : LPVOID;
                              TokenInformationLength : DWORD) : BOOL;

PROCEDURE AdjustTokenPrivileges(TokenHandle : HANDLE;
                                DisableAllPrivileges : BOOL;
                                NewState : PTOKEN_PRIVILEGES;
                                BufferLength : DWORD;
                                PreviousState : PTOKEN_PRIVILEGES;
                                ReturnLength : PDWORD) : BOOL;

PROCEDURE AdjustTokenGroups(TokenHandle : HANDLE;
                            ResetToDefault : BOOL;
                            NewState : PTOKEN_GROUPS;
                            BufferLength : DWORD;
                            PreviousState : PTOKEN_GROUPS;
                            VAR OUT ReturnLength : DWORD) : BOOL;

PROCEDURE PrivilegeCheck(ClientToken : HANDLE;
                         RequiredPrivileges : PPRIVILEGE_SET;
                         VAR OUT pfResult : BOOL) : BOOL;

PROCEDURE AccessCheckAndAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                    HandleId : LPVOID;
                                    VAR ObjectTypeName : ARRAY OF ACHAR;
                                    VAR ObjectName : ARRAY OF ACHAR;
                                    SecurityDescriptor : PSECURITY_DESCRIPTOR;
                                    DesiredAccess : DWORD;
                                    GenericMapping : PGENERIC_MAPPING;
                                    ObjectCreation : BOOL;
                                    VAR GrantedAccess : DWORD;
                                    VAR OUT AccessStatus : BOOL;
                                    VAR OUT pfGenerateOnClose : BOOL) : BOOL;

PROCEDURE AccessCheckAndAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                    HandleId : LPVOID;
                                    VAR ObjectTypeName : ARRAY OF UCHAR;
                                    VAR ObjectName : ARRAY OF UCHAR;
                                    SecurityDescriptor : PSECURITY_DESCRIPTOR;
                                    DesiredAccess : DWORD;
                                    GenericMapping : PGENERIC_MAPPING;
                                    ObjectCreation : BOOL;
                                    VAR GrantedAccess : DWORD;
                                    VAR OUT AccessStatus : BOOL;
                                    VAR OUT pfGenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE AccessCheckAndAuditAlarm = AccessCheckAndAuditAlarmW;
%ELSE
PROCEDURE AccessCheckAndAuditAlarm = AccessCheckAndAuditAlarmA;
%END

TYPE
    AUDIT_EVENT_TYPE = (AuditEventObjectAccess,
                        AuditEventDirectoryServiceAccess);

CONST AUDIT_ALLOW_NO_PRIVILEGE = 1h;

(*
 DS values for Source and ObjectTypeName
*)
CONST
    ACCESS_DS_SOURCE_A = "DS";
    ACCESS_DS_SOURCE_W = "DS";
    ACCESS_DS_OBJECT_TYPE_NAME_A = "Directory Service Object";
    ACCESS_DS_OBJECT_TYPE_NAME_W = "Directory Service Object";

(* NT only *)
PROCEDURE AccessCheckByTypeAndAuditAlarmA (
    SubsystemName : ARRAY OF ACHAR;
    HandleId : LPVOID;
    ObjectTypeName : ARRAY OF ACHAR;
    ObjectName : ARRAY OF ACHAR;
    SecurityDescriptor : PSECURITY_DESCRIPTOR;
    PrincipalSelfSid : PSID;
    DesiredAccess : DWORD;
    AuditType : AUDIT_EVENT_TYPE;
    Flags : DWORD;
    ObjectTypeList : OBJECT_TYPE_LIST;
    ObjectTypeListLength : DWORD;
    GenericMapping : GENERIC_MAPPING;
    ObjectCreation : BOOL;
    VAR GrantedAccess : DWORD;
    VAR AccessStatus : BOOL;
    VAR pfGenerateOnClose : BOOL) : BOOL;

(* NT only *)
PROCEDURE AccessCheckByTypeAndAuditAlarmW (
    SubsystemName : ARRAY OF WCHAR;
    HandleId : LPVOID;
    ObjectTypeName : ARRAY OF WCHAR;
    ObjectName : ARRAY OF WCHAR;
    SecurityDescriptor : PSECURITY_DESCRIPTOR;
    PrincipalSelfSid : PSID;
    DesiredAccess : DWORD;
    AuditType : AUDIT_EVENT_TYPE;
    Flags : DWORD;
    ObjectTypeList : OBJECT_TYPE_LIST;
    ObjectTypeListLength : DWORD;
    GenericMapping : GENERIC_MAPPING;
    ObjectCreation : BOOL;
    VAR GrantedAccess : DWORD;
    VAR AccessStatus : BOOL;
    VAR pfGenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
(* NT only *)
PROCEDURE AccessCheckByTypeAndAuditAlarm = AccessCheckByTypeAndAuditAlarmW;
%ELSE
(* NT only *)
PROCEDURE AccessCheckByTypeAndAuditAlarm = AccessCheckByTypeAndAuditAlarmA;
%END

(* NT only *)
PROCEDURE AccessCheckByTypeResultListAndAuditAlarmA (
    SubsystemName : ARRAY OF ACHAR;
    HandleId : LPVOID;
    ObjectTypeName : ARRAY OF ACHAR;
    ObjectName : ARRAY OF ACHAR;
    SecurityDescriptor : PSECURITY_DESCRIPTOR;
    PrincipalSelfSid : PSID;
    DesiredAccess : DWORD;
    AuditType : AUDIT_EVENT_TYPE;
    Flags : DWORD;
    ObjectTypeList : OBJECT_TYPE_LIST;
    ObjectTypeListLength : DWORD;
    GenericMapping : GENERIC_MAPPING;
    ObjectCreation : BOOL;
    VAR GrantedAccess : DWORD;
    VAR AccessStatus : BOOL;
    VAR pfGenerateOnClose : BOOL) : BOOL;

(* NT only *)
PROCEDURE AccessCheckByTypeResultListAndAuditAlarmW (
    SubsystemName : ARRAY OF WCHAR;
    HandleId : LPVOID;
    ObjectTypeName : ARRAY OF WCHAR;
    ObjectName : ARRAY OF WCHAR;
    SecurityDescriptor : PSECURITY_DESCRIPTOR;
    PrincipalSelfSid : PSID;
    DesiredAccess : DWORD;
    AuditType : AUDIT_EVENT_TYPE;
    Flags : DWORD;
    ObjectTypeList : OBJECT_TYPE_LIST;
    ObjectTypeListLength : DWORD;
    GenericMapping : GENERIC_MAPPING;
    ObjectCreation : BOOL;
    VAR GrantedAccess : DWORD;
    VAR AccessStatus : BOOL;
    VAR pfGenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
(* NT only *)
PROCEDURE AccessCheckByTypeResultListAndAuditAlarm = AccessCheckByTypeResultListAndAuditAlarmW;
%ELSE
(* NT only *)
PROCEDURE AccessCheckByTypeResultListAndAuditAlarm = AccessCheckByTypeResultListAndAuditAlarmA;
%END

PROCEDURE ObjectOpenAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                HandleId : LPVOID;
                                VAR ObjectTypeName : ARRAY OF ACHAR;
                                VAR ObjectName : ARRAY OF ACHAR;
                                pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                ClientToken : HANDLE;
                                DesiredAccess : DWORD;
                                GrantedAccess : DWORD;
                                Privileges : PPRIVILEGE_SET;
                                ObjectCreation : BOOL;
                                AccessGranted : BOOL;
                                GenerateOnClose : LPBOOL) : BOOL;

PROCEDURE ObjectOpenAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                HandleId : LPVOID;
                                VAR ObjectTypeName : ARRAY OF UCHAR;
                                VAR ObjectName : ARRAY OF UCHAR;
                                pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                ClientToken : HANDLE;
                                DesiredAccess : DWORD;
                                GrantedAccess : DWORD;
                                Privileges : PPRIVILEGE_SET;
                                ObjectCreation : BOOL;
                                AccessGranted : BOOL;
                                GenerateOnClose : LPBOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE ObjectOpenAuditAlarm = ObjectOpenAuditAlarmW;
%ELSE
PROCEDURE ObjectOpenAuditAlarm = ObjectOpenAuditAlarmA;
%END

PROCEDURE ObjectPrivilegeAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                     HandleId : LPVOID;
                                     ClientToken : HANDLE;
                                     DesiredAccess : DWORD;
                                     Privileges : PPRIVILEGE_SET;
                                     AccessGranted : BOOL) : BOOL;

PROCEDURE ObjectPrivilegeAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                     HandleId : LPVOID;
                                     ClientToken : HANDLE;
                                     DesiredAccess : DWORD;
                                     Privileges : PPRIVILEGE_SET;
                                     AccessGranted : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE ObjectPrivilegeAuditAlarm = ObjectPrivilegeAuditAlarmW;
%ELSE
PROCEDURE ObjectPrivilegeAuditAlarm = ObjectPrivilegeAuditAlarmA;
%END



PROCEDURE ObjectCloseAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                 HandleId : LPVOID;
                                 GenerateOnClose : BOOL) : BOOL;

PROCEDURE ObjectCloseAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                 HandleId : LPVOID;
                                 GenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE ObjectCloseAuditAlarm = ObjectCloseAuditAlarmW;
%ELSE
PROCEDURE ObjectCloseAuditAlarm = ObjectCloseAuditAlarmA;
%END

PROCEDURE ObjectDeleteAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                  HandleId : LPVOID;
                                  GenerateOnClose : BOOL) : BOOL;

PROCEDURE ObjectDeleteAuditAlarmW(SubsystemName : ARRAY OF WCHAR;
                                  HandleId : LPVOID;
                                  GenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE ObjectDeleteAuditAlarm = ObjectDeleteAuditAlarmW;
%ELSE
PROCEDURE ObjectDeleteAuditAlarm = ObjectDeleteAuditAlarmA;
%END

PROCEDURE PrivilegedServiceAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                       ServiceName : ARRAY OF ACHAR;
                                       ClientToken : HANDLE;
                                       Privileges : PPRIVILEGE_SET;
                                       AccessGranted : BOOL) : BOOL;

PROCEDURE PrivilegedServiceAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                       ServiceName : ARRAY OF UCHAR;
                                       ClientToken : HANDLE;
                                       Privileges : PPRIVILEGE_SET;
                                       AccessGranted : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE PrivilegedServiceAuditAlarm = PrivilegedServiceAuditAlarmW;
%ELSE
PROCEDURE PrivilegedServiceAuditAlarm = PrivilegedServiceAuditAlarmA;
%END

PROCEDURE IsValidSid(pSid : PSID) : BOOL;

PROCEDURE EqualSid(pSid1 : PSID;
                   pSid2 : PSID) : BOOL;

PROCEDURE EqualPrefixSid(pSid1 : PSID;
                         pSid2 : PSID) : BOOL;

PROCEDURE GetSidLengthRequired(nSubAuthorityCount : UCHAR) : DWORD;

PROCEDURE AllocateAndInitializeSid(pIdentifierAuthority : PSID_IDENTIFIER_AUTHORITY;
                                   nSubAuthorityCount : BYTE;
                                   nSubAuthority0 : DWORD;
                                   nSubAuthority1 : DWORD;
                                   nSubAuthority2 : DWORD;
                                   nSubAuthority3 : DWORD;
                                   nSubAuthority4 : DWORD;
                                   nSubAuthority5 : DWORD;
                                   nSubAuthority6 : DWORD;
                                   nSubAuthority7 : DWORD;
                                   VAR pSid : PSID) : BOOL;

PROCEDURE FreeSid(pSid : PSID) : PVOID;

PROCEDURE InitializeSid(Sid : PSID;
                        pIdentifierAuthority : PSID_IDENTIFIER_AUTHORITY;
                        nSubAuthorityCount : BYTE) : BOOL;

PROCEDURE GetSidIdentifierAuthority(pSid : PSID) : PSID_IDENTIFIER_AUTHORITY;

PROCEDURE GetSidSubAuthority(pSid : PSID;
                             nSubAuthority : DWORD) : PDWORD;

PROCEDURE GetSidSubAuthorityCount(pSid : PSID) : PUCHAR;

PROCEDURE GetLengthSid(pSid : PSID) : DWORD;

PROCEDURE CopySid(nDestinationSidLength : DWORD;
                  pDestinationSid : PSID;
                  pSourceSid : PSID) : BOOL;

PROCEDURE AreAllAccessesGranted(GrantedAccess : DWORD;
                                DesiredAccess : DWORD) : BOOL;

PROCEDURE AreAnyAccessesGranted(GrantedAccess : DWORD;
                                DesiredAccess : DWORD) : BOOL;

PROCEDURE MapGenericMask(AccessMask : PDWORD;
                         GenericMapping : PGENERIC_MAPPING);

PROCEDURE IsValidAcl(pAcl : ACL) : BOOL;

PROCEDURE InitializeAcl(VAR pAcl : ACL;
                        nAclLength : DWORD;
                        dwAclRevision : DWORD) : BOOL;

PROCEDURE GetAclInformation(pAcl : ACL;
                            pAclInformation : LPVOID;
                            nAclInformationLength : DWORD;
                            dwAclInformationClass : ACL_INFORMATION_CLASS) : BOOL;

PROCEDURE SetAclInformation(pAcl : PACL;
                            pAclInformation : LPVOID;
                            nAclInformationLength : DWORD;
                            dwAclInformationClass : ACL_INFORMATION_CLASS) : BOOL;

PROCEDURE AddAce(pAcl : ACL;
                 dwAceRevision : DWORD;
                 dwStartingAceIndex : DWORD;
                 pAceList : LPVOID;
                 nAceListLength : DWORD) : BOOL;

PROCEDURE DeleteAce(pAcl : ACL;
                    dwAceIndex : DWORD) : BOOL;

PROCEDURE GetAce(pAcl : ACL;
                 dwAceIndex : DWORD;
                 VAR pAce : LPVOID) : BOOL;

PROCEDURE AddAccessAllowedAce(pAcl : ACL;
                              dwAceRevision : DWORD;
                              AccessMask : DWORD;
                              pSid : PSID) : BOOL;

(* NT only *)
PROCEDURE AddAccessAllowedAceEx (pAcl : PACL;
                                 dwAceRevision : DWORD;
                                 AceFlags : DWORD;
                                 AccessMask : DWORD;
                                 pSid : PSID) : BOOL;

PROCEDURE AddAccessDeniedAce(pAcl : ACL;
                             dwAceRevision : DWORD;
                             AccessMask : DWORD;
                             pSid : PSID) : BOOL;

(* NT only *)
PROCEDURE AddAccessDeniedAceEx(pAcl : PACL;
                               dwAceRevision : DWORD;
                               AceFlags : DWORD;
                               AccessMask : DWORD;
                               pSid : PSID) : BOOL;

PROCEDURE AddAuditAccessAce(pAcl : ACL;
                            dwAceRevision : DWORD;
                            dwAccessMask : DWORD;
                            pSid : PSID;
                            bAuditSuccess : BOOL;
                            bAuditFailure : BOOL) : BOOL;

(* NT only *)
PROCEDURE AddAuditAccessAceEx(pAcl : PACL;
                              dwAceRevision : DWORD;
                              AceFlags : DWORD;
                              dwAccessMask : DWORD;
                              pSid : PSID;
                              bAuditSuccess : BOOL;
                              bAuditFailure : BOOL) : BOOL;

(* NT only *)
PROCEDURE AddAccessAllowedObjectAce(pAcl : PACL;
                                    dwAceRevision : DWORD;
                                    AceFlags : DWORD;
                                    AccessMask : DWORD;
                                    ObjectTypeGuid : GUID;
                                    InheritedObjectTypeGuid : GUID;
                                    pSid : PSID) : BOOL;

(* NT only *)
PROCEDURE AddAccessDeniedObjectAce(pAcl : PACL;
                                   dwAceRevision : DWORD;
                                   AceFlags : DWORD;
                                   AccessMask : DWORD;
                                   ObjectTypeGuid : GUID;
                                   InheritedObjectTypeGuid : GUID;
                                   pSid : PSID) : BOOL;

(* NT only *)
PROCEDURE AddAuditAccessObjectAce(pAcl : PACL;
                                  dwAceRevision : DWORD;
                                  AceFlags : DWORD;
                                  AccessMask : DWORD;
                                  ObjectTypeGuid : GUID;
                                  InheritedObjectTypeGuid : GUID;
                                  pSid : PSID;
                                  bAuditSuccess : BOOL;
                                  bAuditFailure : BOOL) : BOOL;


PROCEDURE FindFirstFreeAce(pAcl : ACL;
                           VAR pAce : LPVOID) : BOOL;

PROCEDURE InitializeSecurityDescriptor(VAR pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                       dwRevision : DWORD) : BOOL;

PROCEDURE IsValidSecurityDescriptor(pSecurityDescriptor : SECURITY_DESCRIPTOR) : BOOL;

PROCEDURE GetSecurityDescriptorLength(pSecurityDescriptor : SECURITY_DESCRIPTOR) : DWORD;

PROCEDURE GetSecurityDescriptorControl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                       VAR pControl : SECURITY_DESCRIPTOR_CONTROL;
                                       VAR lpdwRevision : DWORD) : BOOL;

(* NT only *)
PROCEDURE SetSecurityDescriptorControl(
    pSecurityDescriptor : PSECURITY_DESCRIPTOR;
    ControlBitsOfInterest : SECURITY_DESCRIPTOR_CONTROL;
    ControlBitsToSet : SECURITY_DESCRIPTOR_CONTROL) : BOOL;

PROCEDURE SetSecurityDescriptorDacl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                    bDaclPresent : BOOL;
                                    pDacl : PACL;
                                    bDaclDefaulted : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorDacl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                    VAR lpbDaclPresent : BOOL;
                                    VAR pDacl : PACL;
                                    VAR lpbDaclDefaulted : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorSacl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                    bSaclPresent : BOOL;
                                    pSacl : PACL;
                                    bSaclDefaulted : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorSacl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                    VAR lpbSaclPresent : BOOL;
                                    VAR pSacl : PACL;
                                    VAR lpbSaclDefaulted : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorOwner(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                     pOwner : PSID;
                                     bOwnerDefaulted : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorOwner(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                     VAR pOwner : PSID;
                                     VAR lpbOwnerDefaulted : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorGroup(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                     pGroup : PSID;
                                     bGroupDefaulted : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorGroup(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                     VAR pGroup : PSID;
                                     VAR lpbGroupDefaulted : BOOL) : BOOL;

PROCEDURE CreatePrivateObjectSecurity(ParentDescriptor : SECURITY_DESCRIPTOR;
                                      CreatorDescriptor : SECURITY_DESCRIPTOR;
                                      VAR NewDescriptor : PSECURITY_DESCRIPTOR;
                                      IsDirectoryObject : BOOL;
                                      Token : HANDLE;
                                      GenericMapping : GENERIC_MAPPING) : BOOL;


(*NT only*)
PROCEDURE ConvertToAutoInheritPrivateObjectSecurity(
    ParentDescriptor : PSECURITY_DESCRIPTOR;
    CurrentSecurityDescriptor : PSECURITY_DESCRIPTOR;
    VAR NewSecurityDescriptor : PSECURITY_DESCRIPTOR;
    ObjectType : GUID;
    IsDirectoryObject : BOOLEAN;
    GenericMapping : GENERIC_MAPPING) : BOOL;

(*NT only*)
PROCEDURE CreatePrivateObjectSecurityEx(
    ParentDescriptor : PSECURITY_DESCRIPTOR;
    CreatorDescriptor : PSECURITY_DESCRIPTOR;
    VAR NewDescriptor : PSECURITY_DESCRIPTOR;
    ObjectType : GUID;
    IsContainerObject : BOOL;
    AutoInheritFlags : ULONG;
    Token : HANDLE;
    GenericMapping : GENERIC_MAPPING) : BOOL;


PROCEDURE SetPrivateObjectSecurity(SecurityInformation : SECURITY_INFORMATION;
                                   ModificationDescriptor : PSECURITY_DESCRIPTOR;
                                   VAR ObjectsSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                   GenericMapping : PGENERIC_MAPPING;
                                   Token : HANDLE) : BOOL;

(*NT only*)
PROCEDURE SetPrivateObjectSecurityEx(
    SecurityInformation : SECURITY_INFORMATION;
    ModificationDescriptor : PSECURITY_DESCRIPTOR;
    VAR ObjectsSecurityDescriptor : PSECURITY_DESCRIPTOR;
    AutoInheritFlags : ULONG;
    GenericMapping : GENERIC_MAPPING;
    Token : HANDLE) : BOOL;

PROCEDURE GetPrivateObjectSecurity(ObjectDescriptor : PSECURITY_DESCRIPTOR;
                                   SecurityInformation : SECURITY_INFORMATION;
                                   ResultantDescriptor : PSECURITY_DESCRIPTOR;
                                   DescriptorLength : DWORD;
                                   ReturnLength : PDWORD) : BOOL;

PROCEDURE DestroyPrivateObjectSecurity(VAR ObjectDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE MakeSelfRelativeSD(pAbsoluteSecurityDescriptor : PSECURITY_DESCRIPTOR;
                             pSelfRelativeSecurityDescriptor : PSECURITY_DESCRIPTOR;
                             VAR lpdwBufferLength : DWORD) : BOOL;

PROCEDURE MakeAbsoluteSD(pSelfRelativeSecurityDescriptor : PSECURITY_DESCRIPTOR;
                         pAbsoluteSecurityDescriptor : PSECURITY_DESCRIPTOR;
                         VAR lpdwAbsoluteSecurityDescriptorSize : DWORD;
                         pDacl : PACL;
                         VAR lpdwDaclSize : DWORD;
                         pSacl : PACL;
                         VAR lpdwSaclSize : DWORD;
                         pOwner : PSID;
                         VAR lpdwOwnerSize : DWORD;
                         pPrimaryGroup : PSID;
                         VAR lpdwPrimaryGroupSize : DWORD) : BOOL;

PROCEDURE SetFileSecurityA(lpFileName : ARRAY OF ACHAR;
                           SecurityInformation : SECURITY_INFORMATION;
                           pSecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE SetFileSecurityW(lpFileName : ARRAY OF UCHAR;
                           SecurityInformation : SECURITY_INFORMATION;
                           pSecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetFileSecurity = SetFileSecurityW;
%ELSE
PROCEDURE SetFileSecurity = SetFileSecurityA;
%END

PROCEDURE GetFileSecurityA(lpFileName : ARRAY OF ACHAR;
                           RequestedInformation : SECURITY_INFORMATION;
                           pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                           nLength : DWORD;
                           VAR lpnLengthNeeded : DWORD) : BOOL;

PROCEDURE GetFileSecurityW(lpFileName : ARRAY OF UCHAR;
                           RequestedInformation : SECURITY_INFORMATION;
                           pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                           nLength : DWORD;
                           VAR lpnLengthNeeded : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetFileSecurity = GetFileSecurityW;
%ELSE
PROCEDURE GetFileSecurity = GetFileSecurityA;
%END

PROCEDURE SetKernelObjectSecurity(Handle : HANDLE;
                                  SecurityInformation : SECURITY_INFORMATION;
                                  SecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE FindFirstChangeNotificationA(lpPathName : ARRAY OF ACHAR;
                                       bWatchSubtree : BOOL;
                                       dwNotifyFilter : DWORD) : HANDLE;

PROCEDURE FindFirstChangeNotificationW(lpPathName : ARRAY OF UCHAR;
                                       bWatchSubtree : BOOL;
                                       dwNotifyFilter : DWORD) : HANDLE;

%IF UNICODE %THEN
PROCEDURE FindFirstChangeNotification = FindFirstChangeNotificationW;
%ELSE
PROCEDURE FindFirstChangeNotification = FindFirstChangeNotificationA;
%END

PROCEDURE FindNextChangeNotification(hChangeHandle : HANDLE) : BOOL;

PROCEDURE FindCloseChangeNotification(hChangeHandle : HANDLE) : BOOL;

(*NT only*)
PROCEDURE ReadDirectoryChangesW(
    hDirectory : HANDLE;
    VAR lpBuffer : ARRAY OF LOC;
    nBufferLength : DWORD;
    bWatchSubtree : BOOL;
    dwNotifyFilter : DWORD;
    VAR lpBytesReturned : DWORD;
    lpOverlapped : LPOVERLAPPED;
    lpCompletionRoutine : LPOVERLAPPED_COMPLETION_ROUTINE) : BOOL;

PROCEDURE VirtualLock(lpAddress : LPVOID; dwSize : SIZE_T) : BOOL;

PROCEDURE VirtualUnlock(lpAddress : LPVOID; dwSize : SIZE_T) : BOOL;

PROCEDURE MapViewOfFileEx(hFileMappingObject : HANDLE;
                          dwDesiredAccess : DWORD;
                          dwFileOffsetHigh : DWORD;
                          dwFileOffsetLow : DWORD;
                          dwNumberOfBytesToMap : SIZE_T;
                          lpBaseAddress : LPVOID) : LPVOID;

PROCEDURE SetPriorityClass(hProcess : HANDLE;
                           dwPriorityClass : DWORD) : BOOL;

PROCEDURE GetPriorityClass(hProcess : HANDLE) : DWORD;

PROCEDURE IsBadReadPtr(lp : LPCVOID;
                       ucb : UINT_PTR) : BOOL;

PROCEDURE IsBadWritePtr(lp : LPVOID;
                        ucb : UINT_PTR) : BOOL;

PROCEDURE IsBadHugeReadPtr(lp : LPCVOID;
                           ucb : UINT_PTR) : BOOL;

PROCEDURE IsBadHugeWritePtr(lp : LPVOID;
                            ucb : UINT_PTR) : BOOL;

PROCEDURE IsBadCodePtr(lpfn : FARPROC) : BOOL;

PROCEDURE IsBadStringPtrA(lpsz : LPCSTR;
                          ucchMax : UINT_PTR) : BOOL;

PROCEDURE IsBadStringPtrW(lpsz : LPCWSTR;
                          ucchMax : UINT_PTR) : BOOL;

%IF UNICODE %THEN
PROCEDURE IsBadStringPtr = IsBadStringPtrW;
%ELSE
PROCEDURE IsBadStringPtr = IsBadStringPtrA;
%END

PROCEDURE LookupAccountSidA(lpSystemName : ARRAY OF ACHAR;
                            Sid : PSID;
                            VAR Name : ARRAY OF ACHAR;
                            VAR cbName : DWORD;
                            VAR ReferencedDomainName : ARRAY OF ACHAR;
                            VAR cbReferencedDomainName : DWORD;
                            peUse : PSID_NAME_USE) : BOOL;

PROCEDURE LookupAccountSidW(lpSystemName : ARRAY OF UCHAR;
                            Sid : PSID;
                            VAR Name : ARRAY OF UCHAR;
                            VAR cbName : DWORD;
                            VAR ReferencedDomainName : ARRAY OF UCHAR;
                            VAR cbReferencedDomainName : DWORD;
                            peUse : PSID_NAME_USE) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupAccountSid = LookupAccountSidW;
%ELSE
PROCEDURE LookupAccountSid = LookupAccountSidA;
%END

PROCEDURE LookupAccountNameA(lpSystemName : ARRAY OF ACHAR;
                             lpAccountName : ARRAY OF ACHAR;
                             Sid : PSID;
                             VAR cbSid : DWORD;
                             VAR ReferencedDomainName : ARRAY OF ACHAR;
                             VAR cbReferencedDomainName : DWORD;
                             peUse : PSID_NAME_USE) : BOOL;

PROCEDURE LookupAccountNameW(lpSystemName : ARRAY OF UCHAR;
                             lpAccountName : ARRAY OF UCHAR;
                             Sid : PSID;
                             VAR cbSid : DWORD;
                             VAR ReferencedDomainName : ARRAY OF UCHAR;
                             VAR cbReferencedDomainName : DWORD;
                             peUse : PSID_NAME_USE) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupAccountName = LookupAccountNameW;
%ELSE
PROCEDURE LookupAccountName = LookupAccountNameA;
%END

PROCEDURE LookupPrivilegeValueA(lpSystemName : ARRAY OF ACHAR;
                                lpName : ARRAY OF ACHAR;
                                VAR lpLuid : LUID) : BOOL;

PROCEDURE LookupPrivilegeValueW(lpSystemName : ARRAY OF UCHAR;
                                lpName : ARRAY OF UCHAR;
                                VAR lpLuid : LUID) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupPrivilegeValue = LookupPrivilegeValueW;
%ELSE
PROCEDURE LookupPrivilegeValue = LookupPrivilegeValueA;
%END

PROCEDURE LookupPrivilegeNameA(lpSystemName : ARRAY OF ACHAR;
                               VAR lpLuid : LUID;
                               VAR lpName : ARRAY OF ACHAR;
                               VAR cbName : DWORD) : BOOL;

PROCEDURE LookupPrivilegeNameW(lpSystemName : ARRAY OF UCHAR;
                               VAR lpLuid : LUID;
                               VAR lpName : ARRAY OF UCHAR;
                               VAR cbName : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupPrivilegeName = LookupPrivilegeNameW;
%ELSE
PROCEDURE LookupPrivilegeName = LookupPrivilegeNameA;
%END

PROCEDURE LookupPrivilegeDisplayNameA(lpSystemName : ARRAY OF ACHAR;
                                      lpName : ARRAY OF ACHAR;
                                      VAR lpDisplayName : ARRAY OF ACHAR;
                                      VAR cbDisplayName : DWORD;
                                      VAR lpLanguageId : DWORD) : BOOL;

PROCEDURE LookupPrivilegeDisplayNameW(lpSystemName : ARRAY OF UCHAR;
                                      lpName : ARRAY OF UCHAR;
                                      VAR lpDisplayName : ARRAY OF UCHAR;
                                      VAR cbDisplayName : DWORD;
                                      VAR lpLanguageId : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupPrivilegeDisplayName = LookupPrivilegeDisplayNameW;
%ELSE
PROCEDURE LookupPrivilegeDisplayName = LookupPrivilegeDisplayNameA;
%END

PROCEDURE AllocateLocallyUniqueId(VAR Luid : LUID) : BOOL;

PROCEDURE BuildCommDCBA(lpDef : ARRAY OF ACHAR;
                        VAR OUT lpDCB : DCB) : BOOL;

PROCEDURE BuildCommDCBW(lpDef : ARRAY OF UCHAR;
                        VAR OUT lpDCB : DCB) : BOOL;

%IF UNICODE %THEN
PROCEDURE BuildCommDCB = BuildCommDCBW;
%ELSE
PROCEDURE BuildCommDCB = BuildCommDCBA;
%END

PROCEDURE BuildCommDCBAndTimeoutsA(lpDef : ARRAY OF ACHAR;
                                   VAR OUT lpDCB : DCB;
                                   VAR OUT lpCommTimeouts : COMMTIMEOUTS) : BOOL;

PROCEDURE BuildCommDCBAndTimeoutsW(lpDef : ARRAY OF UCHAR;
                                   VAR OUT lpDCB : DCB;
                                   VAR OUT lpCommTimeouts : COMMTIMEOUTS) : BOOL;

%IF UNICODE %THEN
PROCEDURE BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsW;
%ELSE
PROCEDURE BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsA;
%END



PROCEDURE CommConfigDialogA(
                            lpszName : ARRAY OF ACHAR;
                            hWnd : HWND;
                            VAR lpCC : COMMCONFIG
                            ) : BOOL;

PROCEDURE CommConfigDialogW(
                            lpszName : ARRAY OF UCHAR;
                            hWnd : HWND;
                            VAR lpCC : COMMCONFIG
                            ) : BOOL;
%IF UNICODE %THEN
PROCEDURE CommConfigDialog = CommConfigDialogW;
%ELSE
PROCEDURE CommConfigDialog = CommConfigDialogA;
%END

PROCEDURE GetDefaultCommConfigA(
                                lpszName : ARRAY OF ACHAR;
                                VAR lpCC : COMMCONFIG;
                                VAR lpdwSize : DWORD
                                ) : BOOL;

PROCEDURE GetDefaultCommConfigW(
                                lpszName : ARRAY OF UCHAR;
                                VAR lpCC : COMMCONFIG;
                                VAR lpdwSize : DWORD
                                ) : BOOL;
%IF UNICODE %THEN
PROCEDURE GetDefaultCommConfig = GetDefaultCommConfigW;
%ELSE
PROCEDURE GetDefaultCommConfig = GetDefaultCommConfigA;
%END

PROCEDURE SetDefaultCommConfigA(
                                lpszName : ARRAY OF ACHAR;
                                VAR lpCC : COMMCONFIG;
                                dwSize : DWORD
                                ) : BOOL;

PROCEDURE SetDefaultCommConfigW(
                                lpszName : ARRAY OF UCHAR;
                                VAR lpCC : COMMCONFIG;
                                dwSize : DWORD
                                ) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetDefaultCommConfig = SetDefaultCommConfigW;
%ELSE
PROCEDURE SetDefaultCommConfig = SetDefaultCommConfigA;
%END



CONST
    MAX_COMPUTERNAME_LENGTH= 15;

PROCEDURE GetComputerNameA(VAR lpBuffer : ARRAY OF ACHAR;
                           VAR nSize : DWORD) : BOOL;

PROCEDURE GetComputerNameW(VAR lpBuffer : ARRAY OF UCHAR;
                           VAR nSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetComputerName = GetComputerNameW;
%ELSE
PROCEDURE GetComputerName = GetComputerNameA;
%END

PROCEDURE SetComputerNameA(lpComputerName : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetComputerNameW(lpComputerName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetComputerName = SetComputerNameW;
%ELSE
PROCEDURE SetComputerName = SetComputerNameA;
%END

TYPE
  COMPUTER_NAME_FORMAT  = ( ComputerNameNetBIOS,
                            ComputerNameDnsHostname,
                            ComputerNameDnsDomain,
                            ComputerNameDnsFullyQualified,
                            ComputerNamePhysicalNetBIOS,
                            ComputerNamePhysicalDnsHostname,
                            ComputerNamePhysicalDnsDomain,
                            ComputerNamePhysicalDnsFullyQualified,
                            ComputerNameMax
                          );

PROCEDURE GetComputerNameExA(    NameType : COMPUTER_NAME_FORMAT;
                             VAR lpBuffer : ARRAY OF ACHAR;
                             VAR nSize : DWORD) : BOOL;

PROCEDURE GetComputerNameExW(    NameType : COMPUTER_NAME_FORMAT;
                             VAR lpBuffer : ARRAY OF UCHAR;
                             VAR nSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetComputerNameEx = GetComputerNameExW;
%ELSE
PROCEDURE GetComputerNameEx = GetComputerNameExA;
%END

PROCEDURE GetUserNameA(VAR lpBuffer : ARRAY OF ACHAR;
                       VAR nSize : DWORD) : BOOL;

PROCEDURE GetUserNameW(VAR lpBuffer : ARRAY OF UCHAR;
                       VAR nSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetUserName = GetUserNameW;
%ELSE
PROCEDURE GetUserName = GetUserNameA;
%END

TYPE
  EXTENDED_NAME_FORMAT = (
    NameUnknown = 0,
    NameFullyQualifiedDN = 1,
    NameSamCompatible = 2,
    NameDisplay = 3,
    NameUniqueId = 6,
    NameCanonical = 7,
    NameUserPrincipal = 8,
    NameCanonicalEx = 9,
    NameServicePrincipal = 10,
    NameDnsDomain = 12 );

(* Do not use these functions directly, as they do NOT exist on NT 4 and also secur32.lib is not linked into the program. *)
PROCEDURE GetUserNameExA(    NameType : EXTENDED_NAME_FORMAT;
                             VAR lpBuffer : ARRAY OF ACHAR;
                             VAR nSize : DWORD) : BOOL;

PROCEDURE GetUserNameExW(    NameType : EXTENDED_NAME_FORMAT;
                             VAR lpBuffer : ARRAY OF UCHAR;
                             VAR nSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetUserNameEx = GetUserNameExW;
%ELSE
PROCEDURE GetUserNameEx = GetUserNameExA;
%END

CONST
    LOGON32_LOGON_INTERACTIVE   = 2;
    LOGON32_LOGON_NETWORK       = 3;
    LOGON32_LOGON_BATCH         = 4;
    LOGON32_LOGON_SERVICE       = 5;

    LOGON32_PROVIDER_DEFAULT    = 0;
    LOGON32_PROVIDER_WINNT35    = 1;
    LOGON32_PROVIDER_WINNT40    = 2;
    LOGON32_PROVIDER_WINNT50    = 3;

PROCEDURE LogonUserA(lpszUsername : ARRAY OF ACHAR;
                     lpszDomain : ARRAY OF ACHAR;
                     lpszPassword : ARRAY OF ACHAR;
                     dwLogonType : DWORD;
                     dwLogonProvider : DWORD;
                     VAR phToken : HANDLE) : BOOL;

PROCEDURE LogonUserW(lpszUsername : ARRAY OF UCHAR;
                     lpszDomain : ARRAY OF UCHAR;
                     lpszPassword : ARRAY OF UCHAR;
                     dwLogonType : DWORD;
                     dwLogonProvider : DWORD;
                     VAR phToken : HANDLE) : BOOL;

%IF UNICODE %THEN
PROCEDURE LogonUser = LogonUserW;
%ELSE
PROCEDURE LogonUser = LogonUserA;
%END

PROCEDURE ImpersonateLoggedOnUser(hToken : HANDLE) : BOOL;

PROCEDURE CreateProcessAsUserA (hToken : HANDLE;
                                lpApplicationName : ARRAY OF ACHAR;
                                lpCommandLine : ARRAY OF ACHAR;
                                lpProcessAttributes : LPSECURITY_ATTRIBUTES;
                                lpThreadAttributes : LPSECURITY_ATTRIBUTES;
                                bInheritHandles : BOOL;
                                dwCreationFlags : DWORD;
                                lpEnvironment : LPVOID;
                                lpCurrentDirectory : ARRAY OF ACHAR;
                                lpStartupInfo : LPSTARTUPINFOA;
                                lpProcessInformation : LPPROCESS_INFORMATION
                                ) : BOOL;

PROCEDURE CreateProcessAsUserW (hToken : HANDLE;
                                lpApplicationName : ARRAY OF UCHAR;
                                lpCommandLine : ARRAY OF UCHAR;
                                lpProcessAttributes : LPSECURITY_ATTRIBUTES;
                                lpThreadAttributes : LPSECURITY_ATTRIBUTES;
                                bInheritHandles : BOOL;
                                dwCreationFlags : DWORD;
                                lpEnvironment : LPVOID;
                                lpCurrentDirectory : ARRAY OF UCHAR;
                                lpStartupInfo : LPSTARTUPINFOW;
                                lpProcessInformation : LPPROCESS_INFORMATION
                                ) : BOOL;

%IF UNICODE %THEN
PROCEDURE CreateProcessAsUser = CreateProcessAsUserW;
%ELSE
PROCEDURE CreateProcessAsUser = CreateProcessAsUserA;
%END

PROCEDURE DuplicateTokenEx(
    hExistingToken : HANDLE;
    dwDesiredAccess : DWORD;
    lpTokenAttributes : SECURITY_ATTRIBUTES;
    ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL;
    TokenType : TOKEN_TYPE;
    VAR OUT phNewToken : HANDLE) : BOOL;

PROCEDURE CreateRestrictedToken(
    ExistingTokenHandle : HANDLE;
    Flags : DWORD;
    DisableSidCount : DWORD;
    SidsToDisable : PSID_AND_ATTRIBUTES;
    DeletePrivilegeCount : DWORD;
    PrivilegesToDelete : PLUID_AND_ATTRIBUTES;
    RestrictedSidCount : DWORD;
    SidsToRestrict : PSID_AND_ATTRIBUTES;
    VAR OUT NewTokenHandle : HANDLE) : BOOL;

PROCEDURE IsTokenRestricted(TokenHandle : HANDLE) : BOOL;

(*
 Plug-and-Play API's
*)
CONST
(*NT only*)
    HW_PROFILE_GUIDLEN         =39;(* 36-characters plus NULL terminator*)
    MAX_PROFILE_LEN            =80;

    DOCKINFO_UNDOCKED          =1h;
    DOCKINFO_DOCKED            =2h;
    DOCKINFO_USER_SUPPLIED     =4h;
    DOCKINFO_USER_UNDOCKED     =(DOCKINFO_USER_SUPPLIED BOR DOCKINFO_UNDOCKED);
    DOCKINFO_USER_DOCKED       =(DOCKINFO_USER_SUPPLIED BOR DOCKINFO_DOCKED);

TYPE
(*NT only*)
    HW_PROFILE_INFOA = RECORD
    dwDockInfo          : DWORD;
    szHwProfileGuid     : ARRAY [0..HW_PROFILE_GUIDLEN-1] OF ACHAR;
    szHwProfileName     : ARRAY [0..MAX_PROFILE_LEN-1] OF ACHAR;
    END;
    LPHW_PROFILE_INFOA = POINTER TO HW_PROFILE_INFOA;

    HW_PROFILE_INFOW = RECORD
    dwDockInfo          : DWORD;
    szHwProfileGuid     : ARRAY [0..HW_PROFILE_GUIDLEN-1] OF WCHAR;
    szHwProfileName     : ARRAY [0..MAX_PROFILE_LEN-1] OF WCHAR;
    END;
    LPHW_PROFILE_INFOW = POINTER TO HW_PROFILE_INFOW;

%IF UNICODE %THEN
    HW_PROFILE_INFO     = HW_PROFILE_INFOW;
    LPHW_PROFILE_INFO   = LPHW_PROFILE_INFOW;
%ELSE
    HW_PROFILE_INFO     = HW_PROFILE_INFOA;
    LPHW_PROFILE_INFO   = LPHW_PROFILE_INFOA;
%END

(*NT only*)
PROCEDURE GetCurrentHwProfileA(VAR lpHwProfileInfo : HW_PROFILE_INFOA) : BOOL;

(*NT only*)
PROCEDURE GetCurrentHwProfileW(VAR lpHwProfileInfo : HW_PROFILE_INFOW) : BOOL;

%IF UNICODE %THEN
(*NT only*)
PROCEDURE GetCurrentHwProfile = GetCurrentHwProfileW;
%ELSE
(*NT only*)
PROCEDURE GetCurrentHwProfile = GetCurrentHwProfileA;
%END

PROCEDURE QueryPerformanceCounter(VAR lpPerformanceCount : LARGE_INTEGER) : BOOL;

PROCEDURE QueryPerformanceFrequency(VAR lpFrequency : LARGE_INTEGER) : BOOL;

PROCEDURE Int64ShraMod32(Value : LONGLONG; ShiftCount : DWORD) : LONGLONG;

TYPE
    OSVERSIONINFOA = RECORD
        dwOSVersionInfoSize     : DWORD;
        dwMajorVersion          : DWORD;
        dwMinorVersion          : DWORD;
        dwBuildNumber           : DWORD;
        dwPlatformId            : DWORD;
        szCSDVersion            : ARRAY [ 0..128-1 ] OF ACHAR;
    END;
    POSVERSIONINFOA = POINTER TO OSVERSIONINFOA;
    LPOSVERSIONINFOA  = POSVERSIONINFOA;

    OSVERSIONINFOW = RECORD
        dwOSVersionInfoSize     : DWORD;
        dwMajorVersion          : DWORD;
        dwMinorVersion          : DWORD;
        dwBuildNumber           : DWORD;
        dwPlatformId            : DWORD;
        szCSDVersion            : ARRAY [ 0..128-1 ] OF UCHAR;
    END;
    POSVERSIONINFOW = POINTER TO OSVERSIONINFOW;
    LPOSVERSIONINFOW  = POSVERSIONINFOW;

%IF UNICODE %THEN
    OSVERSIONINFO = OSVERSIONINFOW;
    POSVERSIONINFO = POSVERSIONINFOW;
    LPOSVERSIONINFO = LPOSVERSIONINFOW;
%ELSE
    OSVERSIONINFO = OSVERSIONINFOA;
    POSVERSIONINFO = POSVERSIONINFOA;
    LPOSVERSIONINFO = LPOSVERSIONINFOA;
%END

    OSVERSIONINFOEXA = RECORD
    dwOSVersionInfoSize : DWORD;
    dwMajorVersion : DWORD;
    dwMinorVersion : DWORD;
    dwBuildNumber : DWORD;
    dwPlatformId : DWORD;
    szCSDVersion : ARRAY [0.. 128-1] OF ACHAR;(* Maintenance string for PSS usage*)
    wServicePackMajor : WORD;
    wServicePackMinor : WORD;
    wSuiteMask : WORD;
    wProductType,
    wReserved : BYTE;
    END;
    POSVERSIONINFOEXA = POINTER TO OSVERSIONINFOEXA;
    LPOSVERSIONINFOEXA= POSVERSIONINFOEXA;

    OSVERSIONINFOEXW = RECORD
    dwOSVersionInfoSize : DWORD;
    dwMajorVersion : DWORD;
    dwMinorVersion : DWORD;
    dwBuildNumber : DWORD;
    dwPlatformId : DWORD;
    szCSDVersion : ARRAY [0.. 128-1] OF WCHAR;(* Maintenance string for PSS usage*)
    wServicePackMajor : WORD;
    wServicePackMinor : WORD;
    wSuiteMask : WORD;
    wProductType,
    wReserved : BYTE;
    END;
    POSVERSIONINFOEXW = POINTER TO OSVERSIONINFOEXW;
    LPOSVERSIONINFOEXW= POSVERSIONINFOEXW;

    %IF UNICODE %THEN
    OSVERSIONINFOEX = OSVERSIONINFOEXW;
    POSVERSIONINFOEX = POSVERSIONINFOEXW;
    LPOSVERSIONINFOEX = LPOSVERSIONINFOEXW;
    %ELSE
    OSVERSIONINFOEX = OSVERSIONINFOEXA;
    POSVERSIONINFOEX = POSVERSIONINFOEXA;
    LPOSVERSIONINFOEX = LPOSVERSIONINFOEXA;
    %END

CONST
    VER_PLATFORM_WIN32s             = 0;
    VER_PLATFORM_WIN32_WINDOWS      = 1;
    VER_PLATFORM_WIN32_NT           = 2;

    VER_SERVER_NT                       = 080000000H;
    VER_WORKSTATION_NT                  = 040000000H;
    VER_SUITE_SMALLBUSINESS             = 000000001H;
    VER_SUITE_ENTERPRISE                = 000000002H;
    VER_SUITE_BACKOFFICE                = 000000004H;
    VER_SUITE_COMMUNICATIONS            = 000000008H;
    VER_SUITE_TERMINAL                  = 000000010H;
    VER_SUITE_SMALLBUSINESS_RESTRICTED  = 000000020H;
    VER_SUITE_EMBEDDEDNT                = 000000040H;
    VER_SUITE_DATACENTER                = 000000080H;
    VER_SUITE_SINGLEUSERTS              = 000000100H;

PROCEDURE GetVersionExA(
                        VAR lpVersionInformation : OSVERSIONINFOA
                        ) : BOOL;

PROCEDURE GetVersionExW(
                        VAR lpVersionInformation : OSVERSIONINFOW
                        ) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetVersionEx = GetVersionExW;
%ELSE
PROCEDURE GetVersionEx = GetVersionExA;
%END



CONST
    TC_NORMAL            = 0;
    TC_HARDERR           = 1;
    TC_GP_TRAP           = 2;
    TC_SIGNAL            = 3;


    AC_LINE_OFFLINE                 = 00h;
    AC_LINE_ONLINE                  = 01h;
    AC_LINE_BACKUP_POWER            = 02h;
    AC_LINE_UNKNOWN                 = 0FFh;

    BATTERY_FLAG_HIGH               = 01h;
    BATTERY_FLAG_LOW                = 02h;
    BATTERY_FLAG_CRITICAL           = 04h;
    BATTERY_FLAG_CHARGING           = 08h;
    BATTERY_FLAG_NO_BATTERY         = 80h;
    BATTERY_FLAG_UNKNOWN            = 0FFh;

    BATTERY_PERCENTAGE_UNKNOWN      = 0FFh;

    BATTERY_LIFE_UNKNOWN        = 0FFFFFFFFh;

TYPE
    SYSTEM_POWER_STATUS = RECORD
        ACLineStatus            : BYTE;
        BatteryFlag             : BYTE;
        BatteryLifePercent      : BYTE;
        Reserved1               : BYTE;
        BatteryLifeTime         : DWORD;
        BatteryFullLifeTime     : DWORD;
    END;
    LPSYSTEM_POWER_STATUS = POINTER TO SYSTEM_POWER_STATUS;

PROCEDURE GetSystemPowerStatus(
                    VAR lpSystemPowerStatus : SYSTEM_POWER_STATUS
                    ) : BOOL;

PROCEDURE SetSystemPowerState(
                    fSuspend : BOOL;
                    fForce : BOOL
                    );

(*      Win Certificate API and Structures                   *)

TYPE
    WIN_CERTIFICATE = RECORD
    dwLength            : DWORD;
    wRevision           : WORD;
    wCertificateType    : WORD;   (* WIN_CERT_TYPE_xxx*)
    bCertificate        : ARRAY [0..ANYSIZE_ARRAY-1] OF BYTE;
    END;
    LPWIN_CERTIFICATE = POINTER TO WIN_CERTIFICATE;

(*
 Currently, the only defined certificate revision is WIN_CERT_REVISION_1_0
*)
CONST
    WIN_CERT_REVISION_1_0           =(0100h);
    WIN_CERT_REVISION_2_0           =(0200h);

(* Possible certificate types are specified by the following values*)

    WIN_CERT_TYPE_X509               =(0001h);   (*bCertificate contains an X.509 Certificate*)
    WIN_CERT_TYPE_PKCS_SIGNED_DATA   =(0002h);   (* bCertificate contains a PKCS SignedData structur*)
    WIN_CERT_TYPE_RESERVED_1         =(0003h);   (* Reserved*)

PROCEDURE WinSubmitCertificate(lpCertificate : WIN_CERTIFICATE) : BOOL;

(*             Trust API and Structures                      *)

PROCEDURE WinVerifyTrust(hwnd : HWND;
                         ActionID : GUID;
                         ActionData : ARRAY OF LOC) : LONG;


PROCEDURE WinLoadTrustProvider(ActionID : GUID) : BOOL;

(*             Common Trust API Data Structures              *)


(* Data type commonly used in ActionData structures*)

TYPE
     WIN_TRUST_SUBJECT = LPVOID;

(*
 Two commonly used ActionData structures
*)

    WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT = RECORD
    hClientToken        : HANDLE;
    SubjectType         : REFGUID;
    Subject             : WIN_TRUST_SUBJECT;
    END;
    LPWIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT = POINTER TO WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT;


    WIN_TRUST_ACTDATA_SUBJECT_ONLY = RECORD
    SubjectType         : REFGUID;
    Subject             : WIN_TRUST_SUBJECT;
    END;
    LPWIN_TRUST_ACTDATA_SUBJECT_ONLY = POINTER TO WIN_TRUST_ACTDATA_SUBJECT_ONLY;


(*      SUBJECT FORM DEFINITIONS                                   *)

(* Currently defined Subject Type Identifiers.  All of the below   *)
(* use the WIN_TRUST_SUBJECT_FILE subject form, defined below.     *)

(* RawFile == 959dc450-8d9e-11cf-8736-00aa00a485eb *)
CONST
    WIN_TRUST_SUBJTYPE_RAW_FILE = GUID
            { 959dc450h,
              8d9eh,
              11cfh,
              {87h, 36h, 00h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(* PeImage == 43c9a1e0-8da0-11cf-8736-00aa00a485eb *)
    WIN_TRUST_SUBJTYPE_PE_IMAGE = GUID
            { 043c9a1e0h,
              08da0h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };


(* JavaClass = 08ad3990-8da1-11cf-8736-00aa00a485eb *)
    WIN_TRUST_SUBJTYPE_JAVA_CLASS = GUID
            { 008ad3990h,
              08da1h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(* Cabinet = d17c5374-a392-11cf-9df5-00aa00c184e0 *)
    WIN_TRUST_SUBJTYPE_CABINET = GUID
            { 0d17c5374h,
              0a392h,
              011cfh,
              { 09dh, 0f5h, 00h, 0aah, 00h, 0c1h, 084h, 0e0h }
            };

(*
 Associated Subject Data Structure:
*)
TYPE
    WIN_TRUST_SUBJECT_FILE = RECORD
    hFile       : HANDLE;
    lpPath      : LPCWSTR;
    END;
    LPWIN_TRUST_SUBJECT_FILE = POINTER TO WIN_TRUST_SUBJECT_FILE;


(* The following subject types use the                             *)
(* WIN_TRUST_SUBJECT_FILE_AND_DISPLAY subject type, defined        *)
(* below.                                                          *)

CONST
    WIN_TRUST_SUBJTYPE_RAW_FILEEX = GUID
            { 06f458110h,
              0c2f1h,
              011cfh,
              { 08ah, 069h, 00h, 0aah, 00h, 06ch, 037h, 06h }
            };

    WIN_TRUST_SUBJTYPE_PE_IMAGEEX = GUID
            { 06f458111h,
              0c2f1h,
              011cfh,
              { 08ah, 069h, 00h, 0aah, 00h, 06ch, 037h, 06h }
            };

    WIN_TRUST_SUBJTYPE_JAVA_CLASSEX = GUID
            { 06f458113h,
              0c2f1h,
              011cfh,
              { 08ah, 069h, 00h, 0aah, 00h, 06ch, 037h, 06h }
            };

    WIN_TRUST_SUBJTYPE_CABINETEX = GUID
            { 06f458114h,
              0c2f1h,
              011cfh,
              { 08ah, 069h, 00h, 0aah, 00h, 06ch, 037h, 06h }
            };

(*
 Associated Subject Data Structure:
*)
TYPE
    WIN_TRUST_SUBJECT_FILE_AND_DISPLAY  = RECORD
    hFile       : HANDLE;              (* handle to the open file if you got it*)
    lpPath      : LPCWSTR;             (* the path to open if you don't*)
    lpDisplayName : LPCWSTR;      (* (optional) display name to show to user*)
                                (*      in place of path*)
    END;
    LPWIN_TRUST_SUBJECT_FILE_AND_DISPLAY = POINTER TO WIN_TRUST_SUBJECT_FILE_AND_DISPLAY;


(*
 Other subject types:
*)

(* OleStorage == c257e740-8da0-11cf-8736-00aa00a485eb *)
CONST
    WIN_TRUST_SUBJTYPE_OLE_STORAGE = GUID
            { 0c257e740h,
              08da0h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };


(*                                                                 *)
(*      TRUST PROVIDER SPECIFIC DEFINITIONS                        *)
(*                                                                 *)
(*                                                                 *)
(*      Each trust provider will have the following                *)
(*      sections defined:                                          *)
(*                                                                 *)
(*      Actions - What actions are supported by the trust          *)
(*          provider.                                              *)
(*                                                                 *)
(*      SubjectForms - Subjects that may be evaluated by this      *)
(*          trust provider.                                        *)
(*                                                                 *)
(*                     and                                         *)
(*                                                                 *)
(*      Data structures to support the subject forms.              *)
(*                                                                 *)
(*                                                                 *)


(*                                                                 *)
(*             Software Publisher Trust Provider                   *)
(*                                                                 *)

(*
 Actions:
*)

(* TrustedPublisher == 66426730-8da1-11cf-8736-00aa00a485eb *)
CONST
    WIN_SPUB_ACTION_TRUSTED_PUBLISHER = GUID
            { 066426730h,
              08da1h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(* NtActivateImage == 8bc96b00-8da1-11cf-8736-00aa00a485eb *)
    WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE = GUID
            { 08bc96b00h,
              08da1h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(* PublishedSoftware == 64b9d180-8da2-11cf-8736-00aa00a485eb *)
    WIN_SPUB_ACTION_PUBLISHED_SOFTWARE = GUID
            { 064b9d180h,
              08da2h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(*
 Data Structures:
*)
(* WIN_SPUB_ACTION_TRUSTED_PUBLISHER:*)
(**)
(*      Uses WIN_SPUB_TRUSTED_PUBLISHER_DATA*)
(**)
(* WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE:*)
(**)
(*      Uses WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT*)
(**)
(* WIN_SPUB_ACTION_PUBLISHED_SOFTWARE:*)
(**)
(*      Uses WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT*)
(**)

TYPE
    WIN_SPUB_TRUSTED_PUBLISHER_DATA = RECORD
    hClientToken        : HANDLE;
    lpCertificate       : LPWIN_CERTIFICATE;
    END;
    LPWIN_SPUB_TRUSTED_PUBLISHER_DATA = POINTER TO WIN_SPUB_TRUSTED_PUBLISHER_DATA;

(*
 Very Large Memory API Subset
*)

(*NT only*)
PROCEDURE VirtualAllocVlm(hProcess : HANDLE;
                          lpAddress : PVOID64;
                          ullSize : DWORDLONG;
                          flAllocationType : DWORD;
                          flProtect : DWORD) : PVOID64;

(*NT only*)
PROCEDURE VirtualFreeVlm(hProcess : HANDLE;
                         lpAddress : PVOID64;
                         ullSize : DWORDLONG;
                         dwFreeType : DWORD) : BOOL;

(*NT only*)
PROCEDURE VirtualProtectVlm(hProcess : HANDLE;
                            lpAddress : PVOID64;
                            ullSize : DWORDLONG;
                            flNewProtect : DWORD;
                            lpflOldProtect : PDWORD) : BOOL;

TYPE
    MEMORY_BASIC_INFORMATION_VLM = RECORD
    CASE : BOOLEAN OF
    FALSE: BaseAddress : PVOID64;|
    TRUE: BaseAddressAsUlongLong : ULONGLONG;
    END;
    CASE : BOOLEAN OF
    FALSE: AllocationBase : PVOID64;|
    TRUE: AllocationBaseAsUlongLong : ULONGLONG;
    END;
    RegionSize : ULONGLONG;
    AllocationProtect : DWORD;
    State : DWORD;
    Protect : DWORD;
    Type : DWORD;
    END;
    PMEMORY_BASIC_INFORMATION_VLM = POINTER TO MEMORY_BASIC_INFORMATION_VLM;

(*NT only*)
PROCEDURE VirtualQueryVlm(hProcess : HANDLE;
                          lpAddress : PVOID64;
                          VAR lpBuffer : MEMORY_BASIC_INFORMATION_VLM;
                          dwLength : DWORD) : DWORD;

TYPE
    MEMORYSTATUSVLM = RECORD
    dwLength            : DWORD;
    dwMemoryLoad        : DWORD;
    ullTotalPhys        : DWORDLONG;
    ullAvailPhys        : DWORDLONG;
    ullTotalPageFile    : DWORDLONG;
    ullAvailPageFile    : DWORDLONG;
    ullTotalVirtual     : DWORDLONG;
    ullAvailVirtual     : DWORDLONG;
    ullAvailExtendedVirtual : DWORDLONG;
    END;
    LPMEMORYSTATUSVLM = POINTER TO MEMORYSTATUSVLM;

(*NT only*)
PROCEDURE GlobalMemoryStatusVlm(VAR lpBuffer : MEMORYSTATUSVLM);

(*NT only*)
PROCEDURE ReadProcessMemoryVlm(hProcess : HANDLE;
                               lpBaseAddress : PVOID64;
                               lpBuffer : PVOID64;
                               nSize : DWORD;
                               VAR lpNumberOfBytesRead : DWORD) : BOOL;

(*NT only*)
PROCEDURE WriteProcessMemoryVlm(hProcess : HANDLE;
                                lpBaseAddress : PVOID64;
                                lpBuffer : PVOID64;
                                nSize : DWORD;
                                VAR lpNumberOfBytesWritten : DWORD) : BOOL;

(*NT only*)
PROCEDURE ReadFileVlm(hFile : HANDLE;
                      lpBuffer : PVOID64;
                      nNumberOfBytesToRead : DWORD;
                      lpReserved : LPDWORD;
                      lpOverlapped : LPOVERLAPPED) : BOOL;

(*NT only*)
PROCEDURE WriteFileVlm(hFile : HANDLE;
                       lpBuffer : PVOID64;
                       nNumberOfBytesToWrite : DWORD;
                       lpReserved : LPDWORD;
                       lpOverlapped : LPOVERLAPPED) : BOOL;

(*NT only*)
PROCEDURE CreateJobObjectA(lpJobAttributes : SECURITY_ATTRIBUTES;
                           lpName : ARRAY OF ACHAR) : HANDLE;

(*NT only*)
PROCEDURE CreateJobObjectW(lpJobAttributes : SECURITY_ATTRIBUTES;
                           lpName : ARRAY OF WCHAR) : HANDLE;

%IF UNICODE %THEN
(*NT only*)
PROCEDURE CreateJobObject = CreateJobObjectW;
%ELSE
(*NT only*)
PROCEDURE CreateJobObject = CreateJobObjectA;
%END

(*NT only*)
PROCEDURE OpenJobObjectA(dwDesiredAccess : DWORD;
                         bInheritHandle : BOOL;
                         lpName : ARRAY OF ACHAR) : HANDLE;

(*NT only*)
PROCEDURE OpenJobObjectW(dwDesiredAccess : DWORD;
                         bInheritHandle : BOOL;
                         lpName : ARRAY OF WCHAR) : HANDLE;

%IF UNICODE %THEN
(*NT only*)
PROCEDURE OpenJobObject = OpenJobObjectW;
%ELSE
(*NT only*)
PROCEDURE OpenJobObject = OpenJobObjectA;
%END

(*NT only*)
PROCEDURE AssignProcessToJobObject(hJob : HANDLE;
                                   hProcess : HANDLE) : BOOL;

(*NT only*)
PROCEDURE TerminateJobObject(hJob : HANDLE;
                             uExitCode : UINT) : BOOL;

CONST
    JOB_OBJECT_UILIMIT_NONE             = 00000000h;
    JOB_OBJECT_UILIMIT_HANDLES          = 00000001h;
    JOB_OBJECT_UILIMIT_READCLIPBOARD    = 00000002h;
    JOB_OBJECT_UILIMIT_WRITECLIPBOARD   = 00000004h;
    JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 00000008h;
    JOB_OBJECT_UILIMIT_DISPLAYSETTINGS  = 00000010h;
    JOB_OBJECT_UILIMIT_GLOBALATOMS      = 00000020h;
    JOB_OBJECT_UILIMIT_DESKTOP          = 00000040h;
    JOB_OBJECT_UILIMIT_EXITWINDOWS      = 00000080h;
    JOB_OBJECT_UILIMIT_ALL              = 000000FFh;
    JOB_OBJECT_UI_VALID_FLAGS           = 000000FFh;

    JOB_OBJECT_SECURITY_NO_ADMIN            = 00000001h;
    JOB_OBJECT_SECURITY_RESTRICTED_TOKEN    = 00000002h;
    JOB_OBJECT_SECURITY_ONLY_TOKEN          = 00000004h;
    JOB_OBJECT_SECURITY_FILTER_TOKENS       = 00000008h;

    JOB_OBJECT_SECURITY_VALID_FLAGS         = 0000000fh;

TYPE
    JOBOBJECTINFOCLASS = (
    SbJobObjectDummy,
    JobObjectBasicAccountingInformation,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    MaxJobObjectInfoClass) BIG;

(*NT only*)
PROCEDURE QueryInformationJobObject(hJob : HANDLE;
                    JobObjectInformationClass : JOBOBJECTINFOCLASS;
                    lpJobObjectInformation : LPVOID;
                    cbJobObjectInformationLength : DWORD;
                    VAR lpReturnLength : DWORD) : BOOL;

(*NT only*)
PROCEDURE SetInformationJobObject(hJob : HANDLE;
    JobObjectInformationClass : JOBOBJECTINFOCLASS;
    lpJobObjectInformation : LPVOID;
    cbJobObjectInformationLength : DWORD) : BOOL;

(* Macros *)
<*/PUSH/NODLLDEF*>
PROCEDURE FreeModule["_FreeLibrary@4"](hLibModule : HINSTANCE) : BOOL;
PROCEDURE MakeProcInstance(a : FARPROC; b : HINSTANCE) : FARPROC;
PROCEDURE FreeProcInstance(a : FARPROC) : FARPROC;
PROCEDURE MAKEINTATOM(i : ADRCARD) : LPSTR;

(**v These procedures don't do anything v**)
PROCEDURE LimitEmsPages(dw : INTEGER);
PROCEDURE SetSwapAreaSize(dw : INTEGER);
PROCEDURE GlobalLRUNewest(h:HANDLE):HANDLE;
PROCEDURE GlobalLRUOldest(h:HANDLE):HANDLE;
PROCEDURE GetFreeSpace():DWORD;
PROCEDURE UnlockResource(h:HANDLE);
(******************************************)

PROCEDURE LockSegment["_GlobalFix@4"](u : UINT);
PROCEDURE UnlockSegment["_GlobalUnfix@4"](u : UINT);

PROCEDURE GetCurrentTime["_GetTickCount@0"]():UINT;
PROCEDURE GlobalDiscard(h:HANDLE):HANDLE;
PROCEDURE LocalDiscard(h:HANDLE):HANDLE;
<*/POP*>

PROCEDURE MAKELANGID(prim : WORD; sub : WORD) : WORD; MACRO;
BEGIN
    RETURN (prim BOR (sub SHL 10));
END MAKELANGID;

PROCEDURE PRIMARYLANGID(id : WORD) : WORD; MACRO;
BEGIN
    RETURN id BAND 03ffh;
END PRIMARYLANGID;

PROCEDURE SUBLANGID(id : WORD) : WORD; MACRO;
BEGIN
    RETURN id SHR 10;
END SUBLANGID;

PROCEDURE MAKELCID(lgid : WORD; srtid : WORD) : DWORD; MACRO;
BEGIN
    RETURN (ORD(srtid) SHL 16) BOR ORD(lgid);
END MAKELCID;

PROCEDURE LANGIDFROMLCID(id : DWORD) : WORD; MACRO;
BEGIN
    RETURN VAL(WORD, id BAND 0ffffh);
END LANGIDFROMLCID;

PROCEDURE SORTIDFROMLCID(id : DWORD) : WORD; MACRO;
BEGIN
    RETURN VAL(WORD, (id BAND NLS_VALID_LOCALE_MASK) SHR 16);
END SORTIDFROMLCID;

CONST
    LANG_SYSTEM_DEFAULT         =
        LANG_NEUTRAL BOR (SUBLANG_SYS_DEFAULT SHL 10);
    LANG_USER_DEFAULT           =
        LANG_NEUTRAL BOR (SUBLANG_DEFAULT SHL 10);

    LOCALE_SYSTEM_DEFAULT       =
        (SORT_DEFAULT SHL 16) BOR LANG_SYSTEM_DEFAULT;
    LOCALE_USER_DEFAULT         =
        (SORT_DEFAULT SHL 16) BOR LANG_USER_DEFAULT;

(************ Stony Brook Stuff *****************)

(*MACROS*)
<*/PUSH/NODLLDEF*>
PROCEDURE Int32x32To64( a, b : LONG) : LONGLONG [Invariant];

PROCEDURE Int64ShllMod32(a : DWORDLONG; b : DWORD) : DWORDLONG [Invariant];

PROCEDURE Int64ShrlMod32(a : DWORDLONG; b : DWORD) : DWORDLONG [Invariant];

PROCEDURE HEAP_MAKE_TAG_FLAGS( b, o : DWORD) : DWORD;

PROCEDURE HasOverlappedIoCompleted(lpOverlapped : OVERLAPPED) : BOOL; MACRO;
BEGIN
    RETURN lpOverlapped.Internal <> STATUS_PENDING;
END HasOverlappedIoCompleted;
<*/POP*>

END WIN32.
