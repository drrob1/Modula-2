(*
* Copyright (c) 1985-2000, Microsoft Corp. All rights reserved.             *
*)
(* Conversion from Microsoft WIN32 SDK C source to Modula-2 source *)
(* Copyright (c) 1995-2000, Stony Brook Software. All rights reserved. *)

DEFINITION MODULE WIN32;
(*****************************************************************************
Differences in naming from what the NT documentation has
SIZE is called WSIZE
FLOAT IS CALLED WFLOAT
INT is called WINT
PROC is called WPROC
*****************************************************************************)

FROM SYSTEM IMPORT
    ADDRESS, CAST, LOC;

<*/CALLS:WIN32SYSTEM*>
<*/NOHIGH*>
<*/ALIGN:8/NOPACK*>

TYPE
    (* Handles *)
    (* THESE ARE USED TO GET STRICT TYPE CHECKING ON HANDLES
    HSTR                =  POINTER TO RECORD END;
    *)

    HDESK               =  POINTER TO RECORD END;
    HENHMETAFILE        =  POINTER TO RECORD END;
    HWINSTA             =  POINTER TO RECORD END;
    HKL                 =  POINTER TO RECORD END;
    HSTR                =  POINTER TO RECORD END;
    HTASK               =  POINTER TO RECORD END;
    HRSRC               =  POINTER TO RECORD END;
    HDC                 =  POINTER TO RECORD END;
    HGLRC               =  POINTER TO RECORD END;(*95*)
    HCOLORSPACE         =  POINTER TO RECORD END;(*95*)
    HGDIOBJ             =  POINTER TO RECORD END;
    HBITMAP             =  POINTER TO RECORD END;
    HPEN                =  POINTER TO RECORD END;
    HBRUSH              =  POINTER TO RECORD END;
    HRGN                =  POINTER TO RECORD END;
    HFONT               =  POINTER TO RECORD END;
    HPALETTE            =  POINTER TO RECORD END;
    HMETAFILE           =  POINTER TO RECORD END;
    HWND                =  POINTER TO RECORD END;
    HMENU               =  POINTER TO RECORD END;
    HICON               =  POINTER TO RECORD END;
    HDWP                =  POINTER TO RECORD END;
    HACCEL              =  POINTER TO RECORD END;
    HHOOK               =  POINTER TO RECORD END;
    HDRVR               =  POINTER TO RECORD END;
    HMODULE             =  POINTER TO RECORD END;
    HINSTANCE           =  POINTER TO RECORD END;
    HCURSOR             =  POINTER TO RECORD END;
    HMETAFILEPICT       =  POINTER TO RECORD END;
    HKEY                =  POINTER TO RECORD END;
    HMF                 =  POINTER TO RECORD END;
    HEMF                =  POINTER TO RECORD END;
    HCONTEXT            =  POINTER TO RECORD END;
    HMONITOR            =  POINTER TO RECORD END;
    HTERMINAL           =  POINTER TO RECORD END;
    HWINEVENTHOOK       =  POINTER TO RECORD END;

CONST
    PointerToArraySize  = 512; (*Stony Brook defined constant *)
TYPE
    ULONG                = CARDINAL32;
    PULONG               = POINTER TO ULONG;
    USHORT               = CARDINAL16;
    PUSHORT              = POINTER TO USHORT;
    PUCHAR               = POINTER TO ARRAY [0..PointerToArraySize-1] OF UCHAR;
    PSZ                  = POINTER TO ARRAY [0..PointerToArraySize-1] OF ACHAR;

CONST
    ANYSIZE_ARRAY               = 1;
    SIZE_OF_80387_REGISTERS     = 80;
    CONTEXT_i386                = 000010000h;
    CONTEXT_i486                = 000010000h;
    MAX_PATH                    = 260;
    NULL                        = 0;
    EXCEPTION_NONCONTINUABLE    = 1;
    EXCEPTION_MAXIMUM_PARAMETERS= 15;
    NLS_VALID_LOCALE_MASK       = 000fffffH;

TYPE
    PVOID                = ADDRESS;
    SHORT                = INTEGER16;
    LONG                 = INTEGER32;
    WCHAR                = UCHAR;
    DWORD                = CARDINAL;
    BOOL                 = DWORDBOOL;
    BYTE                 = CARDINAL8;
    WORD                 = CARDINAL16;

    LPVOID               = ADDRESS;
    LPCVOID              = LPVOID;
    WINT                 = INTEGER;
    UINT                 = CARDINAL;
    UINT32               = CARDINAL32;
    UINT16               = CARDINAL16;
    HANDLE               = ADDRESS;

    PBOOL                = POINTER TO BOOL;
    LPBOOL               = PBOOL;
    PBYTE                = POINTER TO CARDINAL8;
    LPBYTE               = PBYTE;
    PINT                 = POINTER TO WINT;
    LPINT                = PINT;
    PWORD                = POINTER TO WORD;
    LPWORD               = PWORD;
    LPLONG               = POINTER TO LONG;
    PDWORD               = POINTER TO DWORD;
    LPDWORD              = PDWORD;
    PUINT                = POINTER TO UINT;
    PHANDLE              = POINTER TO HANDLE;

    INT_PTR              = INTEGER;(* always the same size as a pointer *)
    UINT_PTR             = CARDINAL;(* always the same size as a pointer *)
    ULONG_PTR            = CARDINAL;(* always the same size as a pointer *)

    %IF VLM %THEN
    PVOID64             = ADDRESS64;(*no application on intel cpu *)
    LPCVOID64           = PVOID64;
    %END

TYPE
    PWCHAR               = POINTER TO WCHAR;
    LPWCH                = PWCHAR;
    PWCH                 = PWCHAR;
    LPCWCH               = PWCHAR;
    PCWCH                = PWCHAR;

    PWSTR                = POINTER TO ARRAY [0..PointerToArraySize-1] OF WCHAR;
    NWPSTR               = PWSTR;
    LPWSTR               = PWSTR;
    LPCWSTR              = PWSTR;
    PCWSTR               = PWSTR;

    PCHAR                = POINTER TO ACHAR;
    LPCH                 = PCHAR;
    PCH                  = PCHAR;
    LPCCH                = PCHAR;
    PCCH                 = PCHAR;

    PSTR                 = POINTER TO ARRAY [0..PointerToArraySize-1] OF ACHAR;
    LPSTR                = PSTR;
    LPCSTR               = PSTR;
    PCSTR                = PSTR;

    TBYTE                = WCHAR;
    PTBYTE               = POINTER TO ARRAY [0..PointerToArraySize-1] OF WCHAR;

%IF UNICODE %THEN
    TCHAR                = UCHAR;

    LP                   = LPWSTR;
    LPTCH                = LPWSTR;
    PTCH                 = LPWSTR;
    PTSTR                = LPWSTR;
    LPTSTR               = LPWSTR;
    LPCTSTR              = LPCWSTR;

%ELSE
    TCHAR                = ACHAR;

    LP                   = LPSTR;
    LPTCH                = LPSTR;
    PTCH                 = LPSTR;
    PTSTR                = LPSTR;
    LPTSTR               = LPSTR;
    LPCTSTR              = LPCSTR;
%END

    PTCHAR               = POINTER TO TCHAR;

    PSHORT               = POINTER TO SHORT;
    PLONG                = POINTER TO LONG;
    CCHAR                = ACHAR;
    LCID                 = DWORD;
    PLCID                = PDWORD;
    LANGID               = WORD;
    WFLOAT               = REAL;
    PFLOAT               = POINTER TO WFLOAT;
    LPFLOAT              = PFLOAT;

    HRESULT              = LONG;(*95*)
    SCODE                = LONG;(*95*)
    PSCODE               = POINTER TO SCODE;

CONST
    APPLICATION_ERROR_MASK= 020000000h;
    ERROR_SEVERITY_SUCCESS= 000000000h;
    ERROR_SEVERITY_INFORMATIONAL= 040000000h;
    ERROR_SEVERITY_WARNING= 080000000h;
    ERROR_SEVERITY_ERROR = 0C0000000h;

    UNICODE_NULL         = CAST(UCHAR,0);

    ROTFLAGS_REGISTRATIONKEEPSALIVE     = 1;

    MEMCTX_TASK         = 1;
    MEMCTX_SHARED       = 2;
    MEMCTX_MACSYSTEM    = 3;
    MEMCTX_UNKNOWN      = -1;
    MEMCTX_SAME         = -2;

    CLSCTX_INPROC_SERVER        = 1;
    CLSCTX_INPROC_HANDLER       = 2;
    CLSCTX_LOCAL_SERVER         = 4;
    CLSCTX_INPROC_SERVER16      = 8;

    MSHLFLAGS_NORMAL            = 0;
    MSHLFLAGS_TABLESTRONG       = 1;
    MSHLFLAGS_TABLEWEAK         = 2;

    MSHCTX_LOCAL                = 0;
    MSHCTX_NOSHAREDMEM          = 1;
    MSHCTX_DIFFERENTMACHINE     = 2;
    MSHCTX_INPROC               = 3;

    DVASPECT_CONTENT            = 1;
    DVASPECT_THUMBNAIL          = 2;
    DVASPECT_ICON               = 4;
    DVASPECT_DOCPRINT           = 8;

    STGC_DEFAULT                                = 0;
    STGC_OVERWRITE                              = 1;
    STGC_ONLYIFCURRENT                          = 2;
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE     = 4;

    STGMOVE_MOVE        = 0;
    STGMOVE_COPY        = 1;

    STATFLAG_DEFAULT    = 0;
    STATFLAG_NONAME     = 1;

TYPE
    LONGLONG             = INTEGER64;
    ULONGLONG            = CARDINAL64;
    DWORDLONG            = CARDINAL64;
    PLONGLONG            = POINTER TO LONGLONG;
    PULONGLONG           = POINTER TO ULONGLONG;
    PDWORDLONG           = POINTER TO DWORDLONG;
    LARGE_INTEGER        = INTEGER64;
    ULARGE_INTEGER       = RECORD
                                CASE : BOOLEAN OF
                                TRUE:
                                    li : CARDINAL64;
                                |
                                FALSE:
                                    lo : DWORD;
                                    hi : DWORD;
                                END;
                            END;

    LUID                 = LARGE_INTEGER;
    PLARGE_INTEGER       = POINTER TO LARGE_INTEGER;
    PULARGE_INTEGER      = POINTER TO ULARGE_INTEGER;

    PLUID                = POINTER TO LUID;

    USN                  = LONGLONG;

    PBOOLEAN             = POINTER TO BOOLEAN;

    LIST_ENTRY = RECORD
          Flink          : POINTER TO LIST_ENTRY;
          Blink          : POINTER TO LIST_ENTRY;
    END;

    PLIST_ENTRY          = POINTER TO LIST_ENTRY;
    PRLIST_ENTRY         = POINTER TO LIST_ENTRY;

    PSINGLE_LIST_ENTRY   = POINTER TO SINGLE_LIST_ENTRY;
    SINGLE_LIST_ENTRY = RECORD
          Next           : PSINGLE_LIST_ENTRY;
    END;

    GUID = RECORD
          Data1          : ULONG;
          Data2          : USHORT;
          Data3          : USHORT;
          Data4          : ARRAY [0..8 - 1] OF BYTE;
    END;
    LPGUID      = POINTER TO GUID;

    UUID                 = GUID;
    IID                  = GUID;
    CLSID                = GUID;
    FMTID                = GUID;

    LPIID                = POINTER TO IID;
    LPCLSID              = POINTER TO CLSID;
    REFGUID              = POINTER TO GUID;
    REFIID               = POINTER TO IID;
    REFCLSID             = POINTER TO CLSID;
    REFFMTID             = POINTER TO FMTID;

    OBJECTID = RECORD
        Lineage         : GUID;
        Uniquifier      : DWORD;
    END;

PROCEDURE INIT_GUID(VAR guid : GUID;
                    l : ULONG;
                    w1 : USHORT;
                    w2 : USHORT;
                    b1, b2, b3, b4, b5, b6, b7, b8 : BYTE) [Invariant];

CONST
    MINCHAR              = MIN(CHAR)(*080h*);
    MAXCHAR              = MAX(CHAR)(*07fh*);
    MINSHORT             = MIN(SHORT);
    MAXSHORT             = MAX(SHORT);
    MINLONG              = MIN(LONG);
    MAXLONG              = MAX(LONG);
    MAXBYTE              = MAX(BYTE);
    MAXWORD              = MAX(WORD);
    MAXDWORD             = MAX(DWORD);

TYPE
    EXCEPTION_DISPOSITION = (ExceptionContinueExecution,
                             ExceptionContinueSearch,
                             ExceptionNestedException,
                             ExceptionCollidedUnwind) BIG;

    FLOATING_SAVE_AREA = RECORD
          ControlWord    : DWORD;
          StatusWord     : DWORD;
          TagWord        : DWORD;
          ErrorOffset    : DWORD;
          ErrorSelector  : DWORD;
          DataOffset     : DWORD;
          DataSelector   : DWORD;
          RegisterArea   : ARRAY [0..SIZE_OF_80387_REGISTERS - 1] OF BYTE;
          Cr0NpxState    : DWORD;
    END;

    PFLOATING_SAVE_AREA  = POINTER TO FLOATING_SAVE_AREA;

    PEXCEPTION_RECORD = POINTER TO EXCEPTION_RECORD;
    EXCEPTION_RECORD = RECORD
        ExceptionCode : DWORD;
        ExceptionFlags : DWORD;
        ExceptionRecord : PEXCEPTION_RECORD;
        ExceptionAddress : PVOID;
        NumberParameters : DWORD;
        ExceptionInformation : ARRAY [0..EXCEPTION_MAXIMUM_PARAMETERS-1] OF DWORD;
    END;

    CONTEXT              = RECORD
        ContextFlags         : DWORD;

        (* CONTEXT_DEBUG_REGISTERS *)
        Dr0                  : DWORD;
        Dr1                  : DWORD;
        Dr2                  : DWORD;
        Dr3                  : DWORD;
        Dr6                  : DWORD;
        Dr7                  : DWORD;

        (* CONTEXT_FLOATING_POINT *)
        FloatSave            : FLOATING_SAVE_AREA;

        (* CONTEXT_SEGMENTS *)
        SegGs                : DWORD;
        SegFs                : DWORD;
        SegEs                : DWORD;
        SegDs                : DWORD;

        (* CONTEXT_INTEGER *)
        Edi                  : DWORD;
        Esi                  : DWORD;
        Ebx                  : DWORD;
        Edx                  : DWORD;
        Ecx                  : DWORD;
        Eax                  : DWORD;

        (* CONTEXT_CONTROL *)
        Ebp                  : DWORD;
        Eip                  : DWORD;
        SegCs                : DWORD;
        EFlags               : DWORD;
        Esp                  : DWORD;
        SegSs                : DWORD;
    END;
    PCONTEXT             = POINTER TO CONTEXT;

PROCEDURE _except_handler(VAR ExceptionRecord : EXCEPTION_RECORD;
                          EstablisherFrame : PVOID;
                          VAR ContextRecord : CONTEXT;
                          DispatcherContext : PVOID ) : EXCEPTION_DISPOSITION[msCDECL];

CONST
    EXCEPTION_EXECUTE_HANDLER= 1;
    EXCEPTION_CONTINUE_SEARCH= 0;
    EXCEPTION_CONTINUE_EXECUTION= -1 ;

    LANG_NEUTRAL         = 000h;
    LANG_ALBANIAN        = 01ch;
    LANG_ARABIC          = 001h;
    LANG_AFRIKAANS       = 036h;
    LANG_BASQUE          = 02dh;
    LANG_BAHASA          = 021h;
    LANG_BULGARIAN       = 002h;
    LANG_BYELORUSSIAN    = 023h;
    LANG_CATALAN         = 003h;
    LANG_CHINESE         = 004h;
    LANG_CROATIAN        = 01ah;
    LANG_CZECH           = 005h;
    LANG_DANISH          = 006h;
    LANG_DUTCH           = 013h;
    LANG_ENGLISH         = 009h;
    LANG_ESTONIAN        = 025h;
    LANG_FAEROESE        = 038h;
    LANG_FARSI           = 029h;
    LANG_FINNISH         = 00bh;
    LANG_FRENCH          = 00ch;
    LANG_GERMAN          = 007h;
    LANG_GREEK           = 008h;
    LANG_HEBREW          = 00dh;
    LANG_HUNGARIAN       = 00eh;
    LANG_ICELANDIC       = 00fh;
    LANG_INDONESIAN      = 021h;
    LANG_ITALIAN         = 010h;
    LANG_JAPANESE        = 011h;
    LANG_KOREAN          = 012h;
    LANG_LATVIAN         = 026h;
    LANG_LITHUANIAN      = 027h;
    LANG_NORWEGIAN       = 014h;
    LANG_POLISH          = 015h;
    LANG_PORTUGUESE      = 016h;
    LANG_RHAETO_ROMAN    = 017h;
    LANG_ROMANIAN        = 018h;
    LANG_RUSSIAN         = 019h;
    LANG_SERBO_CROATIAN  = 01ah;
    LANG_SLOVAK          = 01bh;
    LANG_SLOVENIAN       = 024h;
    LANG_SORBIAN         = 02eh;
    LANG_SPANISH         = 00ah;
    LANG_SWEDISH         = 01dh;
    LANG_THAI            = 01eh;
    LANG_TURKISH         = 01fh;
    LANG_URDU            = 020h;
    LANG_UKRAINIAN       = 022h;

    SUBLANG_NEUTRAL      = 000h;
    SUBLANG_DEFAULT      = 001h;
    SUBLANG_SYS_DEFAULT  = 002h;
    SUBLANG_ARABIC                   = 001h;
    SUBLANG_ARABIC_IRAQ              = 002h;
    SUBLANG_ARABIC_EGYPT             = 003h;
    SUBLANG_ARABIC_LIBYA             = 004h;
    SUBLANG_ARABIC_ALGERIA           = 005h;
    SUBLANG_ARABIC_MOROCCO           = 006h;
    SUBLANG_ARABIC_TUNISIA           = 007h;
    SUBLANG_ARABIC_OMAN              = 008h;
    SUBLANG_ARABIC_YEMEN             = 009h;
    SUBLANG_ARABIC_SYRIA             = 010h;
    SUBLANG_ARABIC_JORDAN            = 011h;
    SUBLANG_ARABIC_LEBANON           = 012h;
    SUBLANG_ARABIC_KUWAIT            = 013h;
    SUBLANG_ARABIC_UAE               = 014h;
    SUBLANG_ARABIC_BAHRAIN           = 015h;
    SUBLANG_ARABIC_QATAR             = 016h;

    SUBLANG_CHINESE_TRADITIONAL      = 001h;
    SUBLANG_CHINESE_SIMPLIFIED       = 002h;
    SUBLANG_CHINESE_HONGKONG         = 003h;
    SUBLANG_CHINESE_SINGAPORE        = 004h;

    SUBLANG_DUTCH        = 001h;
    SUBLANG_DUTCH_BELGIAN= 002h;
    SUBLANG_ENGLISH_US   = 001h;
    SUBLANG_ENGLISH_UK   = 002h;
    SUBLANG_ENGLISH_AUS  = 003h;
    SUBLANG_ENGLISH_CAN  = 004h;
    SUBLANG_ENGLISH_NZ   = 005h;
    SUBLANG_ENGLISH_EIRE = 006h;
    SUBLANG_ENGLISH_SAFRICA     = 07h;
    SUBLANG_ENGLISH_JAMAICA     = 08h;
    SUBLANG_ENGLISH_CARRIBEAN   = 09h;
    SUBLANG_FRENCH              = 001h;
    SUBLANG_FRENCH_BELGIAN      = 002h;
    SUBLANG_FRENCH_CANADIAN     = 003h;
    SUBLANG_FRENCH_SWISS        = 004h;
    SUBLANG_FRENCH_LUXEMBOURG   = 005h;
    SUBLANG_GERMAN              = 001h;
    SUBLANG_GERMAN_SWISS        = 002h;
    SUBLANG_GERMAN_AUSTRIAN     = 003h;
    SUBLANG_GERMAN_LUXEMBOURG   = 004h;
    SUBLANG_GERMAN_LIECHTENSTEIN= 005h;
    SUBLANG_ITALIAN             = 001h;
    SUBLANG_ITALIAN_SWISS       = 002h;

    SUBLANG_KOREAN              = 001h;
    SUBLANG_KOREAN_JOHAB        = 002h;

    SUBLANG_NORWEGIAN_BOKMAL    = 001h;
    SUBLANG_NORWEGIAN_NYNORSK   = 002h;
    SUBLANG_PORTUGUESE          = 002h;
    SUBLANG_PORTUGUESE_BRAZILIAN= 001h;
    SUBLANG_SERBO_CROATIAN_CYRILLIC= 002h;
    SUBLANG_SERBO_CROATIAN_LATIN= 001h;
    SUBLANG_SPANISH             = 001h;
    SUBLANG_SPANISH_MEXICAN     = 002h;
    SUBLANG_SPANISH_MODERN      = 003h;
    SUBLANG_SPANISH_GUATEMALA   = 004h;
    SUBLANG_SPANISH_COSTARICA   = 005h;
    SUBLANG_SPANISH_PANAMA      = 006h;
    SUBLANG_SPANISH_DOMINICAN   = 007h;
    SUBLANG_SPANISH_VENEZUELA   = 008h;
    SUBLANG_SPANISH_COLOMBIA    = 009h;
    SUBLANG_SPANISH_PERU        = 010h;
    SUBLANG_SPANISH_ARGENTINA   = 011h;
    SUBLANG_SPANISH_ECUADOR     = 012h;
    SUBLANG_SPANISH_CHILE       = 013h;
    SUBLANG_SPANISH_URUGUAY     = 014h;
    SUBLANG_SPANISH_PARAGUAY    = 015h;
    SUBLANG_SPANISH_BOLIVIA     = 016h;

    SORT_DEFAULT                = 0;

    SORT_JAPANESE_XJIS          = 0;
    SORT_JAPANESE_UNICODE       = 1;

    SORT_CHINESE_BIG5           = 0;
    SORT_CHINESE_UNICODE        = 1;

    SORT_KOREAN_KSC             = 0;
    SORT_KOREAN_UNICODE         = 1;

CONST
    STATUS_WAIT_0               = 00000000h;
    STATUS_ABANDONED_WAIT_0     = 00000080h;
    STATUS_USER_APC             = 000000C0h;
    STATUS_TIMEOUT              = 00000102h;
    STATUS_PENDING              = 00000103h;
    STATUS_SEGMENT_NOTIFICATION = 40000005h;
    STATUS_GUARD_PAGE_VIOLATION = 80000001h;
    STATUS_DATATYPE_MISALIGNMENT= 80000002h;
    STATUS_BREAKPOINT           = 80000003h;
    STATUS_SINGLE_STEP          = 80000004h;
    STATUS_ACCESS_VIOLATION     = 0C0000005h;
    STATUS_IN_PAGE_ERROR        = 0C0000006h;
    STATUS_NO_MEMORY            = 0C0000017h;
    STATUS_ILLEGAL_INSTRUCTION  = 0C000001Dh;
    STATUS_NONCONTINUABLE_EXCEPTION     = 0C0000025h;
    STATUS_INVALID_DISPOSITION  = 0C0000026h;
    STATUS_ARRAY_BOUNDS_EXCEEDED        = 0C000008Ch;
    STATUS_FLOAT_DENORMAL_OPERAND       = 0C000008Dh;
    STATUS_FLOAT_DIVIDE_BY_ZERO         = 0C000008Eh;
    STATUS_FLOAT_INEXACT_RESULT      = 0C000008Fh;
    STATUS_FLOAT_INVALID_OPERATION    = 0C0000090h;
    STATUS_FLOAT_OVERFLOW       = 0C0000091h;
    STATUS_FLOAT_STACK_CHECK    = 0C0000092h;
    STATUS_FLOAT_UNDERFLOW      = 0C0000093h;
    STATUS_INTEGER_DIVIDE_BY_ZERO    = 0C0000094h;
    STATUS_INTEGER_OVERFLOW     = 0C0000095h;
    STATUS_PRIVILEGED_INSTRUCTION    = 0C0000096h;
    STATUS_STACK_OVERFLOW       = 0C00000FDh;
    STATUS_CONTROL_C_EXIT       = 0C000013Ah;
    STATUS_INVALID_HANDLE       = 0C0000008h;

    MAXIMUM_WAIT_OBJECTS        = 64;
    MAXIMUM_SUSPEND_COUNT       = MAXCHAR;

TYPE
    KSPIN_LOCK           = DWORD;

CONST
    CONTEXT_PORTABLE_32BIT  = 000100000h;
    CONTEXT_ALPHA           = 000020000h;
    CONTEXT_R4000           = 000010000h;

    CONTEXT_CONTROL         = CONTEXT_i386 BOR 00000001h;
    CONTEXT_INTEGER         = CONTEXT_i386 BOR 00000002h;
    CONTEXT_SEGMENTS        = CONTEXT_i386 BOR 00000004h;
    CONTEXT_FLOATING_POINT  = CONTEXT_i386 BOR 00000008h;
    CONTEXT_DEBUG_REGISTERS = CONTEXT_i386 BOR 00000010h;

    CONTEXT_FULL            = CONTEXT_CONTROL BOR
                              CONTEXT_SEGMENTS BOR
                              CONTEXT_INTEGER;

TYPE
    Bytes = RECORD
          BaseMid        : BYTE;
          Flags1         : BYTE;
          Flags2         : BYTE;
          BaseHi         : BYTE;
    END;

    Bits = DWORD;

    HighWord = RECORD
        CASE : CARDINAL OF
          0 : bytes      : Bytes;
          |
          1 : bits       : Bits;
          ELSE
        END;
    END;

    LDT_ENTRY = RECORD
          LimitLow       : WORD;
          BaseLow        : WORD;
          HighWord       : HighWord;
    END;
    PLDT_ENTRY           = POINTER TO LDT_ENTRY;


TYPE
    EXCEPTION_POINTERS = RECORD
          ExceptionRecord : PEXCEPTION_RECORD;
          ContextRecord  : PCONTEXT;
    END;
    PEXCEPTION_POINTERS  = POINTER TO EXCEPTION_POINTERS;

CONST
    DELETE      = 00010000h;
    READ_CONTROL= 00020000h;
    WRITE_DAC  = 00040000h;
    WRITE_OWNER = 00080000h;
    SYNCHRONIZE = 00100000h;
    STANDARD_RIGHTS_REQUIRED    = 000F0000h;
    STANDARD_RIGHTS_READ        = READ_CONTROL;
    STANDARD_RIGHTS_WRITE       = READ_CONTROL;
    STANDARD_RIGHTS_EXECUTE     = READ_CONTROL;
    STANDARD_RIGHTS_ALL         = 001F0000h;
    SPECIFIC_RIGHTS_ALL         = 0000FFFFh;
    ACCESS_SYSTEM_SECURITY      = 01000000h;
    MAXIMUM_ALLOWED             = 02000000h;
    GENERIC_READ                = 80000000h;
    GENERIC_WRITE               = 40000000h;
    GENERIC_EXECUTE             = 20000000h;
    GENERIC_ALL                 = 10000000h;

    PROCESS_TERMINATE           = 0001h;
    PROCESS_CREATE_THREAD       = 0002h;
    PROCESS_VM_OPERATION        = 0008h;
    PROCESS_VM_READ             = 0010h;
    PROCESS_VM_WRITE            = 0020h;
    PROCESS_DUP_HANDLE          = 0040h;
    PROCESS_CREATE_PROCESS      = 0080h;
    PROCESS_SET_QUOTA           = 0100h;
    PROCESS_SET_INFORMATION     = 0200h;
    PROCESS_QUERY_INFORMATION   = 0400h;
    PROCESS_ALL_ACCESS          = STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR 0FFFh;
    THREAD_TERMINATE            = 0001h;
    THREAD_SUSPEND_RESUME       = 0002h;
    THREAD_GET_CONTEXT          = 0008h;
    THREAD_SET_CONTEXT          = 0010h;
    THREAD_SET_INFORMATION      = 0020h;
    THREAD_QUERY_INFORMATION    = 0040h;
    THREAD_SET_THREAD_TOKEN     = 0080h;
    THREAD_IMPERSONATE          = 0100h;
    THREAD_DIRECT_IMPERSONATION = 0200h;
    THREAD_ALL_ACCESS           = STANDARD_RIGHTS_REQUIRED BOR
                                  SYNCHRONIZE BOR 03FFh;
    TLS_MINIMUM_AVAILABLE       = 64;
    THREAD_BASE_PRIORITY_LOWRT  = 15;
    THREAD_BASE_PRIORITY_MAX    = 2;
    THREAD_BASE_PRIORITY_MIN    = -2;
    THREAD_BASE_PRIORITY_IDLE   = -15;

TYPE
    QUOTA_LIMITS = RECORD
        PagedPoolLimit          : DWORD;
        NonPagedPoolLimit       : DWORD;
        MinimumWorkingSetSize   : DWORD;
        MaximumWorkingSetSize   : DWORD;
        PagefileLimit           : DWORD;
        TimeLimit               : LARGE_INTEGER;
    END;
    PQUOTA_LIMITS       =  POINTER TO QUOTA_LIMITS;

CONST
    EVENT_MODIFY_STATE   = 00002h;
    EVENT_ALL_ACCESS    = (STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR 3);
    MUTANT_QUERY_STATE   = 00001h;
    MUTANT_ALL_ACCESS   = (STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR MUTANT_QUERY_STATE);
    MUTEX_MODIFY_STATE   = MUTANT_QUERY_STATE;
    MUTEX_ALL_ACCESS     = MUTANT_ALL_ACCESS;
    SEMAPHORE_MODIFY_STATE= 00002h;
    SEMAPHORE_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR 3);
    TIME_ZONE_ID_UNKNOWN = 0;
    TIME_ZONE_ID_STANDARD= 1;
    TIME_ZONE_ID_DAYLIGHT= 2;

    PROCESSOR_INTEL_386         = 386;
    PROCESSOR_INTEL_486         = 486;
    PROCESSOR_INTEL_PENTIUM     = 586;
    PROCESSOR_INTEL_860         = 860;
    PROCESSOR_MIPS_R2000        = 2000;
    PROCESSOR_MIPS_R3000        = 3000;
    PROCESSOR_MIPS_R4000        = 4000;
    PROCESSOR_ALPHA_21064       = 21064;
    PROCESSOR_PPC_601           = 601;
    PROCESSOR_PPC_603           = 603;
    PROCESSOR_PPC_604           = 604;
    PROCESSOR_PPC_620           = 620;

    PROCESSOR_ARCHITECTURE_INTEL        = 0;
    PROCESSOR_ARCHITECTURE_MIPS         = 1;
    PROCESSOR_ARCHITECTURE_ALPHA        = 2;
    PROCESSOR_ARCHITECTURE_PPC          = 3;
    PROCESSOR_ARCHITECTURE_UNKNOWN      = 0FFFFh;

TYPE
    MEMORY_BASIC_INFORMATION = RECORD
          BaseAddress    : PVOID;
          AllocationBase : PVOID;
          AllocationProtect: DWORD;
          RegionSize     : DWORD;
          State          : DWORD;
          Protect        : DWORD;
          Type           : DWORD;
    END;
    PMEMORY_BASIC_INFORMATION= POINTER TO MEMORY_BASIC_INFORMATION;

CONST
    SECTION_QUERY        = 00001h;
    SECTION_MAP_WRITE    = 00002h;
    SECTION_MAP_READ     = 00004h;
    SECTION_MAP_EXECUTE  = 00008h;
    SECTION_EXTEND_SIZE  = 00010h;

    SECTION_ALL_ACCESS  = STANDARD_RIGHTS_REQUIRED BOR
                          SECTION_QUERY BOR
                          SECTION_MAP_WRITE BOR
                          SECTION_MAP_READ BOR
                          SECTION_MAP_EXECUTE BOR
                          SECTION_EXTEND_SIZE;
    PAGE_NOACCESS        = 001h;
    PAGE_READONLY        = 002h;
    PAGE_READWRITE       = 004h;
    PAGE_WRITECOPY       = 008h;
    PAGE_EXECUTE         = 010h;
    PAGE_EXECUTE_READ    = 020h;
    PAGE_EXECUTE_READWRITE= 040h;
    PAGE_EXECUTE_WRITECOPY= 080h;
    PAGE_GUARD           = 0100h;
    PAGE_NOCACHE         = 0200h;
    MEM_COMMIT           = 01000h;
    MEM_RESERVE          = 02000h;
    MEM_DECOMMIT         = 04000h;
    MEM_RELEASE          = 08000h;
    MEM_FREE             = 010000h;
    MEM_PRIVATE          = 020000h;
    MEM_MAPPED           = 040000h;
    MEM_TOP_DOWN         = 0100000h;
    SEC_FILE             = 0800000h;
    SEC_IMAGE            = 01000000h;
    SEC_RESERVE          = 04000000h;
    SEC_COMMIT           = 08000000h;
    SEC_NOCACHE          = 010000000h;
    MEM_IMAGE            = SEC_IMAGE;

    FILE_READ_DATA       = 0001h;
    FILE_LIST_DIRECTORY  = 0001h;
    FILE_WRITE_DATA      = 0002h;
    FILE_ADD_FILE        = 0002h;
    FILE_APPEND_DATA     = 0004h;
    FILE_ADD_SUBDIRECTORY= 0004h;
    FILE_CREATE_PIPE_INSTANCE= 0004h;
    FILE_READ_EA         = 0008h;
    FILE_WRITE_EA        = 0010h;
    FILE_EXECUTE         = 0020h;
    FILE_TRAVERSE        = 0020h;
    FILE_DELETE_CHILD    = 0040h;
    FILE_READ_ATTRIBUTES = 0080h;
    FILE_WRITE_ATTRIBUTES= 0100h;
    FILE_READ_PROPERTIES = FILE_READ_EA;
    FILE_WRITE_PROPERTIES= FILE_WRITE_EA;

    FILE_ALL_ACCESS  = STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR 01FFh;
    FILE_GENERIC_READ = STANDARD_RIGHTS_READ BOR FILE_READ_DATA BOR
                        FILE_READ_ATTRIBUTES BOR FILE_READ_EA BOR
                        SYNCHRONIZE;

    FILE_GENERIC_WRITE= STANDARD_RIGHTS_WRITE BOR FILE_WRITE_DATA BOR
                                   FILE_WRITE_ATTRIBUTES BOR
                                   FILE_WRITE_EA BOR FILE_APPEND_DATA BOR
                                   SYNCHRONIZE;

    FILE_GENERIC_EXECUTE = STANDARD_RIGHTS_EXECUTE BOR FILE_READ_ATTRIBUTES BOR
                                 FILE_EXECUTE BOR SYNCHRONIZE;

    FILE_SHARE_READ             = 000000001h;
    FILE_SHARE_WRITE            = 000000002h;
    FILE_ATTRIBUTE_READONLY     = 000000001h;
    FILE_ATTRIBUTE_HIDDEN       = 000000002h;
    FILE_ATTRIBUTE_SYSTEM       = 000000004h;
    FILE_ATTRIBUTE_DIRECTORY    = 000000010h;
    FILE_ATTRIBUTE_ARCHIVE      = 000000020h;
    FILE_ATTRIBUTE_NORMAL       = 000000080h;
    FILE_ATTRIBUTE_TEMPORARY    = 000000100h;
    FILE_ATTRIBUTE_ATOMIC_WRITE = 000000200h;
    FILE_ATTRIBUTE_XACTION_WRITE= 000000400h;
    FILE_ATTRIBUTE_COMPRESSED   = 000000800h;
    FILE_ATTRIBUTE_ENCRYPTED            = 00000040h;
    FILE_ATTRIBUTE_SPARSE_FILE          = 00000200h;
    FILE_ATTRIBUTE_REPARSE_POINT        = 00000400h;
    FILE_ATTRIBUTE_OFFLINE              = 00001000h;
    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  = 00002000h;

    FILE_NOTIFY_CHANGE_FILE_NAME= 000000001h;
    FILE_NOTIFY_CHANGE_DIR_NAME = 000000002h;
    FILE_NOTIFY_CHANGE_ATTRIBUTES= 000000004h;
    FILE_NOTIFY_CHANGE_SIZE     = 000000008h;
    FILE_NOTIFY_CHANGE_LAST_WRITE= 000000010h;
    FILE_NOTIFY_CHANGE_SECURITY = 000000100h;
    MAILSLOT_NO_MESSAGE         = -1;
    MAILSLOT_WAIT_FOREVER       = -1;
    FILE_CASE_SENSITIVE_SEARCH  = 000000001h;
    FILE_CASE_PRESERVED_NAMES   = 000000002h;
    FILE_UNICODE_ON_DISK        = 000000004h;
    FILE_PERSISTENT_ACLS        = 000000008h;
    FILE_FILE_COMPRESSION       = 000000010h;
    FILE_VOLUME_IS_COMPRESSED   = 000008000h;
    IO_COMPLETION_MODIFY_STATE  = 2h;
    IO_COMPLETION_ALL_ACCESS    = STANDARD_RIGHTS_REQUIRED BOR
                                  SYNCHRONIZE BOR 3;

    DUPLICATE_CLOSE_SOURCE      = 000000001h;
    DUPLICATE_SAME_ACCESS       = 000000002h;
    FILE_MAP_COPY               = SECTION_QUERY;
    FILE_MAP_WRITE              = SECTION_MAP_WRITE;
    FILE_MAP_READ               = SECTION_MAP_READ;
    FILE_MAP_ALL_ACCESS         = SECTION_ALL_ACCESS;

TYPE
    PACCESS_TOKEN        = PVOID;
    PSECURITY_DESCRIPTOR = PVOID;
    PSID                 = PVOID;
    ACCESS_MASK          = DWORD;
    PACCESS_MASK         = POINTER TO ACCESS_MASK;

    GENERIC_MAPPING = RECORD
          GenericRead    : ACCESS_MASK;
          GenericWrite   : ACCESS_MASK;
          GenericExecute : ACCESS_MASK;
          GenericAll     : ACCESS_MASK;
    END;
    PGENERIC_MAPPING     = POINTER TO GENERIC_MAPPING;

    <*/PUSH/ALIGN:4/NOPACK*>
    LUID_AND_ATTRIBUTES = RECORD
          Luid           : LUID;
          Attributes     : DWORD;
    END;
    <*/POP*>
    PLUID_AND_ATTRIBUTES = POINTER TO LUID_AND_ATTRIBUTES;

    LUID_AND_ATTRIBUTES_ARRAY= ARRAY [0..ANYSIZE_ARRAY - 1] OF LUID_AND_ATTRIBUTES;
    PLUID_AND_ATTRIBUTES_ARRAY= POINTER TO LUID_AND_ATTRIBUTES_ARRAY;

    SID_IDENTIFIER_AUTHORITY = RECORD
          Value          : ARRAY [0..6 - 1] OF BYTE;
    END;
    PSID_IDENTIFIER_AUTHORITY= POINTER TO SID_IDENTIFIER_AUTHORITY;

    SID = RECORD
          Revision       : BYTE;
          SubAuthorityCount: BYTE;
          IdentifierAuthority: SID_IDENTIFIER_AUTHORITY;
          SubAuthority   : ARRAY [0..ANYSIZE_ARRAY - 1] OF DWORD;
    END;
    PISID                = POINTER TO SID;


CONST
    SID_REVISION                        = 1;
    SID_MAX_SUB_AUTHORITIES             = 15;
    SID_RECOMMENDED_SUB_AUTHORITIES     = 1;

TYPE
    SID_NAME_USE        = (SidTypeUser = 1,
                           SidTypeGroup, SidTypeDomain, SidTypeAlias,
                           SidTypeWellKnownGroup, SidTypeDeletedAccount,
                           SidTypeInvalid, SidTypeUnknown) BIG;
    PSID_NAME_USE       = POINTER TO SID_NAME_USE;
    SID_AND_ATTRIBUTES  = RECORD
          Sid            : PSID;
          Attributes     : DWORD;
    END;
    PSID_AND_ATTRIBUTES = POINTER TO SID_AND_ATTRIBUTES;


    SID_AND_ATTRIBUTES_ARRAY = ARRAY [0..ANYSIZE_ARRAY - 1] OF SID_AND_ATTRIBUTES;
    PSID_AND_ATTRIBUTES_ARRAY= POINTER TO SID_AND_ATTRIBUTES_ARRAY;
CONST
    SECURITY_NULL_SID_AUTHORITY  : ARRAY [0..5] OF BYTE = {0,0,0,0,0,0};
    SECURITY_WORLD_SID_AUTHORITY : ARRAY [0..5] OF BYTE = {0,0,0,0,0,1};
    SECURITY_LOCAL_SID_AUTHORITY : ARRAY [0..5] OF BYTE = {0,0,0,0,0,2};
    SECURITY_CREATOR_SID_AUTHORITY: ARRAY [0..5] OF BYTE = {0,0,0,0,0,3};
    SECURITY_NON_UNIQUE_AUTHORITY : ARRAY [0..5] OF BYTE = {0,0,0,0,0,4};
    SECURITY_NT_AUTHORITY         : ARRAY [0..5] OF BYTE = {0,0,0,0,0,5};
    SECURITY_NULL_RID           = 0;
    SECURITY_WORLD_RID          = 0;
    SECURITY_LOCAL_RID          = 0;
    SECURITY_CREATOR_OWNER_RID  = 0;
    SECURITY_CREATOR_GROUP_RID  =1;
    SECURITY_DIALUP_RID         = 1;
    SECURITY_NETWORK_RID        = 2;
    SECURITY_BATCH_RID          = 3;
    SECURITY_INTERACTIVE_RID    = 4;
    SECURITY_LOGON_IDS_RID      = 5;
    SECURITY_SERVICE_RID        = 6;
    SECURITY_ANONYMOUS_LOGON_RID= 7;

CONST
    SECURITY_LOGON_IDS_RID_COUNT                = 3;
    SECURITY_LOCAL_SYSTEM_RID                   = 00000012h;
    SECURITY_NT_NON_UNIQUE                      = 00000015h;
    SECURITY_BUILTIN_DOMAIN_RID                 = 00000020h;
    DOMAIN_USER_RID_ADMIN                       = 000001F4h;
    DOMAIN_USER_RID_GUEST                       = 000001F5h;
    DOMAIN_GROUP_RID_ADMINS                     = 00000200h;
    DOMAIN_GROUP_RID_USERS                      = 00000201h;
    DOMAIN_GROUP_RID_GUESTS                     = 00000202h;

    DOMAIN_ALIAS_RID_ADMINS                     = 00000220h;
    DOMAIN_ALIAS_RID_USERS                      = 00000221h;
    DOMAIN_ALIAS_RID_GUESTS                     = 00000222h;
    DOMAIN_ALIAS_RID_POWER_USERS                = 00000223h;
    DOMAIN_ALIAS_RID_ACCOUNT_OPS                = 00000224h;
    DOMAIN_ALIAS_RID_SYSTEM_OPS                 = 00000225h;
    DOMAIN_ALIAS_RID_PRINT_OPS                  = 00000226h;
    DOMAIN_ALIAS_RID_BACKUP_OPS                 = 00000227h;
    DOMAIN_ALIAS_RID_REPLICATOR                 = 00000228h;
    SYSTEM_LUID                                 = 03E7h;
    SE_GROUP_MANDATORY                          = 1;
    SE_GROUP_ENABLED_BY_DEFAULT                 = 2;
    SE_GROUP_ENABLED                            = 4;
    SE_GROUP_OWNER                              = 8;
    SE_GROUP_LOGON_ID                   = 0C0000000h;
    ACL_REVISION         = 2;
    ACL_REVISION1        = 1;
    ACL_REVISION2        = 2;

TYPE
    ACL = RECORD
          AclRevision    : BYTE;
          Sbz1           : BYTE;
          AclSize        : WORD;
          AceCount       : WORD;
          Sbz2           : WORD;
    END;
    PACL                 = POINTER TO ACL;

    ACE_HEADER = RECORD
          AceType        : BYTE;
          AceFlags       : BYTE;
          AceSize        : WORD;
    END;
    PACE_HEADER          = POINTER TO ACE_HEADER;

CONST
    ACCESS_ALLOWED_ACE_TYPE     = 0;
    ACCESS_DENIED_ACE_TYPE      = 1;
    SYSTEM_AUDIT_ACE_TYPE       = 2;
    SYSTEM_ALARM_ACE_TYPE       = 3;
    OBJECT_INHERIT_ACE          = 1;
    CONTAINER_INHERIT_ACE       = 2;
    NO_PROPAGATE_INHERIT_ACE    = 4;
    INHERIT_ONLY_ACE            = 8;
    VALID_INHERIT_FLAGS         = 0Fh;
    SUCCESSFUL_ACCESS_ACE_FLAG  = 040h;
    FAILED_ACCESS_ACE_FLAG      = 080h;

TYPE
    ACCESS_ALLOWED_ACE = RECORD
          Header         : ACE_HEADER;
          Mask           : ACCESS_MASK;
          SidStart       : DWORD;
    END;
    PACCESS_ALLOWED_ACE  = POINTER TO ACCESS_ALLOWED_ACE;

    ACCESS_DENIED_ACE = RECORD
          Header         : ACE_HEADER;
          Mask           : ACCESS_MASK;
          SidStart       : DWORD;
    END;
    PACCESS_DENIED_ACE   = POINTER TO ACCESS_DENIED_ACE;

    SYSTEM_AUDIT_ACE = RECORD
          Header         : ACE_HEADER;
          Mask           : ACCESS_MASK;
          SidStart       : DWORD;
    END;
    PSYSTEM_AUDIT_ACE    = POINTER TO SYSTEM_AUDIT_ACE;

    SYSTEM_ALARM_ACE = RECORD
          Header         : ACE_HEADER;
          Mask           : ACCESS_MASK;
          SidStart       : DWORD;
    END;
    PSYSTEM_ALARM_ACE    = POINTER TO SYSTEM_ALARM_ACE;

    ACL_INFORMATION_CLASS = (dummy, AclRevisionInformation, AclSizeInformation) BIG;
    ACL_REVISION_INFORMATION = RECORD
          AclRevision    : DWORD;
    END;
    PACL_REVISION_INFORMATION= POINTER TO ACL_REVISION_INFORMATION;

    ACL_SIZE_INFORMATION = RECORD
          AceCount       : DWORD;
          AclBytesInUse  : DWORD;
          AclBytesFree   : DWORD;
    END;
    PACL_SIZE_INFORMATION= POINTER TO ACL_SIZE_INFORMATION;

CONST
    SECURITY_DESCRIPTOR_REVISION= (1);
    SECURITY_DESCRIPTOR_REVISION1= (1);
    SECURITY_DESCRIPTOR_MIN_LENGTH= (20);

TYPE
    SECURITY_DESCRIPTOR_CONTROL= WORD;
    PSECURITY_DESCRIPTOR_CONTROL= POINTER TO SECURITY_DESCRIPTOR_CONTROL;

CONST
    SE_OWNER_DEFAULTED   = (0001);
    SE_GROUP_DEFAULTED   = (0002);
    SE_DACL_PRESENT      = (0004);
    SE_DACL_DEFAULTED    = (0008);
    SE_SACL_PRESENT      = (0010);
    SE_SACL_DEFAULTED    = (0020);
    SE_SELF_RELATIVE     = (8000);

TYPE
    SECURITY_DESCRIPTOR = RECORD
          Revision       : BYTE;
          Sbz1           : BYTE;
          Control        : SECURITY_DESCRIPTOR_CONTROL;
          Owner          : PSID;
          Group          : PSID;
          Sacl           : PACL;
          Dacl           : PACL;
    END;
    PISECURITY_DESCRIPTOR= POINTER TO SECURITY_DESCRIPTOR;

CONST
    SE_PRIVILEGE_ENABLED_BY_DEFAULT     = 1;
    SE_PRIVILEGE_ENABLED                = 2;
    SE_PRIVILEGE_USED_FOR_ACCESS        = 80000000h;
    PRIVILEGE_SET_ALL_NECESSARY         = 1;

TYPE
    PRIVILEGE_SET = RECORD
          PrivilegeCount : DWORD;
          Control        : DWORD;
          Privilege      : ARRAY [0..ANYSIZE_ARRAY - 1] OF LUID_AND_ATTRIBUTES;
    END;
    PPRIVILEGE_SET       = POINTER TO PRIVILEGE_SET;

CONST
    SE_CREATE_TOKEN_NAME              = "SeCreateTokenPrivilege";
    SE_ASSIGNPRIMARYTOKEN_NAME        = "SeAssignPrimaryTokenPrivilege";
    SE_LOCK_MEMORY_NAME               = "SeLockMemoryPrivilege";
    SE_INCREASE_QUOTA_NAME            = "SeIncreaseQuotaPrivilege";
    SE_UNSOLICITED_INPUT_NAME         = "SeUnsolicitedInputPrivilege";
    SE_TCB_NAME                       = "SeTcbPrivilege";
    SE_SECURITY_NAME                  = "SeSecurityPrivilege";
    SE_TAKE_OWNERSHIP_NAME            = "SeTakeOwnershipPrivilege";
    SE_LOAD_DRIVER_NAME               = "SeLoadDriverPrivilege";
    SE_SYSTEM_PROFILE_NAME            = "SeSystemProfilePrivilege";
    SE_SYSTEMTIME_NAME                = "SeSystemtimePrivilege";
    SE_PROF_SINGLE_PROCESS_NAME       = "SeProfileSingleProcessPrivilege";
    SE_INC_BASE_PRIORITY_NAME         = "SeIncreaseBasePriorityPrivilege";
    SE_CREATE_PAGEFILE_NAME           = "SeCreatePagefilePrivilege";
    SE_CREATE_PERMANENT_NAME          = "SeCreatePermanentPrivilege";
    SE_BACKUP_NAME                    = "SeBackupPrivilege";
    SE_RESTORE_NAME                   = "SeRestorePrivilege";
    SE_SHUTDOWN_NAME                  = "SeShutdownPrivilege";
    SE_DEBUG_NAME                     = "SeDebugPrivilege";
    SE_AUDIT_NAME                     = "SeAuditPrivilege";
    SE_SYSTEM_ENVIRONMENT_NAME        = "SeSystemEnvironmentPrivilege";
    SE_CHANGE_NOTIFY_NAME             = "SeChangeNotifyPrivilege";
    SE_REMOTE_SHUTDOWN_NAME           = "SeRemoteShutdownPrivilege";

    SECURITY_DYNAMIC_TRACKING  =        TRUE;
    SECURITY_STATIC_TRACKING   =        FALSE;


TYPE
    SECURITY_IMPERSONATION_LEVEL = (SecurityAnonymous,
                                    SecurityIdentification,
                                    SecurityImpersonation,
                                    SecurityDelegation) BIG;
    PSECURITY_IMPERSONATION_LEVEL= POINTER TO SECURITY_IMPERSONATION_LEVEL;

    SECURITY_CONTEXT_TRACKING_MODE      = BOOLEAN;
    PSECURITY_CONTEXT_TRACKING_MODE     = POINTER TO BOOLEAN;

    SECURITY_QUALITY_OF_SERVICE         = RECORD
          Length                : DWORD;
          ImpersonationLevel    : SECURITY_IMPERSONATION_LEVEL;
          ContextTrackingMode   : SECURITY_CONTEXT_TRACKING_MODE;
          EffectiveOnly         : BOOLEAN;
    END;
    PSECURITY_QUALITY_OF_SERVICE = POINTER TO SECURITY_QUALITY_OF_SERVICE;

    SE_IMPERSONATION_STATE = RECORD
          Token          : PACCESS_TOKEN;
          CopyOnOpen     : BOOLEAN;
          EffectiveOnly  : BOOLEAN;
          Level          : SECURITY_IMPERSONATION_LEVEL;
    END;
    PSE_IMPERSONATION_STATE= POINTER TO SE_IMPERSONATION_STATE;

CONST
    SECURITY_MAX_IMPERSONATION_LEVEL    = SecurityDelegation;
    DEFAULT_IMPERSONATION_LEVEL         = SecurityImpersonation;

    TOKEN_ASSIGN_PRIMARY = 0001h;
    TOKEN_DUPLICATE      = 0002h;
    TOKEN_IMPERSONATE    = 0004h;
    TOKEN_QUERY          = 0008h;
    TOKEN_QUERY_SOURCE   = 0010h;
    TOKEN_ADJUST_PRIVILEGES= 0020h;
    TOKEN_ADJUST_GROUPS  = 0040h;
    TOKEN_ADJUST_DEFAULT = 0080h;
    TOKEN_ALL_ACCESS    = STANDARD_RIGHTS_REQUIRED BOR
                         TOKEN_ASSIGN_PRIMARY BOR
                         TOKEN_DUPLICATE BOR
                         TOKEN_IMPERSONATE BOR
                         TOKEN_QUERY BOR
                         TOKEN_QUERY_SOURCE BOR
                         TOKEN_ADJUST_PRIVILEGES BOR
                         TOKEN_ADJUST_GROUPS BOR
                         TOKEN_ADJUST_DEFAULT;
    TOKEN_READ          = STANDARD_RIGHTS_READ BOR TOKEN_QUERY;
    TOKEN_WRITE         = STANDARD_RIGHTS_WRITE BOR
                         TOKEN_ADJUST_PRIVILEGES BOR
                         TOKEN_ADJUST_GROUPS BOR
                         TOKEN_ADJUST_DEFAULT;
    TOKEN_EXECUTE       = STANDARD_RIGHTS_EXECUTE;

TYPE
    TOKEN_TYPE           = (TokenPrimary, TokenImpersonation) BIG;
    PTOKEN_TYPE          = POINTER TO TOKEN_TYPE;

    TOKEN_INFORMATION_CLASS = (TokenUser, TokenGroups, TokenPrivileges, TokenOwner, TokenPrimaryGroup, TokenDefaultDacl, TokenSource, TokenType, TokenImpersonationLevel, TokenStatistics) BIG;
    PTOKEN_INFORMATION_CLASS= POINTER TO TOKEN_INFORMATION_CLASS;

    TOKEN_USER = RECORD
          User           : SID_AND_ATTRIBUTES;
    END;
    PTOKEN_USER          = POINTER TO TOKEN_USER;

    TOKEN_GROUPS = RECORD
          GroupCount     : DWORD;
          Groups         : ARRAY [0..ANYSIZE_ARRAY - 1] OF SID_AND_ATTRIBUTES;
    END;
    PTOKEN_GROUPS        = POINTER TO TOKEN_GROUPS;

    TOKEN_PRIVILEGES = RECORD
          PrivilegeCount : DWORD;
          Privileges     : ARRAY [0..ANYSIZE_ARRAY - 1] OF LUID_AND_ATTRIBUTES;
    END;
    PTOKEN_PRIVILEGES    = POINTER TO TOKEN_PRIVILEGES;


    TOKEN_OWNER = RECORD
          Owner          : PSID;
    END;
    PTOKEN_OWNER         = POINTER TO TOKEN_OWNER;

    TOKEN_PRIMARY_GROUP = RECORD
          PrimaryGroup   : PSID;
    END;
    PTOKEN_PRIMARY_GROUP = POINTER TO TOKEN_PRIMARY_GROUP;

    TOKEN_DEFAULT_DACL = RECORD
          DefaultDacl    : PACL;
    END;
    PTOKEN_DEFAULT_DACL  = POINTER TO TOKEN_DEFAULT_DACL;

CONST
    TOKEN_SOURCE_LENGTH  = 8;

TYPE
    TOKEN_SOURCE = RECORD
          SourceName     : ARRAY [0..TOKEN_SOURCE_LENGTH - 1] OF ACHAR;
          SourceIdentifier: LUID;
    END;
    PTOKEN_SOURCE        = POINTER TO TOKEN_SOURCE;


    TOKEN_STATISTICS = RECORD
          TokenId        : LUID;
          AuthenticationId: LUID;
          ExpirationTime : LARGE_INTEGER;
          TokenType      : TOKEN_TYPE;
          ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL;
          DynamicCharged : DWORD;
          DynamicAvailable: DWORD;
          GroupCount     : DWORD;
          PrivilegeCount : DWORD;
          ModifiedId     : LUID;
    END;
    PTOKEN_STATISTICS    = POINTER TO TOKEN_STATISTICS;

    TOKEN_CONTROL = RECORD
          TokenId        : LUID;
          AuthenticationId: LUID;
          ModifiedId     : LUID;
          TokenSource    : TOKEN_SOURCE;
    END;
    PTOKEN_CONTROL       = POINTER TO TOKEN_CONTROL;

    SECURITY_INFORMATION = DWORD;
    PSECURITY_INFORMATION= POINTER TO SECURITY_INFORMATION;
CONST
    OWNER_SECURITY_INFORMATION  = 1;
    GROUP_SECURITY_INFORMATION  = 2;
    DACL_SECURITY_INFORMATION   = 4;
    SACL_SECURITY_INFORMATION   = 8;


(* Start of PE|COFF image stuff, all byte aligned *)
<*/PUSH/PACK*>

CONST
    IMAGE_DOS_SIGNATURE  = 05A4Dh;
    IMAGE_OS2_SIGNATURE  = 0454Eh;
    IMAGE_OS2_SIGNATURE_LE= 0454Ch;
    IMAGE_VXD_SIGNATURE  = 0454Ch;
    IMAGE_NT_SIGNATURE   = 000004550h;

TYPE
    IMAGE_DOS_HEADER = RECORD
          e_magic        : WORD;
          e_cblp         : WORD;
          e_cp           : WORD;
          e_crlc         : WORD;
          e_cparhdr      : WORD;
          e_minalloc     : WORD;
          e_maxalloc     : WORD;
          e_ss           : WORD;
          e_sp           : WORD;
          e_csum         : WORD;
          e_ip           : WORD;
          e_cs           : WORD;
          e_lfarlc       : WORD;
          e_ovno         : WORD;
          e_res          : ARRAY [0..4 - 1] OF WORD;
          e_oemid        : WORD;
          e_oeminfo      : WORD;
          e_res2         : ARRAY [0..10 - 1] OF WORD;
          e_lfanew       : LONG;
    END;
    PIMAGE_DOS_HEADER    = POINTER TO IMAGE_DOS_HEADER;

    IMAGE_OS2_HEADER = RECORD
          ne_magic       : WORD;
          ne_ver         : ACHAR;
          ne_rev         : ACHAR;
          ne_enttab      : WORD;
          ne_cbenttab    : WORD;
          ne_crc         : LONG;
          ne_flags       : WORD;
          ne_autodata    : WORD;
          ne_heap        : WORD;
          ne_stack       : WORD;
          ne_csip        : LONG;
          ne_sssp        : LONG;
          ne_cseg        : WORD;
          ne_cmod        : WORD;
          ne_cbnrestab   : WORD;
          ne_segtab      : WORD;
          ne_rsrctab     : WORD;
          ne_restab      : WORD;
          ne_modtab      : WORD;
          ne_imptab      : WORD;
          ne_nrestab     : LONG;
          ne_cmovent     : WORD;
          ne_align       : WORD;
          ne_cres        : WORD;
          ne_exetyp      : BYTE;
          ne_flagsothers : BYTE;
          ne_pretthunks  : WORD;
          ne_psegrefbytes: WORD;
          ne_swaparea    : WORD;
          ne_expver      : WORD;
    END;
    PIMAGE_OS2_HEADER    = POINTER TO IMAGE_OS2_HEADER;

    IMAGE_FILE_HEADER = RECORD
          Machine        : WORD;
          NumberOfSections: WORD;
          TimeDateStamp  : DWORD;
          PointerToSymbolTable: DWORD;
          NumberOfSymbols: DWORD;
          SizeOfOptionalHeader: WORD;
          Characteristics: WORD;
    END;
    PIMAGE_FILE_HEADER   = POINTER TO IMAGE_FILE_HEADER;

    IMAGE_VXD_HEADER = RECORD
        e32_magic       : WORD;
        e32_border      : BYTE;
        e32_worder      : BYTE;
        e32_level       : DWORD;
        e32_cpu         : WORD;
        e32_os          : WORD;
        e32_ver         : DWORD;
        e32_mflags      : DWORD;
        e32_mpages      : DWORD;
        e32_startobj    : DWORD;
        e32_eip         : DWORD;
        e32_stackobj    : DWORD;
        e32_esp         : DWORD;
        e32_pagesize    : DWORD;
        e32_lastpagesize: DWORD;
        e32_fixupsize   : DWORD;
        e32_fixupsum    : DWORD;
        e32_ldrsize     : DWORD;
        e32_ldrsum      : DWORD;
        e32_objtab      : DWORD;
        e32_objcnt      : DWORD;
        e32_objmap      : DWORD;
        e32_itermap             : DWORD;
        e32_rsrctab             : DWORD;
        e32_rsrccnt             : DWORD;
        e32_restab              : DWORD;
        e32_enttab              : DWORD;
        e32_dirtab              : DWORD;
        e32_dircnt              : DWORD;
        e32_fpagetab            : DWORD;
        e32_frectab             : DWORD;
        e32_impmod              : DWORD;
        e32_impmodcnt           : DWORD;
        e32_impproc             : DWORD;
        e32_pagesum             : DWORD;
        e32_datapage            : DWORD;
        e32_preload             : DWORD;
        e32_nrestab             : DWORD;
        e32_cbnrestab           : DWORD;
        e32_nressum             : DWORD;
        e32_autodata            : DWORD;
        e32_debuginfo           : DWORD;
        e32_debuglen            : DWORD;
        e32_instpreload         : DWORD;
        e32_instdemand          : DWORD;
        e32_heapsize            : DWORD;
        e32_res3                : ARRAY [0..12-1] OF BYTE;
        e32_winresoff           : DWORD;
        e32_winreslen           : DWORD;
        e32_devid               : WORD;
        e32_ddkver              : WORD;
  END;
  PIMAGE_VXD_HEADER     = POINTER TO IMAGE_VXD_HEADER;

CONST
    IMAGE_SIZEOF_FILE_HEADER            = 20;
    IMAGE_FILE_RELOCS_STRIPPED          = 00001h;
    IMAGE_FILE_EXECUTABLE_IMAGE         = 00002h;
    IMAGE_FILE_LINE_NUMS_STRIPPED       = 00004h;
    IMAGE_FILE_LOCAL_SYMS_STRIPPED      = 00008h;
    IMAGE_FILE_AGGRESIVE_WS_TRIM        = 00010h;
    IMAGE_FILE_LARGE_ADDRESS_AWARE      = 00020h;
    IMAGE_FILE_16BIT_MACHINE            = 00040h;
    IMAGE_FILE_BYTES_REVERSED_LO        = 00080h;
    IMAGE_FILE_32BIT_MACHINE            = 00100h;
    IMAGE_FILE_DEBUG_STRIPPED           = 00200h;
    IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP  = 00400h;
    IMAGE_FILE_NET_RUN_FROM_SWAP        = 00800h;
    IMAGE_FILE_SYSTEM                   = 01000h;
    IMAGE_FILE_DLL                      = 02000h;
    IMAGE_FILE_UP_SYSTEM_ONLY           = 04000h;
    IMAGE_FILE_BYTES_REVERSED_HI        = 08000h;

    IMAGE_FILE_MACHINE_UNKNOWN  = 0;
    IMAGE_FILE_MACHINE_I860     = 014dh;
    IMAGE_FILE_MACHINE_I386     = 014ch;
    IMAGE_FILE_MACHINE_R3000    = 0162h;
    IMAGE_FILE_MACHINE_R4000    = 0166h;
    IMAGE_FILE_MACHINE_R10000   = 0168h;
    IMAGE_FILE_MACHINE_ALPHA    = 0184h;
    IMAGE_FILE_MACHINE_POWERPC  = 01f0h;
    IMAGE_FILE_MACHINE_IA64     = 0200h;
    IMAGE_FILE_MACHINE_AMD64    = 08664h;
    IMAGE_FILE_MACHINE_ALPHA64  = 00284h;
    IMAGE_FILE_MACHINE_AXP64    = IMAGE_FILE_MACHINE_ALPHA64;
    IMAGE_FILE_MACHINE_CEE      = 0C0EEh;

TYPE
    IMAGE_DATA_DIRECTORY = RECORD
          VirtualAddress : DWORD;
          Size           : DWORD;
    END;
    PIMAGE_DATA_DIRECTORY = POINTER TO IMAGE_DATA_DIRECTORY;

CONST
    IMAGE_NUMBEROF_DIRECTORY_ENTRIES= 16;

TYPE
    IMAGE_OPTIONAL_HEADER = RECORD
          Magic          : WORD;
          MajorLinkerVersion: BYTE;
          MinorLinkerVersion: BYTE;
          SizeOfCode     : DWORD;
          SizeOfInitializedData: DWORD;
          SizeOfUninitializedData: DWORD;
          AddressOfEntryPoint: DWORD;
          BaseOfCode     : DWORD;
          BaseOfData     : DWORD;
          ImageBase      : DWORD;
          SectionAlignment: DWORD;
          FileAlignment  : DWORD;
          MajorOperatingSystemVersion: WORD;
          MinorOperatingSystemVersion: WORD;
          MajorImageVersion: WORD;
          MinorImageVersion: WORD;
          MajorSubsystemVersion: WORD;
          MinorSubsystemVersion: WORD;
          Reserved1      : DWORD;
          SizeOfImage    : DWORD;
          SizeOfHeaders  : DWORD;
          CheckSum       : DWORD;
          Subsystem      : WORD;
          DllCharacteristics: WORD;
          SizeOfStackReserve: DWORD;
          SizeOfStackCommit: DWORD;
          SizeOfHeapReserve: DWORD;
          SizeOfHeapCommit: DWORD;
          LoaderFlags    : DWORD;
          NumberOfRvaAndSizes: DWORD;
          DataDirectory  : ARRAY [0..IMAGE_NUMBEROF_DIRECTORY_ENTRIES - 1] OF IMAGE_DATA_DIRECTORY;
    END;
    PIMAGE_OPTIONAL_HEADER= POINTER TO IMAGE_OPTIONAL_HEADER;

    IMAGE_ROM_OPTIONAL_HEADER = RECORD
        Magic                   : WORD;
        MajorLinkerVersion      : BYTE;
        MinorLinkerVersion      : BYTE;
        SizeOfCode              : DWORD;
        SizeOfInitializedData   : DWORD;
        SizeOfUninitializedData : DWORD;
        AddressOfEntryPoint     : DWORD;
        BaseOfCode              : DWORD;
        BaseOfData              : DWORD;
        BaseOfBss               : DWORD;
        GprMask                 : DWORD;
        CprMask                 : ARRAY [0..4-1] OF DWORD;
        GpValue                 : DWORD;
    END;
    PIMAGE_ROM_OPTIONAL_HEADER  = POINTER TO IMAGE_ROM_OPTIONAL_HEADER;

CONST
    IMAGE_SIZEOF_ROM_OPTIONAL_HEADER    = 56;
    IMAGE_SIZEOF_STD_OPTIONAL_HEADER    = 28;
    IMAGE_SIZEOF_NT_OPTIONAL_HEADER     = 224;

    IMAGE_NT_OPTIONAL_HDR_MAGIC         = 010bh;
    IMAGE_ROM_OPTIONAL_HDR_MAGIC        = 0107h;

TYPE
    IMAGE_ROM_HEADERS = RECORD
        FileHeader      : IMAGE_FILE_HEADER;
        OptionalHeader  : IMAGE_ROM_OPTIONAL_HEADER;
    END;
    PIMAGE_ROM_HEADERS  = POINTER TO IMAGE_ROM_HEADERS;

    IMAGE_NT_HEADERS = RECORD
          Signature      : DWORD;
          FileHeader     : IMAGE_FILE_HEADER;
          OptionalHeader : IMAGE_OPTIONAL_HEADER;
    END;
    PIMAGE_NT_HEADERS    = POINTER TO IMAGE_NT_HEADERS;

CONST
    IMAGE_SUBSYSTEM_UNKNOWN     = 0;
    IMAGE_SUBSYSTEM_NATIVE      = 1;
    IMAGE_SUBSYSTEM_WINDOWS_GUI = 2;
    IMAGE_SUBSYSTEM_WINDOWS_CUI = 3;
    IMAGE_SUBSYSTEM_OS2_CUI     = 5;
    IMAGE_SUBSYSTEM_POSIX_CUI   = 7;
    IMAGE_LIBRARY_PROCESS_INIT  = 1;
    IMAGE_LIBRARY_PROCESS_TERM  = 2;
    IMAGE_LIBRARY_THREAD_INIT   = 4;
    IMAGE_LIBRARY_THREAD_TERM   = 8;
    IMAGE_LOADER_FLAGS_BREAK_ON_LOAD= 000000001h;
    IMAGE_LOADER_FLAGS_DEBUG_ON_LOAD= 000000002h;
    IMAGE_DIRECTORY_ENTRY_EXPORT        = 0;
    IMAGE_DIRECTORY_ENTRY_IMPORT        = 1;
    IMAGE_DIRECTORY_ENTRY_RESOURCE      = 2;
    IMAGE_DIRECTORY_ENTRY_EXCEPTION     = 3;
    IMAGE_DIRECTORY_ENTRY_SECURITY      = 4;
    IMAGE_DIRECTORY_ENTRY_BASERELOC     = 5;
    IMAGE_DIRECTORY_ENTRY_DEBUG         = 6;
    IMAGE_DIRECTORY_ENTRY_COPYRIGHT     = 7;
    IMAGE_DIRECTORY_ENTRY_GLOBALPTR     = 8;
    IMAGE_DIRECTORY_ENTRY_TLS           = 9;
    IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   = 10;
    IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT  = 11;
    IMAGE_DIRECTORY_ENTRY_IAT           = 12;

    IMAGE_SIZEOF_SHORT_NAME     = 8;

TYPE
    Misc1 = RECORD
        CASE : CARDINAL OF
          0 : PhysicalAddress: DWORD;
          |
          1 : VirtualSize: DWORD;
          ELSE
        END;
    END;

    IMAGE_SECTION_HEADER = RECORD
          Name           : ARRAY [0..IMAGE_SIZEOF_SHORT_NAME - 1] OF BYTE;
          a              : Misc1;
          VirtualAddress : DWORD;
          SizeOfRawData  : DWORD;
          PointerToRawData: DWORD;
          PointerToRelocations: DWORD;
          PointerToLinenumbers: DWORD;
          NumberOfRelocations: WORD;
          NumberOfLinenumbers: WORD;
          Characteristics: DWORD;
    END;
    PIMAGE_SECTION_HEADER= POINTER TO IMAGE_SECTION_HEADER;


CONST
    IMAGE_SIZEOF_SECTION_HEADER= 40;
    IMAGE_SCN_TYPE_REGULAR= 000000000h;
    IMAGE_SCN_TYPE_DUMMY = 000000001h;
    IMAGE_SCN_TYPE_NO_LOAD= 000000002h;
    IMAGE_SCN_TYPE_GROUPED= 000000004h;
    IMAGE_SCN_TYPE_NO_PAD= 000000008h;
    IMAGE_SCN_TYPE_COPY  = 000000010h;
    IMAGE_SCN_CNT_CODE   = 000000020h;
    IMAGE_SCN_CNT_INITIALIZED_DATA= 000000040h;
    IMAGE_SCN_CNT_UNINITIALIZED_DATA= 000000080h;
    IMAGE_SCN_LNK_OTHER  = 000000100h;
    IMAGE_SCN_LNK_INFO   = 000000200h;
    IMAGE_SCN_LNK_OVERLAY= 000000400h;
    IMAGE_SCN_LNK_REMOVE = 000000800h;
    IMAGE_SCN_LNK_COMDAT = 000001000h;
    IMAGE_SCN_LNK_NRELOC_OVFL = 01000000h;

    IMAGE_SCN_ALIGN_1BYTES= 000100000h;
    IMAGE_SCN_ALIGN_2BYTES= 000200000h;
    IMAGE_SCN_ALIGN_4BYTES= 000300000h;
    IMAGE_SCN_ALIGN_8BYTES= 000400000h;
    IMAGE_SCN_ALIGN_16BYTES= 000500000h;
    IMAGE_SCN_ALIGN_32BYTES= 000600000h;
    IMAGE_SCN_ALIGN_64BYTES= 000700000h;

    IMAGE_SCN_MEM_FARDATA    = 000008000h;
    IMAGE_SCN_MEM_DISCARDABLE= 002000000h;
    IMAGE_SCN_MEM_NOT_CACHED= 004000000h;
    IMAGE_SCN_MEM_NOT_PAGED= 008000000h;
    IMAGE_SCN_MEM_PURGEABLE  = 000020000h;
    IMAGE_SCN_MEM_16BIT      = 000020000h;
    IMAGE_SCN_MEM_LOCKED     = 000040000h;
    IMAGE_SCN_MEM_PRELOAD    = 000080000h;

    IMAGE_SCN_MEM_SHARED = 010000000h;
    IMAGE_SCN_MEM_EXECUTE= 020000000h;
    IMAGE_SCN_MEM_READ   = 040000000h;
    IMAGE_SCN_MEM_WRITE  = 080000000h;

TYPE
    Name = RECORD
          Short          : DWORD;
          Long           : DWORD;
    END;

    N = RECORD
        CASE : CARDINAL OF
          0 : ShortName  : ARRAY [0..8 - 1] OF BYTE;
          |
          1 : Name       : Name;
          |
          2 : LongName   : ARRAY [0..2 - 1] OF PBYTE;
          ELSE
        END;
    END;

    IMAGE_SYMBOL = RECORD
          Name           : ARRAY [0..7] OF ACHAR;
          Value          : DWORD;
          SectionNumber  : SHORT;
          Type           : WORD;
          StorageClass   : BYTE;
          NumberOfAuxSymbols: BYTE;
    END;
    PIMAGE_SYMBOL        = POINTER TO IMAGE_SYMBOL;

CONST
    IMAGE_SIZEOF_SYMBOL  = 18;
    IMAGE_SYM_UNDEFINED = 0;
    IMAGE_SYM_ABSOLUTE  = -1;
    IMAGE_SYM_DEBUG      = -2;
    IMAGE_SYM_TYPE_NULL  = 0;
    IMAGE_SYM_TYPE_VOID  = 1;
    IMAGE_SYM_TYPE_CHAR  = 2;
    IMAGE_SYM_TYPE_SHORT = 3;
    IMAGE_SYM_TYPE_INT   = 4;
    IMAGE_SYM_TYPE_LONG  = 5;
    IMAGE_SYM_TYPE_FLOAT = 6;
    IMAGE_SYM_TYPE_DOUBLE= 7;
    IMAGE_SYM_TYPE_STRUCT= 8;
    IMAGE_SYM_TYPE_UNION = 9;
    IMAGE_SYM_TYPE_ENUM  = 10;
    IMAGE_SYM_TYPE_MOE   = 11;
    IMAGE_SYM_TYPE_BYTE  = 12;
    IMAGE_SYM_TYPE_WORD  = 13;
    IMAGE_SYM_TYPE_UINT  = 14;
    IMAGE_SYM_TYPE_DWORD = 15;
    IMAGE_SYM_TYPE_PCODE = 08000h;

    IMAGE_SYM_DTYPE_NULL = 0;
    IMAGE_SYM_DTYPE_POINTER     = 1;
    IMAGE_SYM_DTYPE_FUNCTION    = 2;
    IMAGE_SYM_DTYPE_ARRAY       = 3;
    IMAGE_SYM_CLASS_END_OF_FUNCTION     = -1;
    IMAGE_SYM_CLASS_NULL        = 0;
    IMAGE_SYM_CLASS_AUTOMATIC   = 1;
    IMAGE_SYM_CLASS_EXTERNAL    = 2;
    IMAGE_SYM_CLASS_STATIC      = 3;
    IMAGE_SYM_CLASS_REGISTER    = 4;
    IMAGE_SYM_CLASS_EXTERNAL_DEF= 5;
    IMAGE_SYM_CLASS_LABEL       = 6;
    IMAGE_SYM_CLASS_UNDEFINED_LABEL     = 7;
    IMAGE_SYM_CLASS_MEMBER_OF_STRUCT    = 8;
    IMAGE_SYM_CLASS_ARGUMENT            = 9;
    IMAGE_SYM_CLASS_STRUCT_TAG          = 10;
    IMAGE_SYM_CLASS_MEMBER_OF_UNION     = 11;
    IMAGE_SYM_CLASS_UNION_TAG           = 12;
    IMAGE_SYM_CLASS_TYPE_DEFINITION     = 13;
    IMAGE_SYM_CLASS_UNDEFINED_STATIC    = 14;
    IMAGE_SYM_CLASS_ENUM_TAG            = 15;
    IMAGE_SYM_CLASS_MEMBER_OF_ENUM      = 16;
    IMAGE_SYM_CLASS_REGISTER_PARAM      = 17;
    IMAGE_SYM_CLASS_BIT_FIELD           = 18;
    IMAGE_SYM_CLASS_FAR_EXTERNAL        = 44h;
    IMAGE_SYM_CLASS_BLOCK               = 100;
    IMAGE_SYM_CLASS_FUNCTION            = 101;
    IMAGE_SYM_CLASS_END_OF_STRUCT       = 102;
    IMAGE_SYM_CLASS_FILE                = 103;
    IMAGE_SYM_CLASS_SECTION             = 104;
    IMAGE_SYM_CLASS_WEAK_EXTERNAL       = 105;
    N_BTMASK             = 017;
    N_TMASK              = 060;
    N_TMASK1             = 0300;
    N_TMASK2             = 0360;
    N_BTSHFT             = 4;
    N_TSHIFT             = 2;
TYPE
    LnSz = RECORD
          Linenumber     : WORD;
          Size           : WORD;
    END;

    Misc2 = RECORD
        CASE : CARDINAL OF
          0 : LnSz       : LnSz;
          |
          1 : TotalSize  : DWORD;
          ELSE
        END;
    END;

    Function = RECORD
          PointerToLinenumber: DWORD;
          PointerToNextFunction: DWORD;
    END;

    Array = RECORD
          Dimension      : ARRAY [0..4 - 1] OF WORD;
    END;

    FcnAry = RECORD
        CASE : CARDINAL OF
          0 : Function   : Function;
          |
          1 : Array      : Array;
          ELSE
        END;
    END;

    Sym = RECORD
          TagIndex       : DWORD;
          Misc           : Misc2;
          FcnAry         : FcnAry;
          TvIndex        : WORD;
    END;

    File = RECORD
          Name           : ARRAY [0..IMAGE_SIZEOF_SYMBOL - 1] OF BYTE;
    END;

    Section = RECORD
          Length         : DWORD;
          NumberOfRelocations: WORD;
          NumberOfLinenumbers: WORD;
          CheckSum       : DWORD;
          Number         : SHORT;
          Selection      : BYTE;
    END;

    SymStruct = RECORD
        TagIndex                : DWORD;
        CASE : BOOLEAN OF
        TRUE :
                Linenumber      : WORD;
                Size            : WORD;
        |
        FALSE :
                TotalSize : DWORD;
        END;
        CASE :BOOLEAN OF
        TRUE :
            PointerToLinenumber         : DWORD;
            PointerToNextFunction       : DWORD;
        |
        FALSE  :
            Dimension                   : ARRAY [0..4-1] OF WORD;
        END;
        TvIndex         : WORD;
    END;
    SectionStruct = RECORD
        Length                  : DWORD;
        NumberOfRelocations     : WORD;
        NumberOfLinenumbers     : WORD;
        CheckSum                : DWORD;
        Number                  : SHORT;
        Selection               : BYTE;
    END;

    IMAGE_AUX_SYMBOL = RECORD
        Sym     : SymStruct;
        Name    : ARRAY [0..IMAGE_SIZEOF_SYMBOL-1] OF BYTE;
        Section : SectionStruct;
    END;
    PIMAGE_AUX_SYMBOL   = POINTER TO IMAGE_AUX_SYMBOL;

CONST
    IMAGE_SIZEOF_AUX_SYMBOL             = 18;
    IMAGE_COMDAT_SELECT_UNKNOWN         = 0;
    IMAGE_COMDAT_SELECT_NODUPLICATES    = 1;
    IMAGE_COMDAT_SELECT_ANY             = 2;
    IMAGE_COMDAT_SELECT_SAME_SIZE       = 3;
    IMAGE_COMDAT_SELECT_EXACT_MATCH     = 4;
    IMAGE_COMDAT_SELECT_ASSOCIATIVE     = 5;
    IMAGE_COMDAT_SELECT_LARGEST         = 6;
    IMAGE_COMDAT_SELECT_NEWEST          = 7;

    IMAGE_WEAK_EXTERN_SEARCH_UNKNOWN    = 0;
    IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY  = 1;
    IMAGE_WEAK_EXTERN_SEARCH_LIBRARY    = 2;
    IMAGE_WEAK_EXTERN_SEARCH_ALIAS      = 3;

TYPE
    IMAGE_RELOCATION = RECORD
          VirtualAddress : DWORD;
          SymbolTableIndex: DWORD;
          Type           : WORD;
    END;
    PIMAGE_RELOCATION    = POINTER TO IMAGE_RELOCATION;

CONST
    IMAGE_SIZEOF_RELOCATION= 10;
    IMAGE_REL_I860_ABSOLUTE= 0;
    IMAGE_REL_I860_DIR32 = 06;
    IMAGE_REL_I860_DIR32NB= 07;
    IMAGE_REL_I860_SECTION= 012;
    IMAGE_REL_I860_SECREL= 013;

    IMAGE_REL_I860_PAIR  = 034;
    IMAGE_REL_I860_HIGH  = 036;
    IMAGE_REL_I860_LOW0  = 037;
    IMAGE_REL_I860_LOW1  = 040;
    IMAGE_REL_I860_LOW2  = 041;
    IMAGE_REL_I860_LOW3  = 042;
    IMAGE_REL_I860_LOW4  = 043;
    IMAGE_REL_I860_SPLIT0= 044;
    IMAGE_REL_I860_SPLIT1= 045;
    IMAGE_REL_I860_SPLIT2= 046;
    IMAGE_REL_I860_HIGHADJ= 047;
    IMAGE_REL_I860_BRADDR= 050;

    IMAGE_REL_I386_ABSOLUTE= 0;
    IMAGE_REL_I386_DIR16 = 01;
    IMAGE_REL_I386_REL16 = 02;
    IMAGE_REL_I386_DIR32 = 06;
    IMAGE_REL_I386_DIR32NB= 07;
    IMAGE_REL_I386_SEG12 = 010;
    IMAGE_REL_I386_SECTION= 012;
    IMAGE_REL_I386_SECREL= 011;
    IMAGE_REL_I386_REL32 = 020;

    IMAGE_REL_MIPS_ABSOLUTE= 0;
    IMAGE_REL_MIPS_REFHALF= 01;
    IMAGE_REL_MIPS_REFWORD= 02;
    IMAGE_REL_MIPS_JMPADDR= 03;
    IMAGE_REL_MIPS_REFHI = 04;
    IMAGE_REL_MIPS_REFLO = 05;
    IMAGE_REL_MIPS_GPREL = 06;
    IMAGE_REL_MIPS_LITERAL= 07;
    IMAGE_REL_MIPS_SECTION      = 10;
    IMAGE_REL_MIPS_SECREL       = 11;
    IMAGE_REL_MIPS_SECRELLO     = 12;
    IMAGE_REL_MIPS_SECRELHI     = 13;
    IMAGE_REL_MIPS_REFWORDNB    = 22;
    IMAGE_REL_MIPS_PAIR         = 25;

    IMAGE_REL_ALPHA_ABSOLUTE= 00h;
    IMAGE_REL_ALPHA_REFLONG= 01h;
    IMAGE_REL_ALPHA_REFQUAD= 02h;
    IMAGE_REL_ALPHA_GPREL32= 03h;
    IMAGE_REL_ALPHA_LITERAL= 04h;
    IMAGE_REL_ALPHA_LITUSE= 05h;
    IMAGE_REL_ALPHA_GPDISP= 06h;
    IMAGE_REL_ALPHA_BRADDR= 07h;
    IMAGE_REL_ALPHA_HINT = 08h;
    IMAGE_REL_ALPHA_INLINE_REFLONG= 09h;
    IMAGE_REL_ALPHA_REFHI       = 0Ah;
    IMAGE_REL_ALPHA_REFLO       = 0Bh;
    IMAGE_REL_ALPHA_PAIR        = 0Ch;
    IMAGE_REL_ALPHA_MATCH       = 0Dh;
    IMAGE_REL_ALPHA_SECTION     = 0Eh;
    IMAGE_REL_ALPHA_SECREL      = 0Fh;
    IMAGE_REL_ALPHA_SECRELLO    = 11h;
    IMAGE_REL_ALPHA_SECRELHI    = 12h;

    IMAGE_REL_ALPHA_REFLONGNB= 010h;

    (* IBM PowerPC relocation types. *)

    IMAGE_REL_PPC_ABSOLUTE = 0000h;  (* NOP *)
    IMAGE_REL_PPC_ADDR64 = 0001h;  (* 64-bit address *)
    IMAGE_REL_PPC_ADDR32 = 0002h;  (* 32-bit address *)
    IMAGE_REL_PPC_ADDR24 = 0003h;  (* 26-bit address, shifted left 2 (branch absolute) *)
    IMAGE_REL_PPC_ADDR16 = 0004h;  (* 16-bit address *)
    IMAGE_REL_PPC_ADDR14   = 0005h;  (* 16-bit address, shifted left 2 (load doubleword) *)
    IMAGE_REL_PPC_REL24    = 0006h;  (* 26-bit PC-relative offset, shifted left 2 (branch relative) *)
    IMAGE_REL_PPC_REL14    = 0007h;  (* 16-bit PC-relative offset, shifted left 2 (br cond relative) *)
    IMAGE_REL_PPC_TOCREL16 = 0008h;  (* 16-bit offset from TOC base *)
    IMAGE_REL_PPC_TOCREL14 = 0009h;  (* 16-bit offset from TOC base, shifted left 2 (load doubleword) *)

    IMAGE_REL_PPC_ADDR32NB = 000Ah;  (* 32-bit addr w/o image base *)
    IMAGE_REL_PPC_SECREL   = 000Bh;  (* va of containing section (as in an image sectionhdr) *)
    IMAGE_REL_PPC_SECTION  = 000Ch;  (* sectionheader number *)
    IMAGE_REL_PPC_IFGLUE   = 000Dh;  (* substitute TOC restore instruction iff symbol is glue code *)
    IMAGE_REL_PPC_IMGLUE   = 000Eh;  (* symbol is glue code; virtual address is TOC restore instruction *)
    IMAGE_REL_PPC_SECREL16 = 000Fh;  (* va of containing section (limited to 16 bits) *)
    IMAGE_REL_PPC_REFHI    = 0010h;
    IMAGE_REL_PPC_REFLO    = 0011h;
    IMAGE_REL_PPC_PAIR     = 0012h;

    IMAGE_REL_PPC_TYPEMASK = 00FFh;  (* mask to isolate above values in IMAGE_RELOCATION.Type *)

    (* Flag bits in IMAGE_RELOCATION.TYPE *)

    IMAGE_REL_PPC_NEG      = 0100h;  (* subtract reloc value rather th;an adding it *)
    IMAGE_REL_PPC_BRTAKEN  = 0200h;  (* fix branch prediction bit to predict branch taken *)
    IMAGE_REL_PPC_BRNTAKEN = 0400h;  (* fix branch prediction bit to predict branch not taken *)
    IMAGE_REL_PPC_TOCDEFN  = 0800h;  (* toc slot defined in file (or, data in toc) *)

TYPE
    IMAGE_BASE_RELOCATION = RECORD
          VirtualAddress : DWORD;
          SizeOfBlock    : DWORD;
    END;
    PIMAGE_BASE_RELOCATION= POINTER TO IMAGE_BASE_RELOCATION;

CONST
    IMAGE_SIZEOF_BASE_RELOCATION= 8;
    IMAGE_REL_BASED_ABSOLUTE= 0;
    IMAGE_REL_BASED_HIGH = 1;
    IMAGE_REL_BASED_LOW  = 2;
    IMAGE_REL_BASED_HIGHLOW= 3;
    IMAGE_REL_BASED_HIGHADJ= 4;
    IMAGE_REL_BASED_MIPS_JMPADDR= 5;
    IMAGE_REL_BASED_I860_BRADDR= 6;
    IMAGE_REL_BASED_I860_SPLIT= 7;

TYPE
    IMAGE_LINENUMBER = RECORD
        VirtualAddress  : DWORD;
        Linenumber      : WORD;
    END;
    PIMAGE_LINENUMBER   = POINTER TO IMAGE_LINENUMBER;

CONST
    IMAGE_SIZEOF_LINENUMBER              = 6;

TYPE
    Type = RECORD
        CASE : CARDINAL OF
          0 : SymbolTableIndex: DWORD;
          |
          1 : VirtualAddress: DWORD;
          ELSE
        END;
    END;

CONST
    IMAGE_ARCHIVE_START_SIZE             = 8;
    IMAGE_ARCHIVE_START                  = "!<arch>" + CHR(10);
    IMAGE_ARCHIVE_END                    = "`" + CHR(10);
    IMAGE_ARCHIVE_PAD                    = CHR(10);
    IMAGE_ARCHIVE_LINKER_MEMBER          = "/               ";
    IMAGE_ARCHIVE_LONGNAMES_MEMBER       = "//              ";

TYPE
    IMAGE_ARCHIVE_MEMBER_HEADER = RECORD
          Name           : ARRAY [0..16 - 1] OF BYTE;
          Date           : ARRAY [0..12 - 1] OF BYTE;
          UserID         : ARRAY [0..6 - 1] OF BYTE;
          GroupID        : ARRAY [0..6 - 1] OF BYTE;
          Mode           : ARRAY [0..8 - 1] OF BYTE;
          Size           : ARRAY [0..10 - 1] OF BYTE;
          EndHeader      : ARRAY [0..2 - 1] OF BYTE;
    END;
    PIMAGE_ARCHIVE_MEMBER_HEADER= POINTER TO IMAGE_ARCHIVE_MEMBER_HEADER;

CONST
    IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR= 60;

TYPE
    IMAGE_EXPORT_DIRECTORY = RECORD
          Characteristics: DWORD;
          TimeDateStamp  : DWORD;
          MajorVersion   : WORD;
          MinorVersion   : WORD;
          Name           : DWORD;
          Base           : DWORD;
          NumberOfFunctions: DWORD;
          NumberOfNames  : DWORD;
          AddressOfFunctions: POINTER TO PDWORD;
          AddressOfNames : POINTER TO PDWORD;
          AddressOfNameOrdinals: POINTER TO PWORD;
    END;
    PIMAGE_EXPORT_DIRECTORY= POINTER TO IMAGE_EXPORT_DIRECTORY;

    IMAGE_IMPORT_BY_NAME = RECORD
          Hint           : WORD;
          Name           : ARRAY [0..1 - 1] OF BYTE;
    END;
    PIMAGE_IMPORT_BY_NAME= POINTER TO IMAGE_IMPORT_BY_NAME;

    IMAGE_IMPORT_DESCRIPTOR  = RECORD
        Characteristics         : DWORD;
        TimeDateStamp           : DWORD;
        ForwarderChain          : DWORD;
        Name                    : DWORD;
        FirstThunk              : PVOID;
    END;
    IMAGE_BOUND_IMPORT_DESCRIPTOR = RECORD
        TimeDateStamp                   : DWORD;
        OffsetModuleName                : WORD;
        NumberOfModuleForwarderRefs     : WORD;
    END;
    LPIMAGE_BOUND_IMPORT_DESCRIPTOR     = POINTER TO IMAGE_BOUND_IMPORT_DESCRIPTOR;

    IMAGE_BOUND_FORWARDER_REF = RECORD
        TimeDateStamp                   : DWORD;
        OffsetModuleName                : WORD;
        Reserved                        : WORD;
    END;
    PIMAGE_BOUND_FORWARDER_REF          = POINTER TO IMAGE_BOUND_FORWARDER_REF;


CONST
    IMAGE_ORDINAL_FLAG   = 080000000h;

TYPE
    PIMAGE_TLS_CALLBACK  = PROCEDURE(PVOID, DWORD, PVOID) [EXPORT];
    IMAGE_TLS_DIRECTORY = RECORD
          StartAddressOfRawData: DWORD;
          EndAddressOfRawData: DWORD;
          AddressOfIndex : PDWORD;
          AddressOfCallBacks: POINTER TO PIMAGE_TLS_CALLBACK;
          SizeOfZeroFill : DWORD;
          Characteristics: DWORD;
    END;
    PIMAGE_TLS_DIRECTORY = POINTER TO IMAGE_TLS_DIRECTORY;

    IMAGE_RESOURCE_DIRECTORY = RECORD
          Characteristics: DWORD;
          TimeDateStamp  : DWORD;
          MajorVersion   : WORD;
          MinorVersion   : WORD;
          NumberOfNamedEntries: WORD;
          NumberOfIdEntries: WORD;
    END;
    PIMAGE_RESOURCE_DIRECTORY= POINTER TO IMAGE_RESOURCE_DIRECTORY;

CONST
    IMAGE_RESOURCE_NAME_IS_STRING= 080000000h;
    IMAGE_RESOURCE_DATA_IS_DIRECTORY= 080000000h;

TYPE
    IMAGE_RESOURCE_DIRECTORY_ENTRY = RECORD
          Name           : DWORD;
          OffsetToData   : DWORD;
    END;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY= POINTER TO IMAGE_RESOURCE_DIRECTORY_ENTRY;

    IMAGE_RESOURCE_DIRECTORY_STRING = RECORD
          Length         : WORD;
          NameString     : ARRAY [0..1 - 1] OF ACHAR;
    END;
    PIMAGE_RESOURCE_DIRECTORY_STRING= POINTER TO IMAGE_RESOURCE_DIRECTORY_STRING;

    IMAGE_RESOURCE_DIR_STRING_U = RECORD
          Length         : WORD;
          NameString     : ARRAY [0..1 - 1] OF WCHAR;
    END;
    PIMAGE_RESOURCE_DIR_STRING_U= POINTER TO IMAGE_RESOURCE_DIR_STRING_U;

    IMAGE_RESOURCE_DATA_ENTRY = RECORD
          OffsetToData   : DWORD;
          Size           : DWORD;
          CodePage       : DWORD;
          Reserved       : DWORD;
    END;
    PIMAGE_RESOURCE_DATA_ENTRY= POINTER TO IMAGE_RESOURCE_DATA_ENTRY;

    IMAGE_LOAD_CONFIG_DIRECTORY = RECORD
          Characteristics: DWORD;
          TimeDateStamp  : DWORD;
          MajorVersion   : WORD;
          MinorVersion   : WORD;
          GlobalFlagsClear: DWORD;
          GlobalFlagsSet : DWORD;
          CriticalSectionDefaultTimeout: DWORD;
          DeCommitFreeBlockThreshold: DWORD;
          DeCommitTotalFreeThreshold: DWORD;
          Reserved       : ARRAY [0..8 - 1] OF DWORD;
    END;
    PIMAGE_LOAD_CONFIG_DIRECTORY= POINTER TO IMAGE_LOAD_CONFIG_DIRECTORY;

    IMAGE_RUNTIME_FUNCTION_ENTRY = RECORD
          BeginAddress   : DWORD;
          EndAddress     : DWORD;
          ExceptionHandler: PVOID;
          HandlerData    : PVOID;
          PrologEndAddress: DWORD;
    END;
    PIMAGE_RUNTIME_FUNCTION_ENTRY= POINTER TO IMAGE_RUNTIME_FUNCTION_ENTRY;

    IMAGE_DEBUG_DIRECTORY = RECORD
          Characteristics: DWORD;
          TimeDateStamp  : DWORD;
          MajorVersion   : WORD;
          MinorVersion   : WORD;
          Type           : DWORD;
          SizeOfData     : DWORD;
          AddressOfRawData: DWORD;
          PointerToRawData: DWORD;
    END;
    PIMAGE_DEBUG_DIRECTORY= POINTER TO IMAGE_DEBUG_DIRECTORY;

CONST
    IMAGE_DEBUG_TYPE_UNKNOWN            = 0;
    IMAGE_DEBUG_TYPE_COFF               = 1;
    IMAGE_DEBUG_TYPE_CODEVIEW           = 2;
    IMAGE_DEBUG_TYPE_FPO                = 3;
    IMAGE_DEBUG_TYPE_MISC               = 4;
    IMAGE_DEBUG_TYPE_EXCEPTION          = 5;
    IMAGE_DEBUG_TYPE_FIXUP              = 6;
    IMAGE_DEBUG_TYPE_OMAP_TO_SRC        = 7;
    IMAGE_DEBUG_TYPE_OMAP_FROM_SRC      = 8;

TYPE
    IMAGE_COFF_SYMBOLS_HEADER = RECORD
          NumberOfSymbols: DWORD;
          LvaToFirstSymbol: DWORD;
          NumberOfLinenumbers: DWORD;
          LvaToFirstLinenumber: DWORD;
          RvaToFirstByteOfCode: DWORD;
          RvaToLastByteOfCode: DWORD;
          RvaToFirstByteOfData: DWORD;
          RvaToLastByteOfData: DWORD;
    END;
    PIMAGE_COFF_SYMBOLS_HEADER= POINTER TO IMAGE_COFF_SYMBOLS_HEADER;

CONST
    FRAME_FPO            = 0;
    FRAME_TRAP           = 1;
    FRAME_TSS            = 2;
    FRAME_NONFPO         = 3;

TYPE
    FPO_DATA = RECORD
        ulOffStart      : DWORD;
        cbProcSize      : DWORD;
        cdwLocals       : DWORD;
        cdwParams       : WORD;
        w1              : WORD;
        w2              : WORD;
    END;
    PFPO_DATA   = POINTER TO FPO_DATA;

CONST
    SIZEOF_RFPO_DATA     = 16;
    IMAGE_DEBUG_MISC_EXENAME= 1;

TYPE
    IMAGE_DEBUG_MISC = RECORD
          DataType       : DWORD;
          Length         : DWORD;
          Unicode        : BOOLEAN;
          Reserved       : ARRAY [0..3 - 1] OF BYTE;
          Data           : ARRAY [0..1 - 1] OF BYTE;
    END;
    PIMAGE_DEBUG_MISC    = POINTER TO IMAGE_DEBUG_MISC;

    IMAGE_FUNCTION_ENTRY = RECORD
        StartingAddress         : DWORD;
        EndingAddress           : DWORD;
        EndOfPrologue           : DWORD;
    END;
    PIMAGE_FUNCTION_ENTRY       = POINTER TO IMAGE_FUNCTION_ENTRY;

    IMAGE_SEPARATE_DEBUG_HEADER = RECORD
          Signature      : WORD;
          Flags          : WORD;
          Machine        : WORD;
          Characteristics: WORD;
          TimeDateStamp  : DWORD;
          CheckSum       : DWORD;
          ImageBase      : DWORD;
          SizeOfImage    : DWORD;
          NumberOfSections: DWORD;
          ExportedNamesSize: DWORD;
          DebugDirectorySize: DWORD;
          Reserved       : ARRAY [0..3 - 1] OF DWORD;
    END;
    PIMAGE_SEPARATE_DEBUG_HEADER= POINTER TO IMAGE_SEPARATE_DEBUG_HEADER;

CONST
    IMAGE_SEPARATE_DEBUG_SIGNATURE= 04944h;

<*/POP*>
(* end of PE|COFF image stuff *)

CONST
    HEAP_NO_SERIALIZE           = 000000001h;
    HEAP_GROWABLE               = 000000002h;
    HEAP_GENERATE_EXCEPTIONS    = 000000004h;
    HEAP_ZERO_MEMORY            = 000000008h;
    HEAP_REALLOC_IN_PLACE_ONLY  = 000000010h;
    HEAP_TAIL_CHECKING_ENABLED  = 000000020h;
    HEAP_FREE_CHECKING_ENABLED  = 000000040h;
    HEAP_DISABLE_COALESCE_ON_FREE= 000000080h;
    HEAP_CREATE_ALIGN_16         = 000010000h;
    HEAP_CREATE_ENABLE_TRACING   = 000020000h;
    HEAP_MAXIMUM_TAG             = 00FFFh;
    HEAP_PSEUDO_TAG_FLAG         = 08000h;
    HEAP_TAG_SHIFT               = 16;

    IS_TEXT_UNICODE_ASCII16               = 0001h;
    IS_TEXT_UNICODE_REVERSE_ASCII16       = 0010h;

    IS_TEXT_UNICODE_STATISTICS            = 0002h;
    IS_TEXT_UNICODE_REVERSE_STATISTICS    = 0020h;

    IS_TEXT_UNICODE_CONTROLS              = 0004h;
    IS_TEXT_UNICODE_REVERSE_CONTROLS      = 0040h;

    IS_TEXT_UNICODE_SIGNATURE             = 0008h;
    IS_TEXT_UNICODE_REVERSE_SIGNATURE     = 0080h;

    IS_TEXT_UNICODE_ILLEGAL_CHARS         = 0100h;
    IS_TEXT_UNICODE_ODD_LENGTH            = 0200h;
    IS_TEXT_UNICODE_DBCS_LEADBYTE         = 0400h;
    IS_TEXT_UNICODE_NULL_BYTES            = 1000h;

    IS_TEXT_UNICODE_UNICODE_MASK          = 0000Fh;
    IS_TEXT_UNICODE_REVERSE_MASK          = 000F0h;
    IS_TEXT_UNICODE_NOT_UNICODE_MASK      = 00F00h;
    IS_TEXT_UNICODE_NOT_ASCII_MASK        = 0F000h;

    COMPRESSION_FORMAT_NONE          = 0000h;
    COMPRESSION_FORMAT_DEFAULT       = 0001h;
    COMPRESSION_FORMAT_LZNT1         = 0002h;
    COMPRESSION_ENGINE_STANDARD      = 0000h;
    COMPRESSION_ENGINE_MAXIMUM       = 0100h;

TYPE
    RTL_CRITICAL_SECTION_DEBUG = RECORD
          Type           : WORD;
          CreatorBackTraceIndex: WORD;
          CriticalSection: POINTER TO RTL_CRITICAL_SECTION;
          ProcessLocksList: LIST_ENTRY;
          EntryCount     : DWORD;
          ContentionCount: DWORD;
          Spare          : ARRAY [0..1] OF DWORD;
    END;
    PRTL_CRITICAL_SECTION_DEBUG= POINTER TO RTL_CRITICAL_SECTION_DEBUG;

CONST
    RTL_CRITSECT_TYPE    = 0;
    RTL_RESOURCE_TYPE    = 1;

TYPE
    RTL_CRITICAL_SECTION = RECORD
        DebugInfo            : PRTL_CRITICAL_SECTION_DEBUG;
        LockCount            : LONG;
        RecursionCount       : LONG;
        OwningThread         : HANDLE;
        LockSemaphore        : HANDLE;
        SpinCount            : DWORD;
    END;
    PRTL_CRITICAL_SECTION       =  POINTER TO RTL_CRITICAL_SECTION;

CONST
    DLL_PROCESS_ATTACH   = 1;
    DLL_THREAD_ATTACH    = 2;
    DLL_THREAD_DETACH    = 3;
    DLL_PROCESS_DETACH   = 0;
    EVENTLOG_SEQUENTIAL_READ= 00001h;
    EVENTLOG_SEEK_READ   = 00002h;
    EVENTLOG_FORWARDS_READ= 00004h;
    EVENTLOG_BACKWARDS_READ= 00008h;
    EVENTLOG_SUCCESS     = 00000h;
    EVENTLOG_ERROR_TYPE  = 00001h;
    EVENTLOG_WARNING_TYPE= 00002h;
    EVENTLOG_INFORMATION_TYPE= 00004h;
    EVENTLOG_AUDIT_SUCCESS= 00008h;
    EVENTLOG_AUDIT_FAILURE= 00010h;
    EVENTLOG_START_PAIRED_EVENT= 00001h;
    EVENTLOG_END_PAIRED_EVENT= 00002h;
    EVENTLOG_END_ALL_PAIRED_EVENTS= 00004h;
    EVENTLOG_PAIRED_EVENT_ACTIVE= 00008h;
    EVENTLOG_PAIRED_EVENT_INACTIVE= 00010h;

TYPE
    EVENTLOGRECORD = RECORD
          Length         : DWORD;
          Reserved       : DWORD;
          RecordNumber   : DWORD;
          TimeGenerated  : DWORD;
          TimeWritten    : DWORD;
          EventID        : DWORD;
          EventType      : WORD;
          NumStrings     : WORD;
          EventCategory  : WORD;
          ReservedFlags  : WORD;
          ClosingRecordNumber: DWORD;
          StringOffset   : DWORD;
          UserSidLength  : DWORD;
          UserSidOffset  : DWORD;
          DataLength     : DWORD;
          DataOffset     : DWORD;
    END;
    PEVENTLOGRECORD      = POINTER TO EVENTLOGRECORD;

CONST
    DBG_CONTINUE                = 00010002h;
    DBG_TERMINATE_THREAD        = 40010003h;
    DBG_TERMINATE_PROCESS       = 40010004h;
    DBG_CONTROL_C               = 40010005h;
    DBG_CONTROL_BREAK           = 40010008h;
    DBG_EXCEPTION_NOT_HANDLED   = 80010001h;
    KEY_QUERY_VALUE             = 0001h;
    KEY_SET_VALUE               = 0002h;
    KEY_CREATE_SUB_KEY          = 0004h;
    KEY_ENUMERATE_SUB_KEYS      = 0008h;
    KEY_NOTIFY                  = 0010h;
    KEY_CREATE_LINK             = 0020h;
    KEY_READ    = (
                          STANDARD_RIGHTS_READ BOR
                         KEY_QUERY_VALUE BOR
                         KEY_ENUMERATE_SUB_KEYS BOR
                          KEY_NOTIFY
                          )
                          BAND
                          ( BNOT SYNCHRONIZE );
    KEY_WRITE           = (
                          STANDARD_RIGHTS_WRITE BOR
                          KEY_SET_VALUE BOR
                          KEY_CREATE_SUB_KEY
                          )
                          BAND
                          ( BNOT SYNCHRONIZE );
    KEY_EXECUTE         = KEY_READ BAND (BNOT SYNCHRONIZE );
    KEY_ALL_ACCESS    =
                          (
                          STANDARD_RIGHTS_ALL BOR
                          KEY_QUERY_VALUE BOR
                          KEY_SET_VALUE BOR
                          KEY_CREATE_SUB_KEY BOR
                          KEY_ENUMERATE_SUB_KEYS BOR
                          KEY_NOTIFY BOR
                          KEY_CREATE_LINK
                          )
                          BAND
                          (BNOT SYNCHRONIZE);
    REG_OPTION_RESERVED         = 0;
    REG_OPTION_NON_VOLATILE     = 0;
    REG_OPTION_VOLATILE         = 1;
    REG_OPTION_CREATE_LINK      = 2;
    REG_OPTION_BACKUP_RESTORE  = 4;
    REG_LEGAL_OPTION    = (
                          REG_OPTION_RESERVED BOR
                          REG_OPTION_NON_VOLATILE BOR
                          REG_OPTION_VOLATILE BOR
                          REG_OPTION_CREATE_LINK BOR
                          REG_OPTION_BACKUP_RESTORE
                          );
    REG_CREATED_NEW_KEY         = 1;
    REG_OPENED_EXISTING_KEY     = 2;
    REG_WHOLE_HIVE_VOLATILE     = 1;
    REG_REFRESH_HIVE            = 2;
    REG_NOTIFY_CHANGE_NAME      = 1;
    REG_NOTIFY_CHANGE_ATTRIBUTES= 2;
    REG_NOTIFY_CHANGE_LAST_SET = 4;
    REG_NOTIFY_CHANGE_SECURITY = 8;
    REG_LEGAL_CHANGE_FILTER     = REG_NOTIFY_CHANGE_NAME BOR
                                 REG_NOTIFY_CHANGE_ATTRIBUTES BOR
                                 REG_NOTIFY_CHANGE_LAST_SET BOR
                                 REG_NOTIFY_CHANGE_SECURITY;
    REG_NONE             = 0;
    REG_SZ               = 1;
    REG_EXPAND_SZ        = 2;
    REG_BINARY           = 3;
    REG_DWORD            = 4;
    REG_DWORD_LITTLE_ENDIAN= 4;
    REG_DWORD_BIG_ENDIAN = 5;
    REG_LINK             = 6;
    REG_MULTI_SZ         = 7;
    REG_RESOURCE_LIST    = 8;
    REG_FULL_RESOURCE_DESCRIPTOR        = 9;
    REG_RESOURCE_REQUIREMENTS_LIST      = 10;

    SERVICE_KERNEL_DRIVER               = 000000001h;
    SERVICE_FILE_SYSTEM_DRIVER          = 000000002h;
    SERVICE_ADAPTER                     = 000000004h;
    SERVICE_RECOGNIZER_DRIVER           = 000000008h;
    SERVICE_DRIVER       = (SERVICE_KERNEL_DRIVER BOR
                            SERVICE_FILE_SYSTEM_DRIVER BOR
                            SERVICE_RECOGNIZER_DRIVER);
    SERVICE_WIN32_OWN_PROCESS           = 000000010h;
    SERVICE_WIN32_SHARE_PROCESS         = 000000020h;
    SERVICE_WIN32        = (SERVICE_WIN32_OWN_PROCESS BOR
                            SERVICE_WIN32_SHARE_PROCESS);

    SERVICE_INTERACTIVE_PROCESS    = 000000100h;

    SERVICE_TYPE_ALL     = SERVICE_WIN32 BOR
                           SERVICE_ADAPTER BOR
                           SERVICE_DRIVER BOR
                           SERVICE_INTERACTIVE_PROCESS;

    SERVICE_BOOT_START   = 000000000h;
    SERVICE_SYSTEM_START = 000000001h;
    SERVICE_AUTO_START   = 000000002h;
    SERVICE_DEMAND_START = 000000003h;
    SERVICE_DISABLED     = 000000004h;
    SERVICE_ERROR_IGNORE = 000000000h;
    SERVICE_ERROR_NORMAL = 000000001h;
    SERVICE_ERROR_SEVERE = 000000002h;
    SERVICE_ERROR_CRITICAL= 000000003h;

TYPE
    SERVICE_NODE_TYPE = (DriverType, FileSystemType, Win32ServiceOwnProcess, Win32ServiceShareProcess, AdapterType, RecognizerType) BIG;
    SERVICE_LOAD_TYPE = (BootLoad, SystemLoad, AutoLoad, DemandLoad, DisableLoad) BIG;
    ERROR_CONTROL_TYPE = (IgnoreError, NormalError, SevereError, CriticalError) BIG;

CONST
    TAPE_ERASE_SHORT     = 0;
    TAPE_ERASE_LONG      = 1;

TYPE
    TAPE_ERASE = RECORD
          Type           : DWORD;
          Immediate      : BOOLEAN;
    END;
    PTAPE_ERASE          = POINTER TO TAPE_ERASE;

CONST
    TAPE_LOAD            = 0;
    TAPE_UNLOAD          = 1;
    TAPE_TENSION         = 2;
    TAPE_LOCK            = 3;
    TAPE_UNLOCK          = 4;
    TAPE_FORMAT          = 5;

TYPE
    TAPE_PREPARE = RECORD
          Operation      : DWORD;
          Immediate      : BOOLEAN;
    END;
    PTAPE_PREPARE        = POINTER TO TAPE_PREPARE;

CONST
    TAPE_SETMARKS        = 0;
    TAPE_FILEMARKS       = 1;
    TAPE_SHORT_FILEMARKS = 2;
    TAPE_LONG_FILEMARKS  = 3;

TYPE
    TAPE_WRITE_MARKS = RECORD
          Type           : DWORD;
          Count          : DWORD;
          Immediate      : BOOLEAN;
    END;
    PTAPE_WRITE_MARKS    = POINTER TO TAPE_WRITE_MARKS;

CONST
    TAPE_ABSOLUTE_POSITION= 0;
    TAPE_LOGICAL_POSITION= 1;
    TAPE_PSEUDO_LOGICAL_POSITION= 2;

TYPE
    TAPE_GET_POSITION = RECORD
          Type           : DWORD;
          Partition      : DWORD;
          Offset         : LARGE_INTEGER;
    END;
    PTAPE_GET_POSITION   = POINTER TO TAPE_GET_POSITION;

CONST
    TAPE_REWIND          = 0;
    TAPE_ABSOLUTE_BLOCK  = 1;
    TAPE_LOGICAL_BLOCK   = 2;
    TAPE_PSEUDO_LOGICAL_BLOCK= 3;
    TAPE_SPACE_END_OF_DATA= 4;
    TAPE_SPACE_RELATIVE_BLOCKS= 5;
    TAPE_SPACE_FILEMARKS = 6;
    TAPE_SPACE_SEQUENTIAL_FMKS= 7;
    TAPE_SPACE_SETMARKS  = 8;
    TAPE_SPACE_SEQUENTIAL_SMKS= 9;

TYPE
    TAPE_SET_POSITION = RECORD
          Method         : DWORD;
          Partition      : DWORD;
          Offset         : LARGE_INTEGER;
          Immediate      : BOOLEAN;
    END;
    PTAPE_SET_POSITION   = POINTER TO TAPE_SET_POSITION;

CONST
    TAPE_DRIVE_FIXED     = 000000001h;
    TAPE_DRIVE_SELECT    = 000000002h;
    TAPE_DRIVE_INITIATOR = 000000004h;
    TAPE_DRIVE_ERASE_SHORT= 000000010h;
    TAPE_DRIVE_ERASE_LONG= 000000020h;
    TAPE_DRIVE_ERASE_BOP_ONLY= 000000040h;
    TAPE_DRIVE_ERASE_IMMEDIATE= 000000080h;
    TAPE_DRIVE_TAPE_CAPACITY= 000000100h;
    TAPE_DRIVE_TAPE_REMAINING= 000000200h;
    TAPE_DRIVE_FIXED_BLOCK= 000000400h;
    TAPE_DRIVE_VARIABLE_BLOCK= 000000800h;
    TAPE_DRIVE_WRITE_PROTECT= 000001000h;
    TAPE_DRIVE_EOT_WZ_SIZE= 000002000h;
    TAPE_DRIVE_ECC       = 000010000h;
    TAPE_DRIVE_COMPRESSION= 000020000h;
    TAPE_DRIVE_PADDING   = 000040000h;
    TAPE_DRIVE_REPORT_SMKS= 000080000h;
    TAPE_DRIVE_GET_ABSOLUTE_BLK= 000100000h;
    TAPE_DRIVE_GET_LOGICAL_BLK= 000200000h;
    TAPE_DRIVE_SET_EOT_WZ_SIZE= 000400000h;
    TAPE_DRIVE_RESERVED_BIT= 080000000h;
    TAPE_DRIVE_LOAD_UNLOAD= 080000001h;
    TAPE_DRIVE_TENSION   = 080000002h;
    TAPE_DRIVE_LOCK_UNLOCK= 080000004h;
    TAPE_DRIVE_REWIND_IMMEDIATE= 080000008h;
    TAPE_DRIVE_SET_BLOCK_SIZE= 080000010h;
    TAPE_DRIVE_LOAD_UNLD_IMMED= 080000020h;
    TAPE_DRIVE_TENSION_IMMED= 080000040h;
    TAPE_DRIVE_LOCK_UNLK_IMMED= 080000080h;
    TAPE_DRIVE_SET_ECC   = 080000100h;
    TAPE_DRIVE_SET_COMPRESSION= 080000200h;
    TAPE_DRIVE_SET_PADDING= 080000400h;
    TAPE_DRIVE_SET_REPORT_SMKS= 080000800h;
    TAPE_DRIVE_ABSOLUTE_BLK= 080001000h;
    TAPE_DRIVE_ABS_BLK_IMMED= 080002000h;
    TAPE_DRIVE_LOGICAL_BLK= 080004000h;
    TAPE_DRIVE_LOG_BLK_IMMED= 080008000h;
    TAPE_DRIVE_END_OF_DATA= 080010000h;
    TAPE_DRIVE_RELATIVE_BLKS= 080020000h;
    TAPE_DRIVE_FILEMARKS = 080040000h;
    TAPE_DRIVE_SEQUENTIAL_FMKS= 080080000h;
    TAPE_DRIVE_SETMARKS  = 080100000h;
    TAPE_DRIVE_SEQUENTIAL_SMKS= 080200000h;
    TAPE_DRIVE_REVERSE_POSITION= 080400000h;
    TAPE_DRIVE_SPACE_IMMEDIATE= 080800000h;
    TAPE_DRIVE_WRITE_SETMARKS= 081000000h;
    TAPE_DRIVE_WRITE_FILEMARKS= 082000000h;
    TAPE_DRIVE_WRITE_SHORT_FMKS= 084000000h;
    TAPE_DRIVE_WRITE_LONG_FMKS= 088000000h;
    TAPE_DRIVE_WRITE_MARK_IMMED= 090000000h;
    TAPE_DRIVE_FORMAT    = 0A0000000h;
    TAPE_DRIVE_FORMAT_IMMEDIATE= 0C0000000h;
    TAPE_DRIVE_HIGH_FEATURES= 080000000h;

TYPE
    TAPE_GET_DRIVE_PARAMETERS = RECORD
          ECC            : BOOLEAN;
          Compression    : BOOLEAN;
          DataPadding    : BOOLEAN;
          ReportSetmarks : BOOLEAN;
          DefaultBlockSize: DWORD;
          MaximumBlockSize: DWORD;
          MinimumBlockSize: DWORD;
          MaximumPartitionCount: DWORD;
          FeaturesLow    : DWORD;
          FeaturesHigh   : DWORD;
          EOTWarningZoneSize: DWORD;
    END;
    PTAPE_GET_DRIVE_PARAMETERS= POINTER TO TAPE_GET_DRIVE_PARAMETERS;

    TAPE_SET_DRIVE_PARAMETERS = RECORD
          ECC            : BOOLEAN;
          Compression    : BOOLEAN;
          DataPadding    : BOOLEAN;
          ReportSetmarks : BOOLEAN;
          EOTWarningZoneSize: DWORD;
    END;
    PTAPE_SET_DRIVE_PARAMETERS= POINTER TO TAPE_SET_DRIVE_PARAMETERS;

    TAPE_GET_MEDIA_PARAMETERS = RECORD
          Capacity       : LARGE_INTEGER;
          Remaining      : LARGE_INTEGER;
          BlockSize      : DWORD;
          PartitionCount : DWORD;
          WriteProtected : BOOLEAN;
    END;
    PTAPE_GET_MEDIA_PARAMETERS= POINTER TO TAPE_GET_MEDIA_PARAMETERS;

    TAPE_SET_MEDIA_PARAMETERS = RECORD
          BlockSize      : DWORD;
    END;
    PTAPE_SET_MEDIA_PARAMETERS= POINTER TO TAPE_SET_MEDIA_PARAMETERS;

CONST
    TAPE_FIXED_PARTITIONS= 0;
    TAPE_SELECT_PARTITIONS= 1;
    TAPE_INITIATOR_PARTITIONS= 2;

TYPE
    TAPE_CREATE_PARTITION = RECORD
          Method         : DWORD;
          Count          : DWORD;
          Size           : DWORD;
    END;
    PTAPE_CREATE_PARTITION= POINTER TO TAPE_CREATE_PARTITION;

    WPARAM               = UINT;
    LPARAM               = LONG;
    LRESULT              = LONG;
    ATOM                 = WORD;
    PATOM                = POINTER TO ATOM;
    LPATOM               = POINTER TO ATOM;
    SPHANDLE             = POINTER TO HANDLE;
    LPHANDLE             = POINTER TO HANDLE;
    HGLOBAL              = HANDLE;
    HLOCAL               = HANDLE;
    GLOBALHANDLE         = HANDLE;
    LOCALHANDLE          = HANDLE;
    FARPROC              = PROCEDURE():INTEGER;
    WPROC                = PROCEDURE():INTEGER;
    HFILE                = INTEGER;
    COLORREF             = DWORD;
    LPCOLORREF           = POINTER TO DWORD;

    RemHGLOBAL = RECORD
        fNullHGlobal    : LONG;
        cbData          : ULONG;
        data            : ARRAY [0..0] OF BYTE;
    END;
    LPRemHGLOBAL        = POINTER TO RemHGLOBAL;

    RemHMETAFILE = RECORD
        mm      : LONG;
        xExt    : LONG;
        yExt    : LONG;
        cbData  : ULONG;
        data    : ARRAY [0..1-1] OF BYTE;
    END;

    RemHENHMETAFILE = RECORD
        cbData  : ULONG;
        data    : ARRAY [0..1-1] OF BYTE;
    END;

    RemHBITMAP = RECORD
        cbData  : ULONG;
        data    : ARRAY [0..1-1] OF BYTE;
    END;

    RemHPALETTE = RECORD
        cbData  : ULONG;
        data    : ARRAY [0..1-1] OF BYTE;
    END;

    RemBRUSH =RECORD
        cbData  : ULONG;
        data    : ARRAY [0..1-1] OF BYTE;
    END;

CONST
    HFILE_ERROR          = -1;
    INVALID_ATOM         = CAST(ATOM,0);

TYPE
    RECT = RECORD
          left           : LONG;
          top            : LONG;
          right          : LONG;
          bottom         : LONG;
    END;
    PRECT                = POINTER TO RECT;
    LPRECT               = PRECT;

    RECTL = RECORD
          left           : LONG;
          top            : LONG;
          right          : LONG;
          bottom         : LONG;
    END;
    PRECTL               = POINTER TO RECTL;
    LPRECTL              = PRECTL;

    POINT = RECORD
          x              : LONG;
          y              : LONG;
    END;
    PPOINT               = POINTER TO POINT;
    LPPOINT              = PPOINT;

    POINTL = RECORD
          x              : LONG;
          y              : LONG;
    END;
    PPOINTL              = POINTER TO POINTL;

    WSIZE = RECORD
          cx             : LONG;
          cy             : LONG;
    END;
    PSIZE                = POINTER TO WSIZE;
    LPSIZE               = PSIZE;

    SIZEL                = WSIZE;
    PSIZEL               = POINTER TO WSIZE;

    POINTS = RECORD
          x              : SHORT;
          y              : SHORT;
    END;
    PPOINTS              = POINTER TO POINTS;
    LPPOINTS             = PPOINTS;

CONST
    DM_UPDATE            = 1;
    DM_COPY              = 2;
    DM_PROMPT            = 4;
    DM_MODIFY            = 8;
    DM_IN_BUFFER         = DM_MODIFY;
    DM_IN_PROMPT         = DM_PROMPT;
    DM_OUT_BUFFER        = DM_COPY;
    DM_OUT_DEFAULT       = DM_UPDATE;

    DC_FIELDS            = 1;
    DC_PAPERS            = 2;
    DC_PAPERSIZE         = 3;
    DC_MINEXTENT         = 4;
    DC_MAXEXTENT         = 5;
    DC_BINS              = 6;
    DC_DUPLEX            = 7;
    DC_SIZE              = 8;
    DC_EXTRA             = 9;
    DC_VERSION           = 10;
    DC_DRIVER            = 11;
    DC_BINNAMES          = 12;
    DC_ENUMRESOLUTIONS   = 13;
    DC_FILEDEPENDENCIES  = 14;
    DC_TRUETYPE          = 15;
    DC_PAPERNAMES        = 16;
    DC_ORIENTATION       = 17;
    DC_COPIES            = 18;

    FILE_BEGIN           = 0;
    FILE_CURRENT         = 1;
    FILE_END             = 2;

    INVALID_HANDLE_VALUE = CAST(HANDLE, -1);
    INVALID_FILE_SIZE   = 0FFFFFFFFh;
    TIME_ZONE_ID_INVALID =0FFFFFFFFh;

    WAIT_FAILED          = 0FFFFFFFFh;
    WAIT_OBJECT_0        = STATUS_WAIT_0;
    WAIT_ABANDONED       = STATUS_ABANDONED_WAIT_0;
    WAIT_ABANDONED_0     = STATUS_ABANDONED_WAIT_0;
    WAIT_TIMEOUT         = STATUS_TIMEOUT;
    WAIT_IO_COMPLETION   = STATUS_USER_APC;
    STILL_ACTIVE         = STATUS_PENDING;

    EXCEPTION_ACCESS_VIOLATION          = STATUS_ACCESS_VIOLATION;
    EXCEPTION_DATATYPE_MISALIGNMENT     = STATUS_DATATYPE_MISALIGNMENT;
    EXCEPTION_BREAKPOINT                = STATUS_BREAKPOINT;
    EXCEPTION_SINGLE_STEP               = STATUS_SINGLE_STEP;
    EXCEPTION_ARRAY_BOUNDS_EXCEEDED     = STATUS_ARRAY_BOUNDS_EXCEEDED;
    EXCEPTION_FLT_DENORMAL_OPERAND      = STATUS_FLOAT_DENORMAL_OPERAND;
    EXCEPTION_FLT_DIVIDE_BY_ZERO        = STATUS_FLOAT_DIVIDE_BY_ZERO;
    EXCEPTION_FLT_INEXACT_RESULT        = STATUS_FLOAT_INEXACT_RESULT;
    EXCEPTION_FLT_INVALID_OPERATION     = STATUS_FLOAT_INVALID_OPERATION;
    EXCEPTION_FLT_OVERFLOW              = STATUS_FLOAT_OVERFLOW;
    EXCEPTION_FLT_STACK_CHECK           = STATUS_FLOAT_STACK_CHECK;
    EXCEPTION_FLT_UNDERFLOW             = STATUS_FLOAT_UNDERFLOW;
    EXCEPTION_INT_DIVIDE_BY_ZERO        = STATUS_INTEGER_DIVIDE_BY_ZERO;
    EXCEPTION_INT_OVERFLOW              = STATUS_INTEGER_OVERFLOW;
    EXCEPTION_PRIV_INSTRUCTION          = STATUS_PRIVILEGED_INSTRUCTION;
    EXCEPTION_IN_PAGE_ERROR             = STATUS_IN_PAGE_ERROR;
    EXCEPTION_ILLEGAL_INSTRUCTION       = STATUS_ILLEGAL_INSTRUCTION;
    EXCEPTION_NONCONTINUABLE_EXCEPTION  = STATUS_NONCONTINUABLE_EXCEPTION;
    EXCEPTION_STACK_OVERFLOW            = STATUS_STACK_OVERFLOW;
    EXCEPTION_INVALID_DISPOSITION       = STATUS_INVALID_DISPOSITION;
    EXCEPTION_GUARD_PAGE                = STATUS_GUARD_PAGE_VIOLATION;
    EXCEPTION_INVALID_HANDLE            = STATUS_INVALID_HANDLE;

    CONTROL_C_EXIT                      = STATUS_CONTROL_C_EXIT;

    FILE_FLAG_WRITE_THROUGH     = 080000000h;
    FILE_FLAG_OVERLAPPED        = 040000000h;
    FILE_FLAG_NO_BUFFERING      = 020000000h;
    FILE_FLAG_RANDOM_ACCESS     = 010000000h;
    FILE_FLAG_SEQUENTIAL_SCAN   = 008000000h;
    FILE_FLAG_DELETE_ON_CLOSE   = 004000000h;
    FILE_FLAG_BACKUP_SEMANTICS  = 002000000h;
    FILE_FLAG_POSIX_SEMANTICS   = 001000000h;
    FILE_FLAG_OPEN_REPARSE_POINT    = 00200000h;
    FILE_FLAG_OPEN_NO_RECALL        = 00100000h;

    CREATE_NEW           = 1;
    CREATE_ALWAYS        = 2;
    OPEN_EXISTING        = 3;
    OPEN_ALWAYS          = 4;
    TRUNCATE_EXISTING    = 5;

(*
 Define possible return codes from the CopyFileEx callback routine
*)

    PROGRESS_CONTINUE   =0;
    PROGRESS_CANCEL     =1;
    PROGRESS_STOP       =2;
    PROGRESS_QUIET      =3;

(*
 Define CopyFileEx callback routine state change values
*)

    CALLBACK_CHUNK_FINISHED         = 00000000;
    CALLBACK_STREAM_SWITCH          = 00000001;

(*
 Define CopyFileEx option flags
*)

    COPY_FILE_FAIL_IF_EXISTS        = 00000001;
    COPY_FILE_RESTARTABLE           = 00000002;
    COPY_FILE_OPEN_SOURCE_FOR_WRITE = 00000004;

    PIPE_ACCESS_INBOUND  = 000000001h;
    PIPE_ACCESS_OUTBOUND = 000000002h;
    PIPE_ACCESS_DUPLEX   = 000000003h;
    PIPE_CLIENT_END      = 000000000h;
    PIPE_SERVER_END      = 000000001h;
    PIPE_WAIT            = 000000000h;
    PIPE_NOWAIT          = 000000001h;
    PIPE_READMODE_BYTE   = 000000000h;
    PIPE_READMODE_MESSAGE= 000000002h;
    PIPE_TYPE_BYTE       = 000000000h;
    PIPE_TYPE_MESSAGE    = 000000004h;
    PIPE_UNLIMITED_INSTANCES    = 255;

    SECURITY_ANONYMOUS          = ORD(SecurityAnonymous) SHL 16;
    SECURITY_IDENTIFICATION     = ORD(SecurityIdentification) SHL 16;
    SECURITY_IMPERSONATION      = ORD(SecurityImpersonation) SHL 16;
    SECURITY_DELEGATION         = ORD(SecurityDelegation) SHL 16;
    SECURITY_CONTEXT_TRACKING   = 000040000h;
    SECURITY_EFFECTIVE_ONLY     = 000080000h;
    SECURITY_SQOS_PRESENT       = 000100000h;
    SECURITY_VALID_SQOS_FLAGS   = 0001F0000h;

TYPE
    OVERLAPPED = RECORD
          Internal       : DWORD;
          InternalHigh   : DWORD;
          Offset         : DWORD;
          OffsetHigh     : DWORD;
          hEvent         : HANDLE;
    END;
    LPOVERLAPPED         = POINTER TO OVERLAPPED;

    SECURITY_ATTRIBUTES = RECORD
          nLength        : DWORD;
          lpSecurityDescriptor: LPVOID;
          bInheritHandle : BOOL;
    END;
    PSECURITY_ATTRIBUTES = POINTER TO SECURITY_ATTRIBUTES;
    LPSECURITY_ATTRIBUTES= PSECURITY_ATTRIBUTES;

    PROCESS_INFORMATION = RECORD
          hProcess       : HANDLE;
          hThread        : HANDLE;
          dwProcessId    : DWORD;
          dwThreadId     : DWORD;
    END;
    PPROCESS_INFORMATION = POINTER TO PROCESS_INFORMATION;
    LPPROCESS_INFORMATION= PPROCESS_INFORMATION;

    FILETIME = RECORD
          dwLowDateTime  : DWORD;
          dwHighDateTime : DWORD;
    END;
    PFILETIME            = POINTER TO FILETIME;
    LPFILETIME           = PFILETIME;

    SYSTEMTIME = RECORD
          wYear          : WORD;
          wMonth         : WORD;
          wDayOfWeek     : WORD;
          wDay           : WORD;
          wHour          : WORD;
          wMinute        : WORD;
          wSecond        : WORD;
          wMilliseconds  : WORD;
    END;
    PSYSTEMTIME          = POINTER TO SYSTEMTIME;
    LPSYSTEMTIME         = PSYSTEMTIME;

    PTHREAD_START_ROUTINE       = PROCEDURE(LPVOID) : DWORD [EXPORT];
    LPTHREAD_START_ROUTINE      = PTHREAD_START_ROUTINE;

    PFIBER_START_ROUTINE        = PROCEDURE (LPVOID) [EXPORT];
    LPFIBER_START_ROUTINE       = PFIBER_START_ROUTINE;

    CRITICAL_SECTION            = RTL_CRITICAL_SECTION;
    PCRITICAL_SECTION           = PRTL_CRITICAL_SECTION;
    LPCRITICAL_SECTION          = PRTL_CRITICAL_SECTION;
    CRITICAL_SECTION_DEBUG      = RTL_CRITICAL_SECTION_DEBUG;
    PCRITICAL_SECTION_DEBUG     = PRTL_CRITICAL_SECTION_DEBUG;
    LPCRITICAL_SECTION_DEBUG    = PRTL_CRITICAL_SECTION_DEBUG;
    LPLDT_ENTRY                 = PLDT_ENTRY;

CONST
    SP_SERIALCOMM         = 00000001h;
    PST_UNSPECIFIED       = 00000000h;
    PST_RS232             = 00000001h;
    PST_PARALLELPORT      = 00000002h;
    PST_RS422             = 00000003h;
    PST_RS423             = 00000004h;
    PST_RS449             = 00000005h;
    PST_MODEM             = 00000006h;
    PST_FAX               = 00000021h;
    PST_SCANNER           = 00000022h;
    PST_NETWORK_BRIDGE    = 00000100h;
    PST_LAT               = 00000101h;
    PST_TCPIP_TELNET      = 00000102h;
    PST_X25               = 00000103h;
    PCF_DTRDSR         = 0001h;
    PCF_RTSCTS         = 0002h;
    PCF_RLSD           = 0004h;
    PCF_PARITY_CHECK   = 0008h;
    PCF_XONXOFF        = 0010h;
    PCF_SETXCHAR       = 0020h;
    PCF_TOTALTIMEOUTS  = 0040h;
    PCF_INTTIMEOUTS    = 0080h;
    PCF_SPECIALCHARS   = 0100h;
    PCF_16BITMODE      = 0200h;
    SP_PARITY          = 0001h;
    SP_BAUD            = 0002h;
    SP_DATABITS        = 0004h;
    SP_STOPBITS        = 0008h;
    SP_HANDSHAKING     = 0010h;
    SP_PARITY_CHECK    = 0020h;
    SP_RLSD            = 0040h;
    BAUD_075           = 00000001h;
    BAUD_110           = 00000002h;
    BAUD_134_5         = 00000004h;
    BAUD_150           = 00000008h;
    BAUD_300           = 00000010h;
    BAUD_600           = 00000020h;
    BAUD_1200          = 00000040h;
    BAUD_1800          = 00000080h;
    BAUD_2400          = 00000100h;
    BAUD_4800          = 00000200h;
    BAUD_7200          = 00000400h;
    BAUD_9600          = 00000800h;
    BAUD_14400         = 00001000h;
    BAUD_19200         = 00002000h;
    BAUD_38400         = 00004000h;
    BAUD_56K           = 00008000h;
    BAUD_128K          = 00010000h;
    BAUD_115200        = 00020000h;
    BAUD_57600         = 00040000h;
    BAUD_USER          = 10000000h;
    DATABITS_5        = 0001h;
    DATABITS_6        = 0002h;
    DATABITS_7        = 0004h;
    DATABITS_8        = 0008h;
    DATABITS_16       = 0010h;
    DATABITS_16X      = 0020h;
    STOPBITS_10       = 0001h;
    STOPBITS_15       = 0002h;
    STOPBITS_20       = 0004h;
    PARITY_NONE       = 0100h;
    PARITY_ODD        = 0200h;
    PARITY_EVEN       = 0400h;
    PARITY_MARK       = 0800h;
    PARITY_SPACE      = 1000h;

TYPE
    COMMPROP = RECORD
          wPacketLength  : WORD;
          wPacketVersion : WORD;
          dwServiceMask  : DWORD;
          dwReserved1    : DWORD;
          dwMaxTxQueue   : DWORD;
          dwMaxRxQueue   : DWORD;
          dwMaxBaud      : DWORD;
          dwProvSubType  : DWORD;
          dwProvCapabilities: DWORD;
          dwSettableParams: DWORD;
          dwSettableBaud : DWORD;
          wSettableData  : WORD;
          wSettableStopParity: WORD;
          dwCurrentTxQueue: DWORD;
          dwCurrentRxQueue: DWORD;
          dwProvSpec1    : DWORD;
          dwProvSpec2    : DWORD;
          wcProvChar     : ARRAY [0..1 - 1] OF WCHAR;
    END;
    LPCOMMPROP           = POINTER TO COMMPROP;

CONST
   COMMPROP_INITIALIZED         = 0E73CF52Eh;

TYPE
    CommStatus = ( fCtsHold         (* Tx waiting for CTS signal     *)
                 , fDsrHold         (* Tx waiting for DSR signal     *)
                 , fRlsdHold        (* Tx waiting for DCD signal     *)
                 , fXoffHold        (* Tx waiting, XOFF char recv'd  *)
                 , fXoffSent        (* Tx waiting, XOFF char sent    *)
                 , fEof             (* EOF character sent            *)
                 , fTxim            (* character waiting for Tx      *)
                 ) BIG;
    CommStatusSet = SET OF CommStatus BIG;

    COMSTAT = RECORD
          status         : CommStatusSet;
          cbInQue        : DWORD;
          cbOutQue       : DWORD;
    END;
    LPCOMSTAT            = POINTER TO COMSTAT;

TYPE
    CommFlags = ( fBinary           (* Binary Mode (skip EOF check)  *)
                , fParity           (* Enable parity checking        *)
                , fOutxCtsFlow      (* CTS handshaking on output     *)
                , fOutxDsrFlow      (* DSR handshaking on output     *)
                , fDtrEnable        (* DTR flow control (1 of 2)     *)
                , fDtrHandshake     (* DTR flow control (2 of 2)     *)
                , fDsrSensitivity   (* DSR Sensitivity               *)
                , fTXContinueOnXoff (* Continue TX when Xoff sent    *)
                , fOutX             (* Enable output X-ON/X-OFF      *)
                , fInX              (* Enable input X-ON/X-OFF       *)
                , fErrorChar        (* Enable Err Replacement        *)
                , fNull             (* Enable Null stripping         *)
                , fRtsEnable        (* RTS flow control (1 of 2)     *)
                , fRtsHandshake     (* RTS flow control (2 of 2)     *)
                                    (* set both=>RTS_CONTROL_TOGGLE  *)
                , fAbortOnError     (* Abort all reads and writes    *)
                ) BIG;
    CommFlagSet = SET OF CommFlags BIG;

CONST
    DTR_CONTROL_DISABLE  = CommFlagSet{};
    DTR_CONTROL_ENABLE   = CommFlagSet{fDtrEnable};
    DTR_CONTROL_HANDSHAKE= CommFlagSet{fDtrHandshake};
    (*
    DTR_CONTROL_DISABLE  = 000h;
    DTR_CONTROL_ENABLE   = 001h;
    DTR_CONTROL_HANDSHAKE= 002h;
    *)

    RTS_CONTROL_DISABLE  = CommFlagSet{};
    RTS_CONTROL_ENABLE   = CommFlagSet{fRtsEnable};
    RTS_CONTROL_HANDSHAKE= CommFlagSet{fRtsHandshake};
    RTS_CONTROL_TOGGLE   = CommFlagSet{fRtsEnable, fRtsHandshake};
    (*
    RTS_CONTROL_DISABLE  = 000h;
    RTS_CONTROL_ENABLE   = 001h;
    RTS_CONTROL_HANDSHAKE= 002h;
    RTS_CONTROL_TOGGLE   = 003h;
    *)

TYPE
    DCB = RECORD
          DCBlength      : DWORD;
          BaudRate       : DWORD;
          flags          : CommFlagSet;
          wReserved      : WORD;
          XonLim         : WORD;
          XoffLim        : WORD;
          ByteSize       : BYTE;
          Parity         : BYTE;
          StopBits       : BYTE;
          XonChar        : ACHAR;
          XoffChar       : ACHAR;
          ErrorChar      : ACHAR;
          EofChar        : ACHAR;
          EvtChar        : ACHAR;
          wReserved1     : WORD;
    END;
    LPDCB                = POINTER TO DCB;

TYPE
    COMMTIMEOUTS = RECORD
          ReadIntervalTimeout: DWORD;
          ReadTotalTimeoutMultiplier: DWORD;
          ReadTotalTimeoutConstant: DWORD;
          WriteTotalTimeoutMultiplier: DWORD;
          WriteTotalTimeoutConstant: DWORD;
    END;
    LPCOMMTIMEOUTS       = POINTER TO COMMTIMEOUTS;

    SYSTEM_INFO = RECORD
          (* Obsolete dwOemId        : DWORD; *)
          wProcessorArchitecture     : WORD;
          wReserved                  : WORD;
          dwPageSize                 : DWORD;
          lpMinimumApplicationAddress: LPVOID;
          lpMaximumApplicationAddress: LPVOID;
          dwActiveProcessorMask      : DWORD;
          dwNumberOfProcessors       : DWORD;
          dwProcessorType            : DWORD;
          dwAllocationGranularity    : DWORD;
          wProcessorLevel            : WORD;
          wProcessorRevision         : WORD;
    END;
    LPSYSTEM_INFO        = POINTER TO SYSTEM_INFO;


CONST
    GMEM_FIXED           = 00000h;
    GMEM_MOVEABLE        = 00002h;
    GMEM_NOCOMPACT       = 00010h;
    GMEM_NODISCARD       = 00020h;
    GMEM_ZEROINIT        = 00040h;
    GMEM_MODIFY          = 00080h;
    GMEM_DISCARDABLE     = 00100h;
    GMEM_NOT_BANKED      = 01000h;
    GMEM_SHARE           = 02000h;
    GMEM_DDESHARE        = 02000h;
    GMEM_NOTIFY          = 04000h;
    GMEM_LOWER           = GMEM_NOT_BANKED;
    GMEM_VALID_FLAGS     = 07F72h;
    GMEM_INVALID_HANDLE  = 08000h;

    GHND                 = (GMEM_MOVEABLE BOR GMEM_ZEROINIT);
    GPTR                 = (GMEM_FIXED BOR GMEM_ZEROINIT);
    GMEM_DISCARDED       = 04000h;
    GMEM_LOCKCOUNT       = 000FFh;

TYPE
    MEMORYSTATUS = RECORD
          dwLength       : DWORD;
          dwMemoryLoad   : DWORD;
          dwTotalPhys    : DWORD;
          dwAvailPhys    : DWORD;
          dwTotalPageFile: DWORD;
          dwAvailPageFile: DWORD;
          dwTotalVirtual : DWORD;
          dwAvailVirtual : DWORD;
    END;
    LPMEMORYSTATUS       = POINTER TO MEMORYSTATUS;

CONST
    LMEM_FIXED           = 00000h;
    LMEM_MOVEABLE        = 00002h;
    LMEM_NOCOMPACT       = 00010h;
    LMEM_NODISCARD       = 00020h;
    LMEM_ZEROINIT        = 00040h;
    LMEM_MODIFY          = 00080h;
    LMEM_DISCARDABLE     = 00F00h;
    LMEM_VALID_FLAGS     = 00F72h;
    LMEM_INVALID_HANDLE  = 08000h;
    LHND                 = (LMEM_MOVEABLE BOR LMEM_ZEROINIT);
    LPTR                 = (LMEM_FIXED BOR LMEM_ZEROINIT);
    NONZEROLHND          = LMEM_MOVEABLE;
    NONZEROLPTR          = LMEM_FIXED;
    LMEM_DISCARDED       = 04000h;
    LMEM_LOCKCOUNT       = 000FFh;
    DEBUG_PROCESS        = 000000001h;
    DEBUG_ONLY_THIS_PROCESS= 000000002h;
    CREATE_SUSPENDED     = 000000004h;
    DETACHED_PROCESS     = 000000008h;

    CREATE_NEW_CONSOLE   = 000000010h;

    NORMAL_PRIORITY_CLASS= 000000020h;
    IDLE_PRIORITY_CLASS  = 000000040h;
    HIGH_PRIORITY_CLASS  = 000000080h;
    REALTIME_PRIORITY_CLASS= 000000100h;

    CREATE_NEW_PROCESS_GROUP    = 000000200h;
    CREATE_UNICODE_ENVIRONMENT  = 000000400h;
    CREATE_SEPARATE_WOW_VDM     = 000000800h;
    CREATE_SHARED_WOW_VDM       = 000001000h;
    CREATE_DEFAULT_ERROR_MODE   = 004000000h;
    CREATE_NO_WINDOW            = 008000000h;
    CREATE_FORCEDOS             = 00002000h;
    BELOW_NORMAL_PRIORITY_CLASS       = 000004000h;(*2k*)
    ABOVE_NORMAL_PRIORITY_CLASS       = 000008000h;(*2k*)

    STACK_SIZE_PARAM_IS_A_RESERVATION = 000010000h;(*XP*)

    PROFILE_USER         = 010000000h;
    PROFILE_KERNEL       = 020000000h;
    PROFILE_SERVER       = 040000000h;

    THREAD_PRIORITY_LOWEST              = THREAD_BASE_PRIORITY_MIN;
    THREAD_PRIORITY_BELOW_NORMAL        = THREAD_PRIORITY_LOWEST + 1;
    THREAD_PRIORITY_NORMAL              = 0;
    THREAD_PRIORITY_HIGHEST             = THREAD_BASE_PRIORITY_MAX;
    THREAD_PRIORITY_ABOVE_NORMAL        = THREAD_PRIORITY_HIGHEST - 1;
    THREAD_PRIORITY_TIME_CRITICAL       = THREAD_BASE_PRIORITY_LOWRT;
    THREAD_PRIORITY_IDLE                = THREAD_BASE_PRIORITY_IDLE;

    THREAD_PRIORITY_ERROR_RETURN= MAXLONG;

    EXCEPTION_DEBUG_EVENT       = 1;

    CREATE_THREAD_DEBUG_EVENT   = 2;
    CREATE_PROCESS_DEBUG_EVENT  = 3;

    EXIT_THREAD_DEBUG_EVENT     = 4;
    EXIT_PROCESS_DEBUG_EVENT    = 5;
    LOAD_DLL_DEBUG_EVENT        = 6;
    UNLOAD_DLL_DEBUG_EVENT      = 7;
    OUTPUT_DEBUG_STRING_EVENT   = 8;
    RIP_EVENT                   = 9;

TYPE
    EXCEPTION_DEBUG_INFO = RECORD
          ExceptionRecord: EXCEPTION_RECORD;
          dwFirstChance  : DWORD;
    END;
    LPEXCEPTION_DEBUG_INFO= POINTER TO EXCEPTION_DEBUG_INFO;

    CREATE_THREAD_DEBUG_INFO = RECORD
          hThread        : HANDLE;
          lpThreadLocalBase: LPVOID;
          lpStartAddress : LPTHREAD_START_ROUTINE;
    END;
    LPCREATE_THREAD_DEBUG_INFO= POINTER TO CREATE_THREAD_DEBUG_INFO;

    CREATE_PROCESS_DEBUG_INFO = RECORD
          hFile          : HANDLE;
          hProcess       : HANDLE;
          hThread        : HANDLE;
          lpBaseOfImage  : LPVOID;
          dwDebugInfoFileOffset: DWORD;
          nDebugInfoSize : DWORD;
          lpThreadLocalBase: LPVOID;
          lpStartAddress : LPTHREAD_START_ROUTINE;
          lpImageName    : LPVOID;
          fUnicode       : WORD;
    END;
    LPCREATE_PROCESS_DEBUG_INFO= POINTER TO CREATE_PROCESS_DEBUG_INFO;

    EXIT_THREAD_DEBUG_INFO = RECORD
          dwExitCode     : DWORD;
    END;
    LPEXIT_THREAD_DEBUG_INFO= POINTER TO EXIT_THREAD_DEBUG_INFO;

    EXIT_PROCESS_DEBUG_INFO = RECORD
          dwExitCode     : DWORD;
    END;
    LPEXIT_PROCESS_DEBUG_INFO= POINTER TO EXIT_PROCESS_DEBUG_INFO;

    LOAD_DLL_DEBUG_INFO = RECORD
          hFile          : HANDLE;
          lpBaseOfDll    : LPVOID;
          dwDebugInfoFileOffset: DWORD;
          nDebugInfoSize : DWORD;
          lpImageName    : LPVOID;
          fUnicode       : WORD;
    END;
    LPLOAD_DLL_DEBUG_INFO= POINTER TO LOAD_DLL_DEBUG_INFO;

    UNLOAD_DLL_DEBUG_INFO = RECORD
          lpBaseOfDll    : LPVOID;
    END;
    LPUNLOAD_DLL_DEBUG_INFO= POINTER TO UNLOAD_DLL_DEBUG_INFO;

    OUTPUT_DEBUG_STRING_INFO = RECORD
          lpDebugStringData: LPSTR;
          fUnicode       : WORD;
          nDebugStringLength: WORD;
    END;
    LPOUTPUT_DEBUG_STRING_INFO= POINTER TO OUTPUT_DEBUG_STRING_INFO;

    RIP_INFO = RECORD
          dwError        : DWORD;
          dwType         : DWORD;
    END;
    LPRIP_INFO           = POINTER TO RIP_INFO;

    DEBUG_EVENT_VARIANT = RECORD
        CASE : CARDINAL OF
        1: Exception : EXCEPTION_DEBUG_INFO ;
        |
        2 : CreateThread : CREATE_THREAD_DEBUG_INFO ;
        |
        3: CreateProcessInfo : CREATE_PROCESS_DEBUG_INFO ;
        |
        4: ExitThread : EXIT_THREAD_DEBUG_INFO ;
        |
        5: ExitProcess : EXIT_THREAD_DEBUG_INFO ;
        |
        6: LoadDll : LOAD_DLL_DEBUG_INFO ;
        |
        7: UnloadDll : UNLOAD_DLL_DEBUG_INFO ;
        |
        8: DebugString : OUTPUT_DEBUG_STRING_INFO ;
        |
        9: RipInfo : RIP_INFO ;
        ELSE
        END;
    END;

    DEBUG_EVENT = RECORD
          dwDebugEventCode: DWORD;
          dwProcessId    : DWORD;
          dwThreadId     : DWORD;
          dbv            : DEBUG_EVENT_VARIANT;
    END;
    LPDEBUG_EVENT        = POINTER TO DEBUG_EVENT;

    LPCONTEXT            = PCONTEXT;
    LPEXCEPTION_RECORD   = PEXCEPTION_RECORD;
    LPEXCEPTION_POINTERS = PEXCEPTION_POINTERS;

CONST
    DRIVE_UNKNOWN        = 0;
    DRIVE_NO_ROOT_DIR    = 1;
    DRIVE_REMOVABLE      = 2;
    DRIVE_FIXED          = 3;
    DRIVE_REMOTE         = 4;
    DRIVE_CDROM          = 5;
    DRIVE_RAMDISK        = 6;
    FILE_TYPE_UNKNOWN    = 00000h;
    FILE_TYPE_DISK       = 00001h;
    FILE_TYPE_CHAR       = 00002h;
    FILE_TYPE_PIPE       = 00003h;
    FILE_TYPE_REMOTE     = 08000h;
    STD_INPUT_HANDLE     = CAST(DWORD, -10);
    STD_OUTPUT_HANDLE   = CAST(DWORD, -11);
    STD_ERROR_HANDLE     = CAST(DWORD, -12);
    NOPARITY             = 0;
    ODDPARITY            = 1;
    EVENPARITY           = 2;
    MARKPARITY           = 3;
    SPACEPARITY          = 4;
    ONESTOPBIT           = 0;
    ONE5STOPBITS         = 1;
    TWOSTOPBITS          = 2;
    IGNORE               = 0;
    INFINITE             = 0FFFFFFFFh;
    CBR_110              = 110;
    CBR_300              = 300;
    CBR_600              = 600;
    CBR_1200             = 1200;
    CBR_2400             = 2400;
    CBR_4800             = 4800;
    CBR_9600             = 9600;
    CBR_14400            = 14400;
    CBR_19200            = 19200;
    CBR_38400            = 38400;
    CBR_56000            = 56000;
    CBR_57600            = 57600;
    CBR_115200           = 115200;
    CBR_128000           = 128000;
    CBR_256000           = 256000;
    CE_RXOVER            = 00001h;
    CE_OVERRUN           = 00002h;
    CE_RXPARITY          = 00004h;
    CE_FRAME             = 00008h;
    CE_BREAK             = 00010h;
    CE_TXFULL            = 00100h;
    CE_PTO               = 00200h;
    CE_IOE               = 00400h;
    CE_DNS               = 00800h;
    CE_OOP               = 01000h;
    CE_MODE              = 08000h;
    IE_BADID             = (-1);
    IE_OPEN              = (-2);
    IE_NOPEN             = (-3);
    IE_MEMORY            = (-4);
    IE_DEFAULT           = (-5);
    IE_HARDWARE          = (-10);
    IE_BYTESIZE          = (-11);
    IE_BAUDRATE          = (-12);
    EV_RXCHAR            = 00001h;
    EV_RXFLAG            = 00002h;
    EV_TXEMPTY           = 00004h;
    EV_CTS               = 00008h;
    EV_DSR               = 00010h;
    EV_RLSD              = 00020h;
    EV_BREAK             = 00040h;
    EV_ERR               = 00080h;
    EV_RING              = 00100h;
    EV_PERR              = 00200h;
    EV_RX80FULL          = 00400h;
    EV_EVENT1            = 00800h;
    EV_EVENT2            = 01000h;
    SETXOFF              = 1;
    SETXON               = 2;
    SETRTS               = 3;
    CLRRTS               = 4;
    SETDTR               = 5;
    CLRDTR               = 6;
    RESETDEV             = 7;
    SETBREAK             = 8;
    CLRBREAK             = 9;
    PURGE_TXABORT        = 00001h;
    PURGE_RXABORT        = 00002h;
    PURGE_TXCLEAR        = 00004h;
    PURGE_RXCLEAR        = 00008h;
    LPTx                 = 080h;
    MS_CTS_ON            = 10h;
    MS_DSR_ON            = 20h;
    MS_RING_ON           = 40h;
    MS_RLSD_ON           = 80h;
    S_QUEUEEMPTY         = 0;
    S_THRESHOLD          = 1;
    S_ALLTHRESHOLD       = 2;
    S_NORMAL             = 0;
    S_LEGATO             = 1;
    S_STACCATO           = 2;
    S_PERIOD512          = 0;
    S_PERIOD1024         = 1;
    S_PERIOD2048         = 2;
    S_PERIODVOICE        = 3;
    S_WHITE512           = 4;
    S_WHITE1024          = 5;
    S_WHITE2048          = 6;
    S_WHITEVOICE         = 7;
    S_SERDVNA            = -1;
    S_SEROFM             = -2;
    S_SERMACT            = -3;
    S_SERQFUL            = -4;
    S_SERBDNT            = -5;
    S_SERDLN             = -6;
    S_SERDCC             = -7;
    S_SERDTP             = -8;
    S_SERDVL             = -9;
    S_SERDMD             = -10;
    S_SERDSH             = -11;
    S_SERDPT             = -12;
    S_SERDFQ             = -13;
    S_SERDDR             = -14;
    S_SERDSR             = -15;
    S_SERDST             = -16;
    NMPWAIT_WAIT_FOREVER = 0ffffffffh;
    NMPWAIT_NOWAIT       = 000000001h;
    NMPWAIT_USE_DEFAULT_WAIT= 000000000h;

    FS_CASE_IS_PRESERVED            = FILE_CASE_PRESERVED_NAMES;
    FS_CASE_SENSITIVE               = FILE_CASE_SENSITIVE_SEARCH;
    FS_UNICODE_STORED_ON_DISK       = FILE_UNICODE_ON_DISK;
    FS_PERSISTENT_ACLS              = FILE_PERSISTENT_ACLS;
    FS_VOL_IS_COMPRESSED            = FILE_VOLUME_IS_COMPRESSED;
    FS_FILE_COMPRESSION             = FILE_FILE_COMPRESSION;

    OF_READ              = 000000000h;
    OF_WRITE             = 000000001h;
    OF_READWRITE         = 000000002h;
    OF_SHARE_COMPAT      = 000000000h;
    OF_SHARE_EXCLUSIVE   = 000000010h;
    OF_SHARE_DENY_WRITE  = 000000020h;
    OF_SHARE_DENY_READ   = 000000030h;
    OF_SHARE_DENY_NONE   = 000000040h;
    OF_PARSE             = 000000100h;
    OF_DELETE            = 000000200h;
    OF_VERIFY            = 000000400h;
    OF_CANCEL            = 000000800h;
    OF_CREATE            = 000001000h;
    OF_PROMPT            = 000002000h;
    OF_EXIST             = 000004000h;
    OF_REOPEN            = 000008000h;
    OFS_MAXPATHNAME      = 128;

TYPE
    OFSTRUCT = RECORD
          cBytes         : BYTE;
          fFixedDisk     : BYTE;
          nErrCode       : WORD;
          Reserved1      : WORD;
          Reserved2      : WORD;
          szPathName     : ARRAY [0..OFS_MAXPATHNAME - 1] OF ACHAR;
    END;
    POFSTRUCT            = POINTER TO OFSTRUCT;
    LPOFSTRUCT           = POFSTRUCT;

PROCEDURE InterlockedIncrement(VAR lpAddend : LONG) : LONG;

PROCEDURE InterlockedDecrement(VAR lpAddend : LONG) : LONG;

PROCEDURE InterlockedExchange(VAR Target : LONG;
                              Value : LONG) : LONG;

(* not Win95 *)
PROCEDURE InterlockedCompareExchange(VAR Destination : LONG;
                                     Exchange : LONG;
                                     Comperand : LONG) : LONG;

(* not Win95 *)
PROCEDURE InterlockedCompareExchangePointer
            ["_InterlockedCompareExchange@12"]
                (VAR Destination : PVOID;
                 Exchange : PVOID;
                 Comperand : PVOID) : PVOID;

(* not Win95 *)
PROCEDURE InterlockedExchangeAdd(VAR Addend : LONG; Value : LONG) : LONG;

PROCEDURE FreeResource(hResData : HGLOBAL) : BOOL;

PROCEDURE LockResource(hResData : HGLOBAL) : LPVOID;

CONST
    MAXINTATOM           = 0C000h;

PROCEDURE WinMain(hInstance : HINSTANCE;
                  hPrevInstance : HINSTANCE;
                  lpCmdLine : LPSTR;
                  nShowCmd : INTEGER) : INTEGER;

PROCEDURE FreeLibrary(hLibModule : HINSTANCE) : BOOL;

(*95*)
PROCEDURE FreeLibraryAndExitThread(hLibModule : HMODULE;
                                   dwExitCode : DWORD);

(*95*)
PROCEDURE DisableThreadLibraryCalls(hLibModule : HMODULE): BOOL;

PROCEDURE GetProcAddress(hModule : HINSTANCE;
                         lpProcName : ARRAY OF ACHAR) : FARPROC;

PROCEDURE GetVersion() : DWORD;

PROCEDURE GlobalAlloc(uFlags : UINT;
                      dwBytes : DWORD) : HGLOBAL;

PROCEDURE GlobalReAlloc(hMem : HGLOBAL;
                        dwBytes : DWORD;
                        uFlags : UINT) : HGLOBAL;

PROCEDURE GlobalSize(hMem : HGLOBAL) : DWORD;

PROCEDURE GlobalFlags(hMem : HGLOBAL) : UINT;

PROCEDURE GlobalLock(hMem : HGLOBAL) : LPVOID;

PROCEDURE GlobalHandle(pMem : LPCVOID) : HGLOBAL;

PROCEDURE GlobalUnlock(hMem : HGLOBAL) : BOOL;

PROCEDURE GlobalFree(hMem : HGLOBAL) : HGLOBAL;

PROCEDURE GlobalCompact(dwMinFree : DWORD) : UINT;

PROCEDURE GlobalFix(hMem : HGLOBAL);

PROCEDURE GlobalUnfix(hMem : HGLOBAL);

PROCEDURE GlobalWire(hMem : HGLOBAL) : LPVOID;

PROCEDURE GlobalUnWire(hMem : HGLOBAL) : BOOL;

PROCEDURE GlobalMemoryStatus(VAR lpBuffer : MEMORYSTATUS);

PROCEDURE LocalAlloc(uFlags : UINT;
                     uBytes : UINT) : HLOCAL;

PROCEDURE LocalReAlloc(hMem : HLOCAL;
                       uBytes : UINT;
                       uFlags : UINT) : HLOCAL;

PROCEDURE LocalLock(hMem : HLOCAL) : LPVOID;

PROCEDURE LocalHandle(pMem : LPCVOID) : HLOCAL;

PROCEDURE LocalUnlock(hMem : HLOCAL) : BOOL;

PROCEDURE LocalSize(hMem : HLOCAL) : UINT;

PROCEDURE LocalFlags(hMem : HLOCAL) : UINT;

PROCEDURE LocalFree(hMem : HLOCAL) : HLOCAL;

PROCEDURE LocalShrink(hMem : HLOCAL;
                      cbNewSize : UINT) : UINT;

PROCEDURE LocalCompact(uMinFree : UINT) : UINT;

PROCEDURE FlushInstructionCache(hProcess : HANDLE;
                                lpBaseAddress : LPCVOID;
                                dwSize : DWORD) : BOOL;

PROCEDURE VirtualAlloc(lpAddress : LPVOID;
                       dwSize : DWORD;
                       flAllocationType : DWORD;
                       flProtect : DWORD) : LPVOID;

PROCEDURE VirtualFree(lpAddress : LPVOID;
                      dwSize : DWORD;
                      dwFreeType : DWORD) : BOOL;

PROCEDURE VirtualProtect(lpAddress : LPVOID;
                         dwSize : DWORD;
                         flNewProtect : DWORD;
                         VAR lpflOldProtect : DWORD) : BOOL;

PROCEDURE VirtualQuery(lpAddress : LPCVOID;
                       VAR lpBuffer : MEMORY_BASIC_INFORMATION;
                       dwLength : DWORD) : DWORD;

PROCEDURE VirtualAllocEx(hProcess : HANDLE;
                         lpAddress : LPVOID;
                         dwSize : DWORD;
                         flAllocationType : DWORD;
                         flProtect : DWORD
                         ) : LPVOID;

PROCEDURE VirtualFreeEx(hProcess : HANDLE;
                        lpAddress : LPVOID;
                        dwSize : DWORD;
                        dwFreeType : DWORD
                        ) : BOOL;

PROCEDURE VirtualProtectEx(hProcess : HANDLE;
                           lpAddress : LPVOID;
                           dwSize : DWORD;
                           flNewProtect : DWORD;
                           VAR lpflOldProtect : DWORD) : BOOL;

PROCEDURE VirtualQueryEx(hProcess : HANDLE;
                         lpAddress : LPCVOID;
                         VAR lpBuffer : MEMORY_BASIC_INFORMATION;
                         dwLength : DWORD) : DWORD;

PROCEDURE HeapCreate(flOptions : DWORD;
                     dwInitialSize : DWORD;
                     dwMaximumSize : DWORD) : HANDLE;

PROCEDURE HeapDestroy(hHeap : HANDLE) : BOOL;

PROCEDURE HeapAlloc(hHeap : HANDLE;
                    dwFlags : DWORD;
                    dwBytes : DWORD) : LPVOID;

PROCEDURE HeapReAlloc(hHeap : HANDLE;
                      dwFlags : DWORD;
                      lpMem : LPVOID;
                      dwBytes : DWORD) : LPVOID;

PROCEDURE HeapFree(hHeap : HANDLE;
                   dwFlags : DWORD;
                   lpMem : LPVOID) : BOOL;

PROCEDURE HeapSize(hHeap : HANDLE;
                   dwFlags : DWORD;
                   lpMem : LPCVOID) : DWORD;

PROCEDURE HeapValidate(hHeap : HANDLE;
                   dwFlags : DWORD;
                   lpMem : LPCVOID) : DWORD;

PROCEDURE HeapCompact(hHeap : HANDLE;
                   dwFlags : DWORD) : UINT;

PROCEDURE GetProcessHeap() : HANDLE;

PROCEDURE GetProcessHeaps(NumberOfHeaps : DWORD;
                          VAR ProcessHeaps : ARRAY OF HANDLE) : DWORD;

TYPE
    Block = RECORD
        hMem            : HANDLE;
        dwReserved      : ARRAY [0.. 3-1] OF DWORD;
    END;

    Region = RECORD
        dwCommittedSize         : DWORD;
        dwUnCommittedSize       : DWORD;
        lpFirstBlock            : LPVOID;
        lpLastBlock             : LPVOID;
    END;

    PROCESS_HEAP_ENTRY = RECORD
        lpData          : PVOID;
        cbData          : DWORD;
        cbOverhead      : BYTE;
        iRegionIndex    : BYTE;
        wFlags          : WORD;
        CASE : CARDINAL OF
            1 : union1 : Block; |
            2 : union2 : Region;|
            ELSE
        END;
    END;
    PPROCESS_HEAP_ENTRY  = POINTER TO PROCESS_HEAP_ENTRY;
    LPPROCESS_HEAP_ENTRY = PPROCESS_HEAP_ENTRY;

CONST
    PROCESS_HEAP_REGION             = 00001h;
    PROCESS_HEAP_UNCOMMITTED_RANGE  = 00002h;
    PROCESS_HEAP_ENTRY_BUSY         = 00004h;
    PROCESS_HEAP_ENTRY_MOVEABLE     = 00010h;
    PROCESS_HEAP_ENTRY_DDESHARE     = 00020h;

PROCEDURE HeapLock(hHeap : HANDLE) : BOOL;

PROCEDURE HeapUnlock(hHeap : HANDLE) : BOOL;

PROCEDURE HeapWalk(hHeap : HANDLE; lpEntry : LPPROCESS_HEAP_ENTRY) : BOOL;



CONST
    SCS_32BIT_BINARY    = 0;
    SCS_DOS_BINARY      = 1;
    SCS_WOW_BINARY      = 2;
    SCS_PIF_BINARY      = 3;
    SCS_POSIX_BINARY    = 4;
    SCS_OS216_BINARY    = 5;

PROCEDURE GetBinaryTypeA(lpApplicationName : ARRAY OF ACHAR;
                         VAR lpBinaryType : DWORD) : BOOL;

PROCEDURE GetBinaryTypeW(lpApplicationName : ARRAY OF UCHAR;
                         VAR lpBinaryType : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetBinaryType = GetBinaryTypeW;
%ELSE
PROCEDURE GetBinaryType = GetBinaryTypeA;
%END

PROCEDURE GetShortPathNameA(lpszLongPath : ARRAY OF ACHAR;
                            VAR lpszShortPath : ARRAY OF ACHAR;
                            cchBuffer : DWORD
                            ) : DWORD;

PROCEDURE GetShortPathNameW(lpszLongPath : ARRAY OF UCHAR;
                            VAR lpszShortPath : ARRAY OF UCHAR;
                            cchBuffer : DWORD
                            ) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetShortPathName = GetShortPathNameW;
%ELSE
PROCEDURE GetShortPathName = GetShortPathNameA;
%END

PROCEDURE GetLongPathNameA(lpszShortPath : ARRAY OF ACHAR;
                           VAR lpszLongPath : ARRAY OF ACHAR;
                           cchBuffer : DWORD) : DWORD;

PROCEDURE GetLongPathNameW(lpszShortPath : ARRAY OF WCHAR;
                           VAR lpszLongPath : ARRAY OF WCHAR;
                           cchBuffer : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetLongPathName = GetLongPathNameW;
%ELSE
PROCEDURE GetLongPathName = GetLongPathNameA;
%END

PROCEDURE GetProcessAffinityMask(
                                hProcess : HANDLE;
                                VAR lpProcessAffinityMask : DWORD;
                                VAR lpSystemAffinityMask : DWORD
                                ) : BOOL;

PROCEDURE SetProcessAffinityMask(hProcess : HANDLE;
                                 dwProcessAffinityMask : DWORD) : BOOL;

PROCEDURE GetProcessWorkingSetSize(
                                    hProcess : HANDLE;
                                    VAR lpMinimumWorkingSetSize : DWORD;
                                    VAR lpMaximumWorkingSetSize : DWORD
                                    ) : BOOL;

PROCEDURE SetProcessWorkingSetSize(
                                    hProcess : HANDLE;
                                    dwMinimumWorkingSetSize : DWORD;
                                    dwMaximumWorkingSetSize : DWORD
                                    ) : BOOL;

PROCEDURE SetThreadAffinityMask(
                                hThread : HANDLE;
                                dwThreadAffinityMask  : DWORD
                                ) : DWORD;


(* NT only *)
PROCEDURE SetThreadIdealProcessor(hThread : HANDLE;
                                  dwIdealProcessor : DWORD) : DWORD;

PROCEDURE SetProcessPriorityBoost(hProcess : HANDLE;
                                  bDisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetProcessPriorityBoost(hProcess : HANDLE;
                                  VAR pDisablePriorityBoost : BOOL) : BOOL;

TYPE
    LATENCY_TIME = (LT_DONT_CARE, LT_LOWEST_LATENCY) BIG;

PROCEDURE RequestWakeupLatency(latency : LATENCY_TIME) : BOOL;

PROCEDURE GetProcessTimes(hProcess : HANDLE;
                          VAR lpCreationTime : FILETIME;
                          VAR lpExitTime : FILETIME;
                          VAR lpKernelTime : FILETIME;
                          VAR lpUserTime : FILETIME) : BOOL;

PROCEDURE OpenProcess(dwDesiredAccess : DWORD;
                      bInheritHandle : BOOL;
                      dwProcessId : DWORD) : HANDLE;

PROCEDURE GetCurrentProcess() : HANDLE;

PROCEDURE GetCurrentProcessId() : DWORD;

PROCEDURE ExitProcess(uExitCode : UINT);

PROCEDURE TerminateProcess(hProcess : HANDLE;
                           uExitCode : UINT) : BOOL;

PROCEDURE GetExitCodeProcess(hProcess : HANDLE;
                             VAR lpExitCode : DWORD) : BOOL;

PROCEDURE FatalExit(ExitCode : INTEGER);


PROCEDURE GetEnvironmentStringsW() : LPWSTR;

PROCEDURE GetEnvironmentStringsA() : LPSTR;

%IF UNICODE %THEN
PROCEDURE GetEnvironmentStrings = GetEnvironmentStringsW;
%ELSE
PROCEDURE GetEnvironmentStrings = GetEnvironmentStringsA;
%END

PROCEDURE FreeEnvironmentStringsA(a : LPSTR) : BOOL;

PROCEDURE FreeEnvironmentStringsW(a : LPWSTR) : BOOL;

%IF UNICODE %THEN
PROCEDURE FreeEnvironmentStrings = FreeEnvironmentStringsW;
%ELSE
PROCEDURE FreeEnvironmentStrings = FreeEnvironmentStringsA;
%END



PROCEDURE RaiseException(dwExceptionCode : DWORD;
                         dwExceptionFlags : DWORD;
                         nNumberOfArguments : DWORD;
                         lpArguments : ARRAY OF DWORD);

PROCEDURE UnhandledExceptionFilter(VAR INOUT ExceptionInfo : EXCEPTION_POINTERS) : LONG;

TYPE
    PTOP_LEVEL_EXCEPTION_FILTER= PROCEDURE(VAR INOUT EXCEPTION_POINTERS) : LONG [EXPORT];
    LPTOP_LEVEL_EXCEPTION_FILTER= PTOP_LEVEL_EXCEPTION_FILTER;

PROCEDURE SetUnhandledExceptionFilter(lpTopLevelExceptionFilter : LPTOP_LEVEL_EXCEPTION_FILTER) : LPTOP_LEVEL_EXCEPTION_FILTER;

(* NT only *)
PROCEDURE CreateFiber(dwStackSize : DWORD;
                      lpStartAddress : LPFIBER_START_ROUTINE;
                      lpParameter : LPVOID) : LPVOID;

(* NT only *)
PROCEDURE DeleteFiber(lpFiber : LPVOID);

(* NT only *)
PROCEDURE ConvertThreadToFiber(lpParameter : LPVOID) : LPVOID;

(* NT only *)
PROCEDURE SwitchToFiber(lpFiber : LPVOID);

(* NT only *)
PROCEDURE SwitchToThread() : BOOL;

PROCEDURE CreateThread(lpThreadAttributes : SECURITY_ATTRIBUTES;
                       dwStackSize : DWORD;
                       lpStartAddress : LPTHREAD_START_ROUTINE;
                       lpParameter : LPVOID;
                       dwCreationFlags : DWORD;
                       VAR lpThreadId : DWORD) : HANDLE;

PROCEDURE CreateRemoteThread(hProcess : HANDLE;
                             lpThreadAttributes : SECURITY_ATTRIBUTES;
                             dwStackSize : DWORD;
                             lpStartAddress : LPTHREAD_START_ROUTINE;
                             lpParameter : LPVOID;
                             dwCreationFlags : DWORD;
                             VAR lpThreadId : DWORD) : HANDLE;

PROCEDURE GetCurrentThread() : HANDLE;

PROCEDURE GetCurrentThreadId() : DWORD;

PROCEDURE SetThreadPriority(hThread : HANDLE;
                            nPriority : INTEGER) : BOOL;

PROCEDURE GetThreadPriority(hThread : HANDLE) : INTEGER;

PROCEDURE SetThreadPriorityBoost(hThread : HANDLE;
                                 bDisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetThreadPriorityBoost(hThread : HANDLE;
                                 VAR pDisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetThreadTimes(hThread : HANDLE;
                         VAR lpCreationTime : FILETIME;
                         VAR lpExitTime : FILETIME;
                         VAR lpKernelTime : FILETIME;
                         VAR lpUserTime : FILETIME) : BOOL;

PROCEDURE ExitThread(dwExitCode : DWORD);

PROCEDURE TerminateThread(hThread : HANDLE;
                          dwExitCode : DWORD) : BOOL;

PROCEDURE GetExitCodeThread(hThread : HANDLE;
                            VAR lpExitCode : DWORD) : BOOL;

PROCEDURE GetThreadSelectorEntry(hThread : HANDLE;
                                 dwSelector : DWORD;
                                 VAR lpSelectorEntry : LDT_ENTRY) : BOOL;

TYPE
    EXECUTION_STATE = DWORD;

CONST
    ES_SYSTEM_REQUIRED  = 00000001h;
    ES_DISPLAY_REQUIRED = 00000002h;
    ES_USER_PRESENT     = 00000004h;
    ES_CONTINUOUS       = 80000000h;

PROCEDURE SetThreadExecutionState(esFlags : EXECUTION_STATE) : EXECUTION_STATE;

PROCEDURE GetLastError() : DWORD;

PROCEDURE SetLastError(dwErrCode : DWORD);


CONST
    SLE_ERROR            = 000000001h;
    SLE_MINORERROR       = 000000002h;
    SLE_WARNING          = 000000003h;

PROCEDURE SetLastErrorEx(dwErrCode : DWORD;
                         dwType : DWORD);

PROCEDURE GetOverlappedResult(hFile : HANDLE;
                              lpOverlapped : LPOVERLAPPED;
                              VAR lpNumberOfBytesTransferred : DWORD;
                              bWait : BOOL) : BOOL;

(*95*)
PROCEDURE CreateIoCompletionPort(
    FileHandle : HANDLE;
    ExistingCompletionPort : HANDLE;
    CompletionKey : DWORD;
    NumberOfConcurrentThreads : DWORD
    ) : HANDLE;

(*95*)
PROCEDURE GetQueuedCompletionStatus(
    CompletionPort : HANDLE;
    VAR lpNumberOfBytesTransferred : DWORD;
    VAR lpCompletionKey : DWORD;
    VAR lpOverlapped : LPOVERLAPPED;
    dwMilliseconds : DWORD
    ):BOOL;

(*95*)
PROCEDURE PostQueuedCompletionStatus(
                                    CompletionPort : HANDLE;
                                    dwNumberOfBytesTransferred : DWORD;
                                    dwCompletionKey : DWORD;
                                    VAR lpOverlapped : OVERLAPPED
                                    ) : BOOL;

CONST
    SEM_FAILCRITICALERRORS= 00001h;
    SEM_NOGPFAULTERRORBOX= 00002h;
    SEM_NOALIGNMENTFAULTEXCEPT  = 00004h;  (*95*)
    SEM_NOOPENFILEERRORBOX= 08000h;

PROCEDURE SetDebugErrorLevel(dwLevel : DWORD);

PROCEDURE SetErrorMode(uMode : UINT) : UINT;

PROCEDURE ReadProcessMemory(hProcess : HANDLE;
                            lpBaseAddress : LPCVOID;
                            VAR lpBuffer : ARRAY OF LOC;
                            nSize : DWORD;
                            VAR lpNumberOfBytesRead : DWORD) : BOOL;

PROCEDURE WriteProcessMemory(hProcess : HANDLE;
                             lpBaseAddress : LPVOID;
                             lpBuffer : ARRAY OF LOC;
                             nSize : DWORD;
                             VAR lpNumberOfBytesWritten : DWORD) : BOOL;

PROCEDURE GetThreadContext(hThread : HANDLE;
                           VAR lpContext : CONTEXT) : BOOL;

PROCEDURE SetThreadContext(hThread : HANDLE;
                           lpContext : CONTEXT) : BOOL;

PROCEDURE SuspendThread(hThread : HANDLE) : DWORD;

PROCEDURE ResumeThread(hThread : HANDLE) : DWORD;

TYPE PAPCFUNC = PROCEDURE(DWORD) [EXPORT];

(* NT only *)
PROCEDURE QueueUserAPC(pfnAPC : PAPCFUNC;
                       hThread : HANDLE;
                       dwData : DWORD) : DWORD;

PROCEDURE IsDebuggerPresent() : BOOL;

PROCEDURE DebugBreak();

PROCEDURE WaitForDebugEvent(VAR lpDebugEvent : DEBUG_EVENT;
                            dwMilliseconds : DWORD) : BOOL;

PROCEDURE ContinueDebugEvent(dwProcessId : DWORD;
                             dwThreadId : DWORD;
                             dwContinueStatus : DWORD) : BOOL;

PROCEDURE DebugActiveProcess(dwProcessId : DWORD) : BOOL;

PROCEDURE InitializeCriticalSection(VAR lpCriticalSection : CRITICAL_SECTION);

PROCEDURE EnterCriticalSection(VAR lpCriticalSection : CRITICAL_SECTION);

PROCEDURE LeaveCriticalSection(VAR lpCriticalSection : CRITICAL_SECTION);

PROCEDURE DeleteCriticalSection(VAR lpCriticalSection : CRITICAL_SECTION);

(* NT only *)
PROCEDURE TryEnterCriticalSection(VAR lpCriticalSection : CRITICAL_SECTION) : BOOL;

(* NT only *)
PROCEDURE InitializeCriticalSectionAndSpinCount(
                        VAR lpCriticalSection : CRITICAL_SECTION;
                        dwSpinCount : DWORD) : BOOL;

(* NT only *)
PROCEDURE SetCriticalSectionSpinCount(
                    VAR lpCriticalSection : CRITICAL_SECTION;
                    dwSpinCount : DWORD) : DWORD;

PROCEDURE SetEvent(hEvent : HANDLE) : BOOL;

PROCEDURE ResetEvent(hEvent : HANDLE) : BOOL;

PROCEDURE PulseEvent(hEvent : HANDLE) : BOOL;

PROCEDURE ReleaseSemaphore(hSemaphore : HANDLE;
                           lReleaseCount : LONG;
                           lpPreviousCount : LPLONG) : BOOL;

PROCEDURE ReleaseMutex(hMutex : HANDLE) : BOOL;

PROCEDURE WaitForSingleObject(hHandle : HANDLE;
                              dwMilliseconds : DWORD) : DWORD;

PROCEDURE WaitForMultipleObjects(nCount : DWORD;
                                 lpHandles : ARRAY OF HANDLE;
                                 bWaitAll : BOOL;
                                 dwMilliseconds : DWORD) : DWORD;

PROCEDURE Sleep(dwMilliseconds : DWORD);

PROCEDURE LoadResource(hModule : HINSTANCE;
                       hResInfo : HRSRC) : HGLOBAL;

PROCEDURE SizeofResource(hModule : HINSTANCE;
                         hResInfo : HRSRC) : DWORD;

PROCEDURE GlobalDeleteAtom(nAtom : ATOM) : ATOM;

PROCEDURE InitAtomTable(nSize : DWORD) : BOOL;

PROCEDURE DeleteAtom(nAtom : ATOM) : ATOM;

PROCEDURE SetHandleCount(uNumber : UINT) : UINT;

PROCEDURE GetLogicalDrives() : DWORD;

PROCEDURE LockFile(hFile : HANDLE;
                   dwFileOffsetLow : DWORD;
                   dwFileOffsetHigh : DWORD;
                   nNumberOfBytesToLockLow : DWORD;
                   nNumberOfBytesToLockHigh : DWORD) : BOOL;

PROCEDURE UnlockFile(hFile : HANDLE;
                     dwFileOffsetLow : DWORD;
                     dwFileOffsetHigh : DWORD;
                     nNumberOfBytesToUnlockLow : DWORD;
                     nNumberOfBytesToUnlockHigh : DWORD) : BOOL;

PROCEDURE LockFileEx(hFile : HANDLE;
                     dwFlags : DWORD;
                     dwReserved : DWORD;
                     nNumberOfBytesToLockLow : DWORD;
                     nNumberOfBytesToLockHigh : DWORD;
                     lpOverlapped : LPOVERLAPPED) : BOOL;


CONST
    LOCKFILE_FAIL_IMMEDIATELY= 000000001h;
    LOCKFILE_EXCLUSIVE_LOCK= 000000002h;

PROCEDURE UnlockFileEx(hFile : HANDLE;
                       dwReserved : DWORD;
                       nNumberOfBytesToUnlockLow : DWORD;
                       nNumberOfBytesToUnlockHigh : DWORD;
                       lpOverlapped : LPOVERLAPPED) : BOOL;


TYPE
    BY_HANDLE_FILE_INFORMATION = RECORD
          dwFileAttributes: DWORD;
          ftCreationTime : FILETIME;
          ftLastAccessTime: FILETIME;
          ftLastWriteTime: FILETIME;
          dwVolumeSerialNumber: DWORD;
          nFileSizeHigh  : DWORD;
          nFileSizeLow   : DWORD;
          nNumberOfLinks : DWORD;
          nFileIndexHigh : DWORD;
          nFileIndexLow  : DWORD;
    END;
    PBY_HANDLE_FILE_INFORMATION= POINTER TO BY_HANDLE_FILE_INFORMATION;
    LPBY_HANDLE_FILE_INFORMATION= PBY_HANDLE_FILE_INFORMATION;

PROCEDURE GetFileInformationByHandle(hFile : HANDLE;
                                     lpFileInformation : LPBY_HANDLE_FILE_INFORMATION) : BOOL;

PROCEDURE GetFileType(hFile : HANDLE) : DWORD;

PROCEDURE GetFileSize(hFile : HANDLE;
                      VAR lpFileSizeHigh : DWORD) : DWORD;

PROCEDURE GetStdHandle(nStdHandle : DWORD) : HANDLE;

PROCEDURE SetStdHandle(nStdHandle : DWORD;
                       hHandle : HANDLE) : BOOL;

PROCEDURE WriteFile(hFile : HANDLE;
                    lpBuffer : LPCVOID;
                    nNumberOfBytesToWrite : DWORD;
                    VAR lpNumberOfBytesWritten : DWORD;
                    lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE ReadFile(hFile : HANDLE;
                   lpBuffer : LPVOID;
                   nNumberOfBytesToRead : DWORD;
                   VAR lpNumberOfBytesRead : DWORD;
                   lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE FlushFileBuffers(hFile : HANDLE) : BOOL;

PROCEDURE DeviceIoControl(hDevice : HANDLE;
                          dwIoControlCode : DWORD;
                          lpInBuffer : LPVOID;
                          nInBufferSize : DWORD;
                          lpOutBuffer : LPVOID;
                          nOutBufferSize : DWORD;
                          VAR lpBytesReturned : DWORD;
                          lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE GetDevicePowerState(hFile : HANDLE) : BOOL;

PROCEDURE SetEndOfFile(hFile : HANDLE) : BOOL;

PROCEDURE SetFilePointer(hFile : HANDLE;
                         lDistanceToMove : LONG;
                         lpDistanceToMoveHigh : PLONG;
                         dwMoveMethod : DWORD) : DWORD;

PROCEDURE FindClose(hFindFile : HANDLE) : BOOL;

PROCEDURE GetFileTime(hFile : HANDLE;
                      VAR lpCreationTime : FILETIME;
                      VAR lpLastAccessTime : FILETIME;
                      VAR lpLastWriteTime : FILETIME) : BOOL;

PROCEDURE SetFileTime(hFile : HANDLE;
                      lpCreationTime : FILETIME;
                      lpLastAccessTime : FILETIME;
                      lpLastWriteTime : FILETIME) : BOOL;

PROCEDURE CloseHandle(hObject : HANDLE) : BOOL;

PROCEDURE DuplicateHandle(hSourceProcessHandle : HANDLE;
                          hSourceHandle : HANDLE;
                          hTargetProcessHandle : HANDLE;
                          VAR lpTargetHandle : HANDLE;
                          dwDesiredAccess : DWORD;
                          bInheritHandle : BOOL;
                          dwOptions : DWORD) : BOOL;

PROCEDURE GetHandleInformation(hObject : HANDLE; VAR lpdwFlags : DWORD) : BOOL;

PROCEDURE SetHandleInformation(hObject : HANDLE;
                               dwMask : DWORD;
                               dwFlags : DWORD) : BOOL;

CONST
    HANDLE_FLAG_INHERIT                 = 1;
    HANDLE_FLAG_PROTECT_FROM_CLOSE      = 2;

    HINSTANCE_ERROR                     = 32;

PROCEDURE LoadModule(lpModuleName : ARRAY OF ACHAR;
                     lpParameterBlock : LPVOID) : DWORD;

PROCEDURE WinExec(lpCmdLine : ARRAY OF ACHAR;
                  uCmdShow : UINT) : UINT;

TYPE
    COMMCONFIG = RECORD
        dwSize          : DWORD;
        wVersion        : WORD;
        wReserved       : WORD;
        dcb             : DCB;
        dwProviderSubType : DWORD;
        dwProviderOffset : DWORD;
        dwProviderSize  : DWORD;
        wcProviderData  : ARRAY [0..1-1] OF UCHAR;
    END;
    LPCOMMCONFIG =  POINTER TO COMMCONFIG;

PROCEDURE ClearCommBreak(hFile : HANDLE) : BOOL;

PROCEDURE ClearCommError(hFile : HANDLE;
                         VAR lpErrors : DWORD;
                         VAR OUT lpStat : COMSTAT) : BOOL;

PROCEDURE SetupComm(hFile : HANDLE;
                    dwInQueue : DWORD;
                    dwOutQueue : DWORD) : BOOL;

PROCEDURE EscapeCommFunction(hFile : HANDLE;
                             dwFunc : DWORD) : BOOL;

PROCEDURE GetCommConfig(hCommDev : HANDLE;
                        VAR lpCC : COMMCONFIG;
                        VAR lpdwSize : DWORD) : BOOL;

PROCEDURE SetCommConfig(hCommDev : HANDLE;
                        lpCC : COMMCONFIG;
                        dwSize : DWORD) : BOOL;

PROCEDURE GetCommMask(hFile : HANDLE;
                      VAR lpEvtMask : DWORD) : BOOL;

PROCEDURE GetCommProperties(hFile : HANDLE;
                            lpCommProp : LPCOMMPROP) : BOOL;

PROCEDURE GetCommModemStatus(hFile : HANDLE;
                             VAR lpModemStat : DWORD) : BOOL;

PROCEDURE GetCommState(hFile : HANDLE;
                       lpDCB : LPDCB) : BOOL;

PROCEDURE GetCommTimeouts(hFile : HANDLE;
                          lpCommTimeouts : LPCOMMTIMEOUTS) : BOOL;

PROCEDURE PurgeComm(hFile : HANDLE;
                    dwFlags : DWORD) : BOOL;

PROCEDURE SetCommBreak(hFile : HANDLE) : BOOL;

PROCEDURE SetCommMask(hFile : HANDLE;
                      dwEvtMask : DWORD) : BOOL;

PROCEDURE SetCommState(hFile : HANDLE;
                       lpDCB : LPDCB) : BOOL;

PROCEDURE SetCommTimeouts(hFile : HANDLE;
                          lpCommTimeouts : LPCOMMTIMEOUTS) : BOOL;

PROCEDURE TransmitCommChar(hFile : HANDLE;
                           cChar : ACHAR) : BOOL;

PROCEDURE WaitCommEvent(hFile : HANDLE;
                        VAR lpEvtMask : DWORD;
                        lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE SetTapePosition(hDevice : HANDLE;
                          dwPositionMethod : DWORD;
                          dwPartition : DWORD;
                          dwOffsetLow : DWORD;
                          dwOffsetHigh : DWORD;
                          bImmediate : BOOL) : DWORD;

PROCEDURE GetTapePosition(hDevice : HANDLE;
                          dwPositionType : DWORD;
                          VAR lpdwPartition : DWORD;
                          VAR lpdwOffsetLow : DWORD;
                          VAR lpdwOffsetHigh : DWORD) : DWORD;

PROCEDURE PrepareTape(hDevice : HANDLE;
                      dwOperation : DWORD;
                      bImmediate : BOOL) : DWORD;

PROCEDURE EraseTape(hDevice : HANDLE;
                    dwEraseType : DWORD;
                    bImmediate : BOOL) : DWORD;

PROCEDURE CreateTapePartition(hDevice : HANDLE;
                              dwPartitionMethod : DWORD;
                              dwCount : DWORD;
                              dwSize : DWORD) : DWORD;

PROCEDURE WriteTapemark(hDevice : HANDLE;
                        dwTapemarkType : DWORD;
                        dwTapemarkCount : DWORD;
                        bImmediate : BOOL) : DWORD;

PROCEDURE GetTapeStatus(hDevice : HANDLE) : DWORD;

PROCEDURE GetTapeParameters(hDevice : HANDLE;
                            dwOperation : DWORD;
                            VAR lpdwSize : DWORD;
                            lpTapeInformation : LPVOID) : DWORD;


CONST
    GET_TAPE_MEDIA_INFORMATION= 0;
    GET_TAPE_DRIVE_INFORMATION= 1;

PROCEDURE SetTapeParameters(hDevice : HANDLE;
                            dwOperation : DWORD;
                            lpTapeInformation : LPVOID) : DWORD;


CONST
    SET_TAPE_MEDIA_INFORMATION= 0;
    SET_TAPE_DRIVE_INFORMATION= 1;

PROCEDURE Beep(dwFreq : DWORD;
               dwDuration : DWORD) : BOOL;

PROCEDURE OpenSound();

PROCEDURE CloseSound();

PROCEDURE StartSound();

PROCEDURE StopSound();

PROCEDURE WaitSoundState(nState : DWORD) : DWORD;

PROCEDURE SyncAllVoices() : DWORD;

PROCEDURE CountVoiceNotes(nVoice : DWORD) : DWORD;

PROCEDURE GetThresholdEvent() : LPDWORD;

PROCEDURE GetThresholdStatus() : DWORD;

PROCEDURE SetSoundNoise(nSource : DWORD;
                        nDuration : DWORD) : DWORD;

PROCEDURE SetVoiceAccent(nVoice : DWORD;
                         nTempo : DWORD;
                         nVolume : DWORD;
                         nMode : DWORD;
                         nPitch : DWORD) : DWORD;

PROCEDURE SetVoiceEnvelope(nVoice : DWORD;
                           nShape : DWORD;
                           nRepeat : DWORD) : DWORD;

PROCEDURE SetVoiceNote(nVoice : DWORD;
                       nValue : DWORD;
                       nLength : DWORD;
                       nCdots : DWORD) : DWORD;

PROCEDURE SetVoiceQueueSize(nVoice : DWORD;
                            nBytes : DWORD) : DWORD;

PROCEDURE SetVoiceSound(nVoice : DWORD;
                        Frequency : DWORD;
                        nDuration : DWORD) : DWORD;

PROCEDURE SetVoiceThreshold(nVoice : DWORD;
                            nNotes : DWORD) : DWORD;

PROCEDURE MulDiv(nNumber : INTEGER;
                 nNumerator : INTEGER;
                 nDenominator : INTEGER) : INTEGER;

PROCEDURE GetSystemTime(VAR lpSystemTime : SYSTEMTIME);

PROCEDURE GetSystemTimeAsFileTime(VAR lpSystemTimeAsFileTime : FILETIME);

PROCEDURE SetSystemTime(lpSystemTime : SYSTEMTIME) : BOOL;

PROCEDURE GetLocalTime(VAR lpSystemTime : SYSTEMTIME);

PROCEDURE SetLocalTime(lpSystemTime : SYSTEMTIME) : BOOL;

PROCEDURE GetSystemInfo(VAR lpSystemInfo : SYSTEM_INFO);

PROCEDURE IsProcessorFeaturePresent(ProcessorFeature : DWORD) : BOOL;

TYPE
    TIME_ZONE_INFORMATION = RECORD
          Bias           : LONG;
          StandardName   : ARRAY [0..32 - 1] OF WCHAR;
          StandardDate   : SYSTEMTIME;
          StandardBias   : LONG;
          DaylightName   : ARRAY [0..32 - 1] OF WCHAR;
          DaylightDate   : SYSTEMTIME;
          DaylightBias   : LONG;
    END;
    PTIME_ZONE_INFORMATION= POINTER TO TIME_ZONE_INFORMATION;
    LPTIME_ZONE_INFORMATION= PTIME_ZONE_INFORMATION;

(*95*)
PROCEDURE SystemTimeToTzSpecificLocalTime(
    VAR lpTimeZoneInformation : TIME_ZONE_INFORMATION;
    VAR lpUniversalTime : SYSTEMTIME;
    VAR lpLocalTime : SYSTEMTIME
    ) : BOOL;

PROCEDURE GetTimeZoneInformation(VAR lpTimeZoneInformation : TIME_ZONE_INFORMATION) : DWORD;

PROCEDURE SetTimeZoneInformation(lpTimeZoneInformation : TIME_ZONE_INFORMATION) : BOOL;

PROCEDURE SystemTimeToFileTime(lpSystemTime : SYSTEMTIME;
                               VAR lpFileTime : FILETIME) : BOOL;

PROCEDURE FileTimeToLocalFileTime(lpFileTime : FILETIME;
                                  VAR lpLocalFileTime : FILETIME) : BOOL;

PROCEDURE LocalFileTimeToFileTime(lpLocalFileTime : FILETIME;
                                  VAR lpFileTime : FILETIME) : BOOL;

PROCEDURE FileTimeToSystemTime(lpFileTime : FILETIME;
                               VAR lpSystemTime : SYSTEMTIME) : BOOL;

PROCEDURE CompareFileTime(lpFileTime1 : FILETIME;
                          lpFileTime2 : FILETIME) : LONG;

PROCEDURE FileTimeToDosDateTime(lpFileTime : FILETIME;
                                VAR lpFatDate : WORD;
                                VAR lpFatTime : WORD) : BOOL;

PROCEDURE DosDateTimeToFileTime(wFatDate : WORD;
                                wFatTime : WORD;
                                VAR lpFileTime : FILETIME) : BOOL;

PROCEDURE GetTickCount() : DWORD;


PROCEDURE SetSystemTimeAdjustment(
                                    dwTimeAdjustment : DWORD;
                                    bTimeAdjustmentDisabled : BOOL
                                    ) : BOOL;

PROCEDURE GetSystemTimeAdjustment(
                                    VAR lpTimeAdjustment : DWORD;
                                    VAR lpTimeIncrement : DWORD;
                                    VAR lpTimeAdjustmentDisabled : BOOL
                                    ) : BOOL;


PROCEDURE FormatMessageA(
                        dwFlags : DWORD;
                        lpSource : LPCVOID;
                        dwMessageId : DWORD;
                        dwLanguageId : DWORD;
                        VAR lpBuffer : ARRAY OF ACHAR;
                        nSize : DWORD;
                        Arguments : PCHAR
                        ) : DWORD;

PROCEDURE FormatMessageW(
                        dwFlags : DWORD;
                        lpSource : LPCVOID;
                        dwMessageId : DWORD;
                        dwLanguageId : DWORD;
                        VAR lpBuffer : ARRAY OF UCHAR;
                        nSize : DWORD;
                        Arguments : PCHAR
                        ) : DWORD;

%IF UNICODE %THEN
PROCEDURE FormatMessage = FormatMessageW;
%ELSE
PROCEDURE FormatMessage = FormatMessageA;
%END

CONST
    FORMAT_MESSAGE_ALLOCATE_BUFFER= 000000100h;
    FORMAT_MESSAGE_IGNORE_INSERTS= 000000200h;
    FORMAT_MESSAGE_FROM_STRING= 000000400h;
    FORMAT_MESSAGE_FROM_HMODULE= 000000800h;
    FORMAT_MESSAGE_FROM_SYSTEM= 000001000h;
    FORMAT_MESSAGE_ARGUMENT_ARRAY= 000002000h;
    FORMAT_MESSAGE_MAX_WIDTH_MASK= 0000000FFh;

TYPE
    MESSAGE_RESOURCE_ENTRY = RECORD
        Length          : WORD;
        Flags           : WORD;
        Text            : ARRAY [0..1-1] OF BYTE;
    END;
    PMESSAGE_RESOURCE_ENTRY = POINTER TO MESSAGE_RESOURCE_ENTRY;

CONST
    MESSAGE_RESOURCE_UNICODE    = 1;

TYPE
    MESSAGE_RESOURCE_BLOCK = RECORD
        LowId           : DWORD;
        HighId          : DWORD;
        OffsetToEntries : DWORD;
    END;
    PMESSAGE_RESOURCE_BLOCK = POINTER TO MESSAGE_RESOURCE_BLOCK;

    MESSAGE_RESOURCE_DATA = RECORD
        NumberOfBlocks          : DWORD;
        Blocks                  : ARRAY [0..1-1] OF MESSAGE_RESOURCE_BLOCK;
    END;
    PMESSAGE_RESOURCE_DATA      = POINTER TO MESSAGE_RESOURCE_DATA;

PROCEDURE CreatePipe(VAR read : HANDLE;
                     VAR write : HANDLE;
                     attr : SECURITY_ATTRIBUTES;
                     size : DWORD) : BOOL;

PROCEDURE ConnectNamedPipe(hNamedPipe : HANDLE;
                           lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE DisconnectNamedPipe(hNamedPipe : HANDLE) : BOOL;

PROCEDURE SetNamedPipeHandleState(hNamedPipe : HANDLE;
                                  VAR lpMode : DWORD;
                                  VAR lpMaxCollectionCount : DWORD;
                                  VAR lpCollectDataTimeout : DWORD) : BOOL;

PROCEDURE GetNamedPipeInfo(hNamedPipe : HANDLE;
                           VAR lpFlags : DWORD;
                           VAR lpOutBufferSize : DWORD;
                           VAR lpInBufferSize : DWORD;
                           VAR lpMaxInstances : DWORD) : BOOL;

PROCEDURE PeekNamedPipe(hNamedPipe : HANDLE;
                        lpBuffer : LPVOID;
                        nBufferSize : DWORD;
                        VAR lpBytesRead : DWORD;
                        VAR lpTotalBytesAvail : DWORD;
                        VAR lpBytesLeftThisMessage : DWORD) : BOOL;

PROCEDURE TransactNamedPipe(hNamedPipe : HANDLE;
                            lpInBuffer : LPVOID;
                            nInBufferSize : DWORD;
                            lpOutBuffer : LPVOID;
                            nOutBufferSize : DWORD;
                            VAR lpBytesRead : DWORD;
                            lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE CreateMailslotA(lpName : ARRAY OF ACHAR;
                          nMaxMessageSize : DWORD;
                          lReadTimeout : DWORD;
                          lpSecurityAttributes : SECURITY_ATTRIBUTES) : HANDLE;

PROCEDURE CreateMailslotW(lpName : ARRAY OF UCHAR;
                          nMaxMessageSize : DWORD;
                          lReadTimeout : DWORD;
                          lpSecurityAttributes : SECURITY_ATTRIBUTES) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateMailslot = CreateMailslotW;
%ELSE
PROCEDURE CreateMailslot = CreateMailslotA;

%END

PROCEDURE GetMailslotInfo(hMailslot : HANDLE;
                          VAR lpMaxMessageSize : DWORD;
                          VAR lpNextSize : DWORD;
                          VAR lpMessageCount : DWORD;
                          VAR lpReadTimeout : DWORD) : BOOL;

PROCEDURE SetMailslotInfo(hMailslot : HANDLE;
                          lReadTimeout : DWORD) : BOOL;

PROCEDURE MapViewOfFile(hFileMappingObject : HANDLE;
                        dwDesiredAccess : DWORD;
                        dwFileOffsetHigh : DWORD;
                        dwFileOffsetLow : DWORD;
                        dwNumberOfBytesToMap : DWORD) : LPVOID;

%IF WIN5 %AND VLM %THEN
PROCEDURE MapViewOfFileVlm(hFileMappingObject : HANDLE;
                           dwDesiredAccess : DWORD;
                           ulOffset : DWORDLONG;
                           ulNumberOfBytesToMap : DWORDLONG;
                           lpBaseAddress : PVOID64) : PVOID64;

PROCEDURE UnmapViewOfFileVlm(lpBaseAddress : PVOID64) : BOOL;
%END

PROCEDURE FlushViewOfFile(lpBaseAddress : LPCVOID;
                          dwNumberOfBytesToFlush : DWORD) : BOOL;

PROCEDURE UnmapViewOfFile(lpBaseAddress : LPVOID) : BOOL;

(*
 File Encryption API
*)

PROCEDURE EncryptFileA(lpFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE EncryptFileW(lpFileName : ARRAY OF WCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE EncryptFile = EncryptFileW;
%ELSE
PROCEDURE EncryptFile = EncryptFileA;
%END

PROCEDURE DecryptFileA(lpFileName : ARRAY OF ACHAR;
                       dwReserved : DWORD) : BOOL;

PROCEDURE DecryptFileW(lpFileName : ARRAY OF WCHAR;
                       dwReserved : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE DecryptFile = DecryptFileW;
%ELSE
PROCEDURE DecryptFile = DecryptFileA;
%END

(*
 Currently defined recovery flags
*)

CONST
    EFS_USE_RECOVERY_KEYS  = 1h;

TYPE
    PFE_EXPORT_FUNC = PROCEDURE(VAR ARRAY OF LOC, PVOID, ULONG) : DWORD [EXPORT];
    PFE_IMPORT_FUNC = PROCEDURE(VAR ARRAY OF LOC, PVOID, ULONG) : DWORD [EXPORT];


(*
  OpenRaw flag values
*)
CONST
    CREATE_FOR_IMPORT  =(1);
    CREATE_FOR_DIR     =(2);


PROCEDURE OpenRawA(lpFileName  : ARRAY OF ACHAR;
                   ulFlags : ULONG;
                   VAR pvContext  : PVOID) : DWORD;

PROCEDURE OpenRawW(lpFileName  : ARRAY OF WCHAR;
                   ulFlags : ULONG;
                   VAR pvContext  : PVOID) : DWORD;

%IF UNICODE %THEN
PROCEDURE OpenRaw = OpenRawW;
%ELSE
PROCEDURE OpenRaw = OpenRawA;
%END

PROCEDURE ReadRaw(pfExportCallback : PFE_EXPORT_FUNC;
                  pvCallbackContext : PVOID;
                  pvContext : PVOID) : DWORD;

PROCEDURE WriteRaw(pfExportCallback : PFE_IMPORT_FUNC;
                   pvCallbackContext : PVOID;
                   pvContext : PVOID) : DWORD;

PROCEDURE CloseRaw(pvContext : PVOID);

TYPE
    RECOVERY_AGENT_INFORMATIONA = RECORD
    NextEntryOffset : DWORD;
    AgentNameLength : DWORD;
    AgentInformation : ARRAY [0..1-1] OF ACHAR;
    END;
    LPRECOVERY_AGENT_INFORMATIONA = POINTER TO RECOVERY_AGENT_INFORMATIONA;

    RECOVERY_AGENT_INFORMATIONW = RECORD
    NextEntryOffset : DWORD;
    AgentNameLength : DWORD;
    AgentInformation : ARRAY [0..1-1] OF WCHAR;
    END;
    LPRECOVERY_AGENT_INFORMATIONW = POINTER TO RECOVERY_AGENT_INFORMATIONW;

%IF UNICODE %THEN
    RECOVERY_AGENT_INFORMATION = RECOVERY_AGENT_INFORMATIONW;
    LPRECOVERY_AGENT_INFORMATION = LPRECOVERY_AGENT_INFORMATIONW;
%ELSE
    RECOVERY_AGENT_INFORMATION = RECOVERY_AGENT_INFORMATIONA;
    LPRECOVERY_AGENT_INFORMATION = LPRECOVERY_AGENT_INFORMATIONA;
%END

PROCEDURE QueryRecoveryAgentsA(lpFileName : ARRAY OF ACHAR;
     VAR OUT AgentCount : DWORD;
     VAR OUT RecoveryAgentInformation : RECOVERY_AGENT_INFORMATIONA) : DWORD;

PROCEDURE QueryRecoveryAgentsW(lpFileName : ARRAY OF WCHAR;
     VAR OUT AgentCount : DWORD;
     VAR OUT RecoveryAgentInformation : RECOVERY_AGENT_INFORMATIONW) : DWORD;

%IF UNICODE %THEN
PROCEDURE QueryRecoveryAgents = QueryRecoveryAgentsW;
%ELSE
PROCEDURE QueryRecoveryAgents = QueryRecoveryAgentsA;
%END

PROCEDURE lstrcmpA(lpString1 : ARRAY OF ACHAR;
                   lpString2 : ARRAY OF ACHAR) : INTEGER;

PROCEDURE lstrcmpW(lpString1 : ARRAY OF UCHAR;
                   lpString2 : ARRAY OF UCHAR) : INTEGER;

%IF UNICODE %THEN
PROCEDURE lstrcmp = lstrcmpW;
%ELSE
PROCEDURE lstrcmp = lstrcmpA;
%END

PROCEDURE lstrcmpiA(lpString1 : ARRAY OF ACHAR;
                    lpString2 : ARRAY OF ACHAR) : INTEGER;

PROCEDURE lstrcmpiW(lpString1 : ARRAY OF UCHAR;
                    lpString2 : ARRAY OF UCHAR) : INTEGER;

%IF UNICODE %THEN
PROCEDURE lstrcmpi = lstrcmpiW;
%ELSE
PROCEDURE lstrcmpi = lstrcmpiA;
%END

PROCEDURE lstrcpynA(
                    VAR lpString1 : ARRAY OF ACHAR;
                    lpString2 : ARRAY OF ACHAR;
                    iMaxLength : WINT
                    ) : LPSTR;

PROCEDURE lstrcpynW(
                    VAR lpString1 : ARRAY OF UCHAR;
                    lpString2 : ARRAY OF UCHAR;
                    iMaxLength : WINT
                    ) : LPWSTR;
%IF UNICODE %THEN
PROCEDURE lstrcpyn = lstrcpynW;
%ELSE
PROCEDURE lstrcpyn = lstrcpynA;
%END

PROCEDURE lstrcpyA(VAR lpString1 : ARRAY OF ACHAR;
                   lpString2 : ARRAY OF ACHAR) : LPSTR;

PROCEDURE lstrcpyW(VAR lpString1 : ARRAY OF UCHAR;
                   lpString2 : ARRAY OF UCHAR) : LPWSTR;

%IF UNICODE %THEN
PROCEDURE lstrcpy = lstrcpyW;
%ELSE
PROCEDURE lstrcpy = lstrcpyA;
%END

PROCEDURE lstrcatA(VAR lpString1 : ARRAY OF ACHAR;
                   lpString2 : ARRAY OF ACHAR) : LPSTR;

PROCEDURE lstrcatW(VAR lpString1 : ARRAY OF UCHAR;
                   lpString2 : ARRAY OF UCHAR) : LPWSTR;

%IF UNICODE %THEN
PROCEDURE lstrcat = lstrcatW;
%ELSE
PROCEDURE lstrcat = lstrcatA;
%END

PROCEDURE lstrlenA(lpString : ARRAY OF ACHAR) : INTEGER;

PROCEDURE lstrlenW(lpString : ARRAY OF UCHAR) : INTEGER;

%IF UNICODE %THEN
PROCEDURE lstrlen = lstrlenW;
%ELSE
PROCEDURE lstrlen = lstrlenA;
%END

PROCEDURE OpenFile(lpFileName : ARRAY OF ACHAR;
                   VAR lpReOpenBuff : OFSTRUCT;
                   uStyle : UINT) : HFILE;

PROCEDURE _lopen(lpPathName : ARRAY OF ACHAR;
                 iReadWrite : INTEGER) : HFILE;

PROCEDURE _lcreat(lpPathName : ARRAY OF ACHAR;
                  iAttribute : INTEGER) : HFILE;

PROCEDURE _lread(hFile : HFILE;
                 VAR lpBuffer : ARRAY OF LOC;
                 uBytes : UINT) : UINT;

PROCEDURE _lwrite(hFile : HFILE;
                  lpBuffer : ARRAY OF LOC;
                  uBytes : UINT) : UINT;

PROCEDURE _hread(hFile : HFILE;
                 VAR lpBuffer : ARRAY OF LOC;
                 lBytes : INTEGER) : INTEGER;

PROCEDURE _hwrite(hFile : HFILE;
                  lpBuffer : ARRAY OF LOC;
                  lBytes : INTEGER) : INTEGER;

PROCEDURE _lclose(hFile : HFILE) : HFILE;

PROCEDURE _llseek(hFile : HFILE;
                  lOffset : LONG;
                  iOrigin : INTEGER) : LONG;

(*95*)
PROCEDURE IsTextUnicode(
                        lpBuffer : ADDRESS;
                        cb : WINT;
                        VAR lpi : WINT
                        ) :  BOOL;

CONST
    TLS_OUT_OF_INDEXES = 0FFFFFFFFh;

PROCEDURE TlsAlloc() : DWORD;

PROCEDURE TlsGetValue(dwTlsIndex : DWORD) : LPVOID;

PROCEDURE TlsSetValue(dwTlsIndex : DWORD;
                      lpTlsValue : LPVOID) : BOOL;

PROCEDURE TlsFree(dwTlsIndex : DWORD) : BOOL;

TYPE
    LPOVERLAPPED_COMPLETION_ROUTINE= PROCEDURE (DWORD, DWORD, LPOVERLAPPED) [EXPORT];

PROCEDURE SleepEx(dwMilliseconds : DWORD;
                  bAlertable : BOOL) : DWORD;

PROCEDURE WaitForSingleObjectEx(hHandle : HANDLE;
                                dwMilliseconds : DWORD;
                                bAlertable : BOOL) : DWORD;

PROCEDURE WaitForMultipleObjectsEx(nCount : DWORD;
                                   lpHandles : ARRAY OF HANDLE;
                                   bWaitAll : BOOL;
                                   dwMilliseconds : DWORD;
                                   bAlertable : BOOL) : DWORD;

(* NT only *)
PROCEDURE SignalObjectAndWait(hObjectToSignal : HANDLE;
                              hObjectToWaitOn : HANDLE;
                              dwMilliseconds : DWORD;
                              bAlertable : BOOL) : DWORD;

PROCEDURE ReadFileEx(hFile : HANDLE;
                     lpBuffer : LPVOID;
                     nNumberOfBytesToRead : DWORD;
                     lpOverlapped : LPOVERLAPPED;
                     lpCompletionRoutine : LPOVERLAPPED_COMPLETION_ROUTINE) : BOOL;

PROCEDURE WriteFileEx(hFile : HANDLE;
                      lpBuffer : LPCVOID;
                      nNumberOfBytesToWrite : DWORD;
                      lpOverlapped : LPOVERLAPPED;
                      lpCompletionRoutine : LPOVERLAPPED_COMPLETION_ROUTINE) : BOOL;

PROCEDURE BackupRead(hFile : HANDLE;
                     lpBuffer : LPBYTE;
                     nNumberOfBytesToRead : DWORD;
                     VAR lpNumberOfBytesRead : DWORD;
                     bAbort : BOOL;
                     bProcessSecurity : BOOL;
                     VAR lpContext : LPVOID) : BOOL;

PROCEDURE BackupSeek(hFile : HANDLE;
                     dwLowBytesToSeek : DWORD;
                     dwHighBytesToSeek : DWORD;
                     VAR lpdwLowByteSeeked : DWORD;
                     VAR lpdwHighByteSeeked : DWORD;
                     VAR lpContext : LPVOID) : BOOL;

PROCEDURE BackupWrite(hFile : HANDLE;
                      lpBuffer : LPBYTE;
                      nNumberOfBytesToWrite : DWORD;
                      VAR lpNumberOfBytesWritten : DWORD;
                      bAbort : BOOL;
                      bProcessSecurity : BOOL;
                      VAR lpContext : LPVOID) : BOOL;


TYPE
    WIN32_STREAM_ID = RECORD
          dwStreamId     : DWORD;
          dwStreamAttributes: DWORD;
          Size           : LARGE_INTEGER;
          dwStreamNameSize: DWORD;
          cStreamName    : ARRAY [0..ANYSIZE_ARRAY - 1] OF WCHAR;
    END;
    LPWIN32_STREAM_ID    = POINTER TO WIN32_STREAM_ID;

CONST
    BACKUP_INVALID       = 000000000h;
    BACKUP_DATA          = 000000001h;
    BACKUP_EA_DATA       = 000000002h;
    BACKUP_SECURITY_DATA = 000000003h;
    BACKUP_ALTERNATE_DATA= 000000004h;
    BACKUP_LINK          = 000000005h;
    BACKUP_PROPERTY_DATA = 000000006h;
    BACKUP_OBJECT_ID        = 00000007h;
    BACKUP_REPARSE_DATA     = 00000008h;
    BACKUP_SPARSE_BLOCK     = 00000009h;

    STREAM_NORMAL_ATTRIBUTE     = 00000h;
    STREAM_MODIFIED_WHEN_READ   = 00001h;
    STREAM_CONTAINS_SECURITY    = 00002h;
    STREAM_CONTAINS_PROPERTIES  = 00004h;
    STREAM_SPARSE_ATTRIBUTE     = 00000008h;

%IF WIN5 %AND VLM %THEN
(*
 Define segement buffer structure for scatter/gather read/write.
*)

TYPE
    FILE_SEGMENT_ELEMENT = RECORD
    CASE : BOOLEAN OF
    FALSE: Buffer : PVOID64;|
    TRUE: Alignment : ULONGLONG;
    END;
    END;
    PFILE_SEGMENT_ELEMENT = POINTER TO FILE_SEGMENT_ELEMENT;

PROCEDURE ReadFileScatter(hFile : HANDLE;
                          aSegmentArray : ARRAY OF FILE_SEGMENT_ELEMENT;
                          nNumberOfBytesToRead : DWORD;
                          lpReserved : LPDWORD;
                          lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE WriteFileGather(hFile : HANDLE;
                          aSegmentArray : ARRAY OF FILE_SEGMENT_ELEMENT;
                          nNumberOfBytesToWrite : DWORD;
                          lpReserved : LPDWORD;
                          lpOverlapped : LPOVERLAPPED) : BOOL;
%END

CONST
    STARTF_USESHOWWINDOW = 000000001h;
    STARTF_USESIZE       = 000000002h;
    STARTF_USEPOSITION   = 000000004h;
    STARTF_USECOUNTCHARS = 000000008h;
    STARTF_USEFILLATTRIBUTE= 000000010h;
    STARTF_RUNFULLSCREEN   = 000000020h;
    STARTF_FORCEONFEEDBACK = 000000040h;
    STARTF_FORCEOFFFEEDBACK= 000000080h;
    STARTF_USESTDHANDLES   = 000000100h;
    STARTF_USEHOTKEY       = 000000200h;(*95*)


TYPE
    STARTUPINFOA = RECORD
          cb             : DWORD;
          lpReserved     : LPSTR;
          lpDesktop      : LPSTR;
          lpTitle        : LPSTR;
          dwX            : DWORD;
          dwY            : DWORD;
          dwXSize        : DWORD;
          dwYSize        : DWORD;
          dwXCountChars  : DWORD;
          dwYCountChars  : DWORD;
          dwFillAttribute: DWORD;
          dwFlags        : DWORD;
          wShowWindow    : WORD;
          cbReserved2    : WORD;
          lpReserved2    : LPBYTE;
          hStdInput      : HANDLE;
          hStdOutput     : HANDLE;
          hStdError      : HANDLE;
    END;
    LPSTARTUPINFOA       = POINTER TO STARTUPINFOA;

    STARTUPINFOW = RECORD
          cb             : DWORD;
          lpReserved     : LPWSTR;
          lpDesktop      : LPWSTR;
          lpTitle        : LPWSTR;
          dwX            : DWORD;
          dwY            : DWORD;
          dwXSize        : DWORD;
          dwYSize        : DWORD;
          dwXCountChars  : DWORD;
          dwYCountChars  : DWORD;
          dwFillAttribute: DWORD;
          dwFlags        : DWORD;
          wShowWindow    : WORD;
          cbReserved2    : WORD;
          lpReserved2    : LPBYTE;
          hStdInput      : HANDLE;
          hStdOutput     : HANDLE;
          hStdError      : HANDLE;
    END;
    LPSTARTUPINFOW       = POINTER TO STARTUPINFOW;

    %IF UNICODE %THEN
    STARTUPINFO          = STARTUPINFOW;
    %ELSE
    STARTUPINFO          = STARTUPINFOA;
    %END
    LPSTARTUPINFO        = POINTER TO STARTUPINFO;

CONST
    SHUTDOWN_NORETRY     = 000000001h;

TYPE
    WIN32_FIND_DATAA = RECORD
          dwFileAttributes: DWORD;
          ftCreationTime : FILETIME;
          ftLastAccessTime: FILETIME;
          ftLastWriteTime: FILETIME;
          nFileSizeHigh  : DWORD;
          nFileSizeLow   : DWORD;
          dwReserved0    : DWORD;
          dwReserved1    : DWORD;
          cFileName      : ARRAY [0..MAX_PATH - 1] OF ACHAR;
          cAlternateFileName: ARRAY [0..14 - 1] OF ACHAR;
    END;
    PWIN32_FIND_DATAA    = POINTER TO WIN32_FIND_DATAA;
    LPWIN32_FIND_DATAA   = PWIN32_FIND_DATAA;

    WIN32_FIND_DATAW = RECORD
          dwFileAttributes: DWORD;
          ftCreationTime : FILETIME;
          ftLastAccessTime: FILETIME;
          ftLastWriteTime: FILETIME;
          nFileSizeHigh  : DWORD;
          nFileSizeLow   : DWORD;
          dwReserved0    : DWORD;
          dwReserved1    : DWORD;
          cFileName      : ARRAY [0..MAX_PATH - 1] OF WCHAR;
          cAlternateFileName: ARRAY [0..14 - 1] OF WCHAR;
    END;
    PWIN32_FIND_DATAW    = POINTER TO WIN32_FIND_DATAW;
    LPWIN32_FIND_DATAW   = PWIN32_FIND_DATAW;

%IF UNICODE %THEN
    WIN32_FIND_DATA      = WIN32_FIND_DATAW;
    PWIN32_FIND_DATA     = PWIN32_FIND_DATAW;
%ELSE
    WIN32_FIND_DATA      = WIN32_FIND_DATAA;
    PWIN32_FIND_DATA     = PWIN32_FIND_DATAA;
%END
    LPWIN32_FIND_DATA    = PWIN32_FIND_DATA;

    WIN32_FILE_ATTRIBUTE_DATA = RECORD
    dwFileAttributes    :DWORD;
    ftCreationTime      : FILETIME;
    ftLastAccessTime    : FILETIME;
    ftLastWriteTime     : FILETIME;
    nFileSizeHigh       : DWORD;
    nFileSizeLow        : DWORD;
    END;
    LPWIN32_FILE_ATTRIBUTE_DATA = POINTER TO WIN32_FILE_ATTRIBUTE_DATA;

PROCEDURE CreateMutexA(lpMutexAttributes : SECURITY_ATTRIBUTES;
                       bInitialOwner : BOOL;
                       lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateMutexW(lpMutexAttributes : SECURITY_ATTRIBUTES;
                       bInitialOwner : BOOL;
                       lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateMutex = CreateMutexW;
%ELSE
PROCEDURE CreateMutex = CreateMutexA;
%END

PROCEDURE OpenMutexA(dwDesiredAccess : DWORD;
                     bInheritHandle : BOOL;
                     lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenMutexW(dwDesiredAccess : DWORD;
                     bInheritHandle : BOOL;
                     lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenMutex = OpenMutexW;
%ELSE
PROCEDURE OpenMutex = OpenMutexA;
%END

PROCEDURE CreateEventA(lpEventAttributes : SECURITY_ATTRIBUTES;
                       bManualReset : BOOL;
                       bInitialState : BOOL;
                       lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateEventW(lpEventAttributes : SECURITY_ATTRIBUTES;
                       bManualReset : BOOL;
                       bInitialState : BOOL;
                       lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateEvent = CreateEventW;
%ELSE
PROCEDURE CreateEvent = CreateEventA;
%END

PROCEDURE OpenEventA(dwDesiredAccess : DWORD;
                     bInheritHandle : BOOL;
                     lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenEventW(dwDesiredAccess : DWORD;
                     bInheritHandle : BOOL;
                     lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenEvent = OpenEventW;
%ELSE
PROCEDURE OpenEvent = OpenEventA;
%END

PROCEDURE CreateSemaphoreA(lpSemaphoreAttributes : SECURITY_ATTRIBUTES;
                           lInitialCount : LONG;
                           lMaximumCount : LONG;
                           lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateSemaphoreW(lpSemaphoreAttributes : SECURITY_ATTRIBUTES;
                           lInitialCount : LONG;
                           lMaximumCount : LONG;
                           lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateSemaphore = CreateSemaphoreW;
%ELSE
PROCEDURE CreateSemaphore = CreateSemaphoreA;
%END

PROCEDURE OpenSemaphoreA(dwDesiredAccess : DWORD;
                         bInheritHandle : BOOL;
                         lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenSemaphoreW(dwDesiredAccess : DWORD;
                         bInheritHandle : BOOL;
                         lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenSemaphore = OpenSemaphoreW;
%ELSE
PROCEDURE OpenSemaphore = OpenSemaphoreA;
%END

TYPE PTIMERAPCROUTINE   = PROCEDURE((*lpArgToCompletionRoutine*)LPVOID,
                                    (*dwTimerLowValue*)DWORD,
                                    (*dwTimerHighValue*)DWORD) [EXPORT];

PROCEDURE CreateWaitableTimerA(lpTimerAttributes : SECURITY_ATTRIBUTES;
                               bManualReset : BOOL;
                               lpTimerName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateWaitableTimerW(lpTimerAttributes : SECURITY_ATTRIBUTES;
                               bManualReset : BOOL;
                               lpTimerName : ARRAY OF WCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateWaitableTimer = CreateWaitableTimerW;
%ELSE
PROCEDURE CreateWaitableTimer = CreateWaitableTimerA;
%END

PROCEDURE OpenWaitableTimerA(dwDesiredAccess : DWORD;
                             bInheritHandle : BOOL;
                             lpTimerName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenWaitableTimerW(dwDesiredAccess : DWORD;
                             bInheritHandle : BOOL;
                             lpTimerName : ARRAY OF WCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenWaitableTimer = OpenWaitableTimerW;
%ELSE
PROCEDURE OpenWaitableTimer = OpenWaitableTimerA;
%END

PROCEDURE SetWaitableTimer(hTimer : HANDLE;
                           VAR lpDueTime : LARGE_INTEGER;
                           lPeriod : LONG;
                           pfnCompletionRoutine : PTIMERAPCROUTINE;
                           lpArgToCompletionRoutine : LPVOID;
                           fResume : BOOL) : BOOL;

PROCEDURE CancelWaitableTimer(hTimer : HANDLE) : BOOL;

PROCEDURE CreateFileMappingA(hFile : HANDLE;
                             lpFileMappingAttributes : SECURITY_ATTRIBUTES;
                             flProtect : DWORD;
                             dwMaximumSizeHigh : DWORD;
                             dwMaximumSizeLow : DWORD;
                             lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateFileMappingW(hFile : HANDLE;
                             lpFileMappingAttributes : SECURITY_ATTRIBUTES;
                             flProtect : DWORD;
                             dwMaximumSizeHigh : DWORD;
                             dwMaximumSizeLow : DWORD;
                             lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateFileMapping = CreateFileMappingW;
%ELSE
PROCEDURE CreateFileMapping = CreateFileMappingA;
%END

PROCEDURE OpenFileMappingA(dwDesiredAccess : DWORD;
                           bInheritHandle : BOOL;
                           lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenFileMappingW(dwDesiredAccess : DWORD;
                           bInheritHandle : BOOL;
                           lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenFileMapping = OpenFileMappingW;
%ELSE
PROCEDURE OpenFileMapping = OpenFileMappingA;
%END

PROCEDURE GetLogicalDriveStringsA(nBufferLength : DWORD;
                                  VAR lpBuffer : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetLogicalDriveStringsW(nBufferLength : DWORD;
                                  VAR lpBuffer : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetLogicalDriveStrings = GetLogicalDriveStringsW;
%ELSE
PROCEDURE GetLogicalDriveStrings = GetLogicalDriveStringsA;
%END

PROCEDURE LoadLibraryA(lpLibFileName : ARRAY OF ACHAR) : HINSTANCE;

PROCEDURE LoadLibraryW(lpLibFileName : ARRAY OF UCHAR) : HINSTANCE;

%IF UNICODE %THEN
PROCEDURE LoadLibrary = LoadLibraryW;
%ELSE
PROCEDURE LoadLibrary = LoadLibraryA;
%END

PROCEDURE LoadLibraryExA(lpLibFileName : ARRAY OF ACHAR;
                         hFile : HANDLE;
                         dwFlags : DWORD) : HINSTANCE;

PROCEDURE LoadLibraryExW(lpLibFileName : ARRAY OF UCHAR;
                         hFile : HANDLE;
                         dwFlags : DWORD) : HINSTANCE;
%IF UNICODE %THEN
PROCEDURE LoadLibraryEx = LoadLibraryExW;
%ELSE
PROCEDURE LoadLibraryEx = LoadLibraryExA;
%END

CONST
    DONT_RESOLVE_DLL_REFERENCES         = 000000001h;
    LOAD_LIBRARY_AS_DATAFILE            = 000000002h;
    LOAD_WITH_ALTERED_SEARCH_PATH       = 000000008h;

PROCEDURE GetModuleFileNameA(hModule : HINSTANCE;
                             VAR lpFilename : ARRAY OF ACHAR;
                             nSize : DWORD) : DWORD;

PROCEDURE GetModuleFileNameW(hModule : HINSTANCE;
                             VAR lpFilename : ARRAY OF UCHAR;
                             nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetModuleFileName = GetModuleFileNameW;
%ELSE
PROCEDURE GetModuleFileName = GetModuleFileNameA;
%END

PROCEDURE GetModuleHandleA(lpModuleName : ARRAY OF ACHAR) : HMODULE;

PROCEDURE GetModuleHandleW(lpModuleName : ARRAY OF UCHAR) : HMODULE;

%IF UNICODE %THEN
PROCEDURE GetModuleHandle = GetModuleHandleW;
%ELSE
PROCEDURE GetModuleHandle = GetModuleHandleA;
%END

PROCEDURE CreateProcessA(lpApplicationName : ARRAY OF ACHAR;
                         lpCommandLine : ARRAY OF ACHAR;
                         lpProcessAttributes : SECURITY_ATTRIBUTES;
                         lpThreadAttributes : SECURITY_ATTRIBUTES;
                         bInheritHandles : BOOL;
                         dwCreationFlags : DWORD;
                         lpEnvironment : LPVOID;
                         lpCurrentDirectory : ARRAY OF ACHAR;
                         lpStartupInfo : STARTUPINFOA;
                         VAR lpProcessInformation : PROCESS_INFORMATION) : BOOL;

PROCEDURE CreateProcessW(lpApplicationName : ARRAY OF UCHAR;
                         lpCommandLine : ARRAY OF UCHAR;
                         lpProcessAttributes : SECURITY_ATTRIBUTES;
                         lpThreadAttributes : SECURITY_ATTRIBUTES;
                         bInheritHandles : BOOL;
                         dwCreationFlags : DWORD;
                         lpEnvironment : LPVOID;
                         lpCurrentDirectory : ARRAY OF UCHAR;
                         lpStartupInfo : STARTUPINFOW;
                         VAR lpProcessInformation : PROCESS_INFORMATION) : BOOL;
%IF UNICODE %THEN
PROCEDURE CreateProcess = CreateProcessW;
%ELSE
PROCEDURE CreateProcess = CreateProcessA;
%END

PROCEDURE SetProcessShutdownParameters(dwLevel : DWORD;
                                       dwFlags : DWORD) : BOOL;

PROCEDURE GetProcessShutdownParameters(VAR lpdwLevel : DWORD;
                                       VAR lpdwFlags : DWORD) : BOOL;

PROCEDURE GetProcessVersion(ProcessId : DWORD) : DWORD;

PROCEDURE FatalAppExitA(uAction : UINT;
                        lpMessageText : ARRAY OF ACHAR);

PROCEDURE FatalAppExitW(uAction : UINT;
                        lpMessageText : ARRAY OF UCHAR);

%IF UNICODE %THEN
PROCEDURE FatalAppExit = FatalAppExitW;
%ELSE
PROCEDURE FatalAppExit = FatalAppExitA;
%END

PROCEDURE GetStartupInfoA(VAR lpStartupInfo : STARTUPINFOA);

PROCEDURE GetStartupInfoW(VAR lpStartupInfo : STARTUPINFOW);

%IF UNICODE %THEN
PROCEDURE GetStartupInfo = GetStartupInfoW;
%ELSE
PROCEDURE GetStartupInfo = GetStartupInfoA;
%END

PROCEDURE GetCommandLineA() : LPSTR;

PROCEDURE GetCommandLineW() : LPWSTR;

%IF UNICODE %THEN
PROCEDURE GetCommandLine = GetCommandLineW;
%ELSE
PROCEDURE GetCommandLine = GetCommandLineA;
%END

PROCEDURE GetEnvironmentVariableA(lpName : ARRAY OF ACHAR;
                                  VAR lpBuffer : ARRAY OF ACHAR;
                                  nSize : DWORD) : DWORD;

PROCEDURE GetEnvironmentVariableW(lpName : ARRAY OF UCHAR;
                                  VAR lpBuffer : ARRAY OF UCHAR;
                                  nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetEnvironmentVariable = GetEnvironmentVariableW;
%ELSE
PROCEDURE GetEnvironmentVariable = GetEnvironmentVariableA;
%END

PROCEDURE SetEnvironmentVariableA(lpName : ARRAY OF ACHAR;
                                  lpValue : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetEnvironmentVariableW(lpName : ARRAY OF UCHAR;
                                  lpValue : ARRAY OF UCHAR) : BOOL;
%IF UNICODE %THEN
PROCEDURE SetEnvironmentVariable = SetEnvironmentVariableW;
%ELSE
PROCEDURE SetEnvironmentVariable = SetEnvironmentVariableA;
%END

PROCEDURE ExpandEnvironmentStringsA(lpSrc : ARRAY OF ACHAR;
                                    VAR lpDst : ARRAY OF ACHAR;
                                    nSize : DWORD) : DWORD;

PROCEDURE ExpandEnvironmentStringsW(lpSrc : ARRAY OF UCHAR;
                                    VAR lpDst : ARRAY OF UCHAR;
                                    nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE ExpandEnvironmentStrings = ExpandEnvironmentStringsW;
%ELSE
PROCEDURE ExpandEnvironmentStrings = ExpandEnvironmentStringsA;
%END

PROCEDURE OutputDebugStringW(lpOutputString : ARRAY OF UCHAR);

PROCEDURE OutputDebugStringA(lpOutputString : ARRAY OF ACHAR);

%IF UNICODE %THEN
PROCEDURE OutputDebugString = OutputDebugStringW;
%ELSE
PROCEDURE OutputDebugString = OutputDebugStringA;
%END

PROCEDURE FindResourceA(hModule : HINSTANCE;
                        lpName : ARRAY OF ACHAR;
                        lpType : ARRAY OF ACHAR) : HRSRC;

PROCEDURE FindResourceW(hModule : HINSTANCE;
                        lpName : ARRAY OF UCHAR;
                        lpType : ARRAY OF UCHAR) : HRSRC;

%IF UNICODE %THEN
PROCEDURE FindResource = FindResourceW;
%ELSE
PROCEDURE FindResource = FindResourceA;
%END

PROCEDURE FindResourceExA(hModule : HINSTANCE;
                          lpType : ARRAY OF ACHAR;
                          lpName : ARRAY OF ACHAR;
                          wLanguage : WORD) : HRSRC;

PROCEDURE FindResourceExW(hModule : HINSTANCE;
                          lpType : ARRAY OF UCHAR;
                          lpName : ARRAY OF UCHAR;
                          wLanguage : WORD) : HRSRC;

%IF UNICODE %THEN
PROCEDURE FindResourceEx = FindResourceExW;
%ELSE
PROCEDURE FindResourceEx = FindResourceExA;
%END

TYPE
    ENUMRESTYPEPROCA      = PROCEDURE(HMODULE,
                                      ARRAY OF ACHAR,
                                      LONG) : BOOL [EXPORT];
    ENUMRESTYPEPROCW      = PROCEDURE(HMODULE,
                                      ARRAY OF UCHAR,
                                      LONG) : BOOL [EXPORT];

    ENUMRESNAMEPROCA      = PROCEDURE(HMODULE,
                                      ARRAY OF ACHAR,
                                      ARRAY OF ACHAR,
                                      LONG) : BOOL [EXPORT];
    ENUMRESNAMEPROCW      = PROCEDURE(HMODULE,
                                      ARRAY OF UCHAR,
                                      ARRAY OF UCHAR,
                                      LONG) : BOOL [EXPORT];

    ENUMRESLANGPROCA      = PROCEDURE(HMODULE,
                                      ARRAY OF ACHAR,
                                      ARRAY OF ACHAR,
                                      WORD,
                                      LONG) : BOOL [EXPORT];
    ENUMRESLANGPROCW      = PROCEDURE(HMODULE,
                                      ARRAY OF UCHAR,
                                      ARRAY OF UCHAR,
                                      WORD,
                                      LONG) : BOOL [EXPORT];

%IF UNICODE %THEN
    ENUMRESTYPEPROC     = ENUMRESTYPEPROCW;
    ENUMRESNAMEPROC     = ENUMRESNAMEPROCW;
    ENUMRESLANGPROC     = ENUMRESLANGPROCW;
%ELSE
    ENUMRESTYPEPROC     = ENUMRESTYPEPROCA;
    ENUMRESNAMEPROC     = ENUMRESNAMEPROCA;
    ENUMRESLANGPROC     = ENUMRESLANGPROCA;
%END

PROCEDURE EnumResourceTypesA(hModule : HINSTANCE;
                             lpEnumFunc : ENUMRESTYPEPROCA;
                             lParam : LONG) : BOOL;

PROCEDURE EnumResourceTypesW(hModule : HINSTANCE;
                             lpEnumFunc : ENUMRESTYPEPROCW;
                             lParam : LONG) : BOOL;

%IF UNICODE %THEN
PROCEDURE EnumResourceTypes = EnumResourceTypesW;
%ELSE
PROCEDURE EnumResourceTypes = EnumResourceTypesA;
%END

PROCEDURE EnumResourceNamesA(hModule : HINSTANCE;
                             lpType : ARRAY OF ACHAR;
                             lpEnumFunc : ENUMRESNAMEPROCA;
                             lParam : LONG) : BOOL;

PROCEDURE EnumResourceNamesW(hModule : HINSTANCE;
                             lpType : ARRAY OF UCHAR;
                             lpEnumFunc : ENUMRESNAMEPROCW;
                             lParam : LONG) : BOOL;

%IF UNICODE %THEN
PROCEDURE EnumResourceNames = EnumResourceNamesW;
%ELSE
PROCEDURE EnumResourceNames = EnumResourceNamesA;
%END

PROCEDURE EnumResourceLanguagesA(hModule : HINSTANCE;
                                 lpType : ARRAY OF ACHAR;
                                 lpName : ARRAY OF ACHAR;
                                 lpEnumFunc : ENUMRESLANGPROCA;
                                 lParam : LONG) : BOOL;

PROCEDURE EnumResourceLanguagesW(hModule : HINSTANCE;
                                 lpType : ARRAY OF UCHAR;
                                 lpName : ARRAY OF UCHAR;
                                 lpEnumFunc : ENUMRESLANGPROCW;
                                 lParam : LONG) : BOOL;

%IF UNICODE %THEN
PROCEDURE EnumResourceLanguages = EnumResourceLanguagesW;
%ELSE
PROCEDURE EnumResourceLanguages = EnumResourceLanguagesA;
%END

PROCEDURE BeginUpdateResourceA(pFileName : ARRAY OF ACHAR;
                               bDeleteExistingResources : BOOL) : HANDLE;

PROCEDURE BeginUpdateResourceW(pFileName : ARRAY OF UCHAR;
                               bDeleteExistingResources : BOOL) : HANDLE;

%IF UNICODE %THEN
PROCEDURE BeginUpdateResource = BeginUpdateResourceW;
%ELSE
PROCEDURE BeginUpdateResource = BeginUpdateResourceA;
%END

PROCEDURE UpdateResourceA(hUpdate : HANDLE;
                          lpType : ARRAY OF ACHAR;
                          lpName : ARRAY OF ACHAR;
                          wLanguage : WORD;
                          lpData : LPVOID;
                          cbData : DWORD) : BOOL;

PROCEDURE UpdateResourceW(hUpdate : HANDLE;
                          lpType : ARRAY OF UCHAR;
                          lpName : ARRAY OF UCHAR;
                          wLanguage : WORD;
                          lpData : LPVOID;
                          cbData : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE UpdateResource = UpdateResourceW;
%ELSE
PROCEDURE UpdateResource = UpdateResourceA;
%END

PROCEDURE EndUpdateResourceA(hUpdate : HANDLE;
                             fDiscard : BOOL) : BOOL;

PROCEDURE EndUpdateResourceW(hUpdate : HANDLE;
                             fDiscard : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE EndUpdateResource = EndUpdateResourceW;
%ELSE
PROCEDURE EndUpdateResource = EndUpdateResourceA;
%END

PROCEDURE GlobalAddAtomA(lpString : ARRAY OF ACHAR) : ATOM;

PROCEDURE GlobalAddAtomW(lpString : ARRAY OF UCHAR) : ATOM;

%IF UNICODE %THEN
PROCEDURE GlobalAddAtom = GlobalAddAtomW;
%ELSE
PROCEDURE GlobalAddAtom = GlobalAddAtomA;
%END

PROCEDURE GlobalFindAtomA(lpString : ARRAY OF ACHAR) : ATOM;

PROCEDURE GlobalFindAtomW(lpString : ARRAY OF UCHAR) : ATOM;

%IF UNICODE %THEN
PROCEDURE GlobalFindAtom = GlobalFindAtomW;
%ELSE
PROCEDURE GlobalFindAtom = GlobalFindAtomA;
%END

PROCEDURE GlobalGetAtomNameA(nAtom : ATOM;
                             VAR lpBuffer : ARRAY OF ACHAR;
                             nSize : INTEGER) : UINT;

PROCEDURE GlobalGetAtomNameW(nAtom : ATOM;
                             VAR lpBuffer : ARRAY OF UCHAR;
                             nSize : INTEGER) : UINT;

%IF UNICODE %THEN
PROCEDURE GlobalGetAtomName = GlobalGetAtomNameW;
%ELSE
PROCEDURE GlobalGetAtomName = GlobalGetAtomNameA;
%END

PROCEDURE AddAtomA(lpString : ARRAY OF ACHAR) : ATOM;

PROCEDURE AddAtomW(lpString : ARRAY OF UCHAR) : ATOM;

%IF UNICODE %THEN
PROCEDURE AddAtom = AddAtomW;
%ELSE
PROCEDURE AddAtom = AddAtomA;
%END

PROCEDURE FindAtomA(lpString : ARRAY OF ACHAR) : ATOM;

PROCEDURE FindAtomW(lpString : ARRAY OF UCHAR) : ATOM;

%IF UNICODE %THEN
PROCEDURE FindAtom = FindAtomW;
%ELSE
PROCEDURE FindAtom = FindAtomA;
%END

PROCEDURE GetAtomNameA(nAtom : ATOM;
                       VAR lpBuffer : ARRAY OF ACHAR;
                       nSize : INTEGER) : UINT;

PROCEDURE GetAtomNameW(nAtom : ATOM;
                       VAR lpBuffer : ARRAY OF UCHAR;
                       nSize : INTEGER) : UINT;

%IF UNICODE %THEN
PROCEDURE GetAtomName = GetAtomNameW;
%ELSE
PROCEDURE GetAtomName = GetAtomNameA;
%END

PROCEDURE GetProfileIntA(lpAppName : ARRAY OF ACHAR;
                         lpKeyName : ARRAY OF ACHAR;
                         nDefault : WINT) : UINT;

PROCEDURE GetProfileIntW(lpAppName : ARRAY OF UCHAR;
                         lpKeyName : ARRAY OF UCHAR;
                         nDefault : WINT) : UINT;

%IF UNICODE %THEN
PROCEDURE GetProfileInt = GetProfileIntW;
%ELSE
PROCEDURE GetProfileInt = GetProfileIntA;
%END

PROCEDURE GetProfileStringA(lpAppName : ARRAY OF ACHAR;
                            lpKeyName : ARRAY OF ACHAR;
                            lpDefault : ARRAY OF ACHAR;
                            VAR lpReturnedString : ARRAY OF ACHAR;
                            nSize : DWORD) : DWORD;

PROCEDURE GetProfileStringW(lpAppName : ARRAY OF UCHAR;
                            lpKeyName : ARRAY OF UCHAR;
                            lpDefault : ARRAY OF UCHAR;
                            VAR lpReturnedString : ARRAY OF UCHAR;
                            nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetProfileString = GetProfileStringW;
%ELSE
PROCEDURE GetProfileString = GetProfileStringA;
%END

PROCEDURE WriteProfileStringA(lpAppName : ARRAY OF ACHAR;
                              lpKeyName : ARRAY OF ACHAR;
                              lpString : ARRAY OF ACHAR) : BOOL;

PROCEDURE WriteProfileStringW(lpAppName : ARRAY OF UCHAR;
                              lpKeyName : ARRAY OF UCHAR;
                              lpString : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE WriteProfileString = WriteProfileStringW;
%ELSE
PROCEDURE WriteProfileString = WriteProfileStringA;
%END

PROCEDURE GetProfileSectionA(lpAppName : ARRAY OF ACHAR;
                             VAR lpReturnedString : ARRAY OF ACHAR;
                             nSize : DWORD) : DWORD;

PROCEDURE GetProfileSectionW(lpAppName : ARRAY OF UCHAR;
                             VAR lpReturnedString : ARRAY OF UCHAR;
                             nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetProfileSection = GetProfileSectionW;
%ELSE
PROCEDURE GetProfileSection = GetProfileSectionA;
%END

PROCEDURE WriteProfileSectionA(lpAppName : ARRAY OF ACHAR;
                               lpString : ARRAY OF ACHAR) : BOOL;

PROCEDURE WriteProfileSectionW(lpAppName : ARRAY OF UCHAR;
                               lpString : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE WriteProfileSection = WriteProfileSectionW;
%ELSE
PROCEDURE WriteProfileSection = WriteProfileSectionA;
%END

PROCEDURE GetPrivateProfileIntA(lpAppName : ARRAY OF ACHAR;
                                lpKeyName : ARRAY OF ACHAR;
                                nDefault : WINT;
                                lpFileName : ARRAY OF ACHAR) : UINT;

PROCEDURE GetPrivateProfileIntW(lpAppName : ARRAY OF UCHAR;
                                lpKeyName : ARRAY OF UCHAR;
                                nDefault : WINT;
                                lpFileName : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileInt = GetPrivateProfileIntW;
%ELSE
PROCEDURE GetPrivateProfileInt = GetPrivateProfileIntA;
%END

PROCEDURE GetPrivateProfileStringA(lpAppName : ARRAY OF ACHAR;
                                   lpKeyName : ARRAY OF ACHAR;
                                   lpDefault : ARRAY OF ACHAR;
                                   VAR lpReturnedString : ARRAY OF ACHAR;
                                   nSize : DWORD;
                                   lpFileName : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetPrivateProfileStringW(lpAppName : ARRAY OF UCHAR;
                                   lpKeyName : ARRAY OF UCHAR;
                                   lpDefault : ARRAY OF UCHAR;
                                   VAR lpReturnedString : ARRAY OF UCHAR;
                                   nSize : DWORD;
                                   lpFileName : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileString = GetPrivateProfileStringW;
%ELSE
PROCEDURE GetPrivateProfileString = GetPrivateProfileStringA;
%END

PROCEDURE WritePrivateProfileStringA(lpAppName : ARRAY OF ACHAR;
                                     lpKeyName : ARRAY OF ACHAR;
                                     lpString : ARRAY OF ACHAR;
                                     lpFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE WritePrivateProfileStringW(lpAppName : ARRAY OF UCHAR;
                                     lpKeyName : ARRAY OF UCHAR;
                                     lpString : ARRAY OF UCHAR;
                                     lpFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE WritePrivateProfileString = WritePrivateProfileStringW;
%ELSE
PROCEDURE WritePrivateProfileString = WritePrivateProfileStringA;
%END


PROCEDURE GetPrivateProfileSectionNamesA(
                                    VAR lpszReturnBuffer : ARRAY OF ACHAR;
                                    nSize : DWORD;
                                    lpFileName : ARRAY OF ACHAR
                                    ) : DWORD;

PROCEDURE GetPrivateProfileSectionNamesW(
                                    VAR lpszReturnBuffer : ARRAY OF UCHAR;
                                    nSize : DWORD;
                                    lpFileName : ARRAY OF UCHAR
                                    ) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesW;
%ELSE
PROCEDURE GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesA;
%END

PROCEDURE GetPrivateProfileStructA(
    lpszSection : ARRAY OF ACHAR;
    lpszKey : ARRAY OF ACHAR;
    lpStruct : LPVOID;
    uSizeStruct : UINT;
    szFile : ARRAY OF ACHAR
    ) : BOOL;

PROCEDURE GetPrivateProfileStructW(
    lpszSection : ARRAY OF UCHAR;
    lpszKey : ARRAY OF UCHAR;
    lpStruct : LPVOID;
    uSizeStruct : UINT;
    szFile : ARRAY OF UCHAR
    ) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileStruct = GetPrivateProfileStructW;
%ELSE
PROCEDURE GetPrivateProfileStruct = GetPrivateProfileStructA;
%END

PROCEDURE WritePrivateProfileStructA(
    lpszSection : ARRAY OF ACHAR;
    lpszKey : ARRAY OF ACHAR;
    lpStruct : LPVOID;
    uSizeStruct : UINT;
    szFile : ARRAY OF ACHAR
    ) : BOOL;

PROCEDURE WritePrivateProfileStructW(
    lpszSection : ARRAY OF UCHAR;
    lpszKey : ARRAY OF UCHAR;
    lpStruct : LPVOID;
    uSizeStruct : UINT;
    szFile : ARRAY OF UCHAR
    ) : BOOL;

%IF UNICODE %THEN
PROCEDURE WritePrivateProfileStruct = WritePrivateProfileStructW;
%ELSE
PROCEDURE WritePrivateProfileStruct = WritePrivateProfileStructA;
%END


PROCEDURE GetPrivateProfileSectionA(lpAppName : ARRAY OF ACHAR;
                                    VAR lpReturnedString : ARRAY OF ACHAR;
                                    nSize : DWORD;
                                    lpFileName : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetPrivateProfileSectionW(lpAppName : ARRAY OF UCHAR;
                                    VAR lpReturnedString : ARRAY OF UCHAR;
                                    nSize : DWORD;
                                    lpFileName : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileSection = GetPrivateProfileSectionW;
%ELSE
PROCEDURE GetPrivateProfileSection = GetPrivateProfileSectionA;
%END

PROCEDURE WritePrivateProfileSectionA(lpAppName : ARRAY OF ACHAR;
                                      lpString : ARRAY OF ACHAR;
                                      lpFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE WritePrivateProfileSectionW(lpAppName : ARRAY OF UCHAR;
                                      lpString : ARRAY OF UCHAR;
                                      lpFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE WritePrivateProfileSection = WritePrivateProfileSectionW;
%ELSE
PROCEDURE WritePrivateProfileSection = WritePrivateProfileSectionA;
%END

PROCEDURE GetDriveTypeA(lpRootPathName : ARRAY OF ACHAR) : UINT;

PROCEDURE GetDriveTypeW(lpRootPathName : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE GetDriveType = GetDriveTypeW;
%ELSE
PROCEDURE GetDriveType = GetDriveTypeA;
%END

PROCEDURE GetSystemDirectoryA(VAR lpBuffer : ARRAY OF ACHAR;
                              uSize : UINT) : UINT;

PROCEDURE GetSystemDirectoryW(VAR lpBuffer : ARRAY OF UCHAR;
                              uSize : UINT) : UINT;

%IF UNICODE %THEN
PROCEDURE GetSystemDirectory = GetSystemDirectoryW;
%ELSE
PROCEDURE GetSystemDirectory = GetSystemDirectoryA;
%END

PROCEDURE GetTempPathA(nBufferLength : DWORD;
                       VAR lpBuffer : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetTempPathW(nBufferLength : DWORD;
                       VAR lpBuffer : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetTempPath = GetTempPathW;
%ELSE
PROCEDURE GetTempPath = GetTempPathA;
%END

PROCEDURE GetTempFileNameA(lpPathName : ARRAY OF ACHAR;
                           lpPrefixString : ARRAY OF ACHAR;
                           uUnique : UINT;
                           VAR lpTempFileName : ARRAY OF ACHAR) : UINT;

PROCEDURE GetTempFileNameW(lpPathName : ARRAY OF UCHAR;
                           lpPrefixString : ARRAY OF UCHAR;
                           uUnique : UINT;
                           VAR lpTempFileName : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE GetTempFileName = GetTempFileNameW;
%ELSE
PROCEDURE GetTempFileName = GetTempFileNameA;
%END


PROCEDURE GetWindowsDirectoryA(VAR lpBuffer : ARRAY OF ACHAR;
                               uSize : UINT) : UINT;

PROCEDURE GetWindowsDirectoryW(VAR lpBuffer : ARRAY OF UCHAR;
                               uSize : UINT) : UINT;

%IF UNICODE %THEN
PROCEDURE GetWindowsDirectory = GetWindowsDirectoryW;
%ELSE
PROCEDURE GetWindowsDirectory = GetWindowsDirectoryA;
%END

PROCEDURE SetCurrentDirectoryA(lpPathName : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetCurrentDirectoryW(lpPathName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetCurrentDirectory = SetCurrentDirectoryW;
%ELSE
PROCEDURE SetCurrentDirectory = SetCurrentDirectoryA;
%END

PROCEDURE GetCurrentDirectoryA(nBufferLength : DWORD;
                               VAR lpBuffer : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetCurrentDirectoryW(nBufferLength : DWORD;
                               VAR lpBuffer : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetCurrentDirectory = GetCurrentDirectoryW;
%ELSE
PROCEDURE GetCurrentDirectory = GetCurrentDirectoryA;
%END

PROCEDURE GetDiskFreeSpaceA(lpRootPathName : ARRAY OF ACHAR;
                            VAR lpSectorsPerCluster : DWORD;
                            VAR lpBytesPerSector : DWORD;
                            VAR lpNumberOfFreeClusters : DWORD;
                            VAR TotalNumberOfClusters : DWORD) : BOOL;

PROCEDURE GetDiskFreeSpaceW(lpRootPathName : ARRAY OF UCHAR;
                            VAR lpSectorsPerCluster : DWORD;
                            VAR lpBytesPerSector : DWORD;
                            VAR lpNumberOfFreeClusters : DWORD;
                            VAR lpTotalNumberOfClusters : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetDiskFreeSpace = GetDiskFreeSpaceW;
%ELSE
PROCEDURE GetDiskFreeSpace = GetDiskFreeSpaceA;
%END

PROCEDURE GetDiskFreeSpaceExA(
                    lpDirectoryName : ARRAY OF ACHAR;
                    VAR lpFreeBytesAvailableToCaller : ULARGE_INTEGER;
                    VAR lpTotalNumberOfBytes : ULARGE_INTEGER;
                    VAR lpTotalNumberOfFreeBytes : ULARGE_INTEGER) : BOOL;

PROCEDURE GetDiskFreeSpaceExW(
                    lpDirectoryName : ARRAY OF WCHAR;
                    VAR lpFreeBytesAvailableToCaller : ULARGE_INTEGER;
                    VAR lpTotalNumberOfBytes : ULARGE_INTEGER;
                    VAR lpTotalNumberOfFreeBytes : ULARGE_INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetDiskFreeSpaceEx = GetDiskFreeSpaceExW;
%ELSE
PROCEDURE GetDiskFreeSpaceEx = GetDiskFreeSpaceExA;
%END

PROCEDURE CreateDirectoryA(lpPathName : ARRAY OF ACHAR;
                           lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

PROCEDURE CreateDirectoryW(lpPathName : ARRAY OF UCHAR;
                           lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

%IF UNICODE %THEN
PROCEDURE CreateDirectory = CreateDirectoryW;
%ELSE
PROCEDURE CreateDirectory = CreateDirectoryA;
%END

PROCEDURE CreateDirectoryExA(lpTemplateDirectory : ARRAY OF ACHAR;
                             lpNewDirectory : ARRAY OF ACHAR;
                             lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

PROCEDURE CreateDirectoryExW(lpTemplateDirectory : ARRAY OF UCHAR;
                             lpNewDirectory : ARRAY OF UCHAR;
                             lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

%IF UNICODE %THEN
PROCEDURE CreateDirectoryEx = CreateDirectoryExW;
%ELSE
PROCEDURE CreateDirectoryEx = CreateDirectoryExA;
%END

PROCEDURE RemoveDirectoryA(lpPathName : ARRAY OF ACHAR) : BOOL;

PROCEDURE RemoveDirectoryW(lpPathName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE RemoveDirectory = RemoveDirectoryW;
%ELSE
PROCEDURE RemoveDirectory = RemoveDirectoryA;
%END

PROCEDURE GetFullPathNameA(lpFileName : ARRAY OF ACHAR;
                           nBufferLength : DWORD;
                           VAR lpBuffer : ARRAY OF ACHAR;
                           VAR lpFilePart : LPSTR) : DWORD;

PROCEDURE GetFullPathNameW(lpFileName : ARRAY OF UCHAR;
                           nBufferLength : DWORD;
                           VAR lpBuffer : ARRAY OF UCHAR;
                           VAR lpFilePart : LPWSTR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetFullPathName = GetFullPathNameW;
%ELSE
PROCEDURE GetFullPathName = GetFullPathNameA;
%END

CONST
    DDD_RAW_TARGET_PATH  = 000000001h;
    DDD_REMOVE_DEFINITION= 000000002h;
    DDD_EXACT_MATCH_ON_REMOVE= 000000004h;
    DDD_NO_BROADCAST_SYSTEM     = 00000008h;

PROCEDURE DefineDosDeviceA(dwFlags : DWORD;
                           lpDeviceName : ARRAY OF ACHAR;
                           lpTargetPath : ARRAY OF ACHAR) : BOOL;

PROCEDURE DefineDosDeviceW(dwFlags : DWORD;
                           lpDeviceName : ARRAY OF UCHAR;
                           lpTargetPath : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE DefineDosDevice = DefineDosDeviceW;
%ELSE
PROCEDURE DefineDosDevice = DefineDosDeviceA;
%END

PROCEDURE QueryDosDeviceA(lpDeviceName : ARRAY OF ACHAR;
                          VAR lpTargetPath : ARRAY OF ACHAR;
                          ucchMax : DWORD) : DWORD;

PROCEDURE QueryDosDeviceW(lpDeviceName : ARRAY OF UCHAR;
                          VAR lpTargetPath : ARRAY OF UCHAR;
                          ucchMax : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE QueryDosDevice = QueryDosDeviceW;
%ELSE
PROCEDURE QueryDosDevice = QueryDosDeviceA;
%END

PROCEDURE CreateFileA(lpFileName : ARRAY OF ACHAR;
                      dwDesiredAccess : DWORD;
                      dwShareMode : DWORD;
                      lpSecurityAttributes : SECURITY_ATTRIBUTES;
                      dwCreationDisposition : DWORD;
                      dwFlagsAndAttributes : DWORD;
                      hTemplateFile : HANDLE) : HANDLE;

PROCEDURE CreateFileW(lpFileName : ARRAY OF UCHAR;
                      dwDesiredAccess : DWORD;
                      dwShareMode : DWORD;
                      lpSecurityAttributes : SECURITY_ATTRIBUTES;
                      dwCreationDisposition : DWORD;
                      dwFlagsAndAttributes : DWORD;
                      hTemplateFile : HANDLE) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateFile = CreateFileW;
%ELSE
PROCEDURE CreateFile = CreateFileA;
%END

PROCEDURE SetFileAttributesA(lpFileName : ARRAY OF ACHAR;
                             dwFileAttributes : DWORD) : BOOL;

PROCEDURE SetFileAttributesW(lpFileName : ARRAY OF UCHAR;
                             dwFileAttributes : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetFileAttributes = SetFileAttributesW;
%ELSE
PROCEDURE SetFileAttributes = SetFileAttributesA;
%END

PROCEDURE GetFileAttributesA(lpFileName : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetFileAttributesW(lpFileName : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetFileAttributes = GetFileAttributesW;
%ELSE
PROCEDURE GetFileAttributes = GetFileAttributesA;
%END

TYPE
    GET_FILEEX_INFO_LEVELS = (GetFileExInfoStandard,
                              GetFileExMaxInfoLevel) BIG;

PROCEDURE GetFileAttributesExA(lpFileName : ARRAY OF ACHAR;
                               fInfoLevelId : GET_FILEEX_INFO_LEVELS;
                               VAR lpFileInformation : ARRAY OF LOC) : BOOL;

PROCEDURE GetFileAttributesExW(lpFileName : ARRAY OF WCHAR;
                               fInfoLevelId : GET_FILEEX_INFO_LEVELS;
                               VAR lpFileInformation : ARRAY OF LOC) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetFileAttributesEx = GetFileAttributesExW;
%ELSE
PROCEDURE GetFileAttributesEx = GetFileAttributesExA;
%END

PROCEDURE GetCompressedFileSizeA(lpFileName : ARRAY OF ACHAR;
                                 VAR lpFileSizeHigh : DWORD) : DWORD;

PROCEDURE GetCompressedFileSizeW(lpFileName : ARRAY OF UCHAR;
                                 VAR lpFileSizeHigh : DWORD) : DWORD;
%IF UNICODE %THEN
PROCEDURE GetCompressedFileSize = GetCompressedFileSizeW;
%ELSE
PROCEDURE GetCompressedFileSize = GetCompressedFileSizeA;
%END

PROCEDURE DeleteFileA(lpFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE DeleteFileW(lpFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE DeleteFile = DeleteFileW;
%ELSE
PROCEDURE DeleteFile = DeleteFileA;
%END

TYPE
    FINDEX_INFO_LEVELS = (
                          FindExInfoStandard,
                          FindExInfoMaxInfoLevel) BIG;

    FINDEX_SEARCH_OPS = (FindExSearchNameMatch,
                         FindExSearchLimitToDirectories,
                         FindExSearchLimitToDevices,
                         FindExSearchMaxSearchOp) BIG;

CONST
    FIND_FIRST_EX_CASE_SENSITIVE   = 00000001h;

(* NT only *)
PROCEDURE FindFirstFileExA(lpFileName : ARRAY OF ACHAR;
                           fInfoLevelId : FINDEX_INFO_LEVELS;
                           VAR lpFindFileData : ARRAY OF LOC;
                           fSearchOp : FINDEX_SEARCH_OPS;
                           lpSearchFilter : LPVOID;
                           dwAdditionalFlags : DWORD) : HANDLE;

(* NT only *)
PROCEDURE FindFirstFileExW(lpFileName : ARRAY OF WCHAR;
                           fInfoLevelId : FINDEX_INFO_LEVELS;
                           VAR lpFindFileData : ARRAY OF LOC;
                           fSearchOp : FINDEX_SEARCH_OPS;
                           lpSearchFilter : LPVOID;
                           dwAdditionalFlags : DWORD) : HANDLE;

%IF UNICODE %THEN
(* NT only *)
PROCEDURE FindFirstFileEx = FindFirstFileExW;
%ELSE
(* NT only *)
PROCEDURE FindFirstFileEx = FindFirstFileExA;
%END

PROCEDURE FindFirstFileA(lpFileName : ARRAY OF ACHAR;
                         VAR lpFindFileData : WIN32_FIND_DATAA) : HANDLE;

PROCEDURE FindFirstFileW(lpFileName : ARRAY OF UCHAR;
                         VAR lpFindFileData : WIN32_FIND_DATAW) : HANDLE;

%IF UNICODE %THEN
PROCEDURE FindFirstFile = FindFirstFileW;
%ELSE
PROCEDURE FindFirstFile = FindFirstFileA;
%END

PROCEDURE FindNextFileA(hFindFile : HANDLE;
                        VAR lpFindFileData : WIN32_FIND_DATAA) : BOOL;

PROCEDURE FindNextFileW(hFindFile : HANDLE;
                        VAR lpFindFileData : WIN32_FIND_DATAW) : BOOL;

%IF UNICODE %THEN
PROCEDURE FindNextFile = FindNextFileW;
%ELSE
PROCEDURE FindNextFile = FindNextFileA;
%END

PROCEDURE SearchPathA(lpPath : ARRAY OF ACHAR;
                      lpFileName : ARRAY OF ACHAR;
                      lpExtension : ARRAY OF ACHAR;
                      nBufferLength : DWORD;
                      VAR lpBuffer : ARRAY OF ACHAR;
                      VAR lpFilePart : LPSTR) : DWORD;

PROCEDURE SearchPathW(lpPath : ARRAY OF UCHAR;
                      lpFileName : ARRAY OF UCHAR;
                      lpExtension : ARRAY OF UCHAR;
                      nBufferLength : DWORD;
                      VAR lpBuffer : ARRAY OF UCHAR;
                      VAR lpFilePart : LPWSTR) : DWORD;

%IF UNICODE %THEN
PROCEDURE SearchPath = SearchPathW;
%ELSE
PROCEDURE SearchPath = SearchPathA;
%END

PROCEDURE CopyFileA(lpExistingFileName : ARRAY OF ACHAR;
                    lpNewFileName : ARRAY OF ACHAR;
                    bFailIfExists : BOOL) : BOOL;

PROCEDURE CopyFileW(lpExistingFileName : ARRAY OF UCHAR;
                    lpNewFileName : ARRAY OF UCHAR;
                    bFailIfExists : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE CopyFile = CopyFileW;
%ELSE
PROCEDURE CopyFile = CopyFileA;
%END

TYPE
    LPPROGRESS_ROUTINE  = PROCEDURE(
    LARGE_INTEGER(*TotalFileSize*),
    LARGE_INTEGER(*TotalBytesTransferred*),
    LARGE_INTEGER(*StreamSize*),
    LARGE_INTEGER(*StreamBytesTransferred*),
    DWORD(*dwStreamNumber*),
    DWORD(*dwCallbackReason*),
    HANDLE(*hSourceFile*),
    HANDLE(*hDestinationFile*),
    LPVOID(*lpData*)
    ) : DWORD [EXPORT];

(* NT only *)
PROCEDURE CopyFileExA(lpExistingFileName : ARRAY OF ACHAR;
                      lpNewFileName : ARRAY OF ACHAR;
                      lpProgressRoutine : LPPROGRESS_ROUTINE;
                      lpData : LPVOID;
                      VAR pbCancel : BOOL;
                      dwCopyFlags : DWORD) : BOOL;

(* NT only *)
PROCEDURE CopyFileExW(lpExistingFileName : ARRAY OF WCHAR;
                      lpNewFileName : ARRAY OF WCHAR;
                      lpProgressRoutine : LPPROGRESS_ROUTINE;
                      lpData : LPVOID;
                      VAR pbCancel : BOOL;
                      dwCopyFlags : DWORD) : BOOL;

%IF UNICODE %THEN
(* NT only *)
PROCEDURE CopyFileEx = CopyFileExW;
%ELSE
(* NT only *)
PROCEDURE CopyFileEx = CopyFileExA;
%END

PROCEDURE MoveFileA(lpExistingFileName : ARRAY OF ACHAR;
                    lpNewFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE MoveFileW(lpExistingFileName : ARRAY OF UCHAR;
                    lpNewFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE MoveFile = MoveFileW;
%ELSE
PROCEDURE MoveFile = MoveFileA;
%END

PROCEDURE MoveFileExA(lpExistingFileName : ARRAY OF ACHAR;
                      lpNewFileName : ARRAY OF ACHAR;
                      dwFlags : DWORD) : BOOL;

PROCEDURE MoveFileExW(lpExistingFileName : ARRAY OF UCHAR;
                      lpNewFileName : ARRAY OF UCHAR;
                      dwFlags : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE MoveFileEx = MoveFileExW;
%ELSE
PROCEDURE MoveFileEx = MoveFileExA;
%END

%IF WIN5 %THEN
(* NT only *)
PROCEDURE MoveFileWithProgressA(lpExistingFileName : ARRAY OF ACHAR;
                                lpNewFileName : ARRAY OF ACHAR;
                                lpProgressRoutine : LPPROGRESS_ROUTINE;
                                lpData : LPVOID;
                                dwFlags : DWORD) : BOOL;

(* NT only *)
PROCEDURE MoveFileWithProgressW(lpExistingFileName : ARRAY OF WCHAR;
                                lpNewFileName : ARRAY OF WCHAR;
                                lpProgressRoutine : LPPROGRESS_ROUTINE;
                                lpData : LPVOID;
                                dwFlags : DWORD) : BOOL;
%IF UNICODE %THEN
(* NT only *)
PROCEDURE MoveFileWithProgress = MoveFileWithProgressW;
%ELSE
(* NT only *)
PROCEDURE MoveFileWithProgress = MoveFileWithProgressA;
%END
%END

CONST
    MOVEFILE_REPLACE_EXISTING= 000000001h;
    MOVEFILE_COPY_ALLOWED= 000000002h;
    MOVEFILE_DELAY_UNTIL_REBOOT= 000000004h;
    MOVEFILE_WRITE_THROUGH          = 00000008h;
    %IF WIN5 %THEN
    MOVEFILE_CREATE_HARDLINK        = 00000010h;(* NT only *)
    MOVEFILE_FAIL_IF_NOT_TRACKABLE  = 00000020h;(* NT only *)
    %END

%IF WIN5 %THEN
(*
 API call to create hard links.
*)

(* NT only *)
PROCEDURE CreateHardLinkA(lpFileName : ARRAY OF ACHAR;
                          lpExistingFileName : ARRAY OF ACHAR;
                          lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

(* NT only *)
PROCEDURE CreateHardLinkW(lpFileName : ARRAY OF WCHAR;
                          lpExistingFileName : ARRAY OF WCHAR;
                          lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;
%IF UNICODE %THEN
(* NT only *)
PROCEDURE CreateHardLink = CreateHardLinkW;
%ELSE
(* NT only *)
PROCEDURE CreateHardLink = CreateHardLinkA;
%END
%END

PROCEDURE CreateNamedPipeA(lpName : ARRAY OF ACHAR;
                           dwOpenMode : DWORD;
                           dwPipeMode : DWORD;
                           nMaxInstances : DWORD;
                           nOutBufferSize : DWORD;
                           nInBufferSize : DWORD;
                           nDefaultTimeOut : DWORD;
                           lpSecurityAttributes : SECURITY_ATTRIBUTES) : HANDLE;

PROCEDURE CreateNamedPipeW(lpName : ARRAY OF UCHAR;
                           dwOpenMode : DWORD;
                           dwPipeMode : DWORD;
                           nMaxInstances : DWORD;
                           nOutBufferSize : DWORD;
                           nInBufferSize : DWORD;
                           nDefaultTimeOut : DWORD;
                           lpSecurityAttributes : SECURITY_ATTRIBUTES) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateNamedPipe = CreateNamedPipeW;
%ELSE
PROCEDURE CreateNamedPipe = CreateNamedPipeA;
%END

PROCEDURE GetNamedPipeHandleStateA(hNamedPipe : HANDLE;
                                   VAR lpState : DWORD;
                                   VAR lpCurInstances : DWORD;
                                   VAR lpMaxCollectionCount : DWORD;
                                   VAR LpCollectDataTimeout : DWORD;
                                   VAR lpUserName : ARRAY OF ACHAR;
                                   nMaxUserNameSize : DWORD) : BOOL;

PROCEDURE GetNamedPipeHandleStateW(hNamedPipe : HANDLE;
                                   VAR lpState : DWORD;
                                   VAR lpCurInstances : DWORD;
                                   VAR lpMaxCollectionCount : DWORD;
                                   VAR lpCollectDataTimeout : DWORD;
                                   VAR lpUserName : ARRAY OF UCHAR;
                                   nMaxUserNameSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetNamedPipeHandleState = GetNamedPipeHandleStateW;
%ELSE
PROCEDURE GetNamedPipeHandleState = GetNamedPipeHandleStateA;
%END

PROCEDURE CallNamedPipeA(lpNamedPipeName : ARRAY OF ACHAR;
                         lpInBuffer : LPVOID;
                         nInBufferSize : DWORD;
                         lpOutBuffer : LPVOID;
                         nOutBufferSize : DWORD;
                         VAR lpBytesRead : DWORD;
                         nTimeOut : DWORD) : BOOL;

PROCEDURE CallNamedPipeW(lpNamedPipeName : ARRAY OF UCHAR;
                         lpInBuffer : LPVOID;
                         nInBufferSize : DWORD;
                         lpOutBuffer : LPVOID;
                         nOutBufferSize : DWORD;
                         VAR lpBytesRead : DWORD;
                         nTimeOut : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE CallNamedPipe = CallNamedPipeW;
%ELSE
PROCEDURE CallNamedPipe = CallNamedPipeA;
%END

PROCEDURE WaitNamedPipeA(lpNamedPipeName : ARRAY OF ACHAR;
                         nTimeOut : DWORD) : BOOL;

PROCEDURE WaitNamedPipeW(lpNamedPipeName : ARRAY OF UCHAR;
                         nTimeOut : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE WaitNamedPipe = WaitNamedPipeW;
%ELSE
PROCEDURE WaitNamedPipe = WaitNamedPipeA;
%END

PROCEDURE SetVolumeLabelA(lpRootPathName : ARRAY OF ACHAR;
                          lpVolumeName : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetVolumeLabelW(lpRootPathName : ARRAY OF UCHAR;
                          lpVolumeName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetVolumeLabel = SetVolumeLabelW;
%ELSE
PROCEDURE SetVolumeLabel = SetVolumeLabelA;
%END

PROCEDURE SetFileApisToOEM();

(*95*)
PROCEDURE SetFileApisToANSI();

(*95*)
PROCEDURE AreFileApisANSI() : BOOL;


PROCEDURE GetVolumeInformationA(lpRootPathName : ARRAY OF ACHAR;
                                VAR lpVolumeNameBuffer : ARRAY OF ACHAR;
                                nVolumeNameSize : DWORD;
                                VAR lpVolumeSerialNumber : DWORD;
                                VAR lpMaximumComponentLength : DWORD;
                                VAR lpFileSystemFlags : DWORD;
                                VAR lpFileSystemNameBuffer : ARRAY OF ACHAR;
                                nFileSystemNameSize : DWORD) : BOOL;

PROCEDURE GetVolumeInformationW(lpRootPathName : ARRAY OF UCHAR;
                                VAR lpVolumeNameBuffer : ARRAY OF UCHAR;
                                nVolumeNameSize : DWORD;
                                VAR lpVolumeSerialNumber : DWORD;
                                VAR lpMaximumComponentLength : DWORD;
                                VAR lpFileSystemFlags : DWORD;
                                VAR lpFileSystemNameBuffer : ARRAY OF UCHAR;
                                nFileSystemNameSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetVolumeInformation = GetVolumeInformationW;
%ELSE
PROCEDURE GetVolumeInformation = GetVolumeInformationA;
%END

PROCEDURE CancelIo(hFile : HANDLE) : BOOL;

PROCEDURE ClearEventLogA(hEventLog : HANDLE;
                         lpBackupFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE ClearEventLogW(hEventLog : HANDLE;
                         lpBackupFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE ClearEventLog = ClearEventLogW;
%ELSE
PROCEDURE ClearEventLog = ClearEventLogA;
%END

PROCEDURE BackupEventLogA(hEventLog : HANDLE;
                          lpBackupFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE BackupEventLogW(hEventLog : HANDLE;
                          lpBackupFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE BackupEventLog = BackupEventLogW;
%ELSE
PROCEDURE BackupEventLog = BackupEventLogA;
%END

PROCEDURE CloseEventLog(hEventLog : HANDLE) : BOOL;

PROCEDURE DeregisterEventSource(hEventLog : HANDLE) : BOOL;

(*95*)
PROCEDURE NotifyChangeEventLog(
                                hEventLog : HANDLE;
                                hEvent : HANDLE
                                ) : BOOL;

PROCEDURE GetNumberOfEventLogRecords(hEventLog : HANDLE;
                                     NumberOfRecords : PDWORD) : BOOL;

PROCEDURE GetOldestEventLogRecord(hEventLog : HANDLE;
                                  OldestRecord : PDWORD) : BOOL;

PROCEDURE OpenEventLogA(lpUNCServerName : ARRAY OF ACHAR;
                        lpSourceName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenEventLogW(lpUNCServerName : ARRAY OF UCHAR;
                        lpSourceName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenEventLog = OpenEventLogW;
%ELSE
PROCEDURE OpenEventLog = OpenEventLogA;
%END

PROCEDURE RegisterEventSourceA(lpUNCServerName : ARRAY OF ACHAR;
                               lpSourceName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE RegisterEventSourceW(lpUNCServerName : ARRAY OF UCHAR;
                               lpSourceName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE RegisterEventSource = RegisterEventSourceW;
%ELSE
PROCEDURE RegisterEventSource = RegisterEventSourceA;
%END

PROCEDURE OpenBackupEventLogA(lpUNCServerName : ARRAY OF ACHAR;
                              lpFileName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenBackupEventLogW(lpUNCServerName : ARRAY OF UCHAR;
                              lpFileName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenBackupEventLog = OpenBackupEventLogW;
%ELSE
PROCEDURE OpenBackupEventLog = OpenBackupEventLogA;
%END

PROCEDURE ReadEventLogA(hEventLog : HANDLE;
                        dwReadFlags : DWORD;
                        dwRecordOffset : DWORD;
                        lpBuffer : LPVOID;
                        nNumberOfBytesToRead : DWORD;
                        VAR pnBytesRead : DWORD;
                        VAR pnMinNumberOfBytesNeeded : DWORD) : BOOL;

PROCEDURE ReadEventLogW(hEventLog : HANDLE;
                        dwReadFlags : DWORD;
                        dwRecordOffset : DWORD;
                        lpBuffer : LPVOID;
                        nNumberOfBytesToRead : DWORD;
                        VAR pnBytesRead : DWORD;
                        VAR pnMinNumberOfBytesNeeded : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE ReadEventLog = ReadEventLogW;
%ELSE
PROCEDURE ReadEventLog = ReadEventLogA;
%END

PROCEDURE ReportEventA(hEventLog : HANDLE;
                       wType : WORD;
                       wCategory : WORD;
                       dwEventID : DWORD;
                       lpUserSid : PSID;
                       wNumStrings : WORD;
                       dwDataSize : DWORD;
                       lpStrings : ARRAY OF LPSTR;
                       lpRawData : LPVOID) : BOOL;

PROCEDURE ReportEventW(hEventLog : HANDLE;
                       wType : WORD;
                       wCategory : WORD;
                       dwEventID : DWORD;
                       lpUserSid : PSID;
                       wNumStrings : WORD;
                       dwDataSize : DWORD;
                       lpStrings : ARRAY OF LPWSTR;
                       lpRawData : LPVOID) : BOOL;

%IF UNICODE %THEN
PROCEDURE ReportEvent = ReportEventW;
%ELSE
PROCEDURE ReportEvent = ReportEventA;
%END

PROCEDURE DuplicateToken(ExistingTokenHandle : HANDLE;
                         ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL;
                         DuplicateTokenHandle : PHANDLE) : BOOL;

PROCEDURE GetKernelObjectSecurity(Handle : HANDLE;
                                  RequestedInformation : SECURITY_INFORMATION;
                                  pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                  nLength : DWORD;
                                  VAR lpnLengthNeeded : DWORD) : BOOL;

PROCEDURE ImpersonateNamedPipeClient(hNamedPipe : HANDLE) : BOOL;

PROCEDURE ImpersonateSelf(ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL) : BOOL;

PROCEDURE RevertToSelf() : BOOL;

PROCEDURE SetThreadToken(VAR Thread : HANDLE; Token : HANDLE) : BOOL;

PROCEDURE AccessCheck(pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                      ClientToken : HANDLE;
                      DesiredAccess : DWORD;
                      GenericMapping : PGENERIC_MAPPING;
                      PrivilegeSet : PPRIVILEGE_SET;
                      VAR PrivilegeSetLength : DWORD;
                      VAR GrantedAccess : DWORD;
                      AccessStatus : LPBOOL) : BOOL;

%IF WIN5 %THEN

(*               Object Type list for AccessCheckByType               *)

TYPE
    OBJECT_TYPE_LIST = RECORD
    Level       : WORD;
    Sbz         : WORD;
    ObjectType  : REFGUID;
    END;
    POBJECT_TYPE_LIST = POINTER TO OBJECT_TYPE_LIST;

(*
 DS values for Level
*)
CONST
    ACCESS_OBJECT_GUID       =0;
    ACCESS_PROPERTY_SET_GUID =1;
    ACCESS_PROPERTY_GUID     =2;

    ACCESS_MAX_LEVEL         =4;

(* NT only *)
PROCEDURE AccessCheckByType (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                             PrincipalSelfSid : PSID;
                             ClientToken : HANDLE;
                             DesiredAccess : DWORD;
                             ObjectTypeList : OBJECT_TYPE_LIST;
                             ObjectTypeListLength : DWORD;
                             GenericMapping : GENERIC_MAPPING;
                             PrivilegeSet : PRIVILEGE_SET;
                             VAR PrivilegeSetLength : DWORD;
                             VAR GrantedAccess : DWORD;
                             VAR AccessStatus : BOOL) : BOOL;

(* NT only *)
PROCEDURE AccessCheckByTypeResultList (
                            pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                            PrincipalSelfSid : PSID;
                            ClientToken : HANDLE;
                            DesiredAccess : DWORD;
                            ObjectTypeList: OBJECT_TYPE_LIST;
                            ObjectTypeListLength : DWORD;
                            GenericMapping : GENERIC_MAPPING;
                            PrivilegeSet : PRIVILEGE_SET;
                            VAR PrivilegeSetLength : DWORD;
                            VAR GrantedAccessList : DWORD;
                            VAR AccessStatusList  : DWORD) : BOOL;

%END

PROCEDURE OpenProcessToken(ProcessHandle : HANDLE;
                           DesiredAccess : DWORD;
                           TokenHandle : PHANDLE) : BOOL;

PROCEDURE OpenThreadToken(ThreadHandle : HANDLE;
                          DesiredAccess : DWORD;
                          OpenAsSelf : BOOL;
                          TokenHandle : PHANDLE) : BOOL;

PROCEDURE GetTokenInformation(TokenHandle : HANDLE;
                              TokenInformationClass : TOKEN_INFORMATION_CLASS;
                              TokenInformation : LPVOID;
                              TokenInformationLength : DWORD;
                              ReturnLength : PDWORD) : BOOL;

PROCEDURE SetTokenInformation(TokenHandle : HANDLE;
                              TokenInformationClass : TOKEN_INFORMATION_CLASS;
                              TokenInformation : LPVOID;
                              TokenInformationLength : DWORD) : BOOL;

PROCEDURE AdjustTokenPrivileges(TokenHandle : HANDLE;
                                DisableAllPrivileges : BOOL;
                                NewState : PTOKEN_PRIVILEGES;
                                BufferLength : DWORD;
                                PreviousState : PTOKEN_PRIVILEGES;
                                ReturnLength : PDWORD) : BOOL;

PROCEDURE AdjustTokenGroups(TokenHandle : HANDLE;
                            ResetToDefault : BOOL;
                            NewState : PTOKEN_GROUPS;
                            BufferLength : DWORD;
                            PreviousState : PTOKEN_GROUPS;
                            VAR OUT ReturnLength : DWORD) : BOOL;

PROCEDURE PrivilegeCheck(ClientToken : HANDLE;
                         RequiredPrivileges : PPRIVILEGE_SET;
                         VAR OUT pfResult : BOOL) : BOOL;

PROCEDURE AccessCheckAndAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                    HandleId : LPVOID;
                                    VAR ObjectTypeName : ARRAY OF ACHAR;
                                    VAR ObjectName : ARRAY OF ACHAR;
                                    SecurityDescriptor : PSECURITY_DESCRIPTOR;
                                    DesiredAccess : DWORD;
                                    GenericMapping : PGENERIC_MAPPING;
                                    ObjectCreation : BOOL;
                                    VAR GrantedAccess : DWORD;
                                    VAR OUT AccessStatus : BOOL;
                                    VAR OUT pfGenerateOnClose : BOOL) : BOOL;

PROCEDURE AccessCheckAndAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                    HandleId : LPVOID;
                                    VAR ObjectTypeName : ARRAY OF UCHAR;
                                    VAR ObjectName : ARRAY OF UCHAR;
                                    SecurityDescriptor : PSECURITY_DESCRIPTOR;
                                    DesiredAccess : DWORD;
                                    GenericMapping : PGENERIC_MAPPING;
                                    ObjectCreation : BOOL;
                                    VAR GrantedAccess : DWORD;
                                    VAR OUT AccessStatus : BOOL;
                                    VAR OUT pfGenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE AccessCheckAndAuditAlarm = AccessCheckAndAuditAlarmW;
%ELSE
PROCEDURE AccessCheckAndAuditAlarm = AccessCheckAndAuditAlarmA;
%END

%IF WIN5 %THEN
TYPE
    AUDIT_EVENT_TYPE = (AuditEventObjectAccess,
                        AuditEventDirectoryServiceAccess);

CONST AUDIT_ALLOW_NO_PRIVILEGE = 1h;

(*
 DS values for Source and ObjectTypeName
*)
CONST
    ACCESS_DS_SOURCE_A = "DS";
    ACCESS_DS_SOURCE_W = "DS";
    ACCESS_DS_OBJECT_TYPE_NAME_A = "Directory Service Object";
    ACCESS_DS_OBJECT_TYPE_NAME_W = "Directory Service Object";

(* NT only *)
PROCEDURE AccessCheckByTypeAndAuditAlarmA (
    SubsystemName : ARRAY OF ACHAR;
    HandleId : LPVOID;
    ObjectTypeName : ARRAY OF ACHAR;
    ObjectName : ARRAY OF ACHAR;
    SecurityDescriptor : PSECURITY_DESCRIPTOR;
    PrincipalSelfSid : PSID;
    DesiredAccess : DWORD;
    AuditType : AUDIT_EVENT_TYPE;
    Flags : DWORD;
    ObjectTypeList : OBJECT_TYPE_LIST;
    ObjectTypeListLength : DWORD;
    GenericMapping : GENERIC_MAPPING;
    ObjectCreation : BOOL;
    VAR GrantedAccess : DWORD;
    VAR AccessStatus : BOOL;
    VAR pfGenerateOnClose : BOOL) : BOOL;

(* NT only *)
PROCEDURE AccessCheckByTypeAndAuditAlarmW (
    SubsystemName : ARRAY OF WCHAR;
    HandleId : LPVOID;
    ObjectTypeName : ARRAY OF WCHAR;
    ObjectName : ARRAY OF WCHAR;
    SecurityDescriptor : PSECURITY_DESCRIPTOR;
    PrincipalSelfSid : PSID;
    DesiredAccess : DWORD;
    AuditType : AUDIT_EVENT_TYPE;
    Flags : DWORD;
    ObjectTypeList : OBJECT_TYPE_LIST;
    ObjectTypeListLength : DWORD;
    GenericMapping : GENERIC_MAPPING;
    ObjectCreation : BOOL;
    VAR GrantedAccess : DWORD;
    VAR AccessStatus : BOOL;
    VAR pfGenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
(* NT only *)
PROCEDURE AccessCheckByTypeAndAuditAlarm = AccessCheckByTypeAndAuditAlarmW;
%ELSE
(* NT only *)
PROCEDURE AccessCheckByTypeAndAuditAlarm = AccessCheckByTypeAndAuditAlarmA;
%END

(* NT only *)
PROCEDURE AccessCheckByTypeResultListAndAuditAlarmA (
    SubsystemName : ARRAY OF ACHAR;
    HandleId : LPVOID;
    ObjectTypeName : ARRAY OF ACHAR;
    ObjectName : ARRAY OF ACHAR;
    SecurityDescriptor : PSECURITY_DESCRIPTOR;
    PrincipalSelfSid : PSID;
    DesiredAccess : DWORD;
    AuditType : AUDIT_EVENT_TYPE;
    Flags : DWORD;
    ObjectTypeList : OBJECT_TYPE_LIST;
    ObjectTypeListLength : DWORD;
    GenericMapping : GENERIC_MAPPING;
    ObjectCreation : BOOL;
    VAR GrantedAccess : DWORD;
    VAR AccessStatus : BOOL;
    VAR pfGenerateOnClose : BOOL) : BOOL;

(* NT only *)
PROCEDURE AccessCheckByTypeResultListAndAuditAlarmW (
    SubsystemName : ARRAY OF WCHAR;
    HandleId : LPVOID;
    ObjectTypeName : ARRAY OF WCHAR;
    ObjectName : ARRAY OF WCHAR;
    SecurityDescriptor : PSECURITY_DESCRIPTOR;
    PrincipalSelfSid : PSID;
    DesiredAccess : DWORD;
    AuditType : AUDIT_EVENT_TYPE;
    Flags : DWORD;
    ObjectTypeList : OBJECT_TYPE_LIST;
    ObjectTypeListLength : DWORD;
    GenericMapping : GENERIC_MAPPING;
    ObjectCreation : BOOL;
    VAR GrantedAccess : DWORD;
    VAR AccessStatus : BOOL;
    VAR pfGenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
(* NT only *)
PROCEDURE AccessCheckByTypeResultListAndAuditAlarm = AccessCheckByTypeResultListAndAuditAlarmW;
%ELSE
(* NT only *)
PROCEDURE AccessCheckByTypeResultListAndAuditAlarm = AccessCheckByTypeResultListAndAuditAlarmA;
%END

%END

PROCEDURE ObjectOpenAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                HandleId : LPVOID;
                                VAR ObjectTypeName : ARRAY OF ACHAR;
                                VAR ObjectName : ARRAY OF ACHAR;
                                pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                ClientToken : HANDLE;
                                DesiredAccess : DWORD;
                                GrantedAccess : DWORD;
                                Privileges : PPRIVILEGE_SET;
                                ObjectCreation : BOOL;
                                AccessGranted : BOOL;
                                GenerateOnClose : LPBOOL) : BOOL;

PROCEDURE ObjectOpenAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                HandleId : LPVOID;
                                VAR ObjectTypeName : ARRAY OF UCHAR;
                                VAR ObjectName : ARRAY OF UCHAR;
                                pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                ClientToken : HANDLE;
                                DesiredAccess : DWORD;
                                GrantedAccess : DWORD;
                                Privileges : PPRIVILEGE_SET;
                                ObjectCreation : BOOL;
                                AccessGranted : BOOL;
                                GenerateOnClose : LPBOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE ObjectOpenAuditAlarm = ObjectOpenAuditAlarmW;
%ELSE
PROCEDURE ObjectOpenAuditAlarm = ObjectOpenAuditAlarmA;
%END

PROCEDURE ObjectPrivilegeAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                     HandleId : LPVOID;
                                     ClientToken : HANDLE;
                                     DesiredAccess : DWORD;
                                     Privileges : PPRIVILEGE_SET;
                                     AccessGranted : BOOL) : BOOL;

PROCEDURE ObjectPrivilegeAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                     HandleId : LPVOID;
                                     ClientToken : HANDLE;
                                     DesiredAccess : DWORD;
                                     Privileges : PPRIVILEGE_SET;
                                     AccessGranted : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE ObjectPrivilegeAuditAlarm = ObjectPrivilegeAuditAlarmW;
%ELSE
PROCEDURE ObjectPrivilegeAuditAlarm = ObjectPrivilegeAuditAlarmA;
%END



PROCEDURE ObjectCloseAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                 HandleId : LPVOID;
                                 GenerateOnClose : BOOL) : BOOL;

PROCEDURE ObjectCloseAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                 HandleId : LPVOID;
                                 GenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE ObjectCloseAuditAlarm = ObjectCloseAuditAlarmW;
%ELSE
PROCEDURE ObjectCloseAuditAlarm = ObjectCloseAuditAlarmA;
%END

PROCEDURE ObjectDeleteAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                  HandleId : LPVOID;
                                  GenerateOnClose : BOOL) : BOOL;

PROCEDURE ObjectDeleteAuditAlarmW(SubsystemName : ARRAY OF WCHAR;
                                  HandleId : LPVOID;
                                  GenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE ObjectDeleteAuditAlarm = ObjectDeleteAuditAlarmW;
%ELSE
PROCEDURE ObjectDeleteAuditAlarm = ObjectDeleteAuditAlarmA;
%END

PROCEDURE PrivilegedServiceAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                       ServiceName : ARRAY OF ACHAR;
                                       ClientToken : HANDLE;
                                       Privileges : PPRIVILEGE_SET;
                                       AccessGranted : BOOL) : BOOL;

PROCEDURE PrivilegedServiceAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                       ServiceName : ARRAY OF UCHAR;
                                       ClientToken : HANDLE;
                                       Privileges : PPRIVILEGE_SET;
                                       AccessGranted : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE PrivilegedServiceAuditAlarm = PrivilegedServiceAuditAlarmW;
%ELSE
PROCEDURE PrivilegedServiceAuditAlarm = PrivilegedServiceAuditAlarmA;
%END

PROCEDURE IsValidSid(pSid : PSID) : BOOL;

PROCEDURE EqualSid(pSid1 : PSID;
                   pSid2 : PSID) : BOOL;

PROCEDURE EqualPrefixSid(pSid1 : PSID;
                         pSid2 : PSID) : BOOL;

PROCEDURE GetSidLengthRequired(nSubAuthorityCount : UCHAR) : DWORD;

PROCEDURE AllocateAndInitializeSid(pIdentifierAuthority : PSID_IDENTIFIER_AUTHORITY;
                                   nSubAuthorityCount : BYTE;
                                   nSubAuthority0 : DWORD;
                                   nSubAuthority1 : DWORD;
                                   nSubAuthority2 : DWORD;
                                   nSubAuthority3 : DWORD;
                                   nSubAuthority4 : DWORD;
                                   nSubAuthority5 : DWORD;
                                   nSubAuthority6 : DWORD;
                                   nSubAuthority7 : DWORD;
                                   VAR pSid : PSID) : BOOL;

PROCEDURE FreeSid(pSid : PSID) : PVOID;

PROCEDURE InitializeSid(Sid : PSID;
                        pIdentifierAuthority : PSID_IDENTIFIER_AUTHORITY;
                        nSubAuthorityCount : BYTE) : BOOL;

PROCEDURE GetSidIdentifierAuthority(pSid : PSID) : PSID_IDENTIFIER_AUTHORITY;

PROCEDURE GetSidSubAuthority(pSid : PSID;
                             nSubAuthority : DWORD) : PDWORD;

PROCEDURE GetSidSubAuthorityCount(pSid : PSID) : PUCHAR;

PROCEDURE GetLengthSid(pSid : PSID) : DWORD;

PROCEDURE CopySid(nDestinationSidLength : DWORD;
                  pDestinationSid : PSID;
                  pSourceSid : PSID) : BOOL;

PROCEDURE AreAllAccessesGranted(GrantedAccess : DWORD;
                                DesiredAccess : DWORD) : BOOL;

PROCEDURE AreAnyAccessesGranted(GrantedAccess : DWORD;
                                DesiredAccess : DWORD) : BOOL;

PROCEDURE MapGenericMask(AccessMask : PDWORD;
                         GenericMapping : PGENERIC_MAPPING);

PROCEDURE IsValidAcl(pAcl : ACL) : BOOL;

PROCEDURE InitializeAcl(VAR pAcl : ACL;
                        nAclLength : DWORD;
                        dwAclRevision : DWORD) : BOOL;

PROCEDURE GetAclInformation(pAcl : ACL;
                            pAclInformation : LPVOID;
                            nAclInformationLength : DWORD;
                            dwAclInformationClass : ACL_INFORMATION_CLASS) : BOOL;

PROCEDURE SetAclInformation(pAcl : PACL;
                            pAclInformation : LPVOID;
                            nAclInformationLength : DWORD;
                            dwAclInformationClass : ACL_INFORMATION_CLASS) : BOOL;

PROCEDURE AddAce(pAcl : ACL;
                 dwAceRevision : DWORD;
                 dwStartingAceIndex : DWORD;
                 pAceList : LPVOID;
                 nAceListLength : DWORD) : BOOL;

PROCEDURE DeleteAce(pAcl : ACL;
                    dwAceIndex : DWORD) : BOOL;

PROCEDURE GetAce(pAcl : ACL;
                 dwAceIndex : DWORD;
                 VAR pAce : LPVOID) : BOOL;

PROCEDURE AddAccessAllowedAce(pAcl : ACL;
                              dwAceRevision : DWORD;
                              AccessMask : DWORD;
                              pSid : PSID) : BOOL;

%IF WIN5 %THEN
(* NT only *)
PROCEDURE AddAccessAllowedAceEx (pAcl : PACL;
                                 dwAceRevision : DWORD;
                                 AceFlags : DWORD;
                                 AccessMask : DWORD;
                                 pSid : PSID) : BOOL;
%END

PROCEDURE AddAccessDeniedAce(pAcl : ACL;
                             dwAceRevision : DWORD;
                             AccessMask : DWORD;
                             pSid : PSID) : BOOL;

%IF WIN5 %THEN
(* NT only *)
PROCEDURE AddAccessDeniedAceEx(pAcl : PACL;
                               dwAceRevision : DWORD;
                               AceFlags : DWORD;
                               AccessMask : DWORD;
                               pSid : PSID) : BOOL;
%END

PROCEDURE AddAuditAccessAce(pAcl : ACL;
                            dwAceRevision : DWORD;
                            dwAccessMask : DWORD;
                            pSid : PSID;
                            bAuditSuccess : BOOL;
                            bAuditFailure : BOOL) : BOOL;

%IF WIN5 %THEN
(* NT only *)
PROCEDURE AddAuditAccessAceEx(pAcl : PACL;
                              dwAceRevision : DWORD;
                              AceFlags : DWORD;
                              dwAccessMask : DWORD;
                              pSid : PSID;
                              bAuditSuccess : BOOL;
                              bAuditFailure : BOOL) : BOOL;

(* NT only *)
PROCEDURE AddAccessAllowedObjectAce(pAcl : PACL;
                                    dwAceRevision : DWORD;
                                    AceFlags : DWORD;
                                    AccessMask : DWORD;
                                    ObjectTypeGuid : GUID;
                                    InheritedObjectTypeGuid : GUID;
                                    pSid : PSID) : BOOL;

(* NT only *)
PROCEDURE AddAccessDeniedObjectAce(pAcl : PACL;
                                   dwAceRevision : DWORD;
                                   AceFlags : DWORD;
                                   AccessMask : DWORD;
                                   ObjectTypeGuid : GUID;
                                   InheritedObjectTypeGuid : GUID;
                                   pSid : PSID) : BOOL;

(* NT only *)
PROCEDURE AddAuditAccessObjectAce(pAcl : PACL;
                                  dwAceRevision : DWORD;
                                  AceFlags : DWORD;
                                  AccessMask : DWORD;
                                  ObjectTypeGuid : GUID;
                                  InheritedObjectTypeGuid : GUID;
                                  pSid : PSID;
                                  bAuditSuccess : BOOL;
                                  bAuditFailure : BOOL) : BOOL;

%END

PROCEDURE FindFirstFreeAce(pAcl : ACL;
                           VAR pAce : LPVOID) : BOOL;

PROCEDURE InitializeSecurityDescriptor(VAR pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                       dwRevision : DWORD) : BOOL;

PROCEDURE IsValidSecurityDescriptor(pSecurityDescriptor : SECURITY_DESCRIPTOR) : BOOL;

PROCEDURE GetSecurityDescriptorLength(pSecurityDescriptor : SECURITY_DESCRIPTOR) : DWORD;

PROCEDURE GetSecurityDescriptorControl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                       VAR pControl : SECURITY_DESCRIPTOR_CONTROL;
                                       VAR lpdwRevision : DWORD) : BOOL;

%IF WIN5 %THEN
(* NT only *)
PROCEDURE SetSecurityDescriptorControl(
    pSecurityDescriptor : PSECURITY_DESCRIPTOR;
    ControlBitsOfInterest : SECURITY_DESCRIPTOR_CONTROL;
    ControlBitsToSet : SECURITY_DESCRIPTOR_CONTROL) : BOOL;
%END

PROCEDURE SetSecurityDescriptorDacl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                    bDaclPresent : BOOL;
                                    pDacl : PACL;
                                    bDaclDefaulted : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorDacl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                    VAR lpbDaclPresent : BOOL;
                                    VAR pDacl : PACL;
                                    VAR lpbDaclDefaulted : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorSacl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                    bSaclPresent : BOOL;
                                    pSacl : PACL;
                                    bSaclDefaulted : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorSacl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                    VAR lpbSaclPresent : BOOL;
                                    VAR pSacl : PACL;
                                    VAR lpbSaclDefaulted : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorOwner(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                     pOwner : PSID;
                                     bOwnerDefaulted : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorOwner(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                     VAR pOwner : PSID;
                                     VAR lpbOwnerDefaulted : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorGroup(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                     pGroup : PSID;
                                     bGroupDefaulted : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorGroup(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                     VAR pGroup : PSID;
                                     VAR lpbGroupDefaulted : BOOL) : BOOL;

PROCEDURE CreatePrivateObjectSecurity(ParentDescriptor : SECURITY_DESCRIPTOR;
                                      CreatorDescriptor : SECURITY_DESCRIPTOR;
                                      VAR NewDescriptor : PSECURITY_DESCRIPTOR;
                                      IsDirectoryObject : BOOL;
                                      Token : HANDLE;
                                      GenericMapping : GENERIC_MAPPING) : BOOL;

%IF WIN5 %THEN

(*NT only*)
PROCEDURE ConvertToAutoInheritPrivateObjectSecurity(
    ParentDescriptor : PSECURITY_DESCRIPTOR;
    CurrentSecurityDescriptor : PSECURITY_DESCRIPTOR;
    VAR NewSecurityDescriptor : PSECURITY_DESCRIPTOR;
    ObjectType : GUID;
    IsDirectoryObject : BOOLEAN;
    GenericMapping : GENERIC_MAPPING) : BOOL;

(*NT only*)
PROCEDURE CreatePrivateObjectSecurityEx(
    ParentDescriptor : PSECURITY_DESCRIPTOR;
    CreatorDescriptor : PSECURITY_DESCRIPTOR;
    VAR NewDescriptor : PSECURITY_DESCRIPTOR;
    ObjectType : GUID;
    IsContainerObject : BOOL;
    AutoInheritFlags : ULONG;
    Token : HANDLE;
    GenericMapping : GENERIC_MAPPING) : BOOL;

%END

PROCEDURE SetPrivateObjectSecurity(SecurityInformation : SECURITY_INFORMATION;
                                   ModificationDescriptor : PSECURITY_DESCRIPTOR;
                                   VAR ObjectsSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                   GenericMapping : PGENERIC_MAPPING;
                                   Token : HANDLE) : BOOL;

%IF WIN5 %THEN
(*NT only*)
PROCEDURE SetPrivateObjectSecurityEx(
    SecurityInformation : SECURITY_INFORMATION;
    ModificationDescriptor : PSECURITY_DESCRIPTOR;
    VAR ObjectsSecurityDescriptor : PSECURITY_DESCRIPTOR;
    AutoInheritFlags : ULONG;
    GenericMapping : GENERIC_MAPPING;
    Token : HANDLE) : BOOL;
%END

PROCEDURE GetPrivateObjectSecurity(ObjectDescriptor : PSECURITY_DESCRIPTOR;
                                   SecurityInformation : SECURITY_INFORMATION;
                                   ResultantDescriptor : PSECURITY_DESCRIPTOR;
                                   DescriptorLength : DWORD;
                                   ReturnLength : PDWORD) : BOOL;

PROCEDURE DestroyPrivateObjectSecurity(VAR ObjectDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE MakeSelfRelativeSD(pAbsoluteSecurityDescriptor : PSECURITY_DESCRIPTOR;
                             pSelfRelativeSecurityDescriptor : PSECURITY_DESCRIPTOR;
                             VAR lpdwBufferLength : DWORD) : BOOL;

PROCEDURE MakeAbsoluteSD(pSelfRelativeSecurityDescriptor : PSECURITY_DESCRIPTOR;
                         pAbsoluteSecurityDescriptor : PSECURITY_DESCRIPTOR;
                         VAR lpdwAbsoluteSecurityDescriptorSize : DWORD;
                         pDacl : PACL;
                         VAR lpdwDaclSize : DWORD;
                         pSacl : PACL;
                         VAR lpdwSaclSize : DWORD;
                         pOwner : PSID;
                         VAR lpdwOwnerSize : DWORD;
                         pPrimaryGroup : PSID;
                         VAR lpdwPrimaryGroupSize : DWORD) : BOOL;

PROCEDURE SetFileSecurityA(lpFileName : ARRAY OF ACHAR;
                           SecurityInformation : SECURITY_INFORMATION;
                           pSecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE SetFileSecurityW(lpFileName : ARRAY OF UCHAR;
                           SecurityInformation : SECURITY_INFORMATION;
                           pSecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetFileSecurity = SetFileSecurityW;
%ELSE
PROCEDURE SetFileSecurity = SetFileSecurityA;
%END

PROCEDURE GetFileSecurityA(lpFileName : ARRAY OF ACHAR;
                           RequestedInformation : SECURITY_INFORMATION;
                           pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                           nLength : DWORD;
                           VAR lpnLengthNeeded : DWORD) : BOOL;

PROCEDURE GetFileSecurityW(lpFileName : ARRAY OF UCHAR;
                           RequestedInformation : SECURITY_INFORMATION;
                           pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                           nLength : DWORD;
                           VAR lpnLengthNeeded : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetFileSecurity = GetFileSecurityW;
%ELSE
PROCEDURE GetFileSecurity = GetFileSecurityA;
%END

PROCEDURE SetKernelObjectSecurity(Handle : HANDLE;
                                  SecurityInformation : SECURITY_INFORMATION;
                                  SecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE FindFirstChangeNotificationA(lpPathName : ARRAY OF ACHAR;
                                       bWatchSubtree : BOOL;
                                       dwNotifyFilter : DWORD) : HANDLE;

PROCEDURE FindFirstChangeNotificationW(lpPathName : ARRAY OF UCHAR;
                                       bWatchSubtree : BOOL;
                                       dwNotifyFilter : DWORD) : HANDLE;

%IF UNICODE %THEN
PROCEDURE FindFirstChangeNotification = FindFirstChangeNotificationW;
%ELSE
PROCEDURE FindFirstChangeNotification = FindFirstChangeNotificationA;
%END

PROCEDURE FindNextChangeNotification(hChangeHandle : HANDLE) : BOOL;

PROCEDURE FindCloseChangeNotification(hChangeHandle : HANDLE) : BOOL;

(*NT only*)
PROCEDURE ReadDirectoryChangesW(
    hDirectory : HANDLE;
    VAR lpBuffer : ARRAY OF LOC;
    nBufferLength : DWORD;
    bWatchSubtree : BOOL;
    dwNotifyFilter : DWORD;
    VAR lpBytesReturned : DWORD;
    lpOverlapped : LPOVERLAPPED;
    lpCompletionRoutine : LPOVERLAPPED_COMPLETION_ROUTINE) : BOOL;

PROCEDURE VirtualLock(lpAddress : LPVOID;
                      dwSize : DWORD) : BOOL;

PROCEDURE VirtualUnlock(lpAddress : LPVOID;
                        dwSize : DWORD) : BOOL;

PROCEDURE MapViewOfFileEx(hFileMappingObject : HANDLE;
                          dwDesiredAccess : DWORD;
                          dwFileOffsetHigh : DWORD;
                          dwFileOffsetLow : DWORD;
                          dwNumberOfBytesToMap : DWORD;
                          lpBaseAddress : LPVOID) : LPVOID;

PROCEDURE SetPriorityClass(hProcess : HANDLE;
                           dwPriorityClass : DWORD) : BOOL;

PROCEDURE GetPriorityClass(hProcess : HANDLE) : DWORD;

PROCEDURE IsBadReadPtr(lp : LPCVOID;
                       ucb : UINT) : BOOL;

PROCEDURE IsBadWritePtr(lp : LPVOID;
                        ucb : UINT) : BOOL;

PROCEDURE IsBadHugeReadPtr(lp : LPCVOID;
                           ucb : UINT) : BOOL;

PROCEDURE IsBadHugeWritePtr(lp : LPVOID;
                            ucb : UINT) : BOOL;

PROCEDURE IsBadCodePtr(lpfn : FARPROC) : BOOL;

PROCEDURE IsBadStringPtrA(lpsz : LPCSTR;
                          ucchMax : UINT) : BOOL;

PROCEDURE IsBadStringPtrW(lpsz : LPCWSTR;
                          ucchMax : UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE IsBadStringPtr = IsBadStringPtrW;
%ELSE
PROCEDURE IsBadStringPtr = IsBadStringPtrA;
%END

PROCEDURE LookupAccountSidA(lpSystemName : ARRAY OF ACHAR;
                            Sid : PSID;
                            VAR Name : ARRAY OF ACHAR;
                            VAR cbName : DWORD;
                            VAR ReferencedDomainName : ARRAY OF ACHAR;
                            VAR cbReferencedDomainName : DWORD;
                            peUse : PSID_NAME_USE) : BOOL;

PROCEDURE LookupAccountSidW(lpSystemName : ARRAY OF UCHAR;
                            Sid : PSID;
                            VAR Name : ARRAY OF UCHAR;
                            VAR cbName : DWORD;
                            VAR ReferencedDomainName : ARRAY OF UCHAR;
                            VAR cbReferencedDomainName : DWORD;
                            peUse : PSID_NAME_USE) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupAccountSid = LookupAccountSidW;
%ELSE
PROCEDURE LookupAccountSid = LookupAccountSidA;
%END

PROCEDURE LookupAccountNameA(lpSystemName : ARRAY OF ACHAR;
                             lpAccountName : ARRAY OF ACHAR;
                             Sid : PSID;
                             VAR cbSid : DWORD;
                             VAR ReferencedDomainName : ARRAY OF ACHAR;
                             VAR cbReferencedDomainName : DWORD;
                             peUse : PSID_NAME_USE) : BOOL;

PROCEDURE LookupAccountNameW(lpSystemName : ARRAY OF UCHAR;
                             lpAccountName : ARRAY OF UCHAR;
                             Sid : PSID;
                             VAR cbSid : DWORD;
                             VAR ReferencedDomainName : ARRAY OF UCHAR;
                             VAR cbReferencedDomainName : DWORD;
                             peUse : PSID_NAME_USE) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupAccountName = LookupAccountNameW;
%ELSE
PROCEDURE LookupAccountName = LookupAccountNameA;
%END

PROCEDURE LookupPrivilegeValueA(lpSystemName : ARRAY OF ACHAR;
                                lpName : ARRAY OF ACHAR;
                                VAR lpLuid : LUID) : BOOL;

PROCEDURE LookupPrivilegeValueW(lpSystemName : ARRAY OF UCHAR;
                                lpName : ARRAY OF UCHAR;
                                VAR lpLuid : LUID) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupPrivilegeValue = LookupPrivilegeValueW;
%ELSE
PROCEDURE LookupPrivilegeValue = LookupPrivilegeValueA;
%END

PROCEDURE LookupPrivilegeNameA(lpSystemName : ARRAY OF ACHAR;
                               VAR lpLuid : LUID;
                               VAR lpName : ARRAY OF ACHAR;
                               VAR cbName : DWORD) : BOOL;

PROCEDURE LookupPrivilegeNameW(lpSystemName : ARRAY OF UCHAR;
                               VAR lpLuid : LUID;
                               VAR lpName : ARRAY OF UCHAR;
                               VAR cbName : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupPrivilegeName = LookupPrivilegeNameW;
%ELSE
PROCEDURE LookupPrivilegeName = LookupPrivilegeNameA;
%END

PROCEDURE LookupPrivilegeDisplayNameA(lpSystemName : ARRAY OF ACHAR;
                                      lpName : ARRAY OF ACHAR;
                                      VAR lpDisplayName : ARRAY OF ACHAR;
                                      VAR cbDisplayName : DWORD;
                                      VAR lpLanguageId : DWORD) : BOOL;

PROCEDURE LookupPrivilegeDisplayNameW(lpSystemName : ARRAY OF UCHAR;
                                      lpName : ARRAY OF UCHAR;
                                      VAR lpDisplayName : ARRAY OF UCHAR;
                                      VAR cbDisplayName : DWORD;
                                      VAR lpLanguageId : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupPrivilegeDisplayName = LookupPrivilegeDisplayNameW;
%ELSE
PROCEDURE LookupPrivilegeDisplayName = LookupPrivilegeDisplayNameA;
%END

PROCEDURE AllocateLocallyUniqueId(VAR Luid : LUID) : BOOL;

PROCEDURE BuildCommDCBA(lpDef : ARRAY OF ACHAR;
                        lpDCB : LPDCB) : BOOL;

PROCEDURE BuildCommDCBW(lpDef : ARRAY OF UCHAR;
                        lpDCB : LPDCB) : BOOL;

%IF UNICODE %THEN
PROCEDURE BuildCommDCB = BuildCommDCBW;
%ELSE
PROCEDURE BuildCommDCB = BuildCommDCBA;
%END

PROCEDURE BuildCommDCBAndTimeoutsA(lpDef : ARRAY OF ACHAR;
                                   lpDCB : LPDCB;
                                   lpCommTimeouts : LPCOMMTIMEOUTS) : BOOL;

PROCEDURE BuildCommDCBAndTimeoutsW(lpDef : ARRAY OF UCHAR;
                                   lpDCB : LPDCB;
                                   lpCommTimeouts : LPCOMMTIMEOUTS) : BOOL;

%IF UNICODE %THEN
PROCEDURE BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsW;
%ELSE
PROCEDURE BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsA;
%END



PROCEDURE CommConfigDialogA(
                            lpszName : ARRAY OF ACHAR;
                            hWnd : HWND;
                            VAR lpCC : COMMCONFIG
                            ) : BOOL;

PROCEDURE CommConfigDialogW(
                            lpszName : ARRAY OF UCHAR;
                            hWnd : HWND;
                            VAR lpCC : COMMCONFIG
                            ) : BOOL;
%IF UNICODE %THEN
PROCEDURE CommConfigDialog = CommConfigDialogW;
%ELSE
PROCEDURE CommConfigDialog = CommConfigDialogA;
%END

PROCEDURE GetDefaultCommConfigA(
                                lpszName : ARRAY OF ACHAR;
                                VAR lpCC : COMMCONFIG;
                                VAR lpdwSize : DWORD
                                ) : BOOL;

PROCEDURE GetDefaultCommConfigW(
                                lpszName : ARRAY OF UCHAR;
                                VAR lpCC : COMMCONFIG;
                                VAR lpdwSize : DWORD
                                ) : BOOL;
%IF UNICODE %THEN
PROCEDURE GetDefaultCommConfig = GetDefaultCommConfigW;
%ELSE
PROCEDURE GetDefaultCommConfig = GetDefaultCommConfigA;
%END

PROCEDURE SetDefaultCommConfigA(
                                lpszName : ARRAY OF ACHAR;
                                VAR lpCC : COMMCONFIG;
                                dwSize : DWORD
                                ) : BOOL;

PROCEDURE SetDefaultCommConfigW(
                                lpszName : ARRAY OF UCHAR;
                                VAR lpCC : COMMCONFIG;
                                dwSize : DWORD
                                ) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetDefaultCommConfig = SetDefaultCommConfigW;
%ELSE
PROCEDURE SetDefaultCommConfig = SetDefaultCommConfigA;
%END



CONST
    MAX_COMPUTERNAME_LENGTH= 15;

PROCEDURE GetComputerNameA(VAR lpBuffer : ARRAY OF ACHAR;
                           VAR nSize : DWORD) : BOOL;

PROCEDURE GetComputerNameW(VAR lpBuffer : ARRAY OF UCHAR;
                           VAR nSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetComputerName = GetComputerNameW;
%ELSE
PROCEDURE GetComputerName = GetComputerNameA;
%END

PROCEDURE SetComputerNameA(lpComputerName : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetComputerNameW(lpComputerName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetComputerName = SetComputerNameW;
%ELSE
PROCEDURE SetComputerName = SetComputerNameA;
%END

PROCEDURE GetUserNameA(VAR lpBuffer : ARRAY OF ACHAR;
                       VAR nSize : DWORD) : BOOL;

PROCEDURE GetUserNameW(VAR lpBuffer : ARRAY OF UCHAR;
                       VAR nSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetUserName = GetUserNameW;
%ELSE
PROCEDURE GetUserName = GetUserNameA;
%END
CONST
    LOGON32_LOGON_INTERACTIVE   = 2;
    LOGON32_LOGON_NETWORK       = 3;
    LOGON32_LOGON_BATCH         = 4;
    LOGON32_LOGON_SERVICE       = 5;

    LOGON32_PROVIDER_DEFAULT    = 0;
    LOGON32_PROVIDER_WINNT35    = 1;
    LOGON32_PROVIDER_WINNT40    = 2;
    LOGON32_PROVIDER_WINNT50    = 3;

PROCEDURE LogonUserA(lpszUsername : ARRAY OF ACHAR;
                     lpszDomain : ARRAY OF ACHAR;
                     lpszPassword : ARRAY OF ACHAR;
                     dwLogonType : DWORD;
                     dwLogonProvider : DWORD;
                     VAR phToken : HANDLE) : BOOL;

PROCEDURE LogonUserW(lpszUsername : ARRAY OF UCHAR;
                     lpszDomain : ARRAY OF UCHAR;
                     lpszPassword : ARRAY OF UCHAR;
                     dwLogonType : DWORD;
                     dwLogonProvider : DWORD;
                     VAR phToken : HANDLE) : BOOL;

%IF UNICODE %THEN
PROCEDURE LogonUser = LogonUserW;
%ELSE
PROCEDURE LogonUser = LogonUserA;
%END

PROCEDURE ImpersonateLoggedOnUser(hToken : HANDLE) : BOOL;

PROCEDURE CreateProcessAsUserA (hToken : HANDLE;
                                lpApplicationName : ARRAY OF ACHAR;
                                lpCommandLine : ARRAY OF ACHAR;
                                lpProcessAttributes : LPSECURITY_ATTRIBUTES;
                                lpThreadAttributes : LPSECURITY_ATTRIBUTES;
                                bInheritHandles : BOOL;
                                dwCreationFlags : DWORD;
                                lpEnvironment : LPVOID;
                                lpCurrentDirectory : ARRAY OF ACHAR;
                                lpStartupInfo : LPSTARTUPINFOA;
                                lpProcessInformation : LPPROCESS_INFORMATION
                                ) : BOOL;

PROCEDURE CreateProcessAsUserW (hToken : HANDLE;
                                lpApplicationName : ARRAY OF UCHAR;
                                lpCommandLine : ARRAY OF UCHAR;
                                lpProcessAttributes : LPSECURITY_ATTRIBUTES;
                                lpThreadAttributes : LPSECURITY_ATTRIBUTES;
                                bInheritHandles : BOOL;
                                dwCreationFlags : DWORD;
                                lpEnvironment : LPVOID;
                                lpCurrentDirectory : ARRAY OF UCHAR;
                                lpStartupInfo : LPSTARTUPINFOW;
                                lpProcessInformation : LPPROCESS_INFORMATION
                                ) : BOOL;

%IF UNICODE %THEN
PROCEDURE CreateProcessAsUser = CreateProcessAsUserW;
%ELSE
PROCEDURE CreateProcessAsUser = CreateProcessAsUserA;
%END

PROCEDURE DuplicateTokenEx(
    hExistingToken : HANDLE;
    dwDesiredAccess : DWORD;
    lpTokenAttributes : SECURITY_ATTRIBUTES;
    ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL;
    TokenType : TOKEN_TYPE;
    VAR OUT phNewToken : HANDLE) : BOOL;

PROCEDURE CreateRestrictedToken(
    ExistingTokenHandle : HANDLE;
    Flags : DWORD;
    DisableSidCount : DWORD;
    SidsToDisable : PSID_AND_ATTRIBUTES;
    DeletePrivilegeCount : DWORD;
    PrivilegesToDelete : PLUID_AND_ATTRIBUTES;
    RestrictedSidCount : DWORD;
    SidsToRestrict : PSID_AND_ATTRIBUTES;
    VAR OUT NewTokenHandle : HANDLE) : BOOL;

PROCEDURE IsTokenRestricted(TokenHandle : HANDLE) : BOOL;

(*
 Plug-and-Play API's
*)
CONST
(*NT only*)
    HW_PROFILE_GUIDLEN         =39;(* 36-characters plus NULL terminator*)
    MAX_PROFILE_LEN            =80;

    DOCKINFO_UNDOCKED          =1h;
    DOCKINFO_DOCKED            =2h;
    DOCKINFO_USER_SUPPLIED     =4h;
    DOCKINFO_USER_UNDOCKED     =(DOCKINFO_USER_SUPPLIED BOR DOCKINFO_UNDOCKED);
    DOCKINFO_USER_DOCKED       =(DOCKINFO_USER_SUPPLIED BOR DOCKINFO_DOCKED);

TYPE
(*NT only*)
    HW_PROFILE_INFOA = RECORD
    dwDockInfo          : DWORD;
    szHwProfileGuid     : ARRAY [0..HW_PROFILE_GUIDLEN-1] OF ACHAR;
    szHwProfileName     : ARRAY [0..MAX_PROFILE_LEN-1] OF ACHAR;
    END;
    LPHW_PROFILE_INFOA = POINTER TO HW_PROFILE_INFOA;

    HW_PROFILE_INFOW = RECORD
    dwDockInfo          : DWORD;
    szHwProfileGuid     : ARRAY [0..HW_PROFILE_GUIDLEN-1] OF WCHAR;
    szHwProfileName     : ARRAY [0..MAX_PROFILE_LEN-1] OF WCHAR;
    END;
    LPHW_PROFILE_INFOW = POINTER TO HW_PROFILE_INFOW;

%IF UNICODE %THEN
    HW_PROFILE_INFO     = HW_PROFILE_INFOW;
    LPHW_PROFILE_INFO   = LPHW_PROFILE_INFOW;
%ELSE
    HW_PROFILE_INFO     = HW_PROFILE_INFOA;
    LPHW_PROFILE_INFO   = LPHW_PROFILE_INFOA;
%END

(*NT only*)
PROCEDURE GetCurrentHwProfileA(VAR lpHwProfileInfo : HW_PROFILE_INFOA) : BOOL;

(*NT only*)
PROCEDURE GetCurrentHwProfileW(VAR lpHwProfileInfo : HW_PROFILE_INFOW) : BOOL;

%IF UNICODE %THEN
(*NT only*)
PROCEDURE GetCurrentHwProfile = GetCurrentHwProfileW;
%ELSE
(*NT only*)
PROCEDURE GetCurrentHwProfile = GetCurrentHwProfileA;
%END

PROCEDURE QueryPerformanceCounter(VAR lpPerformanceCount : LARGE_INTEGER) : BOOL;

PROCEDURE QueryPerformanceFrequency(VAR lpFrequency : LARGE_INTEGER) : BOOL;

PROCEDURE Int64ShraMod32(Value : LONGLONG; ShiftCount : DWORD) : LONGLONG;

TYPE
    OSVERSIONINFOA = RECORD
        dwOSVersionInfoSize     : DWORD;
        dwMajorVersion          : DWORD;
        dwMinorVersion          : DWORD;
        dwBuildNumber           : DWORD;
        dwPlatformId            : DWORD;
        szCSDVersion            : ARRAY [ 0..128-1 ] OF ACHAR;
    END;
    POSVERSIONINFOA = POINTER TO OSVERSIONINFOA;
    LPOSVERSIONINFOA  = POSVERSIONINFOA;

    OSVERSIONINFOW = RECORD
        dwOSVersionInfoSize     : DWORD;
        dwMajorVersion          : DWORD;
        dwMinorVersion          : DWORD;
        dwBuildNumber           : DWORD;
        dwPlatformId            : DWORD;
        szCSDVersion            : ARRAY [ 0..128-1 ] OF UCHAR;
    END;
    POSVERSIONINFOW = POINTER TO OSVERSIONINFOW;
    LPOSVERSIONINFOW  = POSVERSIONINFOW;

%IF UNICODE %THEN
    OSVERSIONINFO = OSVERSIONINFOW;
    POSVERSIONINFO = POSVERSIONINFOW;
    LPOSVERSIONINFO = LPOSVERSIONINFOW;
%ELSE
    OSVERSIONINFO = OSVERSIONINFOA;
    POSVERSIONINFO = POSVERSIONINFOA;
    LPOSVERSIONINFO = LPOSVERSIONINFOA;
%END

    OSVERSIONINFOEXA = RECORD
    dwOSVersionInfoSize : DWORD;
    dwMajorVersion : DWORD;
    dwMinorVersion : DWORD;
    dwBuildNumber : DWORD;
    dwPlatformId : DWORD;
    szCSDVersion : ARRAY [0.. 128-1] OF ACHAR;(* Maintenance string for PSS usage*)
    wServicePackMajor : WORD;
    wServicePackMinor : WORD;
    wReserved : ARRAY [0..2-1] OF WORD;
    END;
    POSVERSIONINFOEXA = POINTER TO OSVERSIONINFOEXA;
    LPOSVERSIONINFOEXA= POSVERSIONINFOEXA;

    OSVERSIONINFOEXW = RECORD
    dwOSVersionInfoSize : DWORD;
    dwMajorVersion : DWORD;
    dwMinorVersion : DWORD;
    dwBuildNumber : DWORD;
    dwPlatformId : DWORD;
    szCSDVersion : ARRAY [0.. 128-1] OF WCHAR;(* Maintenance string for PSS usage*)
    wServicePackMajor : WORD;
    wServicePackMinor : WORD;
    wReserved : ARRAY [0..2-1] OF WORD;
    END;
    POSVERSIONINFOEXW = POINTER TO OSVERSIONINFOEXW;
    LPOSVERSIONINFOEXW= POSVERSIONINFOEXW;

    %IF UNICODE %THEN
    OSVERSIONINFOEX = OSVERSIONINFOEXW;
    POSVERSIONINFOEX = POSVERSIONINFOEXW;
    LPOSVERSIONINFOEX = LPOSVERSIONINFOEXW;
    %ELSE
    OSVERSIONINFOEX = OSVERSIONINFOEXA;
    POSVERSIONINFOEX = POSVERSIONINFOEXA;
    LPOSVERSIONINFOEX = LPOSVERSIONINFOEXA;
    %END

CONST
    VER_PLATFORM_WIN32s             = 0;
    VER_PLATFORM_WIN32_WINDOWS      = 1;
    VER_PLATFORM_WIN32_NT           = 2;

PROCEDURE GetVersionExA(
                        VAR lpVersionInformation : OSVERSIONINFOA
                        ) : BOOL;

PROCEDURE GetVersionExW(
                        VAR lpVersionInformation : OSVERSIONINFOW
                        ) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetVersionEx = GetVersionExW;
%ELSE
PROCEDURE GetVersionEx = GetVersionExA;
%END



CONST
    TC_NORMAL            = 0;
    TC_HARDERR           = 1;
    TC_GP_TRAP           = 2;
    TC_SIGNAL            = 3;


    AC_LINE_OFFLINE                 = 00h;
    AC_LINE_ONLINE                  = 01h;
    AC_LINE_BACKUP_POWER            = 02h;
    AC_LINE_UNKNOWN                 = 0FFh;

    BATTERY_FLAG_HIGH               = 01h;
    BATTERY_FLAG_LOW                = 02h;
    BATTERY_FLAG_CRITICAL           = 04h;
    BATTERY_FLAG_CHARGING           = 08h;
    BATTERY_FLAG_NO_BATTERY         = 80h;
    BATTERY_FLAG_UNKNOWN            = 0FFh;

    BATTERY_PERCENTAGE_UNKNOWN      = 0FFh;

    BATTERY_LIFE_UNKNOWN        = 0FFFFFFFFh;

TYPE
    SYSTEM_POWER_STATUS = RECORD
        ACLineStatus            : BYTE;
        BatteryFlag             : BYTE;
        BatteryLifePercent      : BYTE;
        Reserved1               : BYTE;
        BatteryLifeTime         : DWORD;
        BatteryFullLifeTime     : DWORD;
    END;
    LPSYSTEM_POWER_STATUS = POINTER TO SYSTEM_POWER_STATUS;

PROCEDURE GetSystemPowerStatus(
                    VAR lpSystemPowerStatus : SYSTEM_POWER_STATUS
                    ) : BOOL;

PROCEDURE SetSystemPowerState(
                    fSuspend : BOOL;
                    fForce : BOOL
                    );

(*      Win Certificate API and Structures                   *)

TYPE
    WIN_CERTIFICATE = RECORD
    dwLength            : DWORD;
    wRevision           : WORD;
    wCertificateType    : WORD;   (* WIN_CERT_TYPE_xxx*)
    bCertificate        : ARRAY [0..ANYSIZE_ARRAY-1] OF BYTE;
    END;
    LPWIN_CERTIFICATE = POINTER TO WIN_CERTIFICATE;

(*
 Currently, the only defined certificate revision is WIN_CERT_REVISION_1_0
*)
CONST
    WIN_CERT_REVISION_1_0           =(0100h);
    WIN_CERT_REVISION_2_0           =(0200h);

(* Possible certificate types are specified by the following values*)

    WIN_CERT_TYPE_X509               =(0001h);   (*bCertificate contains an X.509 Certificate*)
    WIN_CERT_TYPE_PKCS_SIGNED_DATA   =(0002h);   (* bCertificate contains a PKCS SignedData structur*)
    WIN_CERT_TYPE_RESERVED_1         =(0003h);   (* Reserved*)

PROCEDURE WinSubmitCertificate(lpCertificate : WIN_CERTIFICATE) : BOOL;

(*             Trust API and Structures                      *)

PROCEDURE WinVerifyTrust(hwnd : HWND;
                         ActionID : GUID;
                         ActionData : ARRAY OF LOC) : LONG;


PROCEDURE WinLoadTrustProvider(ActionID : GUID) : BOOL;

(*             Common Trust API Data Structures              *)


(* Data type commonly used in ActionData structures*)

TYPE
     WIN_TRUST_SUBJECT = LPVOID;

(*
 Two commonly used ActionData structures
*)

    WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT = RECORD
    hClientToken        : HANDLE;
    SubjectType         : REFGUID;
    Subject             : WIN_TRUST_SUBJECT;
    END;
    LPWIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT = POINTER TO WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT;


    WIN_TRUST_ACTDATA_SUBJECT_ONLY = RECORD
    SubjectType         : REFGUID;
    Subject             : WIN_TRUST_SUBJECT;
    END;
    LPWIN_TRUST_ACTDATA_SUBJECT_ONLY = POINTER TO WIN_TRUST_ACTDATA_SUBJECT_ONLY;


(*      SUBJECT FORM DEFINITIONS                                   *)

(* Currently defined Subject Type Identifiers.  All of the below   *)
(* use the WIN_TRUST_SUBJECT_FILE subject form, defined below.     *)

(* RawFile == 959dc450-8d9e-11cf-8736-00aa00a485eb *)
CONST
    WIN_TRUST_SUBJTYPE_RAW_FILE = GUID
            { 959dc450h,
              8d9eh,
              11cfh,
              {87h, 36h, 00h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(* PeImage == 43c9a1e0-8da0-11cf-8736-00aa00a485eb *)
    WIN_TRUST_SUBJTYPE_PE_IMAGE = GUID
            { 043c9a1e0h,
              08da0h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };


(* JavaClass = 08ad3990-8da1-11cf-8736-00aa00a485eb *)
    WIN_TRUST_SUBJTYPE_JAVA_CLASS = GUID
            { 008ad3990h,
              08da1h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(* Cabinet = d17c5374-a392-11cf-9df5-00aa00c184e0 *)
    WIN_TRUST_SUBJTYPE_CABINET = GUID
            { 0d17c5374h,
              0a392h,
              011cfh,
              { 09dh, 0f5h, 00h, 0aah, 00h, 0c1h, 084h, 0e0h }
            };

(*
 Associated Subject Data Structure:
*)
TYPE
    WIN_TRUST_SUBJECT_FILE = RECORD
    hFile       : HANDLE;
    lpPath      : LPCWSTR;
    END;
    LPWIN_TRUST_SUBJECT_FILE = POINTER TO WIN_TRUST_SUBJECT_FILE;


(* The following subject types use the                             *)
(* WIN_TRUST_SUBJECT_FILE_AND_DISPLAY subject type, defined        *)
(* below.                                                          *)

CONST
    WIN_TRUST_SUBJTYPE_RAW_FILEEX = GUID
            { 06f458110h,
              0c2f1h,
              011cfh,
              { 08ah, 069h, 00h, 0aah, 00h, 06ch, 037h, 06h }
            };

    WIN_TRUST_SUBJTYPE_PE_IMAGEEX = GUID
            { 06f458111h,
              0c2f1h,
              011cfh,
              { 08ah, 069h, 00h, 0aah, 00h, 06ch, 037h, 06h }
            };

    WIN_TRUST_SUBJTYPE_JAVA_CLASSEX = GUID
            { 06f458113h,
              0c2f1h,
              011cfh,
              { 08ah, 069h, 00h, 0aah, 00h, 06ch, 037h, 06h }
            };

    WIN_TRUST_SUBJTYPE_CABINETEX = GUID
            { 06f458114h,
              0c2f1h,
              011cfh,
              { 08ah, 069h, 00h, 0aah, 00h, 06ch, 037h, 06h }
            };

(*
 Associated Subject Data Structure:
*)
TYPE
    WIN_TRUST_SUBJECT_FILE_AND_DISPLAY  = RECORD
    hFile       : HANDLE;              (* handle to the open file if you got it*)
    lpPath      : LPCWSTR;             (* the path to open if you don't*)
    lpDisplayName : LPCWSTR;      (* (optional) display name to show to user*)
                                (*      in place of path*)
    END;
    LPWIN_TRUST_SUBJECT_FILE_AND_DISPLAY = POINTER TO WIN_TRUST_SUBJECT_FILE_AND_DISPLAY;


(*
 Other subject types:
*)

(* OleStorage == c257e740-8da0-11cf-8736-00aa00a485eb *)
CONST
    WIN_TRUST_SUBJTYPE_OLE_STORAGE = GUID
            { 0c257e740h,
              08da0h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };


(*                                                                 *)
(*      TRUST PROVIDER SPECIFIC DEFINITIONS                        *)
(*                                                                 *)
(*                                                                 *)
(*      Each trust provider will have the following                *)
(*      sections defined:                                          *)
(*                                                                 *)
(*      Actions - What actions are supported by the trust          *)
(*          provider.                                              *)
(*                                                                 *)
(*      SubjectForms - Subjects that may be evaluated by this      *)
(*          trust provider.                                        *)
(*                                                                 *)
(*                     and                                         *)
(*                                                                 *)
(*      Data structures to support the subject forms.              *)
(*                                                                 *)
(*                                                                 *)


(*                                                                 *)
(*             Software Publisher Trust Provider                   *)
(*                                                                 *)

(*
 Actions:
*)

(* TrustedPublisher == 66426730-8da1-11cf-8736-00aa00a485eb *)
CONST
    WIN_SPUB_ACTION_TRUSTED_PUBLISHER = GUID
            { 066426730h,
              08da1h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(* NtActivateImage == 8bc96b00-8da1-11cf-8736-00aa00a485eb *)
    WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE = GUID
            { 08bc96b00h,
              08da1h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(* PublishedSoftware == 64b9d180-8da2-11cf-8736-00aa00a485eb *)
    WIN_SPUB_ACTION_PUBLISHED_SOFTWARE = GUID
            { 064b9d180h,
              08da2h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(*
 Data Structures:
*)
(* WIN_SPUB_ACTION_TRUSTED_PUBLISHER:*)
(**)
(*      Uses WIN_SPUB_TRUSTED_PUBLISHER_DATA*)
(**)
(* WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE:*)
(**)
(*      Uses WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT*)
(**)
(* WIN_SPUB_ACTION_PUBLISHED_SOFTWARE:*)
(**)
(*      Uses WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT*)
(**)

TYPE
    WIN_SPUB_TRUSTED_PUBLISHER_DATA = RECORD
    hClientToken        : HANDLE;
    lpCertificate       : LPWIN_CERTIFICATE;
    END;
    LPWIN_SPUB_TRUSTED_PUBLISHER_DATA = POINTER TO WIN_SPUB_TRUSTED_PUBLISHER_DATA;

%IF WIN5 %AND VLM %THEN
(*
 Very Large Memory API Subset
*)

(*NT only*)
PROCEDURE VirtualAllocVlm(hProcess : HANDLE;
                          lpAddress : PVOID64;
                          ullSize : DWORDLONG;
                          flAllocationType : DWORD;
                          flProtect : DWORD) : PVOID64;

(*NT only*)
PROCEDURE VirtualFreeVlm(hProcess : HANDLE;
                         lpAddress : PVOID64;
                         ullSize : DWORDLONG;
                         dwFreeType : DWORD) : BOOL;

(*NT only*)
PROCEDURE VirtualProtectVlm(hProcess : HANDLE;
                            lpAddress : PVOID64;
                            ullSize : DWORDLONG;
                            flNewProtect : DWORD;
                            lpflOldProtect : PDWORD) : BOOL;

TYPE
    MEMORY_BASIC_INFORMATION_VLM = RECORD
    CASE : BOOLEAN OF
    FALSE: BaseAddress : PVOID64;|
    TRUE: BaseAddressAsUlongLong : ULONGLONG;
    END;
    CASE : BOOLEAN OF
    FALSE: AllocationBase : PVOID64;|
    TRUE: AllocationBaseAsUlongLong : ULONGLONG;
    END;
    RegionSize : ULONGLONG;
    AllocationProtect : DWORD;
    State : DWORD;
    Protect : DWORD;
    Type : DWORD;
    END;
    PMEMORY_BASIC_INFORMATION_VLM = POINTER TO MEMORY_BASIC_INFORMATION_VLM;

(*NT only*)
PROCEDURE VirtualQueryVlm(hProcess : HANDLE;
                          lpAddress : PVOID64;
                          VAR lpBuffer : MEMORY_BASIC_INFORMATION_VLM;
                          dwLength : DWORD) : DWORD;

TYPE
    MEMORYSTATUSVLM = RECORD
    dwLength            : DWORD;
    dwMemoryLoad        : DWORD;
    ullTotalPhys        : DWORDLONG;
    ullAvailPhys        : DWORDLONG;
    ullTotalPageFile    : DWORDLONG;
    ullAvailPageFile    : DWORDLONG;
    ullTotalVirtual     : DWORDLONG;
    ullAvailVirtual     : DWORDLONG;
    ullAvailExtendedVirtual : DWORDLONG;
    END;
    LPMEMORYSTATUSVLM = POINTER TO MEMORYSTATUSVLM;

(*NT only*)
PROCEDURE GlobalMemoryStatusVlm(VAR lpBuffer : MEMORYSTATUSVLM);

(*NT only*)
PROCEDURE ReadProcessMemoryVlm(hProcess : HANDLE;
                               lpBaseAddress : PVOID64;
                               lpBuffer : PVOID64;
                               nSize : DWORD;
                               VAR lpNumberOfBytesRead : DWORD) : BOOL;

(*NT only*)
PROCEDURE WriteProcessMemoryVlm(hProcess : HANDLE;
                                lpBaseAddress : PVOID64;
                                lpBuffer : PVOID64;
                                nSize : DWORD;
                                VAR lpNumberOfBytesWritten : DWORD) : BOOL;

(*NT only*)
PROCEDURE ReadFileVlm(hFile : HANDLE;
                      lpBuffer : PVOID64;
                      nNumberOfBytesToRead : DWORD;
                      lpReserved : LPDWORD;
                      lpOverlapped : LPOVERLAPPED) : BOOL;

(*NT only*)
PROCEDURE WriteFileVlm(hFile : HANDLE;
                       lpBuffer : PVOID64;
                       nNumberOfBytesToWrite : DWORD;
                       lpReserved : LPDWORD;
                       lpOverlapped : LPOVERLAPPED) : BOOL;

(*NT only*)
PROCEDURE CreateJobObjectA(lpJobAttributes : SECURITY_ATTRIBUTES;
                           lpName : ARRAY OF ACHAR) : HANDLE;

(*NT only*)
PROCEDURE CreateJobObjectW(lpJobAttributes : SECURITY_ATTRIBUTES;
                           lpName : ARRAY OF WCHAR) : HANDLE;

%IF UNICODE %THEN
(*NT only*)
PROCEDURE CreateJobObject = CreateJobObjectW;
%ELSE
(*NT only*)
PROCEDURE CreateJobObject = CreateJobObjectA;
%END

(*NT only*)
PROCEDURE OpenJobObjectA(dwDesiredAccess : DWORD;
                         bInheritHandle : BOOL;
                         lpName : ARRAY OF ACHAR) : HANDLE;

(*NT only*)
PROCEDURE OpenJobObjectW(dwDesiredAccess : DWORD;
                         bInheritHandle : BOOL;
                         lpName : ARRAY OF WCHAR) : HANDLE;

%IF UNICODE %THEN
(*NT only*)
PROCEDURE OpenJobObject = OpenJobObjectW;
%ELSE
(*NT only*)
PROCEDURE OpenJobObject = OpenJobObjectA;
%END

(*NT only*)
PROCEDURE AssignProcessToJobObject(hJob : HANDLE;
                                   hProcess : HANDLE) : BOOL;

(*NT only*)
PROCEDURE TerminateJobObject(hJob : HANDLE;
                             uExitCode : UINT) : BOOL;

CONST
    JOB_OBJECT_UILIMIT_NONE             = 00000000h;
    JOB_OBJECT_UILIMIT_HANDLES          = 00000001h;
    JOB_OBJECT_UILIMIT_READCLIPBOARD    = 00000002h;
    JOB_OBJECT_UILIMIT_WRITECLIPBOARD   = 00000004h;
    JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 00000008h;
    JOB_OBJECT_UILIMIT_DISPLAYSETTINGS  = 00000010h;
    JOB_OBJECT_UILIMIT_GLOBALATOMS      = 00000020h;
    JOB_OBJECT_UILIMIT_DESKTOP          = 00000040h;
    JOB_OBJECT_UILIMIT_EXITWINDOWS      = 00000080h;
    JOB_OBJECT_UILIMIT_ALL              = 000000FFh;
    JOB_OBJECT_UI_VALID_FLAGS           = 000000FFh;

    JOB_OBJECT_SECURITY_NO_ADMIN            = 00000001h;
    JOB_OBJECT_SECURITY_RESTRICTED_TOKEN    = 00000002h;
    JOB_OBJECT_SECURITY_ONLY_TOKEN          = 00000004h;
    JOB_OBJECT_SECURITY_FILTER_TOKENS       = 00000008h;

    JOB_OBJECT_SECURITY_VALID_FLAGS         = 0000000fh;

TYPE
    JOBOBJECTINFOCLASS = (
    SbJobObjectDummy,
    JobObjectBasicAccountingInformation,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    MaxJobObjectInfoClass) BIG;

(*NT only*)
PROCEDURE QueryInformationJobObject(hJob : HANDLE;
                    JobObjectInformationClass : JOBOBJECTINFOCLASS;
                    lpJobObjectInformation : LPVOID;
                    cbJobObjectInformationLength : DWORD;
                    VAR lpReturnLength : DWORD) : BOOL;

(*NT only*)
PROCEDURE SetInformationJobObject(hJob : HANDLE;
    JobObjectInformationClass : JOBOBJECTINFOCLASS;
    lpJobObjectInformation : LPVOID;
    cbJobObjectInformationLength : DWORD) : BOOL;

%END

(* Macros *)
PROCEDURE FreeModule["_FreeLibrary@4"](hLibModule : HINSTANCE) : BOOL;
PROCEDURE MakeProcInstance(a : FARPROC; b : HINSTANCE) : FARPROC;
PROCEDURE FreeProcInstance(a : FARPROC) : FARPROC;
PROCEDURE MAKEINTATOM(i : CARDINAL) : LPSTR;

(**v These procedures don't do anything v**)
PROCEDURE LimitEmsPages(dw : INTEGER);
PROCEDURE SetSwapAreaSize(dw : INTEGER);
PROCEDURE GlobalLRUNewest(h:HANDLE):HANDLE;
PROCEDURE GlobalLRUOldest(h:HANDLE):HANDLE;
PROCEDURE GetFreeSpace():DWORD;
PROCEDURE UnlockResource(h:HANDLE);
(******************************************)

PROCEDURE LockSegment["_GlobalFix@4"](u : UINT);
PROCEDURE UnlockSegment["_GlobalUnfix@4"](u : UINT);

PROCEDURE GetCurrentTime["_GetTickCount@0"]():UINT;
PROCEDURE GlobalDiscard(h:HANDLE):HANDLE;
PROCEDURE LocalDiscard(h:HANDLE):HANDLE;

PROCEDURE MAKELANGID(prim : WORD; sub : WORD) : WORD; MACRO;
BEGIN
    RETURN (prim BOR (sub SHL 10));
END MAKELANGID;

PROCEDURE PRIMARYLANGID(id : WORD) : WORD; MACRO;
BEGIN
    RETURN id BAND 03ffh;
END PRIMARYLANGID;

PROCEDURE SUBLANGID(id : WORD) : WORD; MACRO;
BEGIN
    RETURN id SHR 10;
END SUBLANGID;

PROCEDURE MAKELCID(lgid : WORD; srtid : WORD) : DWORD; MACRO;
BEGIN
    RETURN (ORD(srtid) SHL 16) BOR ORD(lgid);
END MAKELCID;

PROCEDURE LANGIDFROMLCID(id : DWORD) : WORD; MACRO;
BEGIN
    RETURN VAL(WORD, id BAND 0ffffh);
END LANGIDFROMLCID;

PROCEDURE SORTIDFROMLCID(id : DWORD) : WORD; MACRO;
BEGIN
    RETURN VAL(WORD, (id BAND NLS_VALID_LOCALE_MASK) SHR 16);
END SORTIDFROMLCID;

CONST
    LANG_SYSTEM_DEFAULT         =
        LANG_NEUTRAL BOR (SUBLANG_SYS_DEFAULT SHL 10);
    LANG_USER_DEFAULT           =
        LANG_NEUTRAL BOR (SUBLANG_DEFAULT SHL 10);

    LOCALE_SYSTEM_DEFAULT       =
        (SORT_DEFAULT SHL 16) BOR LANG_SYSTEM_DEFAULT;
    LOCALE_USER_DEFAULT         =
        (SORT_DEFAULT SHL 16) BOR LANG_USER_DEFAULT;

(************ Stony Brook Stuff *****************)

(*MACROS*)
PROCEDURE Int32x32To64( a, b : LONG) : LONGLONG [Invariant];

PROCEDURE Int64ShllMod32(a : DWORDLONG; b : DWORD) : DWORDLONG [Invariant];

PROCEDURE Int64ShrlMod32(a : DWORDLONG; b : DWORD) : DWORDLONG [Invariant];

PROCEDURE HEAP_MAKE_TAG_FLAGS( b, o : DWORD) : DWORD;

PROCEDURE HasOverlappedIoCompleted(lpOverlapped : OVERLAPPED) : BOOL; MACRO;
BEGIN
    RETURN lpOverlapped.Internal <> STATUS_PENDING;
END HasOverlappedIoCompleted;

END WIN32.

(*
* Copyright (c) 1985-2000, Microsoft Corp. All rights reserved.             *
*)
(* Conversion from Microsoft WIN32 SDK C source to Modula-2 source *)
(* Copyright (c) 1995-2000, Stony Brook Software. All rights reserved. *)

DEFINITION MODULE WINGDI;

FROM SYSTEM IMPORT
    CAST, LOC;

FROM WIN32 IMPORT
    HANDLE, WFLOAT, LONG, WORD, DWORD, LPVOID, HGDIOBJ, HMETAFILE, RECTL,
    SIZEL, WCHAR, UINT, COLORREF, POINT, RECT, PSTR, LPCSTR, LPCWSTR, BYTE,
    LPARAM, HPALETTE, BOOL, HDC, HRGN, HBITMAP, HBRUSH, HGLOBAL, HFONT, HPEN,
    HWND, WINT, LPSTR, HMODULE, WSIZE, HENHMETAFILE, PFLOAT, SHORT, USHORT,
    POINTL, POINTS, HGLRC, MAX_PATH, PUINT, PINT, LPWSTR, HCOLORSPACE,
    PVOID, ULONG;

<*/CALLS:WIN32SYSTEM*>
<*/NOHIGH*>
<*/ALIGN:8/NOPACK*>

CONST
    R2_BLACK             = 1;
    R2_NOTMERGEPEN       = 2;
    R2_MASKNOTPEN        = 3;
    R2_NOTCOPYPEN        = 4;
    R2_MASKPENNOT        = 5;
    R2_NOT               = 6;
    R2_XORPEN            = 7;
    R2_NOTMASKPEN        = 8;
    R2_MASKPEN           = 9;
    R2_NOTXORPEN         = 10;
    R2_NOP               = 11;
    R2_MERGENOTPEN       = 12;
    R2_COPYPEN           = 13;
    R2_MERGEPENNOT       = 14;
    R2_MERGEPEN          = 15;
    R2_WHITE             = 16;
    R2_LAST              = 16;
    SRCCOPY              = 000CC0020h;
    SRCPAINT             = 000EE0086h;
    SRCAND               = 0008800C6h;
    SRCINVERT            = 000660046h;
    SRCERASE             = 000440328h;
    NOTSRCCOPY           = 000330008h;
    NOTSRCERASE          = 0001100A6h;
    MERGECOPY            = 000C000CAh;
    MERGEPAINT           = 000BB0226h;
    PATCOPY              = 000F00021h;
    PATPAINT             = 000FB0A09h;
    PATINVERT            = 0005A0049h;
    DSTINVERT            = 000550009h;
    BLACKNESS            = 000000042h;
    WHITENESS            = 000FF0062h;
    GDI_ERROR    = 0FFFFFFFFH;
    HGDI_ERROR           = CAST(HANDLE,0FFFFFFFFH);
    ERROR                = 0;
    NULLREGION           = 1;
    SIMPLEREGION         = 2;
    COMPLEXREGION        = 3;
    RGN_ERROR            = ERROR;

    RGN_AND              = 1;
    RGN_OR               = 2;
    RGN_XOR              = 3;
    RGN_DIFF             = 4;
    RGN_COPY             = 5;
    RGN_MIN              = RGN_AND;
    RGN_MAX              = RGN_COPY;

    BLACKONWHITE         = 1;
    WHITEONBLACK         = 2;
    COLORONCOLOR         = 3;
    HALFTONE             = 4;
    MAXSTRETCHBLTMODE    = 4;
    STRETCH_ANDSCANS     = BLACKONWHITE;
    STRETCH_ORSCANS      = WHITEONBLACK;
    STRETCH_DELETESCANS  = COLORONCOLOR;
    STRETCH_HALFTONE     = HALFTONE;


    ALTERNATE            = 1;
    WINDING              = 2;
    POLYFILL_LAST        = 2;
    TA_NOUPDATECP        = 0;
    TA_UPDATECP          = 1;
    TA_LEFT              = 0;
    TA_RIGHT             = 2;
    TA_CENTER            = 6;
    TA_TOP               = 0;
    TA_BOTTOM            = 8;
    TA_BASELINE          = 24;

%IF WIN4 %THEN
    TA_RTLREADING        = 256;
    TA_MASK              = (TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING);
%ELSE
    TA_MASK              = ( TA_BASELINE + TA_CENTER + TA_UPDATECP );
%END
    VTA_BASELINE = TA_BASELINE;
    VTA_LEFT     = TA_BOTTOM;
    VTA_RIGHT    = TA_TOP;
    VTA_CENTER   = TA_CENTER;
    VTA_BOTTOM   = TA_RIGHT;
    VTA_TOP      = TA_LEFT;


    ETO_GRAYED           = 1;
    ETO_OPAQUE           = 2;
    ETO_CLIPPED          = 4;

    ETO_GLYPH_INDEX      = 0010h;
    ETO_RTLREADING       = 0080h;
    ETO_NUMERICSLOCAL    = 00400h;
    ETO_NUMERICSLATIN    = 00800h;
    ETO_IGNORELANGUAGE   = 01000h;
%IF WIN5 %THEN
    ETO_PDY              = 02000h;(*NT only*)
%END

    ASPECT_FILTERING     = 00001h;
    DCB_RESET            = 00001h;
    DCB_ACCUMULATE       = 00002h;
    DCB_DIRTY            = DCB_ACCUMULATE;

    DCB_SET              = DCB_RESET BOR DCB_ACCUMULATE;
    DCB_ENABLE           = 00004h;
    DCB_DISABLE          = 00008h;

    META_SETBKCOLOR      = 00201h;
    META_SETBKMODE       = 00102h;
    META_SETMAPMODE      = 00103h;
    META_SETROP2         = 00104h;
    META_SETRELABS       = 00105h;
    META_SETPOLYFILLMODE = 00106h;
    META_SETSTRETCHBLTMODE= 00107h;
    META_SETTEXTCHAREXTRA= 00108h;
    META_SETTEXTCOLOR    = 00209h;
    META_SETTEXTJUSTIFICATION= 0020Ah;
    META_SETWINDOWORG    = 0020Bh;
    META_SETWINDOWEXT    = 0020Ch;
    META_SETVIEWPORTORG  = 0020Dh;
    META_SETVIEWPORTEXT  = 0020Eh;
    META_OFFSETWINDOWORG = 0020Fh;
    META_SCALEWINDOWEXT  = 00410h;
    META_OFFSETVIEWPORTORG= 00211h;
    META_SCALEVIEWPORTEXT= 00412h;
    META_LINETO          = 00213h;
    META_MOVETO          = 00214h;
    META_EXCLUDECLIPRECT = 00415h;
    META_INTERSECTCLIPRECT= 00416h;
    META_ARC             = 00817h;
    META_ELLIPSE         = 00418h;
    META_FLOODFILL       = 00419h;
    META_PIE             = 0081Ah;
    META_RECTANGLE       = 0041Bh;
    META_ROUNDRECT       = 0061Ch;
    META_PATBLT          = 0061Dh;
    META_SAVEDC          = 0001Eh;
    META_SETPIXEL        = 0041Fh;
    META_OFFSETCLIPRGN   = 00220h;
    META_TEXTOUT         = 00521h;
    META_BITBLT          = 00922h;
    META_STRETCHBLT      = 00B23h;
    META_POLYGON         = 00324h;
    META_POLYLINE        = 00325h;
    META_ESCAPE          = 00626h;
    META_RESTOREDC       = 00127h;
    META_FILLREGION      = 00228h;
    META_FRAMEREGION     = 00429h;
    META_INVERTREGION    = 0012Ah;
    META_PAINTREGION     = 0012Bh;
    META_SELECTCLIPREGION= 0012Ch;
    META_SELECTOBJECT    = 0012Dh;
    META_SETTEXTALIGN    = 0012Eh;
    META_CHORD           = 00830h;
    META_SETMAPPERFLAGS  = 00231h;
    META_EXTTEXTOUT      = 00a32h;
    META_SETDIBTODEV     = 00d33h;
    META_SELECTPALETTE   = 00234h;
    META_REALIZEPALETTE  = 00035h;
    META_ANIMATEPALETTE  = 00436h;
    META_SETPALENTRIES   = 00037h;
    META_POLYPOLYGON     = 00538h;
    META_RESIZEPALETTE   = 00139h;
    META_DIBBITBLT       = 00940h;
    META_DIBSTRETCHBLT   = 00b41h;
    META_DIBCREATEPATTERNBRUSH= 00142h;
    META_STRETCHDIB      = 00f43h;
    META_EXTFLOODFILL    = 00548h;
    META_DELETEOBJECT    = 001f0h;
    META_CREATEPALETTE   = 000f7h;
    META_CREATEPATTERNBRUSH= 001F9h;
    META_CREATEPENINDIRECT= 002FAh;
    META_CREATEFONTINDIRECT= 002FBh;
    META_CREATEBRUSHINDIRECT= 002FCh;
    META_CREATEREGION    = 006FFh;

TYPE
    DRAWPATRECT = RECORD
        ptPosition      : POINT;
        ptSize          : POINT;
        wStyle          : WORD;
        wPattern        : WORD;
        END;
    PDRAWPATRECT = POINTER TO DRAWPATRECT;

CONST
    NEWFRAME             = 1;
    ABORTDOC             = 2;
    NEXTBAND             = 3;
    SETCOLORTABLE        = 4;
    GETCOLORTABLE        = 5;
    FLUSHOUTPUT          = 6;
    DRAFTMODE            = 7;
    QUERYESCSUPPORT      = 8;
    SETABORTPROC         = 9;
    STARTDOC             = 10;
    ENDDOC               = 11;
    GETPHYSPAGESIZE      = 12;
    GETPRINTINGOFFSET    = 13;
    GETSCALINGFACTOR     = 14;
    MFCOMMENT            = 15;
    GETPENWIDTH          = 16;
    SETCOPYCOUNT         = 17;
    SELECTPAPERSOURCE    = 18;
    DEVICEDATA           = 19;
    PASSTHROUGH          = 19;
    GETTECHNOLGY         = 20;
    GETTECHNOLOGY        = 20;
    SETLINECAP           = 21;
    SETLINEJOIN          = 22;
    SETMITERLIMIT        = 23;
    BANDINFO             = 24;
    DRAWPATTERNRECT      = 25;
    GETVECTORPENSIZE     = 26;
    GETVECTORBRUSHSIZE   = 27;
    ENABLEDUPLEX         = 28;
    GETSETPAPERBINS      = 29;
    GETSETPRINTORIENT    = 30;
    ENUMPAPERBINS        = 31;
    SETDIBSCALING        = 32;
    EPSPRINTING          = 33;
    ENUMPAPERMETRICS     = 34;
    GETSETPAPERMETRICS   = 35;
    POSTSCRIPT_DATA      = 37;
    POSTSCRIPT_IGNORE    = 38;
    MOUSETRAILS          = 39;
    GETDEVICEUNITS       = 42;
    GETEXTENDEDTEXTMETRICS= 256;
    GETEXTENTTABLE       = 257;
    GETPAIRKERNTABLE     = 258;
    GETTRACKKERNTABLE    = 259;
    EXTTEXTOUT           = 512;
    GETFACENAME          = 513;
    DOWNLOADFACE         = 514;
    ENABLERELATIVEWIDTHS = 768;
    ENABLEPAIRKERNING    = 769;
    SETKERNTRACK         = 770;
    SETALLJUSTVALUES     = 771;
    SETCHARSET           = 772;
    STRETCHBLT           = 2048;
    GETSETSCREENPARAMS   = 3072;
    QUERYDIBSUPPORT      = 3073;

    BEGIN_PATH           = 4096;
    CLIP_TO_PATH         = 4097;
    END_PATH             = 4098;
    EXT_DEVICE_CAPS      = 4099;
    RESTORE_CTM          = 4100;
    SAVE_CTM             = 4101;
    SET_ARC_DIRECTION    = 4102;
    SET_BACKGROUND_COLOR = 4103;
    SET_POLY_MODE        = 4104;
    SET_SCREEN_ANGLE     = 4105;
    SET_SPREAD           = 4106;
    TRANSFORM_CTM        = 4107;
    SET_CLIP_BOX         = 4108;
    SET_BOUNDS           = 4109;
    SET_MIRROR_MODE      = 4110;
    OPENCHANNEL          = 4110;
    DOWNLOADHEADER       = 4111;
    CLOSECHANNEL         = 4112;
    POSTSCRIPT_PASSTHROUGH= 4115;
    ENCAPSULATED_POSTSCRIPT= 4116;

    POSTSCRIPT_IDENTIFY     = 4117;   (* new escape for NT5 pscript driver *)
    POSTSCRIPT_INJECTION    = 4118;   (* new escape for NT5 pscript driver *)

(*
 * Parameters for POSTSCRIPT_IDENTIFY escape
 *)

    PSIDENT_GDICENTRIC    =0;
    PSIDENT_PSCENTRIC     =1;

(*
 * Header structure for the input buffer to POSTSCRIPT_INJECTION escape
 *)

TYPE
    PSINJECTDATA = RECORD
    DataBytes   : DWORD;          (* number of raw data bytes *)
    InjectionPoint : DWORD;     (* injection point *)
    Flags : DWORD;              (* flags *)
    Reserved : DWORD;           (* reserved field - must be 0 *)

    (* Followed by raw data to be injected *)
    END;
    PPSINJECTDATA = POINTER TO PSINJECTDATA;

(*
 * Constants for PSINJECTDATA.Flags field
 *)
CONST
      PSINJECT_APPEND       =0;
      PSINJECT_REPLACE      =1;

(*
 * Constants for PSINJECTDATA.InjectionPoint field
 *)

(*
 * The data injected at these points coexist with the output emitted
 * by the driver for the same points.
 *)

    PSINJECT_BEGINSTREAM     =0;
    PSINJECT_PSADOBE         =1;
    PSINJECT_COMMENTS        =2;
    PSINJECT_BEGINDEFAULTS   =3;
    PSINJECT_ENDDEFAULTS     =4;
    PSINJECT_BEGINPROLOG     =5;
    PSINJECT_ENDPROLOG       =6;
    PSINJECT_BEGINSETUP      =7;
    PSINJECT_ENDSETUP        =8;
    PSINJECT_ENDPAGECOMMENTS =9;
    PSINJECT_BEGINPAGESETUP =10;
    PSINJECT_ENDPAGESETUP   =11;
    PSINJECT_SHOWPAGE       =12;
    PSINJECT_PAGETRAILER    =13;
    PSINJECT_TRAILER        =14;
    PSINJECT_EOF            =15;
    PSINJECT_ENDSTREAM      =16;
    PSINJECT_VMSAVE         =17;
    PSINJECT_VMRESTORE      =18;

(*
 * The data injected at these points are appended to the output
 * emitted by the driver for the same points. It will go into
 * the document trailer section. They must be in the form of:
 *     %%+ resource-type resource-names
 *)

    PSINJECT_DOCNEEDEDRES   =19;
    PSINJECT_DOCSUPPLIEDRES =20;

(*
 * The data injected at these points replaces the output emitted
 * by the driver for the same points.
 *)

    PSINJECT_PAGES          =21;
    PSINJECT_PAGEORDER      =22;
    PSINJECT_ORIENTATION    =23;
    PSINJECT_BOUNDINGBOX    =24;
    PSINJECT_PAGENUMBER     =25;
    PSINJECT_PAGEBBOX       =26;

    PSINJECT_MAX            =27;


    QDI_SETDIBITS                = 1;
    QDI_GETDIBITS                = 2;
    QDI_DIBTOSCREEN              = 4;
    QDI_STRETCHDIB               = 8;

    SP_NOTREPORTED       = 04000h;
    SP_ERROR             = ( - 1 ) ;
    SP_APPABORT          = ( - 2 ) ;
    SP_USERABORT         = ( - 3 ) ;
    SP_OUTOFDISK         = ( - 4 ) ;
    SP_OUTOFMEMORY       = ( - 5 ) ;
    PR_JOBSTATUS         = 00000h;
    OBJ_PEN              = 1;
    OBJ_BRUSH            = 2;
    OBJ_DC               = 3;
    OBJ_METADC           = 4;
    OBJ_PAL              = 5;
    OBJ_FONT             = 6;
    OBJ_BITMAP           = 7;
    OBJ_REGION           = 8;
    OBJ_METAFILE         = 9;
    OBJ_MEMDC            = 10;
    OBJ_EXTPEN           = 11;
    OBJ_ENHMETADC        = 12;
    OBJ_ENHMETAFILE      = 13;

    MWT_IDENTITY         = 1;
    MWT_LEFTMULTIPLY     = 2;
    MWT_RIGHTMULTIPLY    = 3;
    MWT_MIN              = MWT_IDENTITY;
    MWT_MAX              = MWT_RIGHTMULTIPLY;


TYPE
    XFORM = RECORD
          eM11           : WFLOAT;
          eM12           : WFLOAT;
          eM21           : WFLOAT;
          eM22           : WFLOAT;
          eDx            : WFLOAT;
          eDy            : WFLOAT;
    END;
    PXFORM               = POINTER TO XFORM;
    LPXFORM              = PXFORM;

    BITMAP = RECORD
          bmType         : LONG;
          bmWidth        : LONG;
          bmHeight       : LONG;
          bmWidthBytes   : LONG;
          bmPlanes       : WORD;
          bmBitsPixel    : WORD;
          bmBits         : LPVOID;
    END;
    PBITMAP              = POINTER TO BITMAP;
    LPBITMAP             = PBITMAP;

    RGBTRIPLE = RECORD
          rgbtBlue       : BYTE;
          rgbtGreen      : BYTE;
          rgbtRed        : BYTE;
    END;

    RGBQUAD = RECORD
          rgbBlue        : BYTE;
          rgbGreen       : BYTE;
          rgbRed         : BYTE;
          rgbReserved    : BYTE;
    END;
    LPRGBQUAD            = POINTER TO RGBQUAD;


    LCSCSTYPE           = LONG;
    LCSGAMUTMATCH       = LONG;

CONST
(* Image Color Matching color definitions *)

    CS_ENABLE                       =000000001h;
    CS_DISABLE                      =000000002h;
    CS_DELETE_TRANSFORM             =000000003h;

(* Logcolorspace signature *)

    LCS_SIGNATURE           ="PSOC";

(* Logcolorspace lcsType values *)

    LCS_sRGB                ="sRGB";
    LCS_WINDOWS_COLOR_SPACE ="Win ";  (* Windows default color space*)

    LCS_CALIBRATED_RGB                  = 0;
    LCS_DEVICE_RGB                      = 1h;
    LCS_DEVICE_CMYK                     = 2h;

    LCS_GM_BUSINESS                     = 1h;
    LCS_GM_GRAPHICS                     = 2h;
    LCS_GM_IMAGES                       = 4h;
    LCS_GM_ABS_COLORIMETRIC         =000000008h;

    CM_OUT_OF_GAMUT             = 255;
    CM_IN_GAMUT                 = 0;

    ICM_ADDPROFILE                  =1;
    ICM_DELETEPROFILE               =2;
    ICM_QUERYPROFILE                =3;
    ICM_SETDEFAULTPROFILE           =4;
    ICM_REGISTERICMATCHER           =5;
    ICM_UNREGISTERICMATCHER         =6;
    ICM_QUERYMATCH                  =7;

TYPE
    FXPT16DOT16         = LONG;
    LPFXPT16DOT16       = POINTER TO FXPT16DOT16;
    FXPT2DOT30          = LONG;
    LPFXPT2DOT30        = POINTER TO FXPT2DOT30;

    CIEXYZ = RECORD
        ciexyzX         : FXPT2DOT30;
        ciexyzY         : FXPT2DOT30;
        ciexyzZ         : FXPT2DOT30;
    END;
    LPCIEXYZ    = POINTER TO CIEXYZ;

    CIEXYZTRIPLE = RECORD
        ciexyzRed       : CIEXYZ;
        ciexyzGreen     : CIEXYZ;
        ciexyzBlue      : CIEXYZ;
    END;
    LPCIEXYZTRIPLE      = POINTER TO CIEXYZTRIPLE;

    LOGCOLORSPACEA = RECORD
        lcsSignature    : DWORD;
        lcsVersion      : DWORD;
        lcsSize         : DWORD;
        lcsCSType       : LCSCSTYPE;
        lcsIntent       : LCSGAMUTMATCH;
        lcsEndpoints    : CIEXYZTRIPLE;
        lcsGammaRed     : DWORD;
        lcsGammaGreen   : DWORD;
        lcsGammaBlue    : DWORD;
        lcsFilename     : ARRAY [0..MAX_PATH-1] OF ACHAR;
    END;
    LPLOGCOLORSPACEA    = POINTER TO LOGCOLORSPACEA;

    LOGCOLORSPACEW = RECORD
        lcsSignature    : DWORD;
        lcsVersion      : DWORD;
        lcsSize         : DWORD;
        lcsCSType       : LCSCSTYPE;
        lcsIntent       : LCSGAMUTMATCH;
        lcsEndpoints    : CIEXYZTRIPLE;
        lcsGammaRed     : DWORD;
        lcsGammaGreen   : DWORD;
        lcsGammaBlue    : DWORD;
        lcsFilename     : ARRAY [0..MAX_PATH-1] OF UCHAR;
    END;
    LPLOGCOLORSPACEW    = POINTER TO LOGCOLORSPACEW;
%IF UNICODE %THEN
    LOGCOLORSPACE       = LOGCOLORSPACEW;
%ELSE
    LOGCOLORSPACE       = LOGCOLORSPACEA;
%END
    LPLOGCOLORSPACE     = POINTER TO LOGCOLORSPACE;


    BITMAPCOREHEADER = RECORD
          bcSize         : DWORD;
          bcWidth        : WORD;
          bcHeight       : WORD;
          bcPlanes       : WORD;
          bcBitCount     : WORD;
    END;
    PBITMAPCOREHEADER    = POINTER TO BITMAPCOREHEADER;
    LPBITMAPCOREHEADER   = PBITMAPCOREHEADER;

    BITMAPINFOHEADER = RECORD
          biSize         : DWORD;
          biWidth        : LONG;
          biHeight       : LONG;
          biPlanes       : WORD;
          biBitCount     : WORD;
          biCompression  : DWORD;
          biSizeImage    : DWORD;
          biXPelsPerMeter: LONG;
          biYPelsPerMeter: LONG;
          biClrUsed      : DWORD;
          biClrImportant : DWORD;
    END;
    PBITMAPINFOHEADER    = POINTER TO BITMAPINFOHEADER;
    LPBITMAPINFOHEADER   = PBITMAPINFOHEADER;


     BITMAPV4HEADER = RECORD
        bV4Size         : DWORD;
        bV4Width        : LONG;
        bV4Height       : LONG;
        bV4Planes       : WORD;
        bV4BitCount     : WORD;
        bV4V4Compression: DWORD;
        bV4SizeImage    : DWORD;
        bV4XPelsPerMeter: LONG;
        bV4YPelsPerMeter: LONG;
        bV4ClrUsed      : DWORD;
        bV4ClrImportant : DWORD;
        bV4RedMask      : DWORD;
        bV4GreenMask    : DWORD;
        bV4BlueMask     : DWORD;
        bV4AlphaMask    : DWORD;
        bV4CSType       : DWORD;
        bV4Endpoints    : CIEXYZTRIPLE;
        bV4GammaRed     : DWORD;
        bV4GammaGreen   : DWORD;
        bV4GammaBlue    : DWORD;
    END;
    PBITMAPV4HEADER     = POINTER TO BITMAPV4HEADER;
    LPBITMAPV4HEADER    = PBITMAPV4HEADER;

    BITMAPV5HEADER = RECORD
        bV5Size         : DWORD;
        bV5Width        : LONG;
        bV5Height       : LONG;
        bV5Planes       : WORD;
        bV5BitCount     : WORD;
        bV5Compression  : DWORD;
        bV5SizeImage    : DWORD;
        bV5XPelsPerMeter : LONG;
        bV5YPelsPerMeter : LONG;
        bV5ClrUsed      : DWORD;
        bV5ClrImportant : DWORD;
        bV5RedMask      : DWORD;
        bV5GreenMask : DWORD;
        bV5BlueMask : DWORD;
        bV5AlphaMask : DWORD;
        bV5CSType : DWORD;
        bV5Endpoints : CIEXYZTRIPLE;
        bV5GammaRed : DWORD;
        bV5GammaGreen : DWORD;
        bV5GammaBlue : DWORD;
        bV5Intent : DWORD;
        bV5ProfileData : DWORD;
        bV5ProfileSize : DWORD;
        bV5Reserved : DWORD;
        END;
    PBITMAPV5HEADER = POINTER TO BITMAPV5HEADER;
    LPBITMAPV5HEADER = PBITMAPV5HEADER;

CONST
    PROFILE_LINKED          = "LINK";
    PROFILE_EMBEDDED        = "MBED";

CONST
    BI_RGB               = 0;
    BI_RLE8              = 1;
    BI_RLE4              = 2;
    BI_BITFIELDS         = 3;

TYPE
    BITMAPINFO = RECORD
          bmiHeader      : BITMAPINFOHEADER;
          bmiColors      : ARRAY [0..1 - 1] OF RGBQUAD;
    END;
    PBITMAPINFO          = POINTER TO BITMAPINFO;
    LPBITMAPINFO         = PBITMAPINFO;

    BITMAPCOREINFO = RECORD
          bmciHeader     : BITMAPCOREHEADER;
          bmciColors     : ARRAY [0..1 - 1] OF RGBTRIPLE;
    END;
    PBITMAPCOREINFO      = POINTER TO BITMAPCOREINFO;
    LPBITMAPCOREINFO     = PBITMAPCOREINFO;

    <*/PUSH/PACK/NOWARN:A*>
    BITMAPFILEHEADER = RECORD
          bfType         : WORD;
          bfSize         : DWORD;
          bfReserved1    : WORD;
          bfReserved2    : WORD;
          bfOffBits      : DWORD;
    END;
  <*/POP*>
    PBITMAPFILEHEADER    = POINTER TO BITMAPFILEHEADER;
    LPBITMAPFILEHEADER   = PBITMAPFILEHEADER;


    FONTSIGNATURE = RECORD
        fsUsb : ARRAY [0..4-1] OF DWORD;
        fsCsb : ARRAY [0..2-1] OF DWORD;
    END;
    PFONTSIGNATURE      = POINTER TO FONTSIGNATURE;
    LPFONTSIGNATURE     = PFONTSIGNATURE;

    CHARSETINFO = RECORD
        ciCharset       : UINT;
        ciACP   : UINT;
        fs              : FONTSIGNATURE;
    END;
    PCHARSETINFO        = POINTER TO CHARSETINFO;
    LPCHARSETINFO       = PCHARSETINFO;

CONST
    TCI_SRCCHARSET      = 1;
    TCI_SRCCODEPAGE     = 2;
    TCI_SRCFONTSIG      = 3;

TYPE
    LOCALESIGNATURE = RECORD
        lsUsb           : ARRAY [0..4-1] OF DWORD;
        lsCsbDefault    : ARRAY [0..2-1] OF DWORD;
        lsCsbSupported  : ARRAY [0..2-1] OF DWORD;
    END;
    PLOCALESIGNATURE    = POINTER TO LOCALESIGNATURE;
    LPLOCALESIGNATURE   = PLOCALESIGNATURE;


    HANDLETABLE = RECORD
          objectHandle   : ARRAY [0..1 - 1] OF HGDIOBJ;
    END;
    PHANDLETABLE         = POINTER TO HANDLETABLE;
    LPHANDLETABLE        = PHANDLETABLE;

    METARECORD = RECORD
          rdSize         : DWORD;
          rdFunction     : WORD;
          rdParm         : ARRAY [0..1 - 1] OF WORD;
    END;
    PMETARECORD          = POINTER TO METARECORD;
    LPMETARECORD         = PMETARECORD;

    METAFILEPICT = RECORD
          mm             : LONG;
          xExt           : LONG;
          yExt           : LONG;
          hMF            : HMETAFILE;
    END;
    LPMETAFILEPICT       = POINTER TO METAFILEPICT;

    <*/PUSH/PACK/NOWARN:A*>
    METAHEADER = RECORD
          mtType         : WORD;
          mtHeaderSize   : WORD;
          mtVersion      : WORD;
          mtSize         : DWORD;
          mtNoObjects    : WORD;
          mtMaxRecord    : DWORD;
          mtNoParameters : WORD;
    END;
  <*/POP*>

    PMETAHEADER          = POINTER TO METAHEADER;
    LPMETAHEADER         = PMETAHEADER;

    ENHMETARECORD = RECORD
          iType          : DWORD;
          nSize          : DWORD;
          dParm          : ARRAY [0..1 - 1] OF DWORD;
    END;
    PENHMETARECORD       = POINTER TO ENHMETARECORD;
    LPENHMETARECORD      = PENHMETARECORD;

    ENHMETAHEADER = RECORD
          iType          : DWORD;
          nSize          : DWORD;
          rclBounds      : RECTL;
          rclFrame       : RECTL;
          dSignature     : DWORD;
          nVersion       : DWORD;
          nBytes         : DWORD;
          nRecords       : DWORD;
          nHandles       : WORD;
          sReserved      : WORD;
          nDescription   : DWORD;
          offDescription : DWORD;
          nPalEntries    : DWORD;
          szlDevice      : SIZEL;
          szlMillimeters : SIZEL;
          cbPixelFormat : DWORD;      (* Size of PIXELFORMATDESCRIPTOR information*)
                                     (* This is 0 if no pixel format is set*)
          offPixelFormat : DWORD;     (* Offset to PIXELFORMATDESCRIPTOR*)
                                     (* This is 0 if no pixel format is set*)
          bOpenGL : DWORD;            (* TRUE if OpenGL commands are present in*)
    END;
    PENHMETAHEADER       = POINTER TO ENHMETAHEADER;
    LPENHMETAHEADER      = PENHMETAHEADER;

CONST
    TMPF_FIXED_PITCH     = 001h;
    TMPF_VECTOR          = 002h;
    TMPF_DEVICE          = 008h;
    TMPF_TRUETYPE        = 004h;

TYPE
%IF UNICODE %THEN
    BCHAR       = UCHAR;
%ELSE
    BCHAR       = ACHAR;
%END

    TEXTMETRICA = RECORD
          tmHeight       : LONG;
          tmAscent       : LONG;
          tmDescent      : LONG;
          tmInternalLeading: LONG;
          tmExternalLeading: LONG;
          tmAveCharWidth : LONG;
          tmMaxCharWidth : LONG;
          tmWeight       : LONG;
          tmOverhang     : LONG;
          tmDigitizedAspectX: LONG;
          tmDigitizedAspectY: LONG;
          tmFirstChar    : BYTE;
          tmLastChar     : BYTE;
          tmDefaultChar  : BYTE;
          tmBreakChar    : BYTE;
          tmItalic       : BYTEBOOL;
          tmUnderlined   : BYTEBOOL;
          tmStruckOut    : BYTEBOOL;
          tmPitchAndFamily: BYTE;
          tmCharSet      : BYTE;
    END;
    PTEXTMETRICA         = POINTER TO TEXTMETRICA;
    LPTEXTMETRICA        = PTEXTMETRICA;

    TEXTMETRICW = RECORD
          tmHeight       : LONG;
          tmAscent       : LONG;
          tmDescent      : LONG;
          tmInternalLeading: LONG;
          tmExternalLeading: LONG;
          tmAveCharWidth : LONG;
          tmMaxCharWidth : LONG;
          tmWeight       : LONG;
          tmOverhang     : LONG;
          tmDigitizedAspectX: LONG;
          tmDigitizedAspectY: LONG;
          tmFirstChar    : WCHAR;
          tmLastChar     : WCHAR;
          tmDefaultChar  : WCHAR;
          tmBreakChar    : WCHAR;
          tmItalic       : BYTEBOOL;
          tmUnderlined   : BYTEBOOL;
          tmStruckOut    : BYTEBOOL;
          tmPitchAndFamily: BYTE;
          tmCharSet      : BYTE;
    END;
    PTEXTMETRICW         = POINTER TO TEXTMETRICW;
    LPTEXTMETRICW        = PTEXTMETRICW;

%IF UNICODE %THEN
    TEXTMETRIC           = TEXTMETRICW;
%ELSE
    TEXTMETRIC           = TEXTMETRICA;
%END
    PTEXTMETRIC          = POINTER TO TEXTMETRIC;
    LPTEXTMETRIC         = PTEXTMETRIC;

CONST
    NTM_REGULAR          = 000000040h;
    NTM_BOLD             = 000000020h;
    NTM_ITALIC           = 000000001h;

    NTM_NONNEGATIVE_AC  =000010000h;
    NTM_OPENTYPE        =000020000h;
    NTM_MULTIPLEMASTER  =000040000h;
    NTM_MM_INSTANCE     =000080000h;
    NTM_TYPE1           =000100000h;
    NTM_DSIG            =000200000h;

TYPE
    NEWTEXTMETRICA = RECORD
          tmHeight       : LONG;
          tmAscent       : LONG;
          tmDescent      : LONG;
          tmInternalLeading: LONG;
          tmExternalLeading: LONG;
          tmAveCharWidth : LONG;
          tmMaxCharWidth : LONG;
          tmWeight       : LONG;
          tmOverhang     : LONG;
          tmDigitizedAspectX: LONG;
          tmDigitizedAspectY: LONG;
          tmFirstChar    : BYTE;
          tmLastChar     : BYTE;
          tmDefaultChar  : BYTE;
          tmBreakChar    : BYTE;
          tmItalic       : BYTEBOOL;
          tmUnderlined   : BYTEBOOL;
          tmStruckOut    : BYTEBOOL;
          tmPitchAndFamily: BYTE;
          tmCharSet      : BYTE;
          ntmFlags       : DWORD;
          ntmSizeEM      : UINT;
          ntmCellHeight  : UINT;
          ntmAvgWidth    : UINT;
    END;
    PNEWTEXTMETRICA      = POINTER TO NEWTEXTMETRICA;
    LPNEWTEXTMETRICA     = PNEWTEXTMETRICA;

    NEWTEXTMETRICW = RECORD
          tmHeight       : LONG;
          tmAscent       : LONG;
          tmDescent      : LONG;
          tmInternalLeading: LONG;
          tmExternalLeading: LONG;
          tmAveCharWidth : LONG;
          tmMaxCharWidth : LONG;
          tmWeight       : LONG;
          tmOverhang     : LONG;
          tmDigitizedAspectX: LONG;
          tmDigitizedAspectY: LONG;
          tmFirstChar    : WCHAR;
          tmLastChar     : WCHAR;
          tmDefaultChar  : WCHAR;
          tmBreakChar    : WCHAR;
          tmItalic       : BYTEBOOL;
          tmUnderlined   : BYTEBOOL;
          tmStruckOut    : BYTEBOOL;
          tmPitchAndFamily: BYTE;
          tmCharSet      : BYTE;
          ntmFlags       : DWORD;
          ntmSizeEM      : UINT;
          ntmCellHeight  : UINT;
          ntmAvgWidth    : UINT;
    END;
    PNEWTEXTMETRICW      = POINTER TO NEWTEXTMETRICW;
    LPNEWTEXTMETRICW     = PNEWTEXTMETRICW;

%IF UNICODE %THEN
    NEWTEXTMETRIC        = NEWTEXTMETRICW;
%ELSE
    NEWTEXTMETRIC        = NEWTEXTMETRICA;
%END
    PNEWTEXTMETRIC       = POINTER TO NEWTEXTMETRIC;
    LPNEWTEXTMETRIC      = PNEWTEXTMETRIC;


    NEWTEXTMETRICEXA = RECORD
        ntmTm           : NEWTEXTMETRICA;
        ntmFontSig      : FONTSIGNATURE;
    END;

    NEWTEXTMETRICEXW = RECORD
        ntmTm           : NEWTEXTMETRICW;
        ntmFontSig      : FONTSIGNATURE;
    END;

%IF UNICODE %THEN
    NEWTEXTMETRICEX = NEWTEXTMETRICEXW;
%ELSE
    NEWTEXTMETRICEX = NEWTEXTMETRICEXA;
%END


    PELARRAY = RECORD
          paXCount       : LONG;
          paYCount       : LONG;
          paXExt         : LONG;
          paYExt         : LONG;
          paRGBs         : BYTE;
    END;
    PPELARRAY            = POINTER TO PELARRAY;
    LPPELARRAY           = PPELARRAY;

    LOGBRUSH = RECORD
          lbStyle        : UINT;
          lbColor        : COLORREF;
          lbHatch        : LONG;
    END;
    PLOGBRUSH            = POINTER TO LOGBRUSH;
    LPLOGBRUSH           = PLOGBRUSH;

    PATTERN              = LOGBRUSH;
    PPATTERN             = POINTER TO PATTERN;
    LPPATTERN            = PPATTERN;

    LOGPEN = RECORD
          lopnStyle      : UINT;
          lopnWidth      : POINT;
          lopnColor      : COLORREF;
    END;
    PLOGPEN              = POINTER TO LOGPEN;
    LPLOGPEN             = PLOGPEN;

    EXTLOGPEN = RECORD
          elpPenStyle    : DWORD;
          elpWidth       : DWORD;
          elpBrushStyle  : UINT;
          elpColor       : COLORREF;
          elpHatch       : LONG;
          elpNumEntries  : DWORD;
          elpStyleEntry  : ARRAY [0..1 - 1] OF DWORD;
    END;
    PEXTLOGPEN           = POINTER TO EXTLOGPEN;
    LPEXTLOGPEN          = PEXTLOGPEN;

    PALETTEENTRY = RECORD
          peRed          : BYTE;
          peGreen        : BYTE;
          peBlue         : BYTE;
          peFlags        : BYTE;
    END;
    PPALETTEENTRY        = POINTER TO PALETTEENTRY;
    LPPALETTEENTRY       = PPALETTEENTRY;

    LOGPALETTE = RECORD
          palVersion     : WORD;
          palNumEntries  : WORD;
          palPalEntry    : ARRAY [0..1 - 1] OF PALETTEENTRY;
    END;
    PLOGPALETTE          = POINTER TO LOGPALETTE;
    LPLOGPALETTE         = PLOGPALETTE;

CONST
    LF_FACESIZE          = 32;

TYPE
    LOGFONTA = RECORD
          lfHeight       : LONG;
          lfWidth        : LONG;
          lfEscapement   : LONG;
          lfOrientation  : LONG;
          lfWeight       : LONG;
          lfItalic       : BYTEBOOL;
          lfUnderline    : BYTEBOOL;
          lfStrikeOut    : BYTEBOOL;
          lfCharSet      : BYTE;
          lfOutPrecision : BYTE;
          lfClipPrecision: BYTE;
          lfQuality      : BYTE;
          lfPitchAndFamily: BYTE;
          lfFaceName     : ARRAY [0..LF_FACESIZE - 1] OF ACHAR;
    END;
    PLOGFONTA            = POINTER TO LOGFONTA;
    LPLOGFONTA           = PLOGFONTA;

    LOGFONTW = RECORD
          lfHeight       : LONG;
          lfWidth        : LONG;
          lfEscapement   : LONG;
          lfOrientation  : LONG;
          lfWeight       : LONG;
          lfItalic       : BYTEBOOL;
          lfUnderline    : BYTEBOOL;
          lfStrikeOut    : BYTEBOOL;
          lfCharSet      : BYTE;
          lfOutPrecision : BYTE;
          lfClipPrecision: BYTE;
          lfQuality      : BYTE;
          lfPitchAndFamily: BYTE;
          lfFaceName     : ARRAY [0..LF_FACESIZE - 1] OF WCHAR;
    END;
    PLOGFONTW            = POINTER TO LOGFONTW;
    LPLOGFONTW           = PLOGFONTW;

%IF UNICODE %THEN
    LOGFONT              = LOGFONTW;
%ELSE
    LOGFONT              = LOGFONTA;
%END
    PLOGFONT             = POINTER TO LOGFONT;
    LPLOGFONT            = PLOGFONT;

CONST
    LF_FULLFACESIZE      = 64;

TYPE
    ENUMLOGFONTA = RECORD
          elfLogFont     : LOGFONTA;
          elfFullName    : ARRAY [0..LF_FULLFACESIZE - 1] OF BYTE;
          elfStyle       : ARRAY [0..LF_FACESIZE - 1] OF BYTE;
    END;
    LPENUMLOGFONTA       = POINTER TO ENUMLOGFONTA;

    ENUMLOGFONTW = RECORD
          elfLogFont     : LOGFONTW;
          elfFullName    : ARRAY [0..LF_FULLFACESIZE - 1] OF WCHAR;
          elfStyle       : ARRAY [0..LF_FACESIZE - 1] OF WCHAR;
    END;
    LPENUMLOGFONTW       = POINTER TO ENUMLOGFONTW;

%IF UNICODE %THEN
    ENUMLOGFONT          = ENUMLOGFONTW;
%ELSE
    ENUMLOGFONT          = ENUMLOGFONTA;
%END
    LPENUMLOGFONT        = POINTER TO ENUMLOGFONT;


    ENUMLOGFONTEXA = RECORD
        elfLogFont      : LOGFONTA;
        elfFullName     : ARRAY [0..LF_FULLFACESIZE-1] OF BYTE;
        elfStyle        : ARRAY [0..LF_FACESIZE-1] OF BYTE;
        elfScript       : ARRAY [0..LF_FACESIZE-1] OF BYTE;
    END;
    LPENUMLOGFONTEXA    = POINTER TO ENUMLOGFONTEXA;

    ENUMLOGFONTEXW = RECORD
        elfLogFont      : LOGFONTW;
        elfFullName     : ARRAY [0..LF_FULLFACESIZE-1] OF BYTE;
        elfStyle        : ARRAY [0..LF_FACESIZE-1] OF BYTE;
        elfScript       : ARRAY [0..LF_FACESIZE-1] OF BYTE;
    END;
    LPENUMLOGFONTEXW    = POINTER TO ENUMLOGFONTEXW;

%IF UNICODE %THEN
    ENUMLOGFONTEX       = ENUMLOGFONTEXW;
%ELSE
    ENUMLOGFONTEX       = ENUMLOGFONTEXA;
%END
    LPENUMLOGFONTEX     = POINTER TO ENUMLOGFONTEX;


CONST
    OUT_DEFAULT_PRECIS   = 0;
    OUT_STRING_PRECIS    = 1;
    OUT_CHARACTER_PRECIS = 2;
    OUT_STROKE_PRECIS    = 3;
    OUT_TT_PRECIS        = 4;
    OUT_DEVICE_PRECIS    = 5;
    OUT_RASTER_PRECIS    = 6;
    OUT_TT_ONLY_PRECIS   = 7;
    OUT_OUTLINE_PRECIS   = 8;
    OUT_SCREEN_OUTLINE_PRECIS   =9;

    CLIP_DEFAULT_PRECIS  = 0;
    CLIP_CHARACTER_PRECIS= 1;
    CLIP_STROKE_PRECIS   = 2;
    CLIP_MASK            = 0fh;
    CLIP_LH_ANGLES       = 1 SHL 4;
    CLIP_TT_ALWAYS       = 2 SHL 4;
    CLIP_EMBEDDED        = 8 SHL 4;
    DEFAULT_QUALITY      = 0;
    DRAFT_QUALITY        = 1;
    PROOF_QUALITY        = 2;

    NONANTIALIASED_QUALITY  = 3;
    ANTIALIASED_QUALITY     = 4;

    DEFAULT_PITCH        = 0;
    FIXED_PITCH          = 1;
    VARIABLE_PITCH       = 2;
    MONO_FONT            = 8;(*95*)
    ANSI_CHARSET         = 0;
    DEFAULT_CHARSET      = 1;
    SYMBOL_CHARSET       = 2;
    SHIFTJIS_CHARSET     = 128;
    HANGEUL_CHARSET      = 129;
    HANGUL_CHARSET          = 129;
    GB2312_CHARSET       = 134;

    CHINESEBIG5_CHARSET  = 136;
    OEM_CHARSET          = 255;

    JOHAB_CHARSET           = 130;
    HEBREW_CHARSET          = 177;
    ARABIC_CHARSET          = 178;
    GREEK_CHARSET           = 161;
    TURKISH_CHARSET         = 162;
    VIETNAMESE_CHARSET      = 163;
    THAI_CHARSET            = 222;
    EASTEUROPE_CHARSET      = 238;
    RUSSIAN_CHARSET         = 204;

    MAC_CHARSET             = 77;
    BALTIC_CHARSET          = 186;

    FS_LATIN1           = 00000001h;
    FS_LATIN2           = 00000002h;
    FS_CYRILLIC         = 00000004h;
    FS_GREEK            = 00000008h;
    FS_TURKISH          = 00000010h;
    FS_HEBREW           = 00000020h;
    FS_ARABIC           = 00000040h;
    FS_BALTIC           = 00000080h;
    FS_VIETNAMESE           = 000000100h;
    FS_THAI             = 00010000h;
    FS_JISJAPAN         = 00020000h;
    FS_CHINESESIMP      = 00040000h;
    FS_WANSUNG          = 00080000h;
    FS_CHINESETRAD      = 00100000h;
    FS_JOHAB        = 00200000h;
    FS_SYMBOL       = 80000000h;

    FF_DONTCARE          = 0;
    FF_ROMAN             = 1 SHL 4;
    FF_SWISS             = 2 SHL 4;
    FF_MODERN            = 3 SHL 4;
    FF_SCRIPT            = 4 SHL 4;
    FF_DECORATIVE        = 5 SHL 4;

    FW_DONTCARE          = 0;
    FW_THIN              = 100;
    FW_EXTRALIGHT        = 200;
    FW_LIGHT             = 300;
    FW_NORMAL            = 400;
    FW_MEDIUM            = 500;
    FW_SEMIBOLD          = 600;
    FW_BOLD              = 700;
    FW_EXTRABOLD         = 800;
    FW_HEAVY             = 900;
    FW_ULTRALIGHT        = FW_EXTRALIGHT;
    FW_REGULAR           = FW_NORMAL;
    FW_DEMIBOLD          = FW_SEMIBOLD;
    FW_ULTRABOLD         = FW_EXTRABOLD;
    FW_BLACK             = FW_HEAVY;

    PANOSE_COUNT         = 10;
    PAN_FAMILYTYPE_INDEX = 0;
    PAN_SERIFSTYLE_INDEX = 1;
    PAN_WEIGHT_INDEX     = 2;
    PAN_PROPORTION_INDEX = 3;
    PAN_CONTRAST_INDEX   = 4;
    PAN_STROKEVARIATION_INDEX= 5;
    PAN_ARMSTYLE_INDEX   = 6;
    PAN_LETTERFORM_INDEX = 7;
    PAN_MIDLINE_INDEX    = 8;
    PAN_XHEIGHT_INDEX    = 9;
    PAN_CULTURE_LATIN    = 0;

TYPE
    PANOSE = RECORD
          bFamilyType    : BYTE;
          bSerifStyle    : BYTE;
          bWeight        : BYTE;
          bProportion    : BYTE;
          bContrast      : BYTE;
          bStrokeVariation: BYTE;
          bArmStyle      : BYTE;
          bLetterform    : BYTE;
          bMidline       : BYTE;
          bXHeight       : BYTE;
    END;
    LPPANOSE             = POINTER TO PANOSE;

CONST
    PAN_ANY              = 0;
    PAN_NO_FIT           = 1;
    PAN_FAMILY_TEXT_DISPLAY= 2;
    PAN_FAMILY_SCRIPT    = 3;
    PAN_FAMILY_DECORATIVE= 4;
    PAN_FAMILY_PICTORIAL = 5;
    PAN_SERIF_COVE       = 2;
    PAN_SERIF_OBTUSE_COVE= 3;
    PAN_SERIF_SQUARE_COVE= 4;
    PAN_SERIF_OBTUSE_SQUARE_COVE= 5;
    PAN_SERIF_SQUARE     = 6;
    PAN_SERIF_THIN       = 7;
    PAN_SERIF_BONE       = 8;
    PAN_SERIF_EXAGGERATED= 9;
    PAN_SERIF_TRIANGLE   = 10;
    PAN_SERIF_NORMAL_SANS= 11;
    PAN_SERIF_OBTUSE_SANS= 12;
    PAN_SERIF_PERP_SANS  = 13;
    PAN_SERIF_FLARED     = 14;
    PAN_SERIF_ROUNDED    = 15;
    PAN_WEIGHT_VERY_LIGHT= 2;
    PAN_WEIGHT_LIGHT     = 3;
    PAN_WEIGHT_THIN      = 4;
    PAN_WEIGHT_BOOK      = 5;
    PAN_WEIGHT_MEDIUM    = 6;
    PAN_WEIGHT_DEMI      = 7;
    PAN_WEIGHT_BOLD      = 8;
    PAN_WEIGHT_HEAVY     = 9;
    PAN_WEIGHT_BLACK     = 10;
    PAN_WEIGHT_NORD      = 11;
    PAN_PROP_OLD_STYLE   = 2;
    PAN_PROP_MODERN      = 3;
    PAN_PROP_EVEN_WIDTH  = 4;
    PAN_PROP_EXPANDED    = 5;
    PAN_PROP_CONDENSED   = 6;
    PAN_PROP_VERY_EXPANDED= 7;
    PAN_PROP_VERY_CONDENSED= 8;
    PAN_PROP_MONOSPACED  = 9;
    PAN_CONTRAST_NONE    = 2;
    PAN_CONTRAST_VERY_LOW= 3;
    PAN_CONTRAST_LOW     = 4;
    PAN_CONTRAST_MEDIUM_LOW= 5;
    PAN_CONTRAST_MEDIUM  = 6;
    PAN_CONTRAST_MEDIUM_HIGH= 7;
    PAN_CONTRAST_HIGH    = 8;
    PAN_CONTRAST_VERY_HIGH= 9;
    PAN_STROKE_GRADUAL_DIAG= 2;
    PAN_STROKE_GRADUAL_TRAN= 3;
    PAN_STROKE_GRADUAL_VERT= 4;
    PAN_STROKE_GRADUAL_HORZ= 5;
    PAN_STROKE_RAPID_VERT= 6;
    PAN_STROKE_RAPID_HORZ= 7;
    PAN_STROKE_INSTANT_VERT= 8;
    PAN_STRAIGHT_ARMS_HORZ= 2;
    PAN_STRAIGHT_ARMS_WEDGE= 3;
    PAN_STRAIGHT_ARMS_VERT= 4;
    PAN_STRAIGHT_ARMS_SINGLE_SERIF= 5;
    PAN_STRAIGHT_ARMS_DOUBLE_SERIF= 6;
    PAN_BENT_ARMS_HORZ   = 7;
    PAN_BENT_ARMS_WEDGE  = 8;
    PAN_BENT_ARMS_VERT   = 9;
    PAN_BENT_ARMS_SINGLE_SERIF= 10;
    PAN_BENT_ARMS_DOUBLE_SERIF= 11;
    PAN_LETT_NORMAL_CONTACT= 2;
    PAN_LETT_NORMAL_WEIGHTED= 3;
    PAN_LETT_NORMAL_BOXED= 4;
    PAN_LETT_NORMAL_FLATTENED= 5;
    PAN_LETT_NORMAL_ROUNDED= 6;
    PAN_LETT_NORMAL_OFF_CENTER= 7;
    PAN_LETT_NORMAL_SQUARE= 8;
    PAN_LETT_OBLIQUE_CONTACT= 9;
    PAN_LETT_OBLIQUE_WEIGHTED= 10;
    PAN_LETT_OBLIQUE_BOXED= 11;
    PAN_LETT_OBLIQUE_FLATTENED= 12;
    PAN_LETT_OBLIQUE_ROUNDED= 13;
    PAN_LETT_OBLIQUE_OFF_CENTER= 14;
    PAN_LETT_OBLIQUE_SQUARE= 15;
    PAN_MIDLINE_STANDARD_TRIMMED= 2;
    PAN_MIDLINE_STANDARD_POINTED= 3;
    PAN_MIDLINE_STANDARD_SERIFED= 4;
    PAN_MIDLINE_HIGH_TRIMMED= 5;
    PAN_MIDLINE_HIGH_POINTED= 6;
    PAN_MIDLINE_HIGH_SERIFED= 7;
    PAN_MIDLINE_CONSTANT_TRIMMED= 8;
    PAN_MIDLINE_CONSTANT_POINTED= 9;
    PAN_MIDLINE_CONSTANT_SERIFED= 10;
    PAN_MIDLINE_LOW_TRIMMED= 11;
    PAN_MIDLINE_LOW_POINTED= 12;
    PAN_MIDLINE_LOW_SERIFED= 13;
    PAN_XHEIGHT_CONSTANT_SMALL= 2;
    PAN_XHEIGHT_CONSTANT_STD= 3;
    PAN_XHEIGHT_CONSTANT_LARGE= 4;
    PAN_XHEIGHT_DUCKING_SMALL= 5;
    PAN_XHEIGHT_DUCKING_STD= 6;
    PAN_XHEIGHT_DUCKING_LARGE= 7;
    ELF_VENDOR_SIZE      = 4;

TYPE
    EXTLOGFONTA = RECORD
          elfLogFont     : LOGFONTA;
          elfFullName    : ARRAY [0..LF_FULLFACESIZE - 1] OF BYTE;
          elfStyle       : ARRAY [0..LF_FACESIZE - 1] OF BYTE;
          elfVersion     : DWORD;
          elfStyleSize   : DWORD;
          elfMatch       : DWORD;
          elfReserved    : DWORD;
          elfVendorId    : ARRAY [0..ELF_VENDOR_SIZE - 1] OF BYTE;
          elfCulture     : DWORD;
          elfPanose      : PANOSE;
    END;
    PEXTLOGFONTA         = POINTER TO EXTLOGFONTA;
    LPEXTLOGFONTA        = PEXTLOGFONTA;

    EXTLOGFONTW = RECORD
          elfLogFont     : LOGFONTW;
          elfFullName    : ARRAY [0..LF_FULLFACESIZE - 1] OF WCHAR;
          elfStyle       : ARRAY [0..LF_FACESIZE - 1] OF WCHAR;
          elfVersion     : DWORD;
          elfStyleSize   : DWORD;
          elfMatch       : DWORD;
          elfReserved    : DWORD;
          elfVendorId    : ARRAY [0..ELF_VENDOR_SIZE - 1] OF BYTE;
          elfCulture     : DWORD;
          elfPanose      : PANOSE;
    END;
    PEXTLOGFONTW         = POINTER TO EXTLOGFONTW;
    LPEXTLOGFONTW        = PEXTLOGFONTW;

%IF UNICODE %THEN
    EXTLOGFONT           = EXTLOGFONTW;
%ELSE
    EXTLOGFONT           = EXTLOGFONTA;
%END
    PEXTLOGFONT          = POINTER TO EXTLOGFONT;
    LPEXTLOGFONT         = PEXTLOGFONT;

CONST
    ELF_VERSION          = 0;
    ELF_CULTURE_LATIN    = 0;
    RASTER_FONTTYPE      = 00001h;
    DEVICE_FONTTYPE      = 0002h;
    TRUETYPE_FONTTYPE    = 0004h;
    PC_RESERVED          = 001h;
    PC_EXPLICIT          = 002h;
    PC_NOCOLLAPSE        = 004h;
    TRANSPARENT          = 1;
    OPAQUE               = 2;
    BKMODE_LAST          = 2;
    GM_COMPATIBLE        = 1;
    GM_ADVANCED          = 2;
    GM_LAST              = 2;
    PT_CLOSEFIGURE       = 001h;
    PT_LINETO            = 002h;
    PT_BEZIERTO          = 004h;
    PT_MOVETO            = 006h;
    MM_TEXT              = 1;
    MM_LOMETRIC          = 2;
    MM_HIMETRIC          = 3;
    MM_LOENGLISH         = 4;
    MM_HIENGLISH         = 5;
    MM_TWIPS             = 6;
    MM_ISOTROPIC         = 7;
    MM_ANISOTROPIC       = 8;
    MM_MIN               = MM_TEXT;
    MM_MAX               = MM_ANISOTROPIC;
    MM_MAX_FIXEDSCALE    = MM_TWIPS;

    ABSOLUTE             = 1;
    RELATIVE             = 2;
    WHITE_BRUSH          = 0;
    LTGRAY_BRUSH         = 1;
    GRAY_BRUSH           = 2;
    DKGRAY_BRUSH         = 3;
    BLACK_BRUSH          = 4;
    NULL_BRUSH           = 5;
    HOLLOW_BRUSH         = NULL_BRUSH;

    WHITE_PEN            = 6;
    BLACK_PEN            = 7;
    NULL_PEN             = 8;
    OEM_FIXED_FONT       = 10;
    ANSI_FIXED_FONT      = 11;
    ANSI_VAR_FONT        = 12;
    SYSTEM_FONT          = 13;
    DEVICE_DEFAULT_FONT  = 14;
    DEFAULT_PALETTE      = 15;
    SYSTEM_FIXED_FONT    = 16;

%IF WIN5 %THEN
    DC_BRUSH            =18;(*NT only*)
    DC_PEN              =19;(*NT only*)
    STOCK_LAST           = 19;
%ELSE
%IF WIN4 %THEN
    DEFAULT_GUI_FONT     = 17;
    STOCK_LAST           = 17;
%ELSE
    STOCK_LAST           = 16;
%END
%END



    CLR_INVALID          = 0FFFFFFFFh;
    BS_SOLID             = 0;
    BS_NULL              = 1;
    BS_HOLLOW            = BS_NULL;
    BS_HATCHED           = 2;
    BS_PATTERN           = 3;
    BS_INDEXED           = 4;
    BS_DIBPATTERN        = 5;
    BS_DIBPATTERNPT      = 6;
    BS_PATTERN8X8        = 7;
    BS_DIBPATTERN8X8     = 8;
    BS_MONOPATTERN      = 9;

    HS_HORIZONTAL        = 0;
    HS_VERTICAL          = 1;
    HS_FDIAGONAL         = 2;
    HS_BDIAGONAL         = 3;
    HS_CROSS             = 4;
    HS_DIAGCROSS         = 5;
    HS_FDIAGONAL1        = 6;
    HS_BDIAGONAL1        = 7;
    HS_SOLID             = 8;
    HS_DENSE1            = 9;
    HS_DENSE2            = 10;
    HS_DENSE3            = 11;
    HS_DENSE4            = 12;
    HS_DENSE5            = 13;
    HS_DENSE6            = 14;
    HS_DENSE7            = 15;
    HS_DENSE8            = 16;
    HS_NOSHADE           = 17;
    HS_HALFTONE          = 18;
    HS_SOLIDCLR          = 19;
    HS_DITHEREDCLR       = 20;
    HS_SOLIDTEXTCLR      = 21;
    HS_DITHEREDTEXTCLR   = 22;
    HS_SOLIDBKCLR        = 23;
    HS_DITHEREDBKCLR     = 24;
    HS_API_MAX           = 25;
    PS_SOLID             = 0;
    PS_DASH              = 1;
    PS_DOT               = 2;
    PS_DASHDOT           = 3;
    PS_DASHDOTDOT        = 4;
    PS_NULL              = 5;
    PS_INSIDEFRAME       = 6;
    PS_USERSTYLE         = 7;
    PS_ALTERNATE         = 8;
    PS_STYLE_MASK        = 00000000Fh;
    PS_ENDCAP_ROUND      = 000000000h;
    PS_ENDCAP_SQUARE     = 000000100h;
    PS_ENDCAP_FLAT       = 000000200h;
    PS_ENDCAP_MASK       = 000000F00h;
    PS_JOIN_ROUND        = 000000000h;
    PS_JOIN_BEVEL        = 000001000h;
    PS_JOIN_MITER        = 000002000h;
    PS_JOIN_MASK         = 00000F000h;
    PS_COSMETIC          = 000000000h;
    PS_GEOMETRIC         = 000010000h;
    PS_TYPE_MASK         = 0000F0000h;
    AD_COUNTERCLOCKWISE  = 1;
    AD_CLOCKWISE         = 2;
    DRIVERVERSION        = 0;
    TECHNOLOGY           = 2;
    HORZSIZE             = 4;
    VERTSIZE             = 6;
    HORZRES              = 8;
    VERTRES              = 10;
    BITSPIXEL            = 12;
    PLANES               = 14;
    NUMBRUSHES           = 16;
    NUMPENS              = 18;
    NUMMARKERS           = 20;
    NUMFONTS             = 22;
    NUMCOLORS            = 24;
    PDEVICESIZE          = 26;
    CURVECAPS            = 28;
    LINECAPS             = 30;
    POLYGONALCAPS        = 32;
    TEXTCAPS             = 34;
    CLIPCAPS             = 36;
    RASTERCAPS           = 38;
    ASPECTX              = 40;
    ASPECTY              = 42;
    ASPECTXY             = 44;
    %IF WIN5 %THEN
    SHADEBLENDCAPS       = 45;   (* Shading and blending caps  *)
    %END

    LOGPIXELSX           = 88;
    LOGPIXELSY           = 90;
    SIZEPALETTE          = 104;
    NUMRESERVED          = 106;
    COLORRES             = 108;
    PHYSICALWIDTH        = 110;
    PHYSICALHEIGHT       = 111;
    PHYSICALOFFSETX      = 112;
    PHYSICALOFFSETY      = 113;
    SCALINGFACTORX       = 114;
    SCALINGFACTORY       = 115;
    VREFRESH             = 116;
    DESKTOPVERTRES       = 117;
    DESKTOPHORZRES       = 118;
    BLTALIGNMENT         = 119;

    DT_PLOTTER           = 0;
    DT_RASDISPLAY        = 1;
    DT_RASPRINTER        = 2;
    DT_RASCAMERA         = 3;
    DT_CHARSTREAM        = 4;
    DT_METAFILE          = 5;
    DT_DISPFILE          = 6;
    CC_NONE              = 0;
    CC_CIRCLES           = 1;
    CC_PIE               = 2;
    CC_CHORD             = 4;
    CC_ELLIPSES          = 8;
    CC_WIDE              = 16;
    CC_STYLED            = 32;
    CC_WIDESTYLED        = 64;
    CC_INTERIORS         = 128;
    CC_ROUNDRECT         = 256;
    LC_NONE              = 0;
    LC_POLYLINE          = 2;
    LC_MARKER            = 4;
    LC_POLYMARKER        = 8;
    LC_WIDE              = 16;
    LC_STYLED            = 32;
    LC_WIDESTYLED        = 64;
    LC_INTERIORS         = 128;
    PC_NONE              = 0;
    PC_POLYGON           = 1;
    PC_RECTANGLE         = 2;
    PC_WINDPOLYGON       = 4;
    PC_TRAPEZOID         = 4;
    PC_SCANLINE          = 8;
    PC_WIDE              = 16;
    PC_STYLED            = 32;
    PC_WIDESTYLED        = 64;
    PC_POLYPOLYGON       = 256;
    PC_PATHS             = 512;

    PC_INTERIORS         = 128;
    CP_NONE              = 0;
    CP_RECTANGLE         = 1;
    CP_REGION            = 2;
    TC_OP_CHARACTER      = 000000001h;
    TC_OP_STROKE         = 000000002h;
    TC_CP_STROKE         = 000000004h;
    TC_CR_90             = 000000008h;
    TC_CR_ANY            = 000000010h;
    TC_SF_X_YINDEP       = 000000020h;
    TC_SA_DOUBLE         = 000000040h;
    TC_SA_INTEGER        = 000000080h;
    TC_SA_CONTIN         = 000000100h;
    TC_EA_DOUBLE         = 000000200h;
    TC_IA_ABLE           = 000000400h;
    TC_UA_ABLE           = 000000800h;
    TC_SO_ABLE           = 000001000h;
    TC_RA_ABLE           = 000002000h;
    TC_VA_ABLE           = 000004000h;
    TC_RESERVED          = 000008000h;
    TC_SCROLLBLT         = 000010000h;

    RC_BITBLT            = 1;
    RC_BANDING           = 2;
    RC_SCALING           = 4;
    RC_BITMAP64          = 8;
    RC_GDI20_OUTPUT      = 00010h;
    RC_GDI20_STATE       = 00020h;
    RC_SAVEBITMAP        = 00040h;
    RC_DI_BITMAP         = 00080h;
    RC_PALETTE           = 00100h;
    RC_DIBTODEV          = 00200h;
    RC_BIGFONT           = 00400h;
    RC_STRETCHBLT        = 00800h;
    RC_FLOODFILL         = 01000h;
    RC_STRETCHDIB        = 02000h;
    RC_OP_DX_OUTPUT      = 04000h;
    RC_DEVBITS           = 08000h;

%IF WIN5 %THEN
    SB_NONE             =000000000h;
    SB_CONST_ALPHA      =000000001h;
    SB_PIXEL_ALPHA      =000000002h;
    SB_PREMULT_ALPHA    =000000004h;

    SB_GRAD_RECT        =000000010h;
    SB_GRAD_TRI         =000000020h;
%END

    DIB_RGB_COLORS       = 0;
    DIB_PAL_COLORS       = 1;
    DIB_PAL_INDICES      = 2;
    DIB_PAL_PHYSINDICES  = 2;
    DIB_PAL_LOGINDICES   = 4;

    SYSPAL_ERROR         = 0;
    SYSPAL_STATIC        = 1;
    SYSPAL_NOSTATIC      = 2;
    SYSPAL_NOSTATIC256   = 3;

    CBM_CREATEDIB        = 002h;
    CBM_INIT             = 004h;

    FLOODFILLBORDER      = 0;
    FLOODFILLSURFACE     = 1;
    CCHDEVICENAME        = 32;
    CCHFORMNAME          = 32;

TYPE
    devicemodeA = RECORD
        dmDeviceName   : ARRAY [0..CCHDEVICENAME - 1] OF ACHAR;
        dmSpecVersion  : WORD;
        dmDriverVersion: WORD;
        dmSize         : WORD;
        dmDriverExtra  : WORD;
        dmFields       : DWORD;
        CASE : BOOLEAN OF
        FALSE: dmOrientation  : INTEGER16;
               dmPaperSize    : INTEGER16;
               dmPaperLength  : INTEGER16;
               dmPaperWidth   : INTEGER16;
        |
        TRUE: dmPosition : POINTL;
        END;
        dmScale        : INTEGER16;
        dmCopies       : INTEGER16;
        dmDefaultSource: INTEGER16;
        dmPrintQuality : INTEGER16;
        dmColor        : INTEGER16;
        dmDuplex       : INTEGER16;
        dmYResolution  : INTEGER16;
        dmTTOption     : INTEGER16;
        dmCollate      : INTEGER16;
        dmFormName     : ARRAY [0..CCHFORMNAME - 1] OF ACHAR;
        dmLogPixels    : WORD;
        dmBitsPerPel   : DWORD;
        dmPelsWidth    : DWORD;
        dmPelsHeight   : DWORD;
        dmDisplayFlags : DWORD;
        dmDisplayFrequency: DWORD;
        %IF WIN4 %THEN
            dmICMMethod : DWORD;
            dmICMIntent : DWORD;
            dmMediaType : DWORD;
            dmDitherType:DWORD;
            dmICCManufacturer:DWORD;
            dmICCModel  : DWORD;

            (* WIN 5.0 and NT 4.x and higher *)
            (* SPECVERSION 401h *)
            dmPanningWidth : DWORD;
            dmPanningHeigh : DWORD;
        %END
    END;
    PDEVMODEA            = POINTER TO devicemodeA;
    LPDEVMODEA           = PDEVMODEA;

    devicemodeW = RECORD
        dmDeviceName   : ARRAY [0..CCHDEVICENAME - 1] OF WCHAR;
        dmSpecVersion  : WORD;
        dmDriverVersion: WORD;
        dmSize         : WORD;
        dmDriverExtra  : WORD;
        dmFields       : DWORD;
        CASE : BOOLEAN OF
        FALSE: dmOrientation  : INTEGER16;
               dmPaperSize    : INTEGER16;
               dmPaperLength  : INTEGER16;
               dmPaperWidth   : INTEGER16;
        |
        TRUE: dmPosition : POINTL;
        END;
        dmScale        : INTEGER16;
        dmCopies       : INTEGER16;
        dmDefaultSource: INTEGER16;
        dmPrintQuality : INTEGER16;
        dmColor        : INTEGER16;
        dmDuplex       : INTEGER16;
        dmYResolution  : INTEGER16;
        dmTTOption     : INTEGER16;
        dmCollate      : INTEGER16;
        dmFormName     : ARRAY [0..CCHFORMNAME - 1] OF WCHAR;
        dmLogPixels    : WORD;
        dmBitsPerPel   : DWORD;
        dmPelsWidth    : DWORD;
        dmPelsHeight   : DWORD;
        dmDisplayFlags : DWORD;
        dmDisplayFrequency: DWORD;
        (*95*)
        %IF WIN4 %THEN
            dmICMMethod : DWORD;
            dmICMIntent : DWORD;
            dmMediaType : DWORD;
            dmDitherType: DWORD;
            dmICCManufacturer: DWORD;
            dmICCModel  : DWORD;

            (* WIN 5.0 and NT 4.x and higher *)
            (* SPECVERSION 401h *)
            dmPanningWidth : DWORD;
            dmPanningHeigh : DWORD;
        %END
    END;
    PDEVMODEW            = POINTER TO devicemodeW;
    LPDEVMODEW           = PDEVMODEW;

%IF UNICODE %THEN
    DEVMODE              = devicemodeW;
%ELSE
    DEVMODE              = devicemodeA;
%END
    DEVMODEA             = devicemodeA;
    DEVMODEW             = devicemodeW;
    PDEVMODE             = POINTER TO DEVMODE;
    LPDEVMODE            = PDEVMODE;

CONST
%IF WIN5 %THEN
    DM_SPECVERSION       = 0401h;(* also NT >= 4.0 *)
%ELSIF WIN4 %THEN
    DM_SPECVERSION       = 0400h;
%ELSE
    DM_SPECVERSION       = 0320h;
%END
    DM_ORIENTATION       = 00000001h;
    DM_PAPERSIZE         = 00000002h;
    DM_PAPERLENGTH       = 00000004h;
    DM_PAPERWIDTH        = 00000008h;

    DM_SCALE             = 00000010h;
    %IF WIN5 %THEN
    DM_POSITION          = 00000020h;
    %END
    DM_COPIES            = 00000100h;
    DM_DEFAULTSOURCE     = 00000200h;
    DM_PRINTQUALITY      = 00000400h;
    DM_COLOR             = 00000800h;
    DM_DUPLEX            = 00001000h;
    DM_YRESOLUTION       = 00002000h;
    DM_TTOPTION          = 00004000h;
    DM_COLLATE           = 00008000h;
    DM_FORMNAME          = 00010000h;

    DM_LOGPIXELS         = 0002000h;
    DM_BITSPERPEL        = 0004000h;
    DM_PELSWIDTH         = 0008000h;
    DM_PELSHEIGHT        = 0010000h;
    DM_DISPLAYFLAGS      = 0020000h;
    DM_DISPLAYFREQUENCY  = 0040000h;
    DM_RESERVED1         = 0080000h;
    DM_RESERVED2         = 0100000h;
    DM_ICMMETHOD         = 0200000h;
    DM_ICMINTENT         = 0400000h;
    DM_MEDIATYPE         = 0800000h;
    DM_DITHERTYPE        = 1000000h;
    DM_PANNINGWIDTH      = 08000000h;
    DM_PANNINGHEIGHT     = 10000000h;

    DMORIENT_PORTRAIT    = 1;
    DMORIENT_LANDSCAPE   = 2;

    DMPAPER_FIRST        = 0;
    DMPAPER_LETTER       = 1;
    DMPAPER_LETTERSMALL  = 2;
    DMPAPER_TABLOID      = 3;
    DMPAPER_LEDGER       = 4;
    DMPAPER_LEGAL        = 5;
    DMPAPER_STATEMENT    = 6;
    DMPAPER_EXECUTIVE    = 7;
    DMPAPER_A3           = 8;
    DMPAPER_A4           = 9;
    DMPAPER_A4SMALL      = 10;
    DMPAPER_A5           = 11;
    DMPAPER_B4           = 12;
    DMPAPER_B5           = 13;
    DMPAPER_FOLIO        = 14;
    DMPAPER_QUARTO       = 15;
    DMPAPER_10X14        = 16;
    DMPAPER_11X17        = 17;
    DMPAPER_NOTE         = 18;
    DMPAPER_ENV_9        = 19;
    DMPAPER_ENV_10       = 20;
    DMPAPER_ENV_11       = 21;
    DMPAPER_ENV_12       = 22;
    DMPAPER_ENV_14       = 23;
    DMPAPER_CSHEET       = 24;
    DMPAPER_DSHEET       = 25;
    DMPAPER_ESHEET       = 26;
    DMPAPER_ENV_DL       = 27;
    DMPAPER_ENV_C5       = 28;
    DMPAPER_ENV_C3       = 29;
    DMPAPER_ENV_C4       = 30;
    DMPAPER_ENV_C6       = 31;
    DMPAPER_ENV_C65      = 32;
    DMPAPER_ENV_B4       = 33;
    DMPAPER_ENV_B5       = 34;
    DMPAPER_ENV_B6       = 35;
    DMPAPER_ENV_ITALY    = 36;
    DMPAPER_ENV_MONARCH  = 37;
    DMPAPER_ENV_PERSONAL = 38;
    DMPAPER_FANFOLD_US   = 39;
    DMPAPER_FANFOLD_STD_GERMAN= 40;
    DMPAPER_FANFOLD_LGL_GERMAN= 41;

    DMPAPER_ISO_B4              = 42;
    DMPAPER_JAPANESE_POSTCARD   = 43;
    DMPAPER_9X11                = 44;
    DMPAPER_10X11               = 45;
    DMPAPER_15X11               = 46;
    DMPAPER_ENV_INVITE          = 47;
    DMPAPER_RESERVED_48         = 48;
    DMPAPER_RESERVED_49         = 49;
    DMPAPER_LETTER_EXTRA        = 50;
    DMPAPER_LEGAL_EXTRA         = 51;
    DMPAPER_TABLOID_EXTRA       = 52;
    DMPAPER_A4_EXTRA            = 53;
    DMPAPER_LETTER_TRANSVERSE   = 54;
    DMPAPER_A4_TRANSVERSE       = 55;
    DMPAPER_LETTER_EXTRA_TRANSVERSE= 56;
    DMPAPER_A_PLUS              = 57;
    DMPAPER_B_PLUS              = 58;
    DMPAPER_LETTER_PLUS         = 59;
    DMPAPER_A4_PLUS             = 60;
    DMPAPER_A5_TRANSVERSE       = 61;
    DMPAPER_B5_TRANSVERSE       = 62;
    DMPAPER_A3_EXTRA            = 63;
    DMPAPER_A5_EXTRA            = 64;
    DMPAPER_B5_EXTRA            = 65;
    DMPAPER_A2                  = 66;
    DMPAPER_A3_TRANSVERSE       = 67;
    DMPAPER_A3_EXTRA_TRANSVERSE = 68;

%IF WIN5 %THEN
    DMPAPER_DBL_JAPANESE_POSTCARD =69; (* Japanese Double Postcard 200 x 148 mm *)
    DMPAPER_A6                  =70;  (* A6 105 x 148 mm                 *)
    DMPAPER_JENV_KAKU2          =71;  (* Japanese Envelope Kaku #2       *)
    DMPAPER_JENV_KAKU3          =72;  (* Japanese Envelope Kaku #3       *)
    DMPAPER_JENV_CHOU3          =73;  (* Japanese Envelope Chou #3       *)
    DMPAPER_JENV_CHOU4          =74;  (* Japanese Envelope Chou #4       *)
    DMPAPER_LETTER_ROTATED      =75;  (* Letter Rotated 11 x 8 1/2 11 in *)
    DMPAPER_A3_ROTATED          =76;  (* A3 Rotated 420 x 297 mm         *)
    DMPAPER_A4_ROTATED          =77;  (* A4 Rotated 297 x 210 mm         *)
    DMPAPER_A5_ROTATED          =78;  (* A5 Rotated 210 x 148 mm         *)
    DMPAPER_B4_JIS_ROTATED      =79;  (* B4 (JIS) Rotated 364 x 257 mm   *)
    DMPAPER_B5_JIS_ROTATED      =80;  (* B5 (JIS) Rotated 257 x 182 mm   *)
    DMPAPER_JAPANESE_POSTCARD_ROTATED =81; (* Japanese Postcard Rotated 148 x 100 mm *)
    DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED =82; (* Double Japanese Postcard Rotated 148 x 200 mm *)
    DMPAPER_A6_ROTATED          =83;  (* A6 Rotated 148 x 105 mm         *)
    DMPAPER_JENV_KAKU2_ROTATED  =84;  (* Japanese Envelope Kaku #2 Rotated *)
    DMPAPER_JENV_KAKU3_ROTATED  =85;  (* Japanese Envelope Kaku #3 Rotated *)
    DMPAPER_JENV_CHOU3_ROTATED  =86;  (* Japanese Envelope Chou #3 Rotated *)
    DMPAPER_JENV_CHOU4_ROTATED  =87;  (* Japanese Envelope Chou #4 Rotated *)
    DMPAPER_B6_JIS              =88;  (* B6 (JIS) 128 x 182 mm           *)
    DMPAPER_B6_JIS_ROTATED      =89;  (* B6 (JIS) Rotated 182 x 128 mm   *)
    DMPAPER_12X11               =90;  (* 12 x 11 in                      *)
    DMPAPER_JENV_YOU4           =91;  (* Japanese Envelope You #4        *)
    DMPAPER_JENV_YOU4_ROTATED   =92;  (* Japanese Envelope You #4 Rotated*)
    DMPAPER_P16K                =93;  (* PRC 16K 146 x 215 mm            *)
    DMPAPER_P32K                =94;  (* PRC 32K 97 x 151 mm             *)
    DMPAPER_P32KBIG             =95;  (* PRC 32K(Big) 97 x 151 mm        *)
    DMPAPER_PENV_1              =96;  (* PRC Envelope #1 102 x 165 mm    *)
    DMPAPER_PENV_2              =97;  (* PRC Envelope #2 102 x 176 mm    *)
    DMPAPER_PENV_3              =98;  (* PRC Envelope #3 125 x 176 mm    *)
    DMPAPER_PENV_4              =99;  (* PRC Envelope #4 110 x 208 mm    *)
    DMPAPER_PENV_5              =100; (* PRC Envelope #5 110 x 220 mm    *)
    DMPAPER_PENV_6              =101; (* PRC Envelope #6 120 x 230 mm    *)
    DMPAPER_PENV_7              =102; (* PRC Envelope #7 160 x 230 mm    *)
    DMPAPER_PENV_8              =103; (* PRC Envelope #8 120 x 309 mm    *)
    DMPAPER_PENV_9              =104; (* PRC Envelope #9 229 x 324 mm    *)
    DMPAPER_PENV_10             =105; (* PRC Envelope #10 324 x 458 mm   *)
    DMPAPER_P16K_ROTATED        =106; (* PRC 16K Rotated                 *)
    DMPAPER_P32K_ROTATED        =107; (* PRC 32K Rotated                 *)
    DMPAPER_P32KBIG_ROTATED     =108; (* PRC 32K(Big) Rotated            *)
    DMPAPER_PENV_1_ROTATED      =109; (* PRC Envelope #1 Rotated 165 x 102 mm *)
    DMPAPER_PENV_2_ROTATED      =110; (* PRC Envelope #2 Rotated 176 x 102 mm *)
    DMPAPER_PENV_3_ROTATED      =111; (* PRC Envelope #3 Rotated 176 x 125 mm *)
    DMPAPER_PENV_4_ROTATED      =112; (* PRC Envelope #4 Rotated 208 x 110 mm *)
    DMPAPER_PENV_5_ROTATED      =113; (* PRC Envelope #5 Rotated 220 x 110 mm *)
    DMPAPER_PENV_6_ROTATED      =114; (* PRC Envelope #6 Rotated 230 x 120 mm *)
    DMPAPER_PENV_7_ROTATED      =115; (* PRC Envelope #7 Rotated 230 x 160 mm *)
    DMPAPER_PENV_8_ROTATED      =116; (* PRC Envelope #8 Rotated 309 x 120 mm *)
    DMPAPER_PENV_9_ROTATED      =117; (* PRC Envelope #9 Rotated 324 x 229 mm *)
    DMPAPER_PENV_10_ROTATED     =118; (* PRC Envelope #10 Rotated 458 x 324 mm *)
%END

%IF WIN5 %THEN
    DMPAPER_LAST = DMPAPER_PENV_10_ROTATED;
%ELSE
    DMPAPER_LAST = DMPAPER_A3_EXTRA_TRANSVERSE;
%END

    DMPAPER_USER         = 256;

    DMBIN_UPPER          = 1;
    DMBIN_FIRST          = DMBIN_UPPER;
    DMBIN_ONLYONE        = 1;
    DMBIN_LOWER          = 2;
    DMBIN_MIDDLE         = 3;
    DMBIN_MANUAL         = 4;
    DMBIN_ENVELOPE       = 5;
    DMBIN_ENVMANUAL      = 6;
    DMBIN_AUTO           = 7;
    DMBIN_TRACTOR        = 8;
    DMBIN_SMALLFMT       = 9;
    DMBIN_LARGEFMT       = 10;
    DMBIN_LARGECAPACITY  = 11;
    DMBIN_CASSETTE       = 14;
    DMBIN_FORMSOURCE     = 15;
    DMBIN_LAST           = DMBIN_FORMSOURCE;
    DMBIN_USER           = 256;

    DMRES_DRAFT          = -1;
    DMRES_LOW            = -2;
    DMRES_MEDIUM         = -3;
    DMRES_HIGH           = -4;

    DMCOLOR_MONOCHROME   = 1;
    DMCOLOR_COLOR        = 2;

    DMDUP_SIMPLEX        = 1;
    DMDUP_VERTICAL       = 2;
    DMDUP_HORIZONTAL     = 3;

    DMTT_BITMAP          = 1;
    DMTT_DOWNLOAD        = 2;
    DMTT_SUBDEV          = 3;
    DMTT_DOWNLOAD_OUTLINE= 4;(*95*)

    DMCOLLATE_FALSE      = 0;
    DMCOLLATE_TRUE       = 1;

(*    DM_GRAYSCALE         = 000000001h;*)
(*    DM_INTERLACED        = 000000002h;*)
    DMDISPLAYFLAGS_TEXTMODE = 00000004h;


    DMICMMETHOD_NONE    = 1;
    DMICMMETHOD_SYSTEM  = 2;
    DMICMMETHOD_DRIVER  = 3;
    DMICMMETHOD_DEVICE  = 4;

    DMICMMETHOD_USER    = 256;

    DMICM_SATURATE      = 1;
    DMICM_CONTRAST      = 2;
    DMICM_COLORIMETRIC       =3;   (* Use specific color metric *)
    DMICM_ABS_COLORIMETRIC   =4;   (* Use specific color metric *)

    DMICM_USER          = 256;

    DMMEDIA_STANDARD      = 1;
    DMMEDIA_GLOSSY        = 2;
    DMMEDIA_TRANSPARENCY  = 3;

    DMMEDIA_USER          = 256;

    DMDITHER_NONE         = 1;
    DMDITHER_COARSE       = 2;
    DMDITHER_FINE         = 3;
    DMDITHER_LINEART      = 4;
    DMDITHER_ERRORDIFFUSION = 5;
    DMDITHER_RESERVED6    = 6;
    DMDITHER_RESERVED7    = 7;
    DMDITHER_RESERVED8    = 8;
    DMDITHER_RESERVED9    = 9;
    DMDITHER_GRAYSCALE    = 10;

    DMDITHER_USER         = 256;

TYPE
    DISPLAY_DEVICEA = RECORD
    cb                  : DWORD;
    DeviceName          : ARRAY [0..32-1] OF ACHAR;
    DeviceString        : ARRAY [0..128-1] OF ACHAR;
    StateFlags          : DWORD;
    END;
    PDISPLAY_DEVICEA = POINTER TO DISPLAY_DEVICEA;
    LPDISPLAY_DEVICEA = PDISPLAY_DEVICEA;

    DISPLAY_DEVICEW = RECORD
    cb                  : DWORD;
    DeviceName          : ARRAY [0..32-1] OF UCHAR;
    DeviceString        : ARRAY [0..128-1] OF UCHAR;
    StateFlags          : DWORD;
    END;
    PDISPLAY_DEVICEW = POINTER TO DISPLAY_DEVICEW;
    LPDISPLAY_DEVICEW = PDISPLAY_DEVICEW;

%IF UNICODE %THEN
    DISPLAY_DEVICE      = DISPLAY_DEVICEW;
    PDISPLAY_DEVICE     = PDISPLAY_DEVICEW;
    LPDISPLAY_DEVICE    = LPDISPLAY_DEVICEW;
%ELSE
    DISPLAY_DEVICE      = DISPLAY_DEVICEA;
    PDISPLAY_DEVICE     = PDISPLAY_DEVICEA;
    LPDISPLAY_DEVICE    = LPDISPLAY_DEVICEA;
%END

CONST
    DISPLAY_DEVICE_ATTACHED_TO_DESKTOP =00000001h;
    DISPLAY_DEVICE_MULTI_DRIVER        =00000002h;
    DISPLAY_DEVICE_PRIMARY_DEVICE      =00000004h;
    DISPLAY_DEVICE_MIRRORING_DRIVER    =00000008h;
    DISPLAY_DEVICE_VGA_COMPATIBLE      =00000010h;

    RDH_RECTANGLES       = 1;

TYPE
RGNDATAHEADER = RECORD
          dwSize         : DWORD;
          iType          : DWORD;
          nCount         : DWORD;
          nRgnSize       : DWORD;
          rcBound        : RECT;
    END;
    PRGNDATAHEADER       = POINTER TO RGNDATAHEADER;

    RGNDATA = RECORD
          rdh            : RGNDATAHEADER;
          Buffer         : ARRAY [0..1 - 1] OF ACHAR;
    END;
    PRGNDATA             = POINTER TO RGNDATA;
    LPRGNDATA            = PRGNDATA;

    ABC = RECORD
          abcA           : INTEGER;
          abcB           : UINT;
          abcC           : INTEGER;
    END;
    PABC                 = POINTER TO ABC;
    LPABC                = PABC;

    ABCFLOAT = RECORD
          abcfA          : WFLOAT;
          abcfB          : WFLOAT;
          abcfC          : WFLOAT;
    END;
    PABCFLOAT            = POINTER TO ABCFLOAT;
    LPABCFLOAT           = PABCFLOAT;

    OUTLINETEXTMETRICA = RECORD
          otmSize        : UINT;
          otmTextMetrics : TEXTMETRICA;
          otmFiller      : BYTE;
          otmPanoseNumber: PANOSE;
          otmfsSelection : UINT;
          otmfsType      : UINT;
          otmsCharSlopeRise: INTEGER;
          otmsCharSlopeRun: INTEGER;
          otmItalicAngle : INTEGER;
          otmEMSquare    : UINT;
          otmAscent      : INTEGER;
          otmDescent     : INTEGER;
          otmLineGap     : UINT;
          otmsCapEmHeight: UINT;
          otmsXHeight    : UINT;
          otmrcFontBox   : RECT;
          otmMacAscent   : INTEGER;
          otmMacDescent  : INTEGER;
          otmMacLineGap  : UINT;
          otmusMinimumPPEM: UINT;
          otmptSubscriptSize: POINT;
          otmptSubscriptOffset: POINT;
          otmptSuperscriptSize: POINT;
          otmptSuperscriptOffset: POINT;
          otmsStrikeoutSize: UINT;
          otmsStrikeoutPosition: INTEGER;
          otmsUnderscoreSize: INTEGER;
          otmsUnderscorePosition: INTEGER;
          otmpFamilyName : PSTR;
          otmpFaceName   : PSTR;
          otmpStyleName  : PSTR;
          otmpFullName   : PSTR;
    END;
    POUTLINETEXTMETRICA  = POINTER TO OUTLINETEXTMETRICA;
    LPOUTLINETEXTMETRICA = POUTLINETEXTMETRICA;

    OUTLINETEXTMETRICW = RECORD
          otmSize        : UINT;
          otmTextMetrics : TEXTMETRICW;
          otmFiller      : BYTE;
          otmPanoseNumber: PANOSE;
          otmfsSelection : UINT;
          otmfsType      : UINT;
          otmsCharSlopeRise: INTEGER;
          otmsCharSlopeRun: INTEGER;
          otmItalicAngle : INTEGER;
          otmEMSquare    : UINT;
          otmAscent      : INTEGER;
          otmDescent     : INTEGER;
          otmLineGap     : UINT;
          otmsCapEmHeight: UINT;
          otmsXHeight    : UINT;
          otmrcFontBox   : RECT;
          otmMacAscent   : INTEGER;
          otmMacDescent  : INTEGER;
          otmMacLineGap  : UINT;
          otmusMinimumPPEM: UINT;
          otmptSubscriptSize: POINT;
          otmptSubscriptOffset: POINT;
          otmptSuperscriptSize: POINT;
          otmptSuperscriptOffset: POINT;
          otmsStrikeoutSize: UINT;
          otmsStrikeoutPosition: INTEGER;
          otmsUnderscoreSize: INTEGER;
          otmsUnderscorePosition: INTEGER;
          otmpFamilyName : PSTR;
          otmpFaceName   : PSTR;
          otmpStyleName  : PSTR;
          otmpFullName   : PSTR;
    END;
    POUTLINETEXTMETRICW  = POINTER TO OUTLINETEXTMETRICW;
    LPOUTLINETEXTMETRICW = POUTLINETEXTMETRICW;

%IF UNICODE %THEN
    OUTLINETEXTMETRIC    = OUTLINETEXTMETRICW;
%ELSE
    OUTLINETEXTMETRIC    = OUTLINETEXTMETRICA;
%END
    POUTLINETEXTMETRIC   = POINTER TO OUTLINETEXTMETRIC;
    LPOUTLINETEXTMETRIC  = POUTLINETEXTMETRIC;

    POLYTEXTA = RECORD
          x              : INTEGER;
          y              : INTEGER;
          n              : UINT;
          lpstr          : LPCSTR;
          uiFlags        : UINT;
          rcl            : RECT;
          pdx            : POINTER TO INTEGER;
    END;
    PPOLYTEXTA           = POINTER TO POLYTEXTA;
    LPPOLYTEXTA          = PPOLYTEXTA;

    POLYTEXTW = RECORD
          x              : INTEGER;
          y              : INTEGER;
          n              : UINT;
          lpstr          : LPCWSTR;
          uiFlags        : UINT;
          rcl            : RECT;
          pdx            : POINTER TO INTEGER;
    END;
    PPOLYTEXTW           = POINTER TO POLYTEXTW;
    LPPOLYTEXTW          = PPOLYTEXTW;

%IF UNICODE %THEN
    POLYTEXT             = POLYTEXTW;
%ELSE
    POLYTEXT             = POLYTEXTA;
%END
    PPOLYTEXT            = POINTER TO POLYTEXT;
    LPPOLYTEXT           = PPOLYTEXT;

    FIXED = RECORD
          fract          : WORD;
          value          : INTEGER16;
    END;

    MAT2 = RECORD
          eM11           : FIXED;
          eM12           : FIXED;
          eM21           : FIXED;
          eM22           : FIXED;
    END;
    LPMAT2               = POINTER TO MAT2;

    GLYPHMETRICS = RECORD
          gmBlackBoxX    : UINT;
          gmBlackBoxY    : UINT;
          gmptGlyphOrigin: POINT;
          gmCellIncX     : INTEGER16;
          gmCellIncY     : INTEGER16;
    END;
    LPGLYPHMETRICS       = POINTER TO GLYPHMETRICS;

CONST
    GGO_METRICS          = 0;
    GGO_BITMAP           = 1;
    GGO_NATIVE           = 2;
    GGO_BEZIER           = 3;

    GGO_GRAY2_BITMAP   = 4;
    GGO_GRAY4_BITMAP   = 5;
    GGO_GRAY8_BITMAP   = 6;
    GGO_GLYPH_INDEX    = 80h;


    TT_POLYGON_TYPE      = 24;
    TT_PRIM_LINE         = 1;
    TT_PRIM_QSPLINE      = 2;
    TT_PRIM_CSPLINE    = 3;

TYPE
    POINTFX = RECORD
          x              : FIXED;
          y              : FIXED;
    END;
    LPPOINTFX            = POINTER TO POINTFX;

    TTPOLYCURVE = RECORD
          wType          : WORD;
          cpfx           : WORD;
          apfx           : ARRAY [0..1 - 1] OF POINTFX;
    END;
    LPTTPOLYCURVE        = POINTER TO TTPOLYCURVE;

    TTPOLYGONHEADER = RECORD
          cb             : DWORD;
          dwType         : DWORD;
          pfxStart       : POINTFX;
    END;
    LPTTPOLYGONHEADER    = POINTER TO TTPOLYGONHEADER;


CONST
    GCP_DBCS            = 0001h;
    GCP_REORDER         = 0002h;
    GCP_USEKERNING      = 0008h;
    GCP_GLYPHSHAPE      = 0010h;
    GCP_LIGATE          = 0020h;
    GCP_DIACRITIC       = 0100h;
    GCP_KASHIDA         = 0400h;
    GCP_ERROR           = 8000h;
    FLI_MASK            = 103Bh;

    GCP_JUSTIFY         = 00010000h;
    GCP_NODIACRITICS    = 00020000h;
    FLI_GLYPHS          = 00040000h;
    GCP_CLASSIN         = 00080000h;
    GCP_MAXEXTENT       = 00100000h;
    GCP_JUSTIFYIN        = 00200000h;
    GCP_DISPLAYZWG       = 00400000h;
    GCP_SYMSWAPOFF       = 00800000h;
    GCP_NUMERICOVERRIDE  = 01000000h;
    GCP_NEUTRALOVERRIDE  = 02000000h;
    GCP_NUMERICSLATIN    = 04000000h;
    GCP_NUMERICSLOCAL    = 08000000h;

    GCPCLASS_LATIN                  = 1;
    GCPCLASS_HEBREW                 = 2;
    GCPCLASS_ARABIC                 = 2;
    GCPCLASS_NEUTRAL                = 3;
    GCPCLASS_LOCALNUMBER            = 4;
    GCPCLASS_LATINNUMBER            = 5;
    GCPCLASS_LATINNUMERICTERMINATOR = 6;
    GCPCLASS_LATINNUMERICSEPARATOR  = 7;
    GCPCLASS_NUMERICSEPARATOR       = 8;
    GCPCLASS_PREBOUNDRTL            = 80h;
    GCPCLASS_PREBOUNDLTR            = 40h;
    GCPCLASS_POSTBOUNDLTR           = 20h;
    GCPCLASS_POSTBOUNDRTL           = 10h;
    GCPGLYPH_LINKBEFORE             = 8000h;
    GCPGLYPH_LINKAFTER              = 4000h;

TYPE
    GCP_RESULTSA = RECORD
        lStructSize     : DWORD;
        lpOutString     : LPSTR;
        lpOrder         : PUINT;
        lpDx            : PINT;
        lpCaretPos      : PINT;
        lpClass         : LPSTR;
        lpGlyphs        : LPWSTR;
        nGlyphs         : UINT;
        nMaxFit         : WINT;
    END;
    LPGCP_RESULTSA      = POINTER TO GCP_RESULTSA;

    GCP_RESULTSW = RECORD
        lStructSize     : DWORD;
        lpOutString     : LPWSTR;
        lpOrder         : PUINT;
        lpDx            : PINT;
        lpCaretPos      : PINT;
        lpClass         : LPSTR;
        lpGlyphs        : LPWSTR;
        nGlyphs         : UINT;
        nMaxFit         : WINT;
    END;
    LPGCP_RESULTSW      = POINTER TO GCP_RESULTSW;
%IF UNICODE %THEN
    GCP_RESULTS         = GCP_RESULTSW;
%ELSE
    GCP_RESULTS         = GCP_RESULTSA;
%END
    LPGCP_RESULTS       = POINTER TO GCP_RESULTS;


TYPE
    RASTERIZER_STATUS = RECORD
          nSize          : INTEGER16;
          wFlags         : INTEGER16;
          nLanguageID    : INTEGER16;
    END;
    LPRASTERIZER_STATUS  = POINTER TO RASTERIZER_STATUS;

CONST
    TT_AVAILABLE         = 00001h;
    TT_ENABLED           = 00002h;


TYPE
    PIXELFORMATDESCRIPTOR = RECORD
        nSize           : WORD;
        nVersion        : WORD;
        dwFlags         : DWORD;
        iPixelType      : BYTE;
        cColorBits      : BYTE;
        cRedBits        : BYTE;
        cRedShift       : BYTE;
        cGreenBits      : BYTE;
        cGreenShift     : BYTE;
        cBlueBits       : BYTE;
        cBlueShift      : BYTE;
        cAlphaBits      : BYTE;
        cAlphaShift     : BYTE;
        cAccumBits      : BYTE;
        cAccumRedBits   : BYTE;
        cAccumGreenBits : BYTE;
        cAccumBlueBits  : BYTE;
        cAccumAlphaBits : BYTE;
        cDepthBits      : BYTE;
        cStencilBits    : BYTE;
        cAuxBuffers             : BYTE;
        iLayerType              : BYTE;
        bReserved               : BYTE;
        dwLayerMask             : DWORD;
        dwVisibleMask   : DWORD;
        dwDamageMask    : DWORD;
    END;
    PPIXELFORMATDESCRIPTOR = POINTER TO PIXELFORMATDESCRIPTOR;
    LPPIXELFORMATDESCRIPTOR = PPIXELFORMATDESCRIPTOR;


CONST
    PFD_TYPE_RGBA        = 0;
    PFD_TYPE_COLORINDEX  = 1;

    PFD_MAIN_PLANE       = 0;
    PFD_OVERLAY_PLANE    = 1;
    PFD_UNDERLAY_PLANE   = -1;

    PFD_DOUBLEBUFFER           = 00000001h;
    PFD_STEREO                 = 00000002h;
    PFD_DRAW_TO_WINDOW         = 00000004h;
    PFD_DRAW_TO_BITMAP         = 00000008h;
    PFD_SUPPORT_GDI            = 00000010h;
    PFD_SUPPORT_OPENGL         = 00000020h;
    PFD_GENERIC_FORMAT         = 00000040h;
    PFD_NEED_PALETTE           = 00000080h;
    PFD_NEED_SYSTEM_PALETTE    = 00000100h;
    PFD_SWAP_EXCHANGE          = 000000200h;
    PFD_SWAP_COPY              = 000000400h;
    PFD_SWAP_LAYER_BUFFERS      =00000800h;
    PFD_GENERIC_ACCELERATED     =00001000h;
    PFD_SUPPORT_DIRECTDRAW      =00002000h;

    PFD_DEPTH_DONTCARE          =20000000h;
    PFD_DOUBLEBUFFER_DONTCARE  = 40000000h;
    PFD_STEREO_DONTCARE        = 80000000h;


TYPE
    OLDFONTENUMPROCA      = PROCEDURE(VAR LOGFONTA,
                                      VAR TEXTMETRICA,
                                      DWORD,
                                      LPARAM) : INTEGER [EXPORT];
    OLDFONTENUMPROCW      = PROCEDURE(VAR LOGFONTW,
                                      VAR TEXTMETRICW,
                                      DWORD,
                                      LPARAM) : INTEGER [EXPORT];

    FONTENUMPROCA = OLDFONTENUMPROCA;
    FONTENUMPROCW = OLDFONTENUMPROCW;

    %IF UNICODE %THEN
    OLDFONTENUMPROC = OLDFONTENUMPROCW;
    %ELSE
    OLDFONTENUMPROC = OLDFONTENUMPROCA;
    %END
    FONTENUMPROC         = OLDFONTENUMPROC;

    GOBJENUMPROC         = PROCEDURE(LPVOID, LPARAM) : INTEGER [EXPORT];
    LINEDDAPROC          = PROCEDURE(INTEGER, INTEGER, LPARAM) [EXPORT];

PROCEDURE AddFontResourceA(a : ARRAY OF ACHAR) : INTEGER;

PROCEDURE AddFontResourceW(a : ARRAY OF UCHAR) : INTEGER;

%IF UNICODE %THEN
PROCEDURE AddFontResource = AddFontResourceW;
%ELSE
PROCEDURE AddFontResource = AddFontResourceA;
%END

PROCEDURE AnimatePalette(a : HPALETTE;
                         b : UINT;
                         c : UINT;
                         d : ARRAY OF PALETTEENTRY) : BOOL;

PROCEDURE Arc(a : HDC;
              b : INTEGER;
              c : INTEGER;
              d : INTEGER;
              e : INTEGER;
              f : INTEGER;
              g : INTEGER;
              h : INTEGER;
              i : INTEGER) : BOOL;

PROCEDURE BitBlt(a : HDC;
                 b : INTEGER;
                 c : INTEGER;
                 d : INTEGER;
                 e : INTEGER;
                 f : HDC;
                 g : INTEGER;
                 h : INTEGER;
                 i : DWORD) : BOOL;

PROCEDURE CancelDC(a : HDC) : BOOL;

PROCEDURE Chord(a : HDC;
                b : INTEGER;
                c : INTEGER;
                d : INTEGER;
                e : INTEGER;
                f : INTEGER;
                g : INTEGER;
                h : INTEGER;
                i : INTEGER) : BOOL;

PROCEDURE ChoosePixelFormat(a : HDC; p : PIXELFORMATDESCRIPTOR) : WINT;

PROCEDURE CloseMetaFile(a : HDC) : HMETAFILE;

PROCEDURE CombineRgn(a : HRGN;
                     b : HRGN;
                     c : HRGN;
                     d : INTEGER) : INTEGER;

PROCEDURE CopyMetaFileA(a : HMETAFILE;
                        b : ARRAY OF ACHAR) : HMETAFILE;

PROCEDURE CopyMetaFileW(a : HMETAFILE;
                        b : ARRAY OF UCHAR) : HMETAFILE;

%IF UNICODE %THEN
PROCEDURE CopyMetaFile = CopyMetaFileW;
%ELSE
PROCEDURE CopyMetaFile = CopyMetaFileA;
%END

PROCEDURE CreateBitmap(a : INTEGER;
                       b : INTEGER;
                       c : UINT;
                       d : UINT;
                       e : LPVOID) : HBITMAP;

PROCEDURE CreateBitmapIndirect(VAR a : BITMAP) : HBITMAP;

PROCEDURE CreateBrushIndirect(VAR a : LOGBRUSH) : HBRUSH;

PROCEDURE CreateCompatibleBitmap(a : HDC;
                                 b : INTEGER;
                                 c : INTEGER) : HBITMAP;

PROCEDURE CreateDiscardableBitmap(a : HDC;
                                  b : INTEGER;
                                  c : INTEGER) : HBITMAP;

PROCEDURE CreateCompatibleDC(a : HDC) : HDC;

PROCEDURE CreateDCA(a : ARRAY OF ACHAR;
                    b : ARRAY OF ACHAR;
                    c : ARRAY OF ACHAR;
                    d : DEVMODEA) : HDC;

PROCEDURE CreateDCW(a : ARRAY OF UCHAR;
                    b : ARRAY OF UCHAR;
                    c : ARRAY OF UCHAR;
                    d : DEVMODEW) : HDC;

%IF UNICODE %THEN
PROCEDURE CreateDC = CreateDCW;
%ELSE
PROCEDURE CreateDC = CreateDCA;
%END

PROCEDURE CreateDIBitmap(a : HDC;
                         VAR b : BITMAPINFOHEADER;
                         c : DWORD;
                         d : LPVOID;
                         VAR e : BITMAPINFO;
                         f : UINT) : HBITMAP;

PROCEDURE CreateDIBPatternBrush(a : HGLOBAL;
                                b : UINT) : HBRUSH;

PROCEDURE CreateDIBPatternBrushPt(a : LPVOID;
                                  b : UINT) : HBRUSH;

PROCEDURE CreateEllipticRgn(a : INTEGER;
                            b : INTEGER;
                            c : INTEGER;
                            d : INTEGER) : HRGN;

PROCEDURE CreateEllipticRgnIndirect(VAR a : RECT) : HRGN;

PROCEDURE CreateFontIndirectA(VAR a : LOGFONTA) : HFONT;

PROCEDURE CreateFontIndirectW(VAR a : LOGFONTW) : HFONT;

%IF UNICODE %THEN
PROCEDURE CreateFontIndirect = CreateFontIndirectW;
%ELSE
PROCEDURE CreateFontIndirect = CreateFontIndirectA;
%END

PROCEDURE CreateFontA(a : INTEGER;
                      b : INTEGER;
                      c : INTEGER;
                      d : INTEGER;
                      e : INTEGER;
                      f : DWORD;
                      g : DWORD;
                      h : DWORD;
                      i : DWORD;
                      j : DWORD;
                      k : DWORD;
                      l : DWORD;
                      m : DWORD;
                      n : ARRAY OF ACHAR) : HFONT;

PROCEDURE CreateFontW(a : INTEGER;
                      b : INTEGER;
                      c : INTEGER;
                      d : INTEGER;
                      e : INTEGER;
                      f : DWORD;
                      g : DWORD;
                      h : DWORD;
                      i : DWORD;
                      j : DWORD;
                      k : DWORD;
                      l : DWORD;
                      m : DWORD;
                      n : ARRAY OF UCHAR) : HFONT;

%IF UNICODE %THEN
PROCEDURE CreateFont = CreateFontW;
%ELSE
PROCEDURE CreateFont = CreateFontA;
%END

PROCEDURE CreateHatchBrush(a : INTEGER;
                           b : COLORREF) : HBRUSH;

PROCEDURE CreateICA(a : ARRAY OF ACHAR;
                    b : ARRAY OF ACHAR;
                    c : ARRAY OF ACHAR;
                    d : DEVMODEA) : HDC;

PROCEDURE CreateICW(a : ARRAY OF UCHAR;
                    b : ARRAY OF UCHAR;
                    c : ARRAY OF UCHAR;
                    d : DEVMODEW) : HDC;

%IF UNICODE %THEN
PROCEDURE CreateIC = CreateICW;
%ELSE
PROCEDURE CreateIC = CreateICA;
%END

PROCEDURE CreateMetaFileA(a : ARRAY OF ACHAR) : HDC;

PROCEDURE CreateMetaFileW(a : ARRAY OF UCHAR) : HDC;

%IF UNICODE %THEN
PROCEDURE CreateMetaFile = CreateMetaFileW;
%ELSE
PROCEDURE CreateMetaFile = CreateMetaFileA;
%END

PROCEDURE CreatePalette(VAR a : LOGPALETTE) : HPALETTE;

PROCEDURE CreatePen(a : INTEGER;
                    b : INTEGER;
                    c : COLORREF) : HPEN;

PROCEDURE CreatePenIndirect(VAR a : LOGPEN) : HPEN;

PROCEDURE CreatePolyPolygonRgn(VAR a : ARRAY OF POINT;
                               VAR b : ARRAY OF WINT;
                               c : INTEGER;
                               d : INTEGER) : HRGN;

PROCEDURE CreatePatternBrush(a : HBITMAP) : HBRUSH;

PROCEDURE CreateRectRgn(a : INTEGER;
                        b : INTEGER;
                        c : INTEGER;
                        d : INTEGER) : HRGN;

PROCEDURE CreateRectRgnIndirect(VAR a : RECT) : HRGN;

PROCEDURE CreateRoundRectRgn(a : INTEGER;
                             b : INTEGER;
                             c : INTEGER;
                             d : INTEGER;
                             e : INTEGER;
                             f : INTEGER) : HRGN;

PROCEDURE CreateScalableFontResourceA(a : DWORD;
                                      b : ARRAY OF ACHAR;
                                      c : ARRAY OF ACHAR;
                                      d : ARRAY OF ACHAR) : BOOL;

PROCEDURE CreateScalableFontResourceW(a : DWORD;
                                      b : ARRAY OF UCHAR;
                                      c : ARRAY OF UCHAR;
                                      d : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE CreateScalableFontResource = CreateScalableFontResourceW;
%ELSE
PROCEDURE CreateScalableFontResource = CreateScalableFontResourceA;
%END

PROCEDURE CreateSolidBrush(a : COLORREF) : HBRUSH;

PROCEDURE DeleteDC(a : HDC) : BOOL;

PROCEDURE DeleteMetaFile(a : HMETAFILE) : BOOL;

PROCEDURE DeleteObject(a : HGDIOBJ) : BOOL;

(*95*)
PROCEDURE DescribePixelFormat(a: HDC;
                              b: WINT;
                              c: UINT;
                              VAR d: PIXELFORMATDESCRIPTOR) : WINT;

TYPE
    LPFNDEVMODE          = PROCEDURE (HWND, HMODULE, LPDEVMODE, LPSTR, LPSTR,
                                      LPDEVMODE, LPSTR, UINT):UINT [EXPORT];
    LPFNDEVCAPS          = PROCEDURE (LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE):DWORD[EXPORT];

CONST
    DM_UPDATE            = 1;
    DM_COPY              = 2;
    DM_PROMPT            = 4;
    DM_MODIFY            = 8;

    DM_IN_BUFFER         = DM_MODIFY;
    DM_IN_PROMPT         = DM_PROMPT;
    DM_OUT_BUFFER        = DM_COPY;
    DM_OUT_DEFAULT       = DM_UPDATE;

    DC_FIELDS            = 1;
    DC_PAPERS            = 2;
    DC_PAPERSIZE         = 3;
    DC_MINEXTENT         = 4;
    DC_MAXEXTENT         = 5;
    DC_BINS              = 6;
    DC_DUPLEX            = 7;
    DC_SIZE              = 8;
    DC_EXTRA             = 9;
    DC_VERSION           = 10;
    DC_DRIVER            = 11;
    DC_BINNAMES          = 12;
    DC_ENUMRESOLUTIONS   = 13;
    DC_FILEDEPENDENCIES  = 14;
    DC_TRUETYPE          = 15;
    DC_PAPERNAMES        = 16;
    DC_ORIENTATION       = 17;
    DC_COPIES            = 18;

    DC_BINADJUST           = 19;
    DC_EMF_COMPLIANT       = 20;
    DC_DATATYPE_PRODUCED   = 21;
    DC_COLLATE             = 22;
    DC_MANUFACTURER        = 23;
    DC_MODEL               = 24;

%IF WIN5 %THEN
    DC_COLORDEVICE          =23;
    DC_NUP                  =24;
    DC_PERSONALITY          =25;
    DC_PRINTRATE            =26;
    DC_PRINTRATEUNIT        =27;
      PRINTRATEUNIT_PPM     =1;
      PRINTRATEUNIT_CPS     =2;
      PRINTRATEUNIT_LPM     =3;
      PRINTRATEUNIT_IPM     =4;
    DC_PRINTERMEM           =28;
    DC_MEDIAREADY           =29;
%END

    DCTT_BITMAP          = 00000001h;
    DCTT_DOWNLOAD        = 00000002h;
    DCTT_SUBDEV          = 00000004h;


    DCTT_DOWNLOAD_OUTLINE   = 0000008h;

    DCBA_FACEUPNONE       = 0;
    DCBA_FACEUPCENTER     = 1h;
    DCBA_FACEUPLEFT       = 2h;
    DCBA_FACEUPRIGHT      = 3h;
    DCBA_FACEDOWNNONE     = 0100h;
    DCBA_FACEDOWNCENTER   = 0101h;
    DCBA_FACEDOWNLEFT     = 0102h;
    DCBA_FACEDOWNRIGHT    = 0103h;


PROCEDURE DeviceCapabilitiesA(a : ARRAY OF ACHAR;
                              b : ARRAY OF ACHAR;
                              c : WORD;
                              VAR d : ARRAY OF ACHAR;
                              VAR e : DEVMODEA) : INTEGER;

PROCEDURE DeviceCapabilitiesW(a : ARRAY OF UCHAR;
                              b : ARRAY OF UCHAR;
                              c : WORD;
                              VAR d : ARRAY OF UCHAR;
                              VAR e : DEVMODEW) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DeviceCapabilities = DeviceCapabilitiesW;
%ELSE
PROCEDURE DeviceCapabilities = DeviceCapabilitiesA;
%END

PROCEDURE Ellipse(a : HDC;
                  b : INTEGER;
                  c : INTEGER;
                  d : INTEGER;
                  e : INTEGER) : BOOL;


PROCEDURE EnumFontFamiliesExA(a: HDC;
                              b: LPLOGFONTA;
                              c: FONTENUMPROC;
                              d: LPARAM;
                              e: DWORD) : WINT;

PROCEDURE EnumFontFamiliesExW(a: HDC;
                              b: LPLOGFONTW;
                              c: FONTENUMPROC;
                              d: LPARAM;
                              e: DWORD) : WINT;
%IF UNICODE %THEN
PROCEDURE EnumFontFamiliesEx = EnumFontFamiliesExW;
%ELSE
PROCEDURE EnumFontFamiliesEx = EnumFontFamiliesExA;
%END


PROCEDURE EnumFontFamiliesA(a : HDC;
                            b : ARRAY OF ACHAR;
                            c : FONTENUMPROC;
                            d : LPARAM) : INTEGER;

PROCEDURE EnumFontFamiliesW(a : HDC;
                            b : ARRAY OF UCHAR;
                            c : FONTENUMPROC;
                            d : LPARAM) : INTEGER;

%IF UNICODE %THEN
PROCEDURE EnumFontFamilies = EnumFontFamiliesW;
%ELSE
PROCEDURE EnumFontFamilies = EnumFontFamiliesA;
%END

PROCEDURE EnumFontsA(a : HDC;
                     b : ARRAY OF ACHAR;
                     c : FONTENUMPROC;
                     d : LPARAM) : INTEGER;

PROCEDURE EnumFontsW(a : HDC;
                     b : ARRAY OF UCHAR;
                     c : FONTENUMPROC;
                     d : LPARAM) : INTEGER;

%IF UNICODE %THEN
PROCEDURE EnumFonts = EnumFontsW;
%ELSE
PROCEDURE EnumFonts = EnumFontsA;
%END

PROCEDURE EnumObjects(a : HDC;
                      b : INTEGER;
                      c : GOBJENUMPROC;
                      d : LPARAM) : INTEGER;

PROCEDURE EqualRgn(a : HRGN;
                   b : HRGN) : BOOL;

PROCEDURE Escape(a : HDC;
                 b : INTEGER;
                 c : INTEGER;
                 d : ARRAY OF LOC;
                 VAR e : ARRAY OF LOC) : INTEGER;

PROCEDURE ExtEscape(a : HDC;
                    b : INTEGER;
                    c : INTEGER;
                    d : ARRAY OF LOC;
                    e : INTEGER;
                    VAR f : ARRAY OF LOC) : INTEGER;

PROCEDURE DrawEscape(a : HDC;
                     b : INTEGER;
                     c : INTEGER;
                     d : ARRAY OF LOC) : INTEGER;

PROCEDURE ExcludeClipRect(a : HDC;
                          b : INTEGER;
                          c : INTEGER;
                          d : INTEGER;
                          e : INTEGER) : INTEGER;

PROCEDURE ExtCreateRegion(VAR a : XFORM;
                          b : DWORD;
                          VAR c : RGNDATA) : HRGN;

PROCEDURE ExtFloodFill(a : HDC;
                       b : INTEGER;
                       c : INTEGER;
                       d : COLORREF;
                       e : UINT) : BOOL;

PROCEDURE FillRgn(a : HDC;
                  b : HRGN;
                  c : HBRUSH) : BOOL;

PROCEDURE FloodFill(a : HDC;
                    b : INTEGER;
                    c : INTEGER;
                    d : COLORREF) : BOOL;

PROCEDURE FrameRgn(a : HDC;
                   b : HRGN;
                   c : HBRUSH;
                   d : INTEGER;
                   e : INTEGER) : BOOL;

PROCEDURE GetROP2(a : HDC) : INTEGER;

PROCEDURE GetAspectRatioFilterEx(a : HDC;
                                 VAR b : WSIZE) : BOOL;

PROCEDURE GetBkColor(a : HDC) : COLORREF;

%IF WIN5 %THEN
(*NT only*)
PROCEDURE GetDCBrushColor(dc : HDC) : COLORREF;

(*NT only*)
PROCEDURE GetDCPenColor(dc : HDC) : COLORREF;
%END

PROCEDURE GetBkMode(a : HDC) : INTEGER;

PROCEDURE GetBitmapBits(a : HBITMAP;
                        b : LONG;
                        c : LPVOID) : LONG;

PROCEDURE GetBitmapDimensionEx(a : HBITMAP;
                               VAR b : WSIZE) : BOOL;

PROCEDURE GetBoundsRect(a : HDC;
                        VAR b : RECT;
                        c : UINT) : UINT;

PROCEDURE GetBrushOrgEx(a : HDC;
                        VAR b : POINT) : BOOL;

PROCEDURE GetCharWidthA(a : HDC;
                        b : UINT;
                        c : UINT;
                        VAR d : WINT) : BOOL;

PROCEDURE GetCharWidthW(a : HDC;
                        b : UINT;
                        c : UINT;
                        VAR d : WINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetCharWidth = GetCharWidthW;
%ELSE
PROCEDURE GetCharWidth = GetCharWidthA;
%END

PROCEDURE GetCharWidth32W(a : HDC;
                          b : UINT;
                          c : UINT;
                          VAR d : WINT) : BOOL;

PROCEDURE GetCharWidth32A(a : HDC;
                          b : UINT;
                          c : UINT;
                          VAR d : WINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetCharWidth32 = GetCharWidth32W;
%ELSE
PROCEDURE GetCharWidth32 = GetCharWidth32A;
%END

PROCEDURE GetCharWidthFloatA(a : HDC;
                             b : UINT;
                             c : UINT;
                             VAR d : WFLOAT) : BOOL;

PROCEDURE GetCharWidthFloatW(a : HDC;
                             b : UINT;
                             c : UINT;
                             VAR d : WFLOAT) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetCharWidthFloat = GetCharWidthFloatW;
%ELSE
PROCEDURE GetCharWidthFloat = GetCharWidthFloatA;
%END

PROCEDURE GetCharABCWidthsA(a : HDC;
                            b : UINT;
                            c : UINT;
                            VAR d : ABC) : BOOL;

PROCEDURE GetCharABCWidthsW(a : HDC;
                            b : UINT;
                            c : UINT;
                            VAR d : ABC) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetCharABCWidths = GetCharABCWidthsW;
%ELSE
PROCEDURE GetCharABCWidths = GetCharABCWidthsA;
%END

PROCEDURE GetCharABCWidthsFloatA(a : HDC;
                                 b : UINT;
                                 c : UINT;
                                 VAR d : ABCFLOAT) : BOOL;

PROCEDURE GetCharABCWidthsFloatW(a : HDC;
                                 b : UINT;
                                 c : UINT;
                                 VAR d : ABCFLOAT) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetCharABCWidthsFloat = GetCharABCWidthsFloatW;
%ELSE
PROCEDURE GetCharABCWidthsFloat = GetCharABCWidthsFloatA;
%END

PROCEDURE GetClipBox(a : HDC;
                     VAR b : RECT) : INTEGER;

PROCEDURE GetClipRgn(a : HDC;
                     b : HRGN) : INTEGER;

PROCEDURE GetMetaRgn(a : HDC;
                     b : HRGN) : INTEGER;

PROCEDURE GetCurrentObject(a : HDC;
                           b : UINT) : HGDIOBJ;

PROCEDURE GetCurrentPositionEx(a : HDC;
                               VAR b : POINT) : BOOL;

PROCEDURE GetDeviceCaps(a : HDC;
                        b : INTEGER) : INTEGER;

PROCEDURE GetDIBits(a : HDC;
                    b : HBITMAP;
                    c : UINT;
                    d : UINT;
                    e : LPVOID;
                    VAR f : BITMAPINFO;
                    g : UINT) : INTEGER;

PROCEDURE GetFontData(a : HDC;
                      b : DWORD;
                      c : DWORD;
                      d : LPVOID;
                      e : DWORD) : DWORD;

PROCEDURE GetGlyphOutlineA(a : HDC;
                           b : UINT;
                           c : UINT;
                           d : GLYPHMETRICS;
                           e : DWORD;
                           f : LPVOID;
                           VAR g : MAT2) : DWORD;

PROCEDURE GetGlyphOutlineW(a : HDC;
                           b : UINT;
                           c : UINT;
                           d : GLYPHMETRICS;
                           e : DWORD;
                           f : LPVOID;
                           VAR g : MAT2) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetGlyphOutline = GetGlyphOutlineW;
%ELSE
PROCEDURE GetGlyphOutline = GetGlyphOutlineA;
%END

PROCEDURE GetGraphicsMode(a : HDC) : INTEGER;

PROCEDURE GetMapMode(a : HDC) : INTEGER;

PROCEDURE GetMetaFileBitsEx(a : HMETAFILE;
                            b : UINT;
                            c : LPVOID) : UINT;

PROCEDURE GetMetaFileA(a : ARRAY OF ACHAR) : HMETAFILE;

PROCEDURE GetMetaFileW(a : ARRAY OF UCHAR) : HMETAFILE;

%IF UNICODE %THEN
PROCEDURE GetMetaFile = GetMetaFileW;
%ELSE
PROCEDURE GetMetaFile = GetMetaFileA;
%END

PROCEDURE GetNearestColor(a : HDC;
                          b : COLORREF) : COLORREF;

PROCEDURE GetNearestPaletteIndex(a : HPALETTE;
                                 b : COLORREF) : UINT;

PROCEDURE GetObjectType(h : HGDIOBJ) : DWORD;

PROCEDURE GetOutlineTextMetricsA(a : HDC;
                                 b : UINT;
                                 VAR c : OUTLINETEXTMETRICA) : UINT;

PROCEDURE GetOutlineTextMetricsW(a : HDC;
                                 b : UINT;
                                 VAR c : OUTLINETEXTMETRICW) : UINT;

%IF UNICODE %THEN
PROCEDURE GetOutlineTextMetrics = GetOutlineTextMetricsW;
%ELSE
PROCEDURE GetOutlineTextMetrics = GetOutlineTextMetricsA;
%END

PROCEDURE GetPaletteEntries(a : HPALETTE;
                            b : UINT;
                            c : UINT;
                            VAR d : ARRAY OF PALETTEENTRY) : UINT;

PROCEDURE GetPixel(a : HDC;
                   b : INTEGER;
                   c : INTEGER) : COLORREF;

(*95*)
PROCEDURE GetPixelFormat(a: HDC) : WINT;


PROCEDURE GetPolyFillMode(a : HDC) : INTEGER;

PROCEDURE GetRasterizerCaps(VAR a : RASTERIZER_STATUS;
                            b : UINT) : BOOL;

PROCEDURE GetRegionData(a : HRGN;
                        b : DWORD;
                        VAR c : RGNDATA) : DWORD;

PROCEDURE GetRgnBox(a : HRGN;
                    VAR b : RECT) : INTEGER;

PROCEDURE GetStockObject(a : INTEGER) : HGDIOBJ;

PROCEDURE GetStretchBltMode(a : HDC) : INTEGER;

PROCEDURE GetSystemPaletteEntries(a : HDC;
                                  b : UINT;
                                  c : UINT;
                                  VAR d : ARRAY OF PALETTEENTRY) : UINT;

PROCEDURE GetSystemPaletteUse(a : HDC) : UINT;

PROCEDURE GetTextCharacterExtra(a : HDC) : INTEGER;

PROCEDURE GetTextAlign(a : HDC) : UINT;

PROCEDURE GetTextColor(a : HDC) : COLORREF;

PROCEDURE GetTextExtentPointA(a : HDC;
                              b : ARRAY OF ACHAR;
                              c : INTEGER;
                              VAR d : WSIZE) : BOOL;

PROCEDURE GetTextExtentPointW(a : HDC;
                              b : ARRAY OF UCHAR;
                              c : INTEGER;
                              VAR d : WSIZE) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetTextExtentPoint = GetTextExtentPointW;
%ELSE
PROCEDURE GetTextExtentPoint = GetTextExtentPointA;
%END

PROCEDURE GetTextExtentPoint32A(a : HDC;
                                b : ARRAY OF ACHAR;
                                c : INTEGER;
                                VAR d : WSIZE) : BOOL;

PROCEDURE GetTextExtentPoint32W(a : HDC;
                                b : ARRAY OF UCHAR;
                                c : INTEGER;
                                VAR d : WSIZE) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetTextExtentPoint32 = GetTextExtentPoint32W;
%ELSE
PROCEDURE GetTextExtentPoint32 = GetTextExtentPoint32A;
%END

PROCEDURE GetTextExtentExPointA(a : HDC;
                                b : ARRAY OF ACHAR;
                                c : INTEGER;
                                d : INTEGER;
                                VAR e : WINT;
                                VAR f : WINT;
                                VAR g : WSIZE) : BOOL;

PROCEDURE GetTextExtentExPointW(a : HDC;
                                b : ARRAY OF UCHAR;
                                c : INTEGER;
                                d : INTEGER;
                                VAR e : WINT;
                                VAR f : WINT;
                                VAR g : WSIZE) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetTextExtentExPoint = GetTextExtentExPointW;
%ELSE
PROCEDURE GetTextExtentExPoint = GetTextExtentExPointA;
%END


PROCEDURE GetTextCharset(hdc : HDC) : WINT;

PROCEDURE GetTextCharsetInfo(hdc : HDC;
                             VAR lpSig : FONTSIGNATURE;
                             dwFlags : DWORD) : WINT;

PROCEDURE TranslateCharsetInfo(VAR lpSrc : DWORD;
                               VAR lpCs : CHARSETINFO;
                               dwFlags : DWORD) : BOOL;

PROCEDURE GetFontLanguageInfo(a: HDC) : DWORD;

PROCEDURE GetCharacterPlacementA(a: HDC;
                                 b: ARRAY OF ACHAR;
                                 d: WINT;
                                 e: WINT;
                                 VAR OUT f: GCP_RESULTSA;
                                 g: DWORD) : DWORD;

PROCEDURE GetCharacterPlacementW(a: HDC;
                                 b: ARRAY OF UCHAR;
                                 d: WINT;
                                 e: WINT;
                                 VAR OUT f: GCP_RESULTSW;
                                 g: DWORD) : DWORD;
%IF UNICODE %THEN
PROCEDURE GetCharacterPlacement = GetCharacterPlacementW;
%ELSE
PROCEDURE GetCharacterPlacement = GetCharacterPlacementA;
%END

%IF WIN5 %THEN
TYPE
(*NT only*)
    WCRANGE = RECORD
    wcLow       : WCHAR;
    cGlyphs     : USHORT;
    END;
    PWCRANGE = POINTER TO WCRANGE;
    LPWCRANGE = PWCRANGE;

(*NT only*)
    GLYPHSET = RECORD
    cbThis      : DWORD;
    flAccel     : DWORD;
    cGlyphsSupported : DWORD;
    cRanges     : DWORD;
    ranges      : ARRAY [0..1-1] OF WCRANGE;
    END;
    PGLYPHSET = POINTER TO GLYPHSET;
    LPGLYPHSET = PGLYPHSET;

CONST
(* flAccel flags for the GLYPHSET structure above *)
    GS_8BIT_INDICES     = 000000001h;

(* flags for GetGlyphIndices *)
    GGI_MARK_NONEXISTING_GLYPHS  = 0001h;

(*NT only*)
PROCEDURE GetFontUnicodeRanges(dc : HDC; VAR b : GLYPHSET) : DWORD;

(*NT only*)
PROCEDURE GetGlyphIndicesA(a : HDC;
                           b : ARRAY OF ACHAR;
                           c : WINT;
                           VAR d : WORD;
                           e : DWORD) : DWORD;

(*NT only*)
PROCEDURE GetGlyphIndicesW(a : HDC;
                           b : ARRAY OF UCHAR;
                           c : WINT;
                           VAR d : WORD;
                           e : DWORD) : DWORD;

%IF UNICODE %THEN
(*NT only*)
PROCEDURE GetGlyphIndices = GetGlyphIndicesW;
%ELSE
(*NT only*)
PROCEDURE GetGlyphIndices = GetGlyphIndicesA;
%END

(*NT only*)
PROCEDURE GetTextExtentPointI(a : HDC;
                              VAR b : WORD;
                              c : WINT;
                              VAR d : WSIZE) : BOOL;

(*NT only*)
PROCEDURE GetTextExtentExPointI(a : HDC;
                                VAR b : WORD;
                                c : WINT;
                                d : WINT;
                                VAR e : WINT;
                                VAR f : WINT;
                                VAR g : WSIZE) : BOOL;

(*NT only*)
PROCEDURE GetCharWidthI(a : HDC;
                        b : UINT;
                        c : UINT;
                        VAR d : WORD;
                        VAR e : WINT) : BOOL;

(*NT only*)
PROCEDURE GetCharABCWidthsI(a : HDC;
                            b : UINT;
                            c : UINT;
                            VAR d : WORD;
                            VAR e : ABC) : BOOL;

CONST
    STAMP_DESIGNVECTOR  =(8000000h + ORD('d') + (ORD('v')SHL 8));
    STAMP_AXESLIST      =(8000000h + ORD('a') + (ORD('l') SHL 8));
    MM_MAX_NUMAXES      =16;

TYPE
    DESIGNVECTOR = RECORD
    dvReserved          : DWORD;
    dvNumAxes           : DWORD;
    dvValues            : ARRAY [0..MM_MAX_NUMAXES-1] OF LONG;
    END;
    PDESIGNVECTOR = POINTER TO DESIGNVECTOR;
    LPDESIGNVECTOR = PDESIGNVECTOR;

(*NT only*)
PROCEDURE AddFontResourceExA(a : ARRAY OF ACHAR;
                             b : DWORD;
                             c : DESIGNVECTOR) : WINT;

(*NT only*)
PROCEDURE AddFontResourceExW(a : ARRAY OF UCHAR;
                             b : DWORD;
                             c : DESIGNVECTOR) : WINT;

%IF UNICODE %THEN
(*NT only*)
PROCEDURE AddFontResourceEx = AddFontResourceExW;
%ELSE
(*NT only*)
PROCEDURE AddFontResourceEx = AddFontResourceExA;
%END

(*NT only*)
PROCEDURE RemoveFontResourceExA(a : ARRAY OF ACHAR;
                                b : DWORD;
                                c : DESIGNVECTOR) : BOOL;

(*NT only*)
PROCEDURE RemoveFontResourceExW(a : ARRAY OF UCHAR;
                                b : DWORD;
                                c : DESIGNVECTOR) : BOOL;

%IF UNICODE %THEN
(*NT only*)
PROCEDURE RemoveFontResourceEx = RemoveFontResourceExW;
%ELSE
(*NT only*)
PROCEDURE RemoveFontResourceEx = RemoveFontResourceExA;
%END

(*NT only*)
PROCEDURE AddFontMemResourceEx(a : PVOID;
                               b : DWORD;
                               c : DESIGNVECTOR;
                               VAR d : DWORD) : HANDLE;

(*NT only*)
PROCEDURE RemoveFontMemResourceEx(a : HANDLE) : BOOL;

CONST
    FR_PRIVATE     =010h;
    FR_NOT_ENUM    =020h;

(* The actual size of the DESIGNVECTOR and ENUMLOGFONTEXDV structures*)
(* is determined by dvNumAxes,*)
(* MM_MAX_NUMAXES only detemines the maximal size allowed*)

    MM_MAX_AXES_NAMELEN =16;

TYPE
    AXISINFOA = RECORD
    axMinValue  : LONG;
    axMaxValue  : LONG;
    axAxisName  : ARRAY [0..MM_MAX_AXES_NAMELEN-1] OF ACHAR;
    END;
    PAXISINFOA = POINTER TO AXISINFOA;
    LPAXISINFOA = PAXISINFOA;

    AXISINFOW = RECORD
    axMinValue  : LONG;
    axMaxValue  : LONG;
    axAxisName  : ARRAY [0..MM_MAX_AXES_NAMELEN-1] OF UCHAR;
    END;
    PAXISINFOW = POINTER TO AXISINFOW;
    LPAXISINFOW = PAXISINFOW;

%IF UNICODE %THEN
    AXISINFO = AXISINFOW;
    PAXISINFO = PAXISINFOW;
    LPAXISINFO = LPAXISINFOW;
%ELSE
    AXISINFO = AXISINFOA;
    PAXISINFO = PAXISINFOA;
    LPAXISINFO = LPAXISINFOA;
%END

    AXESLISTA = RECORD
    axlReserved         : DWORD;
    axlNumAxes          : DWORD;
    axlAxisInfo         : ARRAY [0..MM_MAX_NUMAXES-1] OF AXISINFOA;
    END;
    PAXESLISTA = POINTER TO AXESLISTA;
    LPAXESLISTA = PAXESLISTA;

    AXESLISTW = RECORD
    axlReserved         : DWORD;
    axlNumAxes          : DWORD;
    axlAxisInfo         : ARRAY [0..MM_MAX_NUMAXES-1] OF AXISINFOW;
    END;
    PAXESLISTW = POINTER TO AXESLISTW;
    LPAXESLISTW = PAXESLISTW;

(* The actual size of the AXESLIST and ENUMTEXTMETRIC structure is*)
(* determined by axlNumAxes,*)
(* MM_MAX_NUMAXES only detemines the maximal size allowed*)

    ENUMLOGFONTEXDVA= RECORD
    elfEnumLogfontEx    : ENUMLOGFONTEXA;
    elfDesignVector     : DESIGNVECTOR;
    END;
    PENUMLOGFONTEXDVA = POINTER TO ENUMLOGFONTEXDVA;
    LPENUMLOGFONTEXDVA = PENUMLOGFONTEXDVA;

    ENUMLOGFONTEXDVW= RECORD
    elfEnumLogfontEx    : ENUMLOGFONTEXW;
    elfDesignVector     : DESIGNVECTOR;
    END;
    PENUMLOGFONTEXDVW = POINTER TO ENUMLOGFONTEXDVW;
    LPENUMLOGFONTEXDVW = PENUMLOGFONTEXDVW;

%IF UNICODE %THEN
    ENUMLOGFONTEXDV     = ENUMLOGFONTEXDVW;
    PENUMLOGFONTEXDV    = PENUMLOGFONTEXDVW;
    LPENUMLOGFONTEXDV   = LPENUMLOGFONTEXDVW;
%ELSE
    ENUMLOGFONTEXDV     = ENUMLOGFONTEXDVA;
    PENUMLOGFONTEXDV    = PENUMLOGFONTEXDVA;
    LPENUMLOGFONTEXDV   = LPENUMLOGFONTEXDVA;
%END

(*NT only*)
PROCEDURE CreateFontIndirectExA(a : ENUMLOGFONTEXDVA) : HFONT;

(*NT only*)
PROCEDURE CreateFontIndirectExW(a : ENUMLOGFONTEXDVW) : HFONT;

%IF UNICODE %THEN
(*NT only*)
PROCEDURE CreateFontIndirectEx = CreateFontIndirectExW;
%ELSE
(*NT only*)
PROCEDURE CreateFontIndirectEx = CreateFontIndirectExA;
%END

TYPE
    ENUMTEXTMETRICA = RECORD
    etmNewTextMetricEx  : NEWTEXTMETRICEXA;
    etmAxesList         : AXESLISTA;
    END;
    PENUMTEXTMETRICA = POINTER TO ENUMTEXTMETRICA;
    LPENUMTEXTMETRICA = PENUMTEXTMETRICA;

    ENUMTEXTMETRICW = RECORD
    etmNewTextMetricEx  : NEWTEXTMETRICEXW;
    etmAxesList         : AXESLISTW;
    END;
    PENUMTEXTMETRICW = POINTER TO ENUMTEXTMETRICW;
    LPENUMTEXTMETRICW = PENUMTEXTMETRICW;

    %IF UNICODE %THEN
    ENUMTEXTMETRIC      = ENUMTEXTMETRICW;
    PENUMTEXTMETRIC     = PENUMTEXTMETRICW;
    LPENUMTEXTMETRIC    = LPENUMTEXTMETRICW;
    %ELSE
    ENUMTEXTMETRIC      = ENUMTEXTMETRICA;
    PENUMTEXTMETRIC     = PENUMTEXTMETRICA;
    LPENUMTEXTMETRIC    = LPENUMTEXTMETRICA;
    %END
%END

PROCEDURE GetViewportExtEx(a : HDC;
                           VAR b : WSIZE) : BOOL;

PROCEDURE GetViewportOrgEx(a : HDC;
                           VAR b : POINT) : BOOL;

PROCEDURE GetWindowExtEx(a : HDC;
                         VAR b : WSIZE) : BOOL;

PROCEDURE GetWindowOrgEx(a : HDC;
                         VAR b : POINT) : BOOL;

PROCEDURE IntersectClipRect(a : HDC;
                            b : INTEGER;
                            c : INTEGER;
                            d : INTEGER;
                            e : INTEGER) : INTEGER;

PROCEDURE InvertRgn(a : HDC;
                    b : HRGN) : BOOL;

PROCEDURE LineDDA(a : INTEGER;
                  b : INTEGER;
                  c : INTEGER;
                  d : INTEGER;
                  e : LINEDDAPROC;
                  f : LPARAM) : BOOL;

PROCEDURE LineTo(a : HDC;
                 b : INTEGER;
                 c : INTEGER) : BOOL;

PROCEDURE MaskBlt(a : HDC;
                  b : INTEGER;
                  c : INTEGER;
                  d : INTEGER;
                  e : INTEGER;
                  f : HDC;
                  g : INTEGER;
                  h : INTEGER;
                  i : HBITMAP;
                  j : INTEGER;
                  k : INTEGER;
                  l : DWORD) : BOOL;

PROCEDURE PlgBlt(a : HDC;
                 VAR b : ARRAY OF POINT;
                 c : HDC;
                 d : INTEGER;
                 e : INTEGER;
                 f : INTEGER;
                 g : INTEGER;
                 h : HBITMAP;
                 i : INTEGER;
                 j : INTEGER) : BOOL;

PROCEDURE OffsetClipRgn(a : HDC;
                        b : INTEGER;
                        c : INTEGER) : INTEGER;

PROCEDURE OffsetRgn(a : HRGN;
                    b : INTEGER;
                    c : INTEGER) : INTEGER;

PROCEDURE PatBlt(a : HDC;
                 b : INTEGER;
                 c : INTEGER;
                 d : INTEGER;
                 e : INTEGER;
                 f : DWORD) : BOOL;

PROCEDURE Pie(a : HDC;
              b : INTEGER;
              c : INTEGER;
              d : INTEGER;
              e : INTEGER;
              f : INTEGER;
              g : INTEGER;
              h : INTEGER;
              i : INTEGER) : BOOL;

PROCEDURE PlayMetaFile(a : HDC;
                       b : HMETAFILE) : BOOL;

PROCEDURE PaintRgn(a : HDC;
                   b : HRGN) : BOOL;

PROCEDURE PolyPolygon(a : HDC;
                      VAR b : ARRAY OF POINT;
                      VAR c : ARRAY OF WINT;
                      d : INTEGER) : BOOL;

PROCEDURE PtInRegion(a : HRGN;
                     b : INTEGER;
                     c : INTEGER) : BOOL;

PROCEDURE PtVisible(a : HDC;
                    b : INTEGER;
                    c : INTEGER) : BOOL;

PROCEDURE RectInRegion(a : HRGN;
                       VAR b : RECT) : BOOL;

PROCEDURE RectVisible(a : HDC;
                      VAR b : RECT) : BOOL;

PROCEDURE Rectangle(a : HDC;
                    b : INTEGER;
                    c : INTEGER;
                    d : INTEGER;
                    e : INTEGER) : BOOL;

PROCEDURE RestoreDC(a : HDC;
                    b : INTEGER) : BOOL;

PROCEDURE ResetDCA(a : HDC;
                   VAR b : DEVMODEA) : HDC;

PROCEDURE ResetDCW(a : HDC;
                   VAR b : DEVMODEW) : HDC;


%IF UNICODE %THEN
PROCEDURE ResetDC = ResetDCW;
%ELSE
PROCEDURE ResetDC = ResetDCA;
%END

PROCEDURE RealizePalette(a : HDC) : UINT;

PROCEDURE RemoveFontResourceA(a : ARRAY OF ACHAR) : BOOL;

PROCEDURE RemoveFontResourceW(a : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE RemoveFontResource = RemoveFontResourceW;
%ELSE
PROCEDURE RemoveFontResource = RemoveFontResourceA;
%END

PROCEDURE RoundRect(a : HDC;
                    b : INTEGER;
                    c : INTEGER;
                    d : INTEGER;
                    e : INTEGER;
                    f : INTEGER;
                    g : INTEGER) : BOOL;

PROCEDURE ResizePalette(a : HPALETTE;
                        b : UINT) : BOOL;

PROCEDURE SaveDC(a : HDC) : INTEGER;

PROCEDURE SelectClipRgn(a : HDC;
                        b : HRGN) : INTEGER;

PROCEDURE ExtSelectClipRgn(a : HDC;
                           b : HRGN;
                           c : INTEGER) : INTEGER;

PROCEDURE SetMetaRgn(a : HDC) : INTEGER;

PROCEDURE SelectObject(a : HDC;
                       b : HGDIOBJ) : HGDIOBJ;

PROCEDURE SelectPalette(a : HDC;
                        b : HPALETTE;
                        c : BOOL) : HPALETTE;

PROCEDURE SetBkColor(a : HDC;
                     b : COLORREF) : COLORREF;

%IF WIN5 %THEN
(*NT only*)
PROCEDURE SetDCBrushColor(a : HDC; b : COLORREF) : COLORREF;

(*NT only*)
PROCEDURE SetDCPenColor(a : HDC; b : COLORREF) : COLORREF;
%END

PROCEDURE SetBkMode(a : HDC;
                    b : INTEGER) : INTEGER;

PROCEDURE SetBitmapBits(a : HBITMAP;
                        b : DWORD;
                        c : LPVOID) : LONG;

PROCEDURE SetBoundsRect(a : HDC;
                        VAR b : RECT;
                        c : UINT) : UINT;

PROCEDURE SetDIBits(a : HDC;
                    b : HBITMAP;
                    c : UINT;
                    d : UINT;
                    e : LPVOID;
                    VAR f : BITMAPINFO;
                    g : UINT) : INTEGER;

PROCEDURE SetDIBitsToDevice(a : HDC;
                            b : INTEGER;
                            c : INTEGER;
                            d : DWORD;
                            e : DWORD;
                            f : INTEGER;
                            g : INTEGER;
                            h : UINT;
                            i : UINT;
                            j : LPVOID;
                            VAR k : BITMAPINFO;
                            l : UINT) : INTEGER;

PROCEDURE SetMapperFlags(a : HDC;
                         b : DWORD) : DWORD;

PROCEDURE SetGraphicsMode(hdc : HDC;
                          iMode : INTEGER) : INTEGER;

PROCEDURE SetMapMode(a : HDC;
                     b : INTEGER) : INTEGER;

PROCEDURE SetMetaFileBitsEx(a : UINT;
                            VAR b : BYTE) : HMETAFILE;

PROCEDURE SetPaletteEntries(a : HPALETTE;
                            b : UINT;
                            c : UINT;
                            d : ARRAY OF PALETTEENTRY) : UINT;

PROCEDURE SetPixel(a : HDC;
                   b : INTEGER;
                   c : INTEGER;
                   d : COLORREF) : COLORREF;

(*95*)
PROCEDURE SetPixelFormat(a: HDC; b: WINT; c: PIXELFORMATDESCRIPTOR) : BOOL;

PROCEDURE SetPixelV(a : HDC;
                    b : INTEGER;
                    c : INTEGER;
                    d : COLORREF) : BOOL;

PROCEDURE SetPolyFillMode(a : HDC;
                          b : INTEGER) : INTEGER;

PROCEDURE StretchBlt(a : HDC;
                     b : INTEGER;
                     c : INTEGER;
                     d : INTEGER;
                     e : INTEGER;
                     f : HDC;
                     g : INTEGER;
                     h : INTEGER;
                     i : INTEGER;
                     j : INTEGER;
                     k : DWORD) : BOOL;

PROCEDURE SetRectRgn(a : HRGN;
                     b : INTEGER;
                     c : INTEGER;
                     d : INTEGER;
                     e : INTEGER) : BOOL;

PROCEDURE StretchDIBits(a : HDC;
                        b : INTEGER;
                        c : INTEGER;
                        d : INTEGER;
                        e : INTEGER;
                        f : INTEGER;
                        g : INTEGER;
                        h : INTEGER;
                        i : INTEGER;
                        j : LPVOID;
                        VAR k : BITMAPINFO;
                        l : UINT;
                        m : DWORD) : INTEGER;

PROCEDURE SetROP2(a : HDC;
                  b : INTEGER) : INTEGER;

PROCEDURE SetStretchBltMode(a : HDC;
                            b : INTEGER) : INTEGER;

PROCEDURE SetSystemPaletteUse(a : HDC;
                              b : UINT) : UINT;

PROCEDURE SetTextCharacterExtra(a : HDC;
                                b : INTEGER) : INTEGER;

PROCEDURE SetTextColor(a : HDC;
                       b : COLORREF) : COLORREF;

PROCEDURE SetTextAlign(a : HDC;
                       b : UINT) : UINT;

PROCEDURE SetTextJustification(a : HDC;
                               b : INTEGER;
                               c : INTEGER) : BOOL;

PROCEDURE UpdateColors(a : HDC) : BOOL;

(* image blt*)

TYPE
    COLOR16 = USHORT;

    TRIVERTEX = RECORD
    x           : LONG;
    y           : LONG;
    Red         : COLOR16;
    Green       : COLOR16;
    Blue        : COLOR16;
    Alpha       : COLOR16;
    END;
    PTRIVERTEX = POINTER TO TRIVERTEX;
    LPTRIVERTEX = PTRIVERTEX;

    GRADIENT_TRIANGLE = RECORD
    Vertex1     : ULONG;
    Vertex2     : ULONG;
    Vertex3     : ULONG;
    END;
    PGRADIENT_TRIANGLE = POINTER TO GRADIENT_TRIANGLE;
    LPGRADIENT_TRIANGLE = PGRADIENT_TRIANGLE;

    GRADIENT_RECT = RECORD
    UpperLeft   : ULONG;
    LowerRight  : ULONG;
    END;
    PGRADIENT_RECT = POINTER TO GRADIENT_RECT;
    LPGRADIENT_RECT = PGRADIENT_RECT;

    BLENDFUNCTION = RECORD
    BlendOp             : BYTE;
    BlendFlags          : BYTE;
    SourceConstantAlpha : BYTE;
    AlphaFormat         : BYTE;
    END;
    PBLENDFUNCTION = POINTER TO BLENDFUNCTION;


(* currentlly defined blend function*)
CONST
    AC_SRC_OVER                 = 00h;

(* alpha format flags*)

    AC_SRC_NO_PREMULT_ALPHA     =001h;
    AC_SRC_NO_ALPHA             =002h;
    AC_DST_NO_PREMULT_ALPHA     =010h;
    AC_DST_NO_ALPHA             =020h;

PROCEDURE AlphaBlend(a : HDC;
                     b : WINT;
                     c : WINT;
                     d : WINT;
                     e : WINT;
                     f : HDC;
                     g : WINT;
                     h : WINT;
                     i : WINT;
                     j : WINT;
                     k : BLENDFUNCTION) : BOOL;

PROCEDURE AlphaDIBBlend(a : HDC;
                        b : WINT;
                        c : WINT;
                        d : WINT;
                        e : WINT;
                        f : PVOID;
                        g : BITMAPINFO;
                        h : WINT;
                        i : WINT;
                        j : WINT;
                        k : WINT;
                        l : BLENDFUNCTION) : BOOL;

PROCEDURE TransparentBlt(a : HDC;
                         b : WINT;
                         c : WINT;
                         d : WINT;
                         e : WINT;
                         f : HDC;
                         g : WINT;
                         h : WINT;
                         i : WINT;
                         j : WINT;
                         k : UINT) : BOOL;

PROCEDURE TransparentDIBits(a : HDC;
                            b : WINT;
                            c : WINT;
                            d : WINT;
                            e : WINT;
                            f : PVOID;
                            g : BITMAPINFO;
                            h : WINT;
                            i : WINT;
                            j : WINT;
                            k : WINT;
                            l : UINT) : BOOL;

(* gradient drawing modes*)
CONST
    GRADIENT_FILL_RECT_H    =00000000h;
    GRADIENT_FILL_RECT_V    =00000001h;
    GRADIENT_FILL_TRIANGLE  =00000002h;
    GRADIENT_FILL_OP_FLAG   =000000ffh;

PROCEDURE GradientFill(a : HDC;
                       b : TRIVERTEX;
                       c : ULONG;
                       d : PVOID;
                       e : ULONG;
                       f : ULONG) : BOOL;

PROCEDURE PlayMetaFileRecord(a : HDC;
                             b : LPHANDLETABLE;
                             c : LPMETARECORD;
                             d : UINT) : BOOL;


TYPE
    MFENUMPROC           = PROCEDURE (HDC,
                                      VAR HANDLETABLE,
                                      VAR METARECORD,
                                      INTEGER,
                                      LPARAM):INTEGER[EXPORT];

PROCEDURE EnumMetaFile(a : HDC;
                       b : HMETAFILE;
                       c : MFENUMPROC;
                       d : LPARAM) : BOOL;


TYPE
    ENHMFENUMPROC        = PROCEDURE (HDC,
                                      VAR HANDLETABLE,
                                      VAR ENHMETARECORD,
                                      INTEGER,
                                      LPARAM):INTEGER [EXPORT];

PROCEDURE CloseEnhMetaFile(a : HDC) : HENHMETAFILE;

PROCEDURE CopyEnhMetaFileA(a : HENHMETAFILE;
                           b : ARRAY OF ACHAR) : HENHMETAFILE;

PROCEDURE CopyEnhMetaFileW(a : HENHMETAFILE;
                           b : ARRAY OF UCHAR) : HENHMETAFILE;

%IF UNICODE %THEN
PROCEDURE CopyEnhMetaFile = CopyEnhMetaFileW;
%ELSE
PROCEDURE CopyEnhMetaFile = CopyEnhMetaFileA;
%END

PROCEDURE CreateEnhMetaFileA(a : HDC;
                             b : ARRAY OF ACHAR;
                             c : RECT;
                             d : ARRAY OF ACHAR) : HDC;

PROCEDURE CreateEnhMetaFileW(a : HDC;
                             b : ARRAY OF UCHAR;
                             c : RECT;
                             d : ARRAY OF UCHAR) : HDC;

%IF UNICODE %THEN
PROCEDURE CreateEnhMetaFile = CreateEnhMetaFileW;
%ELSE
PROCEDURE CreateEnhMetaFile = CreateEnhMetaFileA;
%END

PROCEDURE DeleteEnhMetaFile(a : HENHMETAFILE) : BOOL;

PROCEDURE EnumEnhMetaFile(a : HDC;
                          b : HENHMETAFILE;
                          c : ENHMFENUMPROC;
                          d : LPVOID;
                          e : RECT) : BOOL;

PROCEDURE GetEnhMetaFileA(a : ARRAY OF ACHAR) : HENHMETAFILE;

PROCEDURE GetEnhMetaFileW(a : ARRAY OF UCHAR) : HENHMETAFILE;

%IF UNICODE %THEN
PROCEDURE GetEnhMetaFile = GetEnhMetaFileW;
%ELSE
PROCEDURE GetEnhMetaFile = GetEnhMetaFileA;
%END

PROCEDURE GetEnhMetaFileBits(a : HENHMETAFILE;
                             b : UINT;
                             VAR c : ARRAY OF LOC) : UINT;

PROCEDURE GetEnhMetaFileDescriptionA(a : HENHMETAFILE;
                                     b : UINT;
                                     VAR c : ARRAY OF ACHAR) : UINT;

PROCEDURE GetEnhMetaFileDescriptionW(a : HENHMETAFILE;
                                     b : UINT;
                                     VAR c : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE GetEnhMetaFileDescription = GetEnhMetaFileDescriptionW;
%ELSE
PROCEDURE GetEnhMetaFileDescription = GetEnhMetaFileDescriptionA;
%END

PROCEDURE GetEnhMetaFileHeader(a : HENHMETAFILE;
                               b : UINT;
                               VAR c : ENHMETAHEADER) : UINT;

PROCEDURE GetEnhMetaFilePaletteEntries(a : HENHMETAFILE;
                                       b : UINT;
                                       VAR c : ARRAY OF PALETTEENTRY) : UINT;

PROCEDURE GetEnhMetaFilePixelFormat(a : HENHMETAFILE;
                                    b : UINT;
                                    c : PIXELFORMATDESCRIPTOR) : UINT;

PROCEDURE GetWinMetaFileBits(a : HENHMETAFILE;
                             b : UINT;
                             VAR c : ARRAY OF LOC;
                             d : WINT;
                             e : HDC) : UINT;

PROCEDURE PlayEnhMetaFile(a : HDC;
                          b : HENHMETAFILE;
                          c : RECT) : BOOL;

PROCEDURE PlayEnhMetaFileRecord(a : HDC;
                                b : LPHANDLETABLE;
                                c : ENHMETARECORD;
                                d : UINT) : BOOL;

PROCEDURE SetEnhMetaFileBits(a : UINT;
                             b : ARRAY OF LOC) : HENHMETAFILE;

PROCEDURE SetWinMetaFileBits(a : UINT;
                             b : ARRAY OF LOC;
                             c : HDC;
                             d : METAFILEPICT) : HENHMETAFILE;

PROCEDURE GdiComment(a : HDC;
                     b : UINT;
                     c : ARRAY OF LOC) : BOOL;

PROCEDURE GetTextMetricsA(a : HDC;
                          VAR OUT b : TEXTMETRICA) : BOOL;

PROCEDURE GetTextMetricsW(a : HDC;
                          VAR OUT b : TEXTMETRICW) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetTextMetrics = GetTextMetricsW;
%ELSE
PROCEDURE GetTextMetrics = GetTextMetricsA;
%END

PROCEDURE AngleArc(a : HDC;
                   b : INTEGER;
                   c : INTEGER;
                   d : DWORD;
                   e : WFLOAT;
                   f : WFLOAT) : BOOL;

PROCEDURE PolyPolyline(a : HDC;
                       VAR b : ARRAY OF POINT;
                       VAR c : ARRAY OF DWORD;
                       d : DWORD) : BOOL;

PROCEDURE GetWorldTransform(a : HDC;
                            VAR b : XFORM) : BOOL;

PROCEDURE SetWorldTransform(a : HDC;
                            b : XFORM) : BOOL;

PROCEDURE ModifyWorldTransform(a : HDC;
                               VAR b : XFORM;
                               c : DWORD) : BOOL;

PROCEDURE CombineTransform(a : XFORM;
                           VAR b : XFORM;
                           VAR c : XFORM) : BOOL;

(*95*)
PROCEDURE CreateDIBSection(a : HDC;
                           b : BITMAPINFO;
                           c : UINT;
                           VAR d : LPVOID;
                           e : HANDLE;
                           f : DWORD) : HBITMAP;

(*95*)
PROCEDURE GetDIBColorTable(a: HDC;
                           b: UINT;
                           c: UINT;
                           VAR d: ARRAY OF RGBQUAD) : UINT;

(*95*)
PROCEDURE SetDIBColorTable(a: HDC;
                           b: UINT;
                           c: UINT;
                           d: ARRAY OF RGBQUAD) : UINT;

CONST
    CA_NEGATIVE          = 00001h;
    CA_LOG_FILTER        = 00002h;
    ILLUMINANT_DEVICE_DEFAULT= 0;
    ILLUMINANT_A         = 1;
    ILLUMINANT_B         = 2;
    ILLUMINANT_C         = 3;
    ILLUMINANT_D50       = 4;
    ILLUMINANT_D55       = 5;
    ILLUMINANT_D65       = 6;
    ILLUMINANT_D75       = 7;
    ILLUMINANT_F2        = 8;
    ILLUMINANT_MAX_INDEX = ILLUMINANT_F2;
    ILLUMINANT_TUNGSTEN        = ILLUMINANT_A;
    ILLUMINANT_DAYLIGHT        = ILLUMINANT_C;
    ILLUMINANT_FLUORESCENT     = ILLUMINANT_F2;
    ILLUMINANT_NTSC            = ILLUMINANT_C;

    RGB_GAMMA_MIN        = 1344;
    RGB_GAMMA_MAX        = 65000;
    REFERENCE_WHITE_MIN  = 6000;
    REFERENCE_WHITE_MAX  = 10000;
    REFERENCE_BLACK_MIN  = 0;
    REFERENCE_BLACK_MAX  = 4000;
    COLOR_ADJ_MIN        = -100;
    COLOR_ADJ_MAX        = 100;

TYPE
    COLORADJUSTMENT = RECORD
          caSize         : WORD;
          caFlags        : WORD;
          caIlluminantIndex: WORD;
          caRedGamma     : WORD;
          caGreenGamma   : WORD;
          caBlueGamma    : WORD;
          caReferenceBlack: WORD;
          caReferenceWhite: WORD;
          caContrast     : SHORT;
          caBrightness   : SHORT;
          caColorfulness : SHORT;
          caRedGreenTint : SHORT;
    END;
    PCOLORADJUSTMENT     = POINTER TO COLORADJUSTMENT;
    LPCOLORADJUSTMENT    = PCOLORADJUSTMENT;

PROCEDURE SetColorAdjustment(a : HDC;
                             VAR b : COLORADJUSTMENT) : BOOL;

PROCEDURE GetColorAdjustment(a : HDC;
                             VAR b : COLORADJUSTMENT) : BOOL;

PROCEDURE CreateHalftonePalette(a : HDC) : HPALETTE;


TYPE
    ABORTPROC            = PROCEDURE (HDC, INTEGER) : BOOL [EXPORT];

    DOCINFOA = RECORD
          cbSize         : INTEGER;
          lpszDocName    : LPCSTR;
          lpszOutput     : LPCSTR;
%IF WIN4 %THEN
          lpszDatatype   : LPCSTR;
          fwType         : DWORD;
%ELSE
%END
    END;
    LPDOCINFOA           = POINTER TO DOCINFOA;

    DOCINFOW = RECORD
          cbSize         : INTEGER;
          lpszDocName    : LPCWSTR;
          lpszOutput     : LPCWSTR;
%IF WIN4 %THEN
          lpszDatatype   : LPCWSTR;
          fwType         : DWORD;
%END
    END;
    LPDOCINFOW           = POINTER TO DOCINFOW;

%IF UNICODE %THEN
    DOCINFO              = DOCINFOW;
%ELSE
    DOCINFO              = DOCINFOA;
%END
    LPDOCINFO            = POINTER TO DOCINFO;

CONST
    DI_APPBANDING       = 1;
    DI_ROPS_READ_DESTINATION    =00000002h;

PROCEDURE StartDocA(a : HDC;
                    VAR b : DOCINFOA) : INTEGER;

PROCEDURE StartDocW(a : HDC;
                    VAR b : DOCINFOW) : INTEGER;

%IF UNICODE %THEN
PROCEDURE StartDoc = StartDocW;
%ELSE
PROCEDURE StartDoc = StartDocA;
%END

PROCEDURE EndDoc(a : HDC) : INTEGER;

PROCEDURE StartPage(a : HDC) : INTEGER;

PROCEDURE EndPage(a : HDC) : INTEGER;

PROCEDURE AbortDoc(a : HDC) : INTEGER;

PROCEDURE SetAbortProc(a : HDC;
                       b : ABORTPROC) : INTEGER;

PROCEDURE AbortPath(a : HDC) : BOOL;

PROCEDURE ArcTo(a : HDC;
                b : INTEGER;
                c : INTEGER;
                d : INTEGER;
                e : INTEGER;
                f : INTEGER;
                g : INTEGER;
                h : INTEGER;
                i : INTEGER) : BOOL;

PROCEDURE BeginPath(a : HDC) : BOOL;

PROCEDURE CloseFigure(a : HDC) : BOOL;

PROCEDURE EndPath(a : HDC) : BOOL;

PROCEDURE FillPath(a : HDC) : BOOL;

PROCEDURE FlattenPath(a : HDC) : BOOL;

PROCEDURE GetPath(a : HDC;
                  VAR OUT b : ARRAY OF POINT;
                  VAR OUT c : ARRAY OF BYTE;
                  d : INTEGER) : INTEGER;

PROCEDURE PathToRegion(a : HDC) : HRGN;

PROCEDURE PolyDraw(a : HDC;
                   b : ARRAY OF POINT;
                   c : ARRAY OF BYTE;
                   d : INTEGER) : BOOL;

PROCEDURE SelectClipPath(a : HDC;
                         b : INTEGER) : BOOL;

PROCEDURE SetArcDirection(a : HDC;
                          b : INTEGER) : INTEGER;

PROCEDURE SetMiterLimit(a : HDC;
                        b : WFLOAT;
                        c : PFLOAT) : BOOL;

PROCEDURE StrokeAndFillPath(a : HDC) : BOOL;

PROCEDURE StrokePath(a : HDC) : BOOL;

PROCEDURE WidenPath(a : HDC) : BOOL;

PROCEDURE ExtCreatePen(a : DWORD;
                       b : DWORD;
                       c : LOGBRUSH;
                       d : DWORD;
                       e : ARRAY OF DWORD) : HPEN;

PROCEDURE GetMiterLimit(a : HDC;
                        b : PFLOAT) : BOOL;

PROCEDURE GetArcDirection(a : HDC) : INTEGER;

PROCEDURE GetObjectA(a : HGDIOBJ;
                     b : INTEGER;
                     c : LPVOID) : INTEGER;

PROCEDURE GetObjectW(a : HGDIOBJ;
                     b : INTEGER;
                     c : LPVOID) : INTEGER;

%IF UNICODE %THEN
PROCEDURE GetObject = GetObjectW;
%ELSE
PROCEDURE GetObject = GetObjectA;
%END

PROCEDURE MoveToEx(a : HDC;
                   b : INTEGER;
                   c : INTEGER;
                   VAR OUT d : POINT) : BOOL;

PROCEDURE TextOutA(a : HDC;
                   b : INTEGER;
                   c : INTEGER;
                   d : ARRAY OF ACHAR;
                   e : INTEGER) : BOOL;

PROCEDURE TextOutW(a : HDC;
                   b : INTEGER;
                   c : INTEGER;
                   d : ARRAY OF UCHAR;
                   e : INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE TextOut = TextOutW;
%ELSE
PROCEDURE TextOut = TextOutA;
%END

PROCEDURE ExtTextOutA(a : HDC;
                      b : INTEGER;
                      c : INTEGER;
                      d : UINT;
                      e : RECT;
                      f : ARRAY OF ACHAR;
                      g : UINT;
                      h : ARRAY OF WINT) : BOOL;

PROCEDURE ExtTextOutW(a : HDC;
                      b : INTEGER;
                      c : INTEGER;
                      d : UINT;
                      e : RECT;
                      f : ARRAY OF UCHAR;
                      g : UINT;
                      h : ARRAY OF WINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE ExtTextOut = ExtTextOutW;
%ELSE
PROCEDURE ExtTextOut = ExtTextOutA;
%END

PROCEDURE PolyTextOutA(a : HDC;
                       b : ARRAY OF POLYTEXTA;
                       c : INTEGER) : BOOL;

PROCEDURE PolyTextOutW(a : HDC;
                       b : ARRAY OF POLYTEXTW;
                       c : INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE PolyTextOut = PolyTextOutW;
%ELSE
PROCEDURE PolyTextOut = PolyTextOutA;
%END

PROCEDURE CreatePolygonRgn(a : ARRAY OF POINT;
                           b : INTEGER;
                           c : INTEGER) : HRGN;

PROCEDURE DPtoLP(a : HDC;
                 VAR b : ARRAY OF POINT;
                 c : INTEGER) : BOOL;

PROCEDURE LPtoDP(a : HDC;
                 VAR b : ARRAY OF POINT;
                 c : INTEGER) : BOOL;

PROCEDURE Polygon(a : HDC;
                  b : ARRAY OF POINT;
                  c : INTEGER) : BOOL;

PROCEDURE Polyline(a : HDC;
                   b : ARRAY OF POINT;
                   c : INTEGER) : BOOL;

PROCEDURE PolyBezier(a : HDC;
                     b : ARRAY OF POINT;
                     c : DWORD) : BOOL;

PROCEDURE PolyBezierTo(a : HDC;
                       b : ARRAY OF POINT;
                       c : DWORD) : BOOL;

PROCEDURE PolylineTo(a : HDC;
                     b : ARRAY OF POINT;
                     c : DWORD) : BOOL;

PROCEDURE SetViewportExtEx(a : HDC;
                           b : INTEGER;
                           c : INTEGER;
                           VAR d : WSIZE) : BOOL;

PROCEDURE SetViewportOrgEx(a : HDC;
                           b : INTEGER;
                           c : INTEGER;
                           VAR d : POINT) : BOOL;

PROCEDURE SetWindowExtEx(a : HDC;
                         b : INTEGER;
                         c : INTEGER;
                         VAR d : WSIZE) : BOOL;

PROCEDURE SetWindowOrgEx(a : HDC;
                         b : INTEGER;
                         c : INTEGER;
                         VAR d : POINT) : BOOL;

PROCEDURE OffsetViewportOrgEx(a : HDC;
                              b : INTEGER;
                              c : INTEGER;
                              VAR d : POINT) : BOOL;

PROCEDURE OffsetWindowOrgEx(a : HDC;
                            b : INTEGER;
                            c : INTEGER;
                            VAR d : POINT) : BOOL;

PROCEDURE ScaleViewportExtEx(a : HDC;
                             b : INTEGER;
                             c : INTEGER;
                             d : INTEGER;
                             e : INTEGER;
                             VAR f : WSIZE) : BOOL;

PROCEDURE ScaleWindowExtEx(a : HDC;
                           b : INTEGER;
                           c : INTEGER;
                           d : INTEGER;
                           e : INTEGER;
                           VAR f : WSIZE) : BOOL;

PROCEDURE SetBitmapDimensionEx(a : HBITMAP;
                               b : INTEGER;
                               c : INTEGER;
                               VAR d : WSIZE) : BOOL;

PROCEDURE SetBrushOrgEx(a : HDC;
                        b : INTEGER;
                        c : INTEGER;
                        VAR d : POINT) : BOOL;

PROCEDURE GetTextFaceA(a : HDC;
                       b : INTEGER;
                       VAR c : ARRAY OF ACHAR) : INTEGER;

PROCEDURE GetTextFaceW(a : HDC;
                       b : INTEGER;
                       VAR c : ARRAY OF UCHAR) : INTEGER;

%IF UNICODE %THEN
PROCEDURE GetTextFace = GetTextFaceW;
%ELSE
PROCEDURE GetTextFace = GetTextFaceA;
%END

CONST
    FONTMAPPER_MAX       = 10;

TYPE
    KERNINGPAIR = RECORD
          wFirst         : WORD;
          wSecond        : WORD;
          iKernAmount    : INTEGER;
    END;
    LPKERNINGPAIR        = POINTER TO KERNINGPAIR;

PROCEDURE GetKerningPairsA(a : HDC;
                           b : DWORD;
                           VAR c : KERNINGPAIR) : DWORD;

PROCEDURE GetKerningPairsW(a : HDC;
                           b : DWORD;
                           VAR c : KERNINGPAIR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetKerningPairs = GetKerningPairsW;
%ELSE
PROCEDURE GetKerningPairs = GetKerningPairsA;
%END

PROCEDURE GetDCOrgEx(a : HDC;
                     VAR b : POINT) : BOOL;

PROCEDURE FixBrushOrgEx(a : HDC;
                        b : INTEGER;
                        c : INTEGER;
                        d : POINT) : BOOL;

PROCEDURE UnrealizeObject(a : HGDIOBJ) : BOOL;

PROCEDURE GdiFlush() : BOOL;

PROCEDURE GdiSetBatchLimit(a : DWORD) : DWORD;

PROCEDURE GdiGetBatchLimit() : DWORD;



CONST
    ICM_OFF   = 1;
    ICM_ON    = 2;
    ICM_QUERY = 3;
    ICM_DONE_OUTSIDEDC    = 4;

PROCEDURE SetICMMode(a: HDC; b: WINT) : WINT;

PROCEDURE CheckColorsInGamut(a: HDC; b: LPVOID; c: LPVOID; d: DWORD) : BOOL;

PROCEDURE GetColorSpace(a: HDC) : HANDLE;

PROCEDURE GetLogColorSpaceA(a: HCOLORSPACE;
                            VAR b: LOGCOLORSPACEA;
                            c: DWORD) : BOOL;

PROCEDURE GetLogColorSpaceW(a: HCOLORSPACE;
                            VAR b: LOGCOLORSPACEW;
                            c: DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE GetLogColorSpace = GetLogColorSpaceW;
%ELSE
PROCEDURE GetLogColorSpace = GetLogColorSpaceA;
%END

PROCEDURE CreateColorSpaceA(VAR a: LOGCOLORSPACEA) : HCOLORSPACE;

PROCEDURE CreateColorSpaceW(VAR a: LOGCOLORSPACEW) : HCOLORSPACE;

%IF UNICODE %THEN
PROCEDURE CreateColorSpace = CreateColorSpaceW;
%ELSE
PROCEDURE CreateColorSpace = CreateColorSpaceA;
%END

PROCEDURE SetColorSpace(a: HDC; b: HCOLORSPACE) : BOOL;

PROCEDURE DeleteColorSpace(a: HCOLORSPACE) : BOOL;

PROCEDURE GetICMProfileA(a: HDC; b: DWORD; VAR c: ARRAY OF ACHAR) : BOOL;

PROCEDURE GetICMProfileW(a: HDC; b: DWORD; VAR c: ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetICMProfile = GetICMProfileW;
%ELSE
PROCEDURE GetICMProfile = GetICMProfileA;
%END

PROCEDURE SetICMProfileA(a: HDC; VAR b: ARRAY OF ACHAR) : BOOL;

PROCEDURE SetICMProfileW(a: HDC; VAR b: ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetICMProfile = SetICMProfileW;
%ELSE
PROCEDURE SetICMProfile = SetICMProfileA;
%END

PROCEDURE GetDeviceGammaRamp(a: HDC; b: LPVOID) : BOOL;

PROCEDURE SetDeviceGammaRamp(a: HDC; c: LPVOID) : BOOL;

PROCEDURE ColorMatchToTarget(a: HDC; b: HDC; c: DWORD) : BOOL;

PROCEDURE UpdateICMRegKeyA(a: DWORD; b : DWORD;
                           c : ARRAY OF ACHAR; d : UINT) : BOOL;

PROCEDURE UpdateICMRegKeyW(a: DWORD; b : DWORD;
                           c : ARRAY OF UCHAR; d : UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE UpdateICMRegKey = UpdateICMRegKeyW;
%ELSE
PROCEDURE UpdateICMRegKey = UpdateICMRegKeyA;
%END

PROCEDURE ColorCorrectPalette(a : HDC;
                              b : HPALETTE;
                              c : DWORD;
                              d : DWORD) : BOOL;

TYPE
    ICMENUMPROCA        = PROCEDURE(VAR ARRAY OF ACHAR, LPARAM) : WINT [EXPORT];

    ICMENUMPROCW        = PROCEDURE(VAR ARRAY OF UCHAR, LPARAM) : WINT [EXPORT];

%IF UNICODE %THEN
    ICMENUMPROC = ICMENUMPROCW;
%ELSE
    ICMENUMPROC = ICMENUMPROCA;
%END


PROCEDURE EnumICMProfilesA(a: HDC; b: ICMENUMPROCA; c: LPARAM) : WINT;

PROCEDURE EnumICMProfilesW(a: HDC; b: ICMENUMPROCW; c: LPARAM) : WINT;

%IF UNICODE %THEN
PROCEDURE EnumICMProfiles = EnumICMProfilesW;
%ELSE
PROCEDURE EnumICMProfiles = EnumICMProfilesA;
%END


CONST
    ENHMETA_SIGNATURE    = 0464D4520h;
    ENHMETA_STOCK_OBJECT = 080000000h;

    EMR_MIN              = 1;
    EMR_HEADER           = 1;
    EMR_POLYBEZIER       = 2;
    EMR_POLYGON          = 3;
    EMR_POLYLINE         = 4;
    EMR_POLYBEZIERTO     = 5;
    EMR_POLYLINETO       = 6;
    EMR_POLYPOLYLINE     = 7;
    EMR_POLYPOLYGON      = 8;
    EMR_SETWINDOWEXTEX   = 9;
    EMR_SETWINDOWORGEX   = 10;
    EMR_SETVIEWPORTEXTEX = 11;
    EMR_SETVIEWPORTORGEX = 12;
    EMR_SETBRUSHORGEX    = 13;
    EMR_EOF              = 14;
    EMR_SETPIXELV        = 15;
    EMR_SETMAPPERFLAGS   = 16;
    EMR_SETMAPMODE       = 17;
    EMR_SETBKMODE        = 18;
    EMR_SETPOLYFILLMODE  = 19;
    EMR_SETROP2          = 20;
    EMR_SETSTRETCHBLTMODE= 21;
    EMR_SETTEXTALIGN     = 22;
    EMR_SETCOLORADJUSTMENT= 23;
    EMR_SETTEXTCOLOR     = 24;
    EMR_SETBKCOLOR       = 25;
    EMR_OFFSETCLIPRGN    = 26;
    EMR_MOVETOEX         = 27;
    EMR_SETMETARGN       = 28;
    EMR_EXCLUDECLIPRECT  = 29;
    EMR_INTERSECTCLIPRECT= 30;
    EMR_SCALEVIEWPORTEXTEX= 31;
    EMR_SCALEWINDOWEXTEX = 32;
    EMR_SAVEDC           = 33;
    EMR_RESTOREDC        = 34;
    EMR_SETWORLDTRANSFORM= 35;
    EMR_MODIFYWORLDTRANSFORM= 36;
    EMR_SELECTOBJECT     = 37;
    EMR_CREATEPEN        = 38;
    EMR_CREATEBRUSHINDIRECT= 39;
    EMR_DELETEOBJECT     = 40;
    EMR_ANGLEARC         = 41;
    EMR_ELLIPSE          = 42;
    EMR_RECTANGLE        = 43;
    EMR_ROUNDRECT        = 44;
    EMR_ARC              = 45;
    EMR_CHORD            = 46;
    EMR_PIE              = 47;
    EMR_SELECTPALETTE    = 48;
    EMR_CREATEPALETTE    = 49;
    EMR_SETPALETTEENTRIES= 50;
    EMR_RESIZEPALETTE    = 51;
    EMR_REALIZEPALETTE   = 52;
    EMR_EXTFLOODFILL     = 53;
    EMR_LINETO           = 54;
    EMR_ARCTO            = 55;
    EMR_POLYDRAW         = 56;
    EMR_SETARCDIRECTION  = 57;
    EMR_SETMITERLIMIT    = 58;
    EMR_BEGINPATH        = 59;
    EMR_ENDPATH          = 60;
    EMR_CLOSEFIGURE      = 61;
    EMR_FILLPATH         = 62;
    EMR_STROKEANDFILLPATH= 63;
    EMR_STROKEPATH       = 64;
    EMR_FLATTENPATH      = 65;
    EMR_WIDENPATH        = 66;
    EMR_SELECTCLIPPATH   = 67;
    EMR_ABORTPATH        = 68;
    EMR_GDICOMMENT       = 70;
    EMR_FILLRGN          = 71;
    EMR_FRAMERGN         = 72;
    EMR_INVERTRGN        = 73;
    EMR_PAINTRGN         = 74;
    EMR_EXTSELECTCLIPRGN = 75;
    EMR_BITBLT           = 76;
    EMR_STRETCHBLT       = 77;
    EMR_MASKBLT          = 78;
    EMR_PLGBLT           = 79;
    EMR_SETDIBITSTODEVICE= 80;
    EMR_STRETCHDIBITS    = 81;
    EMR_EXTCREATEFONTINDIRECTW= 82;
    EMR_EXTTEXTOUTA      = 83;
    EMR_EXTTEXTOUTW      = 84;
    EMR_POLYBEZIER16     = 85;
    EMR_POLYGON16        = 86;
    EMR_POLYLINE16       = 87;
    EMR_POLYBEZIERTO16   = 88;
    EMR_POLYLINETO16     = 89;
    EMR_POLYPOLYLINE16   = 90;
    EMR_POLYPOLYGON16    = 91;
    EMR_POLYDRAW16       = 92;
    EMR_CREATEMONOBRUSH  = 93;
    EMR_CREATEDIBPATTERNBRUSHPT= 94;
    EMR_EXTCREATEPEN     = 95;
    EMR_POLYTEXTOUTA     = 96;
    EMR_POLYTEXTOUTW     = 97;

    EMR_SETICMMODE       = 98;
    EMR_CREATECOLORSPACE = 99;
    EMR_SETCOLORSPACE    = 100;
    EMR_DELETECOLORSPACE = 101;
    EMR_GLSRECORD                  =102;
    EMR_GLSBOUNDEDRECORD           =103;
    EMR_PIXELFORMAT                =104;

    %IF WIN5 %THEN
    EMR_DRAWESCAPE                 =105;
    EMR_EXTESCAPE                  =106;
    EMR_STARTDOC                   =107;
    EMR_SMALLTEXTOUT               =108;
    EMR_FORCEUFIMAPPING            =109;
    EMR_NAMEDESCAPE                =110;
    EMR_COLORCORRECTPALETTE        =111;
    EMR_SETICMPROFILEA             =112;
    EMR_SETICMPROFILEW             =113;
    EMR_ALPHABLEND                 =114;
    EMR_ALPHADIBBLEND              =115;
    EMR_TRANSPARENTBLT             =116;
    EMR_TRANSPARENTDIB             =117;
    EMR_GRADIENTFILL               =118;
    EMR_SETLINKEDUFIS              =119;
    EMR_SETTEXTJUSTIFICATION       =120;
    %END

    %IF WIN5 %THEN
    EMR_MAX              = 120;
    %ELSE
    EMR_MAX              = 104;
    %END


TYPE
    EMR = RECORD
          iType          : DWORD;
          nSize          : DWORD;
    END;
    PEMR                 = POINTER TO EMR;

    EMRTEXT = RECORD
          ptlReference   : POINTL;
          nChars         : DWORD;
          offString      : DWORD;
          fOptions       : DWORD;
          rcl            : RECTL;
          offDx          : DWORD;
    END;
    PEMRTEXT             = POINTER TO EMRTEXT;

    ABORTPATH = RECORD
          emr            : EMR;
    END;
    PEMRREALIZEPALETTE   = POINTER TO ABORTPATH;
    PEMRSAVEDC           = POINTER TO ABORTPATH;
    PEMRSETMETARGN       = POINTER TO ABORTPATH;
    PEMRWIDENPATH        = POINTER TO ABORTPATH;
    PEMRFLATTENPATH      = POINTER TO ABORTPATH;
    PEMRCLOSEFIGURE      = POINTER TO ABORTPATH;
    PEMRENDPATH          = POINTER TO ABORTPATH;
    PEMRBEGINPATH        = POINTER TO ABORTPATH;
    PEMRABORTPATH        = POINTER TO ABORTPATH;

    EMRREALIZEPALETTE    = ABORTPATH;
    EMRSAVEDC            = ABORTPATH;
    EMRSETMETARGN        = ABORTPATH;
    EMRWIDENPATH         = ABORTPATH;
    EMRFLATTENPATH       = ABORTPATH;
    EMRCLOSEFIGURE       = ABORTPATH;
    EMRENDPATH           = ABORTPATH;
    EMRBEGINPATH         = ABORTPATH;
    EMRABORTPATH         = ABORTPATH;


    EMRSELECTCLIPPATH = RECORD
          emr            : EMR;
          iMode          : DWORD;
    END;
    PEMRSETTEXTALIGN     = POINTER TO EMRSELECTCLIPPATH;
    PEMRSETSTRETCHBLTMODE= POINTER TO EMRSELECTCLIPPATH;
    PEMRSETROP2          = POINTER TO EMRSELECTCLIPPATH;
    PEMRSETPOLYFILLMODE  = POINTER TO EMRSELECTCLIPPATH;
    PEMRSETMAPMODE       = POINTER TO EMRSELECTCLIPPATH;
    PEMRSETBKMODE        = POINTER TO EMRSELECTCLIPPATH;
    PEMRSELECTCLIPPATH   = POINTER TO EMRSELECTCLIPPATH;
    PEMRSETICMMODE       = POINTER TO EMRSELECTCLIPPATH;

    EMRSETTEXTALIGN      = EMRSELECTCLIPPATH;
    EMRSETSTRETCHBLTMODE = EMRSELECTCLIPPATH;
    EMRSETROP2           = EMRSELECTCLIPPATH;
    EMRSETPOLYFILLMODE   = EMRSELECTCLIPPATH;
    EMRSETMAPMODE        = EMRSELECTCLIPPATH;
    EMRSETBKMODE         = EMRSELECTCLIPPATH;
    EMRSETICMMODE        = EMRSELECTCLIPPATH;

    EMRSETMITERLIMIT = RECORD
          emr            : EMR;
          eMiterLimit    : WFLOAT;
    END;
    PEMRSETMITERLIMIT    = POINTER TO EMRSETMITERLIMIT;

    EMRRESTOREDC = RECORD
          emr            : EMR;
          iRelative      : LONG;
    END;
    PEMRRESTOREDC        = POINTER TO EMRRESTOREDC;

    EMRSETARCDIRECTION = RECORD
          emr            : EMR;
          iArcDirection  : DWORD;
    END;
    PEMRSETARCDIRECTION  = POINTER TO EMRSETARCDIRECTION;

    EMRSETMAPPERFLAGS = RECORD
          emr            : EMR;
          dwFlags        : DWORD;
    END;
    PEMRSETMAPPERFLAGS   = POINTER TO EMRSETMAPPERFLAGS;

    EMRSETTEXTCOLOR = RECORD
          emr            : EMR;
          crColor        : COLORREF;
    END;
    EMRSETBKCOLOR        = EMRSETTEXTCOLOR;
    PEMRSETTEXTCOLOR     = POINTER TO EMRSETTEXTCOLOR;
    PEMRSETBKCOLOR       = POINTER TO EMRSETTEXTCOLOR;

    EMRSELECTOBJECT = RECORD
          emr            : EMR;
          ihObject       : DWORD;
    END;
    EMRDELETEOBJECT      = EMRSELECTOBJECT;
    PEMRDELETEOBJECT     = POINTER TO EMRSELECTOBJECT;
    PEMRSELECTOBJECT     = POINTER TO EMRSELECTOBJECT;


    EMRSELECTCOLORSPACE = RECORD
        emr     : EMR;
        ihCS    : DWORD;
    END;
    PEMRSELECTCOLORSPACE        = POINTER TO EMRSELECTCOLORSPACE;
    EMRDELETECOLORSPACE         = EMRSELECTCOLORSPACE;
    PEMRDELETECOLORSPACE        = POINTER TO EMRDELETECOLORSPACE;


    EMRSELECTPALETTE = RECORD
          emr            : EMR;
          ihPal          : DWORD;
    END;
    PEMRSELECTPALETTE    = POINTER TO EMRSELECTPALETTE;

    EMRRESIZEPALETTE = RECORD
          emr            : EMR;
          ihPal          : DWORD;
          cEntries       : DWORD;
    END;
    PEMRRESIZEPALETTE    = POINTER TO EMRRESIZEPALETTE;

    EMRSETPALETTEENTRIES = RECORD
          emr            : EMR;
          ihPal          : DWORD;
          iStart         : DWORD;
          cEntries       : DWORD;
          aPalEntries    : ARRAY [0..1 - 1] OF PALETTEENTRY;
    END;
    PEMRSETPALETTEENTRIES= POINTER TO EMRSETPALETTEENTRIES;

    EMRSETCOLORADJUSTMENT = RECORD
          emr            : EMR;
          ColorAdjustment: COLORADJUSTMENT;
    END;
    PEMRSETCOLORADJUSTMENT= POINTER TO EMRSETCOLORADJUSTMENT;

    EMRGDICOMMENT = RECORD
          emr            : EMR;
          cbData         : DWORD;
          Data           : ARRAY [0..1 - 1] OF BYTE;
    END;
    PEMRGDICOMMENT       = POINTER TO EMRGDICOMMENT;

    EMREOF = RECORD
          emr            : EMR;
          nPalEntries    : DWORD;
          offPalEntries  : DWORD;
          nSizeLast      : DWORD;
    END;
    PEMREOF              = POINTER TO EMREOF;

    EMRLINETO = RECORD
          emr            : EMR;
          ptl            : POINTL;
    END;
    EMRMOVETOEX          = EMRLINETO;
    PEMRMOVETOEX         = POINTER TO EMRLINETO;
    PEMRLINETO           = POINTER TO EMRLINETO;

    EMROFFSETCLIPRGN = RECORD
          emr            : EMR;
          ptlOffset      : POINTL;
    END;
    PEMROFFSETCLIPRGN    = POINTER TO EMROFFSETCLIPRGN;

    EMRFILLPATH = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
    END;
    EMRSTROKEPATH        = EMRFILLPATH;
    EMRSTROKEANDFILLPATH = EMRFILLPATH;
    PEMRSTROKEPATH       = POINTER TO EMRFILLPATH;
    PEMRSTROKEANDFILLPATH= POINTER TO EMRFILLPATH;
    PEMRFILLPATH         = POINTER TO EMRFILLPATH;

    EMREXCLUDECLIPRECT = RECORD
          emr            : EMR;
          rclClip        : RECTL;
    END;
    EMRINTERSECTCLIPRECT = EMREXCLUDECLIPRECT;
    PEMRINTERSECTCLIPRECT= POINTER TO EMREXCLUDECLIPRECT;
    PEMREXCLUDECLIPRECT  = POINTER TO EMREXCLUDECLIPRECT;

    EMRSETVIEWPORTORGEX = RECORD
          emr            : EMR;
          ptlOrigin      : POINTL;
    END;
    EMRSETBRUSHORGEX     = EMRSETVIEWPORTORGEX;
    EMRSETWINDOWORGEX    = EMRSETVIEWPORTORGEX;
    PEMRSETBRUSHORGEX    = POINTER TO EMRSETVIEWPORTORGEX;
    PEMRSETWINDOWORGEX   = POINTER TO EMRSETVIEWPORTORGEX;
    PEMRSETVIEWPORTORGEX = POINTER TO EMRSETVIEWPORTORGEX;

    EMRSETVIEWPORTEXTEX = RECORD
          emr            : EMR;
          szlExtent      : SIZEL;
    END;
    EMRSETWINDOWEXTEX    = EMRSETVIEWPORTEXTEX;
    PEMRSETWINDOWEXTEX   = POINTER TO EMRSETVIEWPORTEXTEX;
    PEMRSETVIEWPORTEXTEX = POINTER TO EMRSETVIEWPORTEXTEX;

    EMRSCALEVIEWPORTEXTEX = RECORD
          emr            : EMR;
          xNum           : LONG;
          xDenom         : LONG;
          yNum           : LONG;
          yDenom         : LONG;
    END;
    EMRSCALEWINDOWEXTEX  = EMRSCALEVIEWPORTEXTEX;
    PEMRSCALEWINDOWEXTEX = POINTER TO EMRSCALEVIEWPORTEXTEX;
    PEMRSCALEVIEWPORTEXTEX= POINTER TO EMRSCALEVIEWPORTEXTEX;

    EMRSETWORLDTRANSFORM = RECORD
          emr            : EMR;
          xform          : XFORM;
    END;
    PEMRSETWORLDTRANSFORM= POINTER TO EMRSETWORLDTRANSFORM;

    EMRMODIFYWORLDTRANSFORM = RECORD
          emr            : EMR;
          xform          : XFORM;
          iMode          : DWORD;
    END;
    PEMRMODIFYWORLDTRANSFORM= POINTER TO EMRMODIFYWORLDTRANSFORM;

    EMRSETPIXELV = RECORD
          emr            : EMR;
          ptlPixel       : POINTL;
          crColor        : COLORREF;
    END;
    PEMRSETPIXELV        = POINTER TO EMRSETPIXELV;

    EMREXTFLOODFILL = RECORD
          emr            : EMR;
          ptlStart       : POINTL;
          crColor        : COLORREF;
          iMode          : DWORD;
    END;
    PEMREXTFLOODFILL     = POINTER TO EMREXTFLOODFILL;

    EMRELLIPSE = RECORD
          emr            : EMR;
          rclBox         : RECTL;
    END;
    EMRRECTANGLE         = EMRELLIPSE;
    PEMRRECTANGLE        = POINTER TO EMRELLIPSE;
    PEMRELLIPSE          = POINTER TO EMRELLIPSE;

    EMRROUNDRECT = RECORD
          emr            : EMR;
          rclBox         : RECTL;
          szlCorner      : SIZEL;
    END;
    PEMRROUNDRECT        = POINTER TO EMRROUNDRECT;

    EMRARC = RECORD
          emr            : EMR;
          rclBox         : RECTL;
          ptlStart       : POINTL;
          ptlEnd         : POINTL;
    END;
    EMRPIE               = EMRARC;
    EMRCHORD             = EMRARC;
    EMRARCTO             = EMRARC;
    PEMRPIE              = POINTER TO EMRARC;
    PEMRCHORD            = POINTER TO EMRARC;
    PEMRARCTO            = POINTER TO EMRARC;
    PEMRARC              = POINTER TO EMRARC;

    EMRANGLEARC = RECORD
          emr            : EMR;
          ptlCenter      : POINTL;
          nRadius        : DWORD;
          eStartAngle    : WFLOAT;
          eSweepAngle    : WFLOAT;
    END;
    PEMRANGLEARC         = POINTER TO EMRANGLEARC;

    EMRPOLYLINE = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          cptl           : DWORD;
          aptl           : ARRAY [0..1 - 1] OF POINTL;
    END;
    EMRPOLYLINETO        = EMRPOLYLINE;
    EMRPOLYBEZIERTO      = EMRPOLYLINE;
    EMRPOLYGON           = EMRPOLYLINE;
    EMRPOLYBEZIER        = EMRPOLYLINE;
    PEMRPOLYLINETO       = POINTER TO EMRPOLYLINE;
    PEMRPOLYBEZIERTO     = POINTER TO EMRPOLYLINE;
    PEMRPOLYGON          = POINTER TO EMRPOLYLINE;
    PEMRPOLYBEZIER       = POINTER TO EMRPOLYLINE;
    PEMRPOLYLINE         = POINTER TO EMRPOLYLINE;

    EMRPOLYLINE16 = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          cpts           : DWORD;
          apts           : ARRAY [0..1 - 1] OF POINTS;
    END;
    EMRPOLYLINETO16      = EMRPOLYLINE16;
    EMRPOLYBEZIERTO16    = EMRPOLYLINE16;
    EMRPOLYGON16         = EMRPOLYLINE16;
    EMRPOLYBEZIER16      = EMRPOLYLINE16;
    PEMRPOLYLINETO16     = POINTER TO EMRPOLYLINE16;
    PEMRPOLYBEZIERTO16   = POINTER TO EMRPOLYLINE16;
    PEMRPOLYGON16        = POINTER TO EMRPOLYLINE16;
    PEMRPOLYBEZIER16     = POINTER TO EMRPOLYLINE16;
    PEMRPOLYLINE16       = POINTER TO EMRPOLYLINE16;

    EMRPOLYDRAW = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          cptl           : DWORD;
          aptl           : ARRAY [0..1 - 1] OF POINTL;
          abTypes        : ARRAY [0..1 - 1] OF BYTE;
    END;
    PEMRPOLYDRAW         = POINTER TO EMRPOLYDRAW;

    EMRPOLYDRAW16 = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          cpts           : DWORD;
          apts           : ARRAY [0..1 - 1] OF POINTS;
          abTypes        : ARRAY [0..1 - 1] OF BYTE;
    END;
    PEMRPOLYDRAW16       = POINTER TO EMRPOLYDRAW16;

    EMRPOLYPOLYLINE = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          nPolys         : DWORD;
          cptl           : DWORD;
          aPolyCounts    : ARRAY [0..1 - 1] OF DWORD;
          aptl           : ARRAY [0..1 - 1] OF POINTL;
    END;
    EMRPOLYPOLYGON      =EMRPOLYPOLYLINE;
    PEMRPOLYPOLYGON      = POINTER TO EMRPOLYPOLYLINE;
    PEMRPOLYPOLYLINE     = POINTER TO EMRPOLYPOLYLINE;

    EMRPOLYPOLYLINE16 = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          nPolys         : DWORD;
          cpts           : DWORD;
          aPolyCounts    : ARRAY [0..1 - 1] OF DWORD;
          apts           : ARRAY [0..1 - 1] OF POINTS;
    END;
    EMRPOLYPOLYGON16     = EMRPOLYPOLYLINE16;
    PEMRPOLYPOLYGON16    = POINTER TO EMRPOLYPOLYLINE16;
    PEMRPOLYPOLYLINE16   = POINTER TO EMRPOLYPOLYLINE16;

    EMRINVERTRGN = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          cbRgnData      : DWORD;
          RgnData        : ARRAY [0..1 - 1] OF BYTE;
    END;
    EMRPAINTRGN          = EMRINVERTRGN;
    PEMRPAINTRGN         = POINTER TO EMRINVERTRGN;
    PEMRINVERTRGN        = POINTER TO EMRINVERTRGN;

    EMRFILLRGN = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          cbRgnData      : DWORD;
          ihBrush        : DWORD;
          RgnData        : ARRAY [0..1 - 1] OF BYTE;
    END;
    PEMRFILLRGN          = POINTER TO EMRFILLRGN;

    EMRFRAMERGN = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          cbRgnData      : DWORD;
          ihBrush        : DWORD;
          szlStroke      : SIZEL;
          RgnData        : ARRAY [0..1 - 1] OF BYTE;
    END;
    PEMRFRAMERGN         = POINTER TO EMRFRAMERGN;

%IF WIN5 %THEN
(*NT only*)
    EMRGRADIENTFILL = RECORD
    emr         : EMR;
    rclBounds   : RECTL;          (* Inclusive-inclusive bounds in device units*)
    nVer        : DWORD;
    nTri        : DWORD;
    ulMode      : ULONG;
    Ver         : ARRAY [0..1-1] OF TRIVERTEX;
    END;
    PEMRGRADIENTFILL = POINTER TO EMRGRADIENTFILL;
%END

    EMREXTSELECTCLIPRGN = RECORD
          emr            : EMR;
          cbRgnData      : DWORD;
          iMode          : DWORD;
          RgnData        : ARRAY [0..1 - 1] OF BYTE;
    END;
    PEMREXTSELECTCLIPRGN = POINTER TO EMREXTSELECTCLIPRGN;

    EMREXTTEXTOUTA = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          iGraphicsMode  : DWORD;
          exScale        : WFLOAT;
          eyScale        : WFLOAT;
          emrtext        : EMRTEXT;
    END;
    EMREXTTEXTOUTW       = EMREXTTEXTOUTA;
    PEMREXTTEXTOUTW      = POINTER TO EMREXTTEXTOUTA;
    PEMREXTTEXTOUTA      = POINTER TO EMREXTTEXTOUTA;

    EMRPOLYTEXTOUTA = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          iGraphicsMode  : DWORD;
          exScale        : WFLOAT;
          eyScale        : WFLOAT;
          cStrings       : LONG;
          aemrtext       : ARRAY [0..1 - 1] OF EMRTEXT;
    END;
    EMRPOLYTEXTOUTW      = EMRPOLYTEXTOUTA;
    PEMRPOLYTEXTOUTW     = POINTER TO EMRPOLYTEXTOUTA;
    PEMRPOLYTEXTOUTA     = POINTER TO EMRPOLYTEXTOUTA;

    EMRBITBLT = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          xDest          : LONG;
          yDest          : LONG;
          cxDest         : LONG;
          cyDest         : LONG;
          dwRop          : DWORD;
          xSrc           : LONG;
          ySrc           : LONG;
          xformSrc       : XFORM;
          crBkColorSrc   : COLORREF;
          iUsageSrc      : DWORD;
          offBmiSrc      : DWORD;
          cbBmiSrc       : DWORD;
          offBitsSrc     : DWORD;
          cbBitsSrc      : DWORD;
    END;
    PEMRBITBLT           = POINTER TO EMRBITBLT;

    EMRSTRETCHBLT = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          xDest          : LONG;
          yDest          : LONG;
          cxDest         : LONG;
          cyDest         : LONG;
          dwRop          : DWORD;
          xSrc           : LONG;
          ySrc           : LONG;
          xformSrc       : XFORM;
          crBkColorSrc   : COLORREF;
          iUsageSrc      : DWORD;
          offBmiSrc      : DWORD;
          cbBmiSrc       : DWORD;
          offBitsSrc     : DWORD;
          cbBitsSrc      : DWORD;
          cxSrc          : LONG;
          cySrc          : LONG;
    END;
    PEMRSTRETCHBLT       = POINTER TO EMRSTRETCHBLT;

    EMRMASKBLT = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          xDest          : LONG;
          yDest          : LONG;
          cxDest         : LONG;
          cyDest         : LONG;
          dwRop          : DWORD;
          xSrc           : LONG;
          ySrc           : LONG;
          xformSrc       : XFORM;
          crBkColorSrc   : COLORREF;
          iUsageSrc      : DWORD;
          offBmiSrc      : DWORD;
          cbBmiSrc       : DWORD;
          offBitsSrc     : DWORD;
          cbBitsSrc      : DWORD;
          xMask          : LONG;
          yMask          : LONG;
          iUsageMask     : DWORD;
          offBmiMask     : DWORD;
          cbBmiMask      : DWORD;
          offBitsMask    : DWORD;
          cbBitsMask     : DWORD;
    END;
    PEMRMASKBLT          = POINTER TO EMRMASKBLT;

    EMRPLGBLT = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          aptlDest       : ARRAY [0..3 - 1] OF POINTL;
          xSrc           : LONG;
          ySrc           : LONG;
          cxSrc          : LONG;
          cySrc          : LONG;
          xformSrc       : XFORM;
          crBkColorSrc   : COLORREF;
          iUsageSrc      : DWORD;
          offBmiSrc      : DWORD;
          cbBmiSrc       : DWORD;
          offBitsSrc     : DWORD;
          cbBitsSrc      : DWORD;
          xMask          : LONG;
          yMask          : LONG;
          iUsageMask     : DWORD;
          offBmiMask     : DWORD;
          cbBmiMask      : DWORD;
          offBitsMask    : DWORD;
          cbBitsMask     : DWORD;
    END;
    PEMRPLGBLT           = POINTER TO EMRPLGBLT;

    EMRSETDIBITSTODEVICE = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          xDest          : LONG;
          yDest          : LONG;
          xSrc           : LONG;
          ySrc           : LONG;
          cxSrc          : LONG;
          cySrc          : LONG;
          offBmiSrc      : DWORD;
          cbBmiSrc       : DWORD;
          offBitsSrc     : DWORD;
          cbBitsSrc      : DWORD;
          iUsageSrc      : DWORD;
          iStartScan     : DWORD;
          cScans         : DWORD;
    END;
    PEMRSETDIBITSTODEVICE= POINTER TO EMRSETDIBITSTODEVICE;

    EMRSTRETCHDIBITS = RECORD
          emr            : EMR;
          rclBounds      : RECTL;
          xDest          : LONG;
          yDest          : LONG;
          xSrc           : LONG;
          ySrc           : LONG;
          cxSrc          : LONG;
          cySrc          : LONG;
          offBmiSrc      : DWORD;
          cbBmiSrc       : DWORD;
          offBitsSrc     : DWORD;
          cbBitsSrc      : DWORD;
          iUsageSrc      : DWORD;
          dwRop          : DWORD;
          cxDest         : LONG;
          cyDest         : LONG;
    END;
    PEMRSTRETCHDIBITS    = POINTER TO EMRSTRETCHDIBITS;

%IF WIN5 %THEN
(*NT only*)
    EMRALPHABLEND = RECORD
    emr         : EMR;
    rclBounds   : RECTL;          (* Inclusive-inclusive bounds in device units*)
    xDest       : LONG;
    yDest       : LONG;
    cxDest      : LONG;
    cyDest      : LONG;
    dwRop       : DWORD;
    xSrc        : LONG;
    ySrc        : LONG;
    xformSrc    : XFORM;           (* Source DC transform*)
    crBkColorSrc : COLORREF;      (* Source DC BkColor in RGB*)
    iUsageSrc   : DWORD;          (* Source bitmap info color table usage*)
                                (* (DIB_RGB_COLORS)*)
    offBmiSrc   : DWORD;          (* Offset to the source BITMAPINFO structure*)
    cbBmiSrc    : DWORD;           (* Size of the source BITMAPINFO structure*)
    offBitsSrc  : DWORD;         (* Offset to the source bitmap bits*)
    cbBitsSrc   : DWORD;          (* Size of the source bitmap bits*)
    cxSrc       : LONG;
    cySrc       : LONG;
    END;
    PEMRALPHABLEND = POINTER TO EMRALPHABLEND;

(*NT only*)
    EMREMRTRANSPARENTBLT = RECORD
    emr         : EMR;
    rclBounds   : RECTL;          (* Inclusive-inclusive bounds in device units*)
    xDest       : LONG;
    yDest       : LONG;
    cxDest      : LONG;
    cyDest      : LONG;
    dwRop       : DWORD;
    xSrc        : LONG;
    ySrc        : LONG;
    xformSrc    : XFORM;           (* Source DC transform*)
    crBkColorSrc : COLORREF;      (* Source DC BkColor in RGB*)
    iUsageSrc   : DWORD;          (* Source bitmap info color table usage*)
                                (* (DIB_RGB_COLORS)*)
    offBmiSrc   : DWORD;          (* Offset to the source BITMAPINFO structure*)
    cbBmiSrc    : DWORD;           (* Size of the source BITMAPINFO structure*)
    offBitsSrc  : DWORD;         (* Offset to the source bitmap bits*)
    cbBitsSrc   : DWORD;          (* Size of the source bitmap bits*)
    cxSrc       : LONG;
    cySrc       : LONG;
    END;
    PEMREMRTRANSPARENTBLT = POINTER TO EMREMRTRANSPARENTBLT;
%END

    EMREXTCREATEFONTINDIRECTW = RECORD
          emr            : EMR;
          ihFont         : DWORD;
          elfw           : EXTLOGFONTW;
    END;
    PEMREXTCREATEFONTINDIRECTW= POINTER TO EMREXTCREATEFONTINDIRECTW;

    EMRCREATEPALETTE = RECORD
          emr            : EMR;
          ihPal          : DWORD;
          lgpl           : LOGPALETTE;
    END;
    PEMRCREATEPALETTE    = POINTER TO EMRCREATEPALETTE;


    EMRCREATECOLORSPACE = RECORD
        emr     : EMR;
        ihCS    : DWORD;
        lcs     : LOGCOLORSPACEW;
    END;
    PEMRCREATECOLORSPACE = POINTER TO EMRCREATECOLORSPACE;


    EMRCREATEPEN = RECORD
          emr            : EMR;
          ihPen          : DWORD;
          lopn           : LOGPEN;
    END;
    PEMRCREATEPEN        = POINTER TO EMRCREATEPEN;

    EMREXTCREATEPEN = RECORD
          emr            : EMR;
          ihPen          : DWORD;
          offBmi         : DWORD;
          cbBmi          : DWORD;
          offBits        : DWORD;
          cbBits         : DWORD;
          elp            : EXTLOGPEN;
    END;
    PEMREXTCREATEPEN     = POINTER TO EMREXTCREATEPEN;

    EMRCREATEBRUSHINDIRECT = RECORD
          emr            : EMR;
          ihBrush        : DWORD;
          lb             : LOGBRUSH;
    END;
    PEMRCREATEBRUSHINDIRECT= POINTER TO EMRCREATEBRUSHINDIRECT;

    EMRCREATEMONOBRUSH = RECORD
          emr            : EMR;
          ihBrush        : DWORD;
          iUsage         : DWORD;
          offBmi         : DWORD;
          cbBmi          : DWORD;
          offBits        : DWORD;
          cbBits         : DWORD;
    END;
    PEMRCREATEMONOBRUSH  = POINTER TO EMRCREATEMONOBRUSH;

    EMRCREATEDIBPATTERNBRUSHPT = RECORD
          emr            : EMR;
          ihBrush        : DWORD;
          iUsage         : DWORD;
          offBmi         : DWORD;
          cbBmi          : DWORD;
          offBits        : DWORD;
          cbBits         : DWORD;
    END;
    PEMRCREATEDIBPATTERNBRUSHPT= POINTER TO EMRCREATEDIBPATTERNBRUSHPT;

    EMRFORMAT = RECORD
        dSignature      : DWORD;
        nVersion        : DWORD;
        cbData          : DWORD;
        offData         : DWORD;
    END;
    PEMRFORMAT = POINTER TO EMRFORMAT;

    EMRGLSRECORD = RECORD
    emr         : EMR;
    cbData      : DWORD;             (* Size of data in bytes*)
    Data        : ARRAY [0..1-1] OF BYTE;
    END;
    PEMRGLSRECORD = POINTER TO EMRGLSRECORD;

    EMRGLSBOUNDEDRECORD = RECORD
    emr         : EMR;
    rclBounds   : RECTL;          (* Bounds in recording coordinates*)
    cbData      : DWORD;          (* Size of data in bytes*)
    Data        : ARRAY [0..1-1] OF BYTE;
    END;
    PEMRGLSBOUNDEDRECORD = POINTER TO EMRGLSBOUNDEDRECORD;

    EMRPIXELFORMAT = RECORD
    emr         : EMR;
    pfd         : PIXELFORMATDESCRIPTOR;
    END;
    PEMRPIXELFORMAT = POINTER TO EMRPIXELFORMAT;

CONST
    SETICMPROFILE_EMBEDED           = 00000001h;

TYPE
    EMRSETICMPROFILE = RECORD
    emr         : EMR;
    dwFlags     : DWORD;            (* flags*)
    cbName      : DWORD;             (* Size of desired profile name*)
    cbData      : DWORD;             (* Size of raw profile data if attached*)
    Data        : ARRAY [0..1-1] OF BYTE;            (* Array size is cbName and cbData*)
    END;
    PEMRSETICMPROFILE = POINTER TO EMRSETICMPROFILE;

CONST
     GDICOMMENT_IDENTIFIER           = 043494447h;
     GDICOMMENT_WINDOWS_METAFILE     = 080000001h;
     GDICOMMENT_BEGINGROUP           = 000000002h;
     GDICOMMENT_ENDGROUP             = 000000003h;
     GDICOMMENT_MULTIFORMATS         = 040000004h;
     EPS_SIGNATURE                   = 046535045h;

PROCEDURE wglCopyContext(a : HGLRC; b : HGLRC; c : UINT) : BOOL;
PROCEDURE wglCreateContext(a: HDC) : HGLRC;
PROCEDURE wglCreateLayerContext(a : HDC; b : WINT) : HGLRC;
PROCEDURE wglDeleteContext(a: HGLRC) : BOOL;
PROCEDURE wglGetCurrentContext() : HGLRC;
PROCEDURE wglGetCurrentDC() : HDC;
PROCEDURE wglGetProcAddress(a: ARRAY OF CHAR) : PROC;
PROCEDURE wglMakeCurrent(a: HDC; b: HGLRC) : BOOL;
PROCEDURE wglShareLists(a: HGLRC; b: HGLRC) : BOOL;
PROCEDURE wglUseFontBitmapsA(a: HDC; b: DWORD; c: DWORD; d: DWORD) : BOOL;
PROCEDURE wglUseFontBitmapsW(a: HDC; b: DWORD; c: DWORD; d: DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE wglUseFontBitmaps = wglUseFontBitmapsW;
%ELSE
PROCEDURE wglUseFontBitmaps = wglUseFontBitmapsA;
%END

PROCEDURE SwapBuffers(a: HDC) : BOOL;

TYPE
    POINTFLOAT = RECORD
        x       : WFLOAT;
        y       : WFLOAT;
    END;
    PPOINTFLOAT = POINTER TO POINTFLOAT;

    GLYPHMETRICSFLOAT = RECORD
        gmfBlackBoxX    : WFLOAT;
        gmfBlackBoxY    : WFLOAT;
        gmfptGlyphOrigin        : POINTFLOAT;
        gmfCellIncX             : WFLOAT;
        gmfCellIncY             : WFLOAT;
    END;
    PGLYPHMETRICSFLOAT = POINTER TO GLYPHMETRICSFLOAT;
    LPGLYPHMETRICSFLOAT = PGLYPHMETRICSFLOAT;

CONST
    WGL_FONT_LINES      = 0;
    WGL_FONT_POLYGONS   = 1;

PROCEDURE wglUseFontOutlinesA
                     (a: HDC; b: DWORD; c: DWORD; d: DWORD; e: WFLOAT;
                      f: WFLOAT; g: WINT; VAR h: GLYPHMETRICSFLOAT) : BOOL;

PROCEDURE wglUseFontOutlinesW
                     (a: HDC; b: DWORD; c: DWORD; d: DWORD; e: WFLOAT;
                      f: WFLOAT; g: WINT; VAR h: GLYPHMETRICSFLOAT) : BOOL;

%IF UNICODE %THEN
PROCEDURE wglUseFontOutlines = wglUseFontOutlinesW;
%ELSE
PROCEDURE wglUseFontOutlines = wglUseFontOutlinesA;
%END

TYPE
(* Layer plane descriptor *)
    LAYERPLANEDESCRIPTOR = RECORD
    nSize               : WORD;
    nVersion            : WORD;
    dwFlags             : DWORD;
    iPixelType          : BYTE;
    cColorBits          : BYTE;
    cRedBits            : BYTE;
    cRedShift           : BYTE;
    cGreenBits          : BYTE;
    cGreenShift         : BYTE;
    cBlueBits           : BYTE;
    cBlueShift          : BYTE;
    cAlphaBits          : BYTE;
    cAlphaShift         : BYTE;
    cAccumBits          : BYTE;
    cAccumRedBits       : BYTE;
    cAccumGreenBits     : BYTE;
    cAccumBlueBits      : BYTE;
    cAccumAlphaBits     : BYTE;
    cDepthBits          : BYTE;
    cStencilBits        : BYTE;
    cAuxBuffers         : BYTE;
    iLayerPlane         : BYTE;
    bReserved           : BYTE;
    crTransparent       : COLORREF;
    END;
    PLAYERPLANEDESCRIPTOR = POINTER TO LAYERPLANEDESCRIPTOR;
    LPLAYERPLANEDESCRIPTOR = PLAYERPLANEDESCRIPTOR;

CONST
(* LAYERPLANEDESCRIPTOR flags *)
    LPD_DOUBLEBUFFER        = 00000001h;
    LPD_STEREO              = 00000002h;
    LPD_SUPPORT_GDI         = 00000010h;
    LPD_SUPPORT_OPENGL      = 00000020h;
    LPD_SHARE_DEPTH         = 00000040h;
    LPD_SHARE_STENCIL       = 00000080h;
    LPD_SHARE_ACCUM         = 00000100h;
    LPD_SWAP_EXCHANGE       = 00000200h;
    LPD_SWAP_COPY           = 00000400h;
    LPD_TRANSPARENT         = 00001000h;

    LPD_TYPE_RGBA        =0;
    LPD_TYPE_COLORINDEX  =1;

(* wglSwapLayerBuffers flags *)
    WGL_SWAP_MAIN_PLANE     = 00000001h;
    WGL_SWAP_OVERLAY1       = 00000002h;
    WGL_SWAP_OVERLAY2       = 00000004h;
    WGL_SWAP_OVERLAY3       = 00000008h;
    WGL_SWAP_OVERLAY4       = 00000010h;
    WGL_SWAP_OVERLAY5       = 00000020h;
    WGL_SWAP_OVERLAY6       = 00000040h;
    WGL_SWAP_OVERLAY7       = 00000080h;
    WGL_SWAP_OVERLAY8       = 00000100h;
    WGL_SWAP_OVERLAY9       = 00000200h;
    WGL_SWAP_OVERLAY10      = 00000400h;
    WGL_SWAP_OVERLAY11      = 00000800h;
    WGL_SWAP_OVERLAY12      = 00001000h;
    WGL_SWAP_OVERLAY13      = 00002000h;
    WGL_SWAP_OVERLAY14      = 00004000h;
    WGL_SWAP_OVERLAY15      = 00008000h;
    WGL_SWAP_UNDERLAY1      = 00010000h;
    WGL_SWAP_UNDERLAY2      = 00020000h;
    WGL_SWAP_UNDERLAY3      = 00040000h;
    WGL_SWAP_UNDERLAY4      = 00080000h;
    WGL_SWAP_UNDERLAY5      = 00100000h;
    WGL_SWAP_UNDERLAY6      = 00200000h;
    WGL_SWAP_UNDERLAY7      = 00400000h;
    WGL_SWAP_UNDERLAY8      = 00800000h;
    WGL_SWAP_UNDERLAY9      = 01000000h;
    WGL_SWAP_UNDERLAY10     = 02000000h;
    WGL_SWAP_UNDERLAY11     = 04000000h;
    WGL_SWAP_UNDERLAY12     = 08000000h;
    WGL_SWAP_UNDERLAY13     = 10000000h;
    WGL_SWAP_UNDERLAY14     = 20000000h;
    WGL_SWAP_UNDERLAY15     = 40000000h;

PROCEDURE wglDescribeLayerPlane(a : HDC;
                                b : WINT;
                                c : WINT;
                                d : UINT;
                                e : LAYERPLANEDESCRIPTOR) : BOOL;

PROCEDURE wglSetLayerPaletteEntries(a : HDC;
                                    b : WINT;
                                    c : WINT;
                                    d : WINT;
                                    VAR e : COLORREF) : WINT;

PROCEDURE wglGetLayerPaletteEntries(a : HDC;
                                    b : WINT;
                                    c : WINT;
                                    d : WINT;
                                    VAR e : COLORREF) : WINT;

PROCEDURE wglRealizeLayerPalette(a : HDC; b : WINT; c : BOOL) : BOOL;

PROCEDURE wglSwapLayerBuffers(a : HDC; b : UINT) : BOOL;

%IF WIN5 %THEN
TYPE
    WGLSWAP = RECORD
    hdc         : HDC;
    uiFlags     : UINT;
    END;
    PWGLSWAP = POINTER TO WGLSWAP;
    LPWGLSWAP = PWGLSWAP;

CONST
    WGL_SWAPMULTIPLE_MAX = 16;

PROCEDURE wglSwapMultipleBuffers(a : UINT; b : WGLSWAP) : DWORD;
%END

TYPE
    DIBSECTION = RECORD
        dsBm                    : BITMAP;
        dsBmih                  : BITMAPINFOHEADER;
        dsBitfields             : ARRAY [0..3-1] OF DWORD;
        dshSection              : HANDLE;
        dsOffset                : DWORD;
    END;
    PDIBSECTION         = POINTER TO DIBSECTION;
    LPDIBSECTION        = PDIBSECTION;


PROCEDURE GetRValue(rgb : COLORREF) : DWORD; MACRO;
BEGIN
    RETURN VAL(CARDINAL8, rgb);
END GetRValue;

PROCEDURE GetGValue(rgb : COLORREF) : DWORD; MACRO;
BEGIN
    RETURN VAL(CARDINAL8, rgb SHR 8);
END GetGValue;

PROCEDURE GetBValue(rgb : COLORREF) : DWORD; MACRO;
BEGIN
    RETURN VAL(CARDINAL8, rgb SHR 16);
END GetBValue;

PROCEDURE RGB(r, g, b : DWORD) : COLORREF; MACRO;
BEGIN
    RETURN (b SHL 16) BOR (g SHL 8) BOR r;
END RGB;

PROCEDURE PALETTEINDEX(n : WORD) : COLORREF; MACRO;
TYPE Ltype =
    RECORD
        CASE : INTEGER OF
            0: L                : CARDINAL32;
            |
            1: W1, W2           : CARDINAL16;
            |
            2: B1,B2,B3,B4      : CARDINAL8;
        ELSE
      END;
   END;
VAR
    l : Ltype;
BEGIN
    l.W1 := n;
    l.B3 := 0;
    l.B4 := 1;
    RETURN l.L;
END PALETTEINDEX;

PROCEDURE PALETTERGB(r, g, b : DWORD) : COLORREF; MACRO;
BEGIN
    RETURN RGB(r, g, b) BOR 02000000h;
END PALETTERGB;

PROCEDURE GetKValue(cmyk : COLORREF) : DWORD; MACRO;
BEGIN
    RETURN cmyk BAND 0ffh;
END GetKValue;

PROCEDURE GetYValue(cmyk : COLORREF) : DWORD; MACRO;
BEGIN
    RETURN (cmyk SHR 8) BAND 0ffh;
END GetYValue;

PROCEDURE GetMValue(cmyk : COLORREF) : DWORD; MACRO;
BEGIN
    RETURN (cmyk SHR 16) BAND 0ffh;
END GetMValue;

PROCEDURE GetCValue(cmyk : COLORREF) : DWORD; MACRO;
BEGIN
    RETURN cmyk SHR 24;
END GetCValue;

PROCEDURE CMYK(c, m, y, k : DWORD) : COLORREF; MACRO;
BEGIN
    RETURN (c SHL 24) BOR (m SHL 16) BOR (y SHL 8) BOR k;
END CMYK;

PROCEDURE MAKEROP4(fore,back : DWORD) : DWORD; MACRO;
BEGIN
    RETURN ((back SHL 8) BAND 0FF000000h) BOR fore;
END MAKEROP4;

END WINGDI.

(*
* Copyright (c) 1985-2000, Microsoft Corp. All rights reserved.             *
*)
(* Conversion from Microsoft WIN32 SDK C source to Modula-2 source *)
(* Copyright (c) 1995-2000, Stony Brook Software. All rights reserved. *)

DEFINITION MODULE WINUSER;

FROM SYSTEM IMPORT
    CAST;
IMPORT SYSTEM;

FROM WIN32 IMPORT
    HANDLE, PVOID, DWORD, HWND, UINT, WPARAM, LPARAM, LRESULT, BOOL, HDC,
    LPCWSTR, LPCSTR, LPWSTR, LPSTR, LPTSTR, POINT, HKL, HDESK, HWINSTA,
    LPSECURITY_ATTRIBUTES,
    PSECURITY_INFORMATION, PSECURITY_DESCRIPTOR, HINSTANCE, HICON, HCURSOR,
    HBRUSH, RECT, WORD, LONG, LPVOID, ATOM, HMENU, WCHAR, SHORT, PBYTE,
    HACCEL, HBITMAP, HRGN,
    WINT, COLORREF, HHOOK, LPATOM, HTASK, HGLOBAL, BYTE;

FROM WINGDI IMPORT
    LOGFONTA, LOGFONTW, DEVMODEA, DEVMODEW;

%IF WIN5 %THEN
FROM WIN32 IMPORT
    HMONITOR, HMODULE, HWINEVENTHOOK;
FROM WINGDI IMPORT
    CCHDEVICENAME, DISPLAY_DEVICEA, DISPLAY_DEVICEW;
%END

<*/CALLS:WIN32SYSTEM*>
<*/NOHIGH*>
<*/ALIGN:8/NOPACK*>

CONST
    WINVER               = 0030Ah;

TYPE
    HDWP                 = HANDLE;

    MENUTEMPLATEA        = BYTE;
    MENUTEMPLATEW        = BYTE;
    LPMENUTEMPLATEA      = PVOID;
    LPMENUTEMPLATEW      = PVOID;
    %IF UNICODE %THEN
    MENUTEMPLATE         = MENUTEMPLATEW;
    LPMENUTEMPLATE       = LPMENUTEMPLATEW;
    %ELSE
    LPMENUTEMPLATE       = LPMENUTEMPLATEA;
    MENUTEMPLATE         = MENUTEMPLATEA;
    %END

    WNDPROC              = PROCEDURE(HWND,
                                     UINT,
                                     WPARAM,
                                     LPARAM) : LRESULT [EXPORT];

    DLGPROC              = PROCEDURE(HWND,
                                     UINT,
                                     WPARAM,
                                     LPARAM) : BOOL [EXPORT];

    TIMERPROC            = PROCEDURE(HWND,
                                     UINT,
                                     UINT,
                                     DWORD) [EXPORT];

    GRAYSTRINGPROC       = PROCEDURE(HDC,
                                     LPARAM,
                                     INTEGER) : BOOL [EXPORT];

    WNDENUMPROC          = PROCEDURE(HWND,
                                     LPARAM) : BOOL [EXPORT];

    HOOKPROC             = PROCEDURE(INTEGER,
                                     WPARAM,
                                     LPARAM) : LRESULT [EXPORT];

    SENDASYNCPROC        = PROCEDURE(HWND,
                                     UINT,
                                     DWORD,
                                     LRESULT) [EXPORT];

    PROPENUMPROCA        = PROCEDURE(HWND,
                                     ARRAY OF ACHAR,
                                     HANDLE) : BOOL [EXPORT];

    PROPENUMPROCW        = PROCEDURE(HWND,
                                     ARRAY OF UCHAR,
                                     HANDLE) : BOOL [EXPORT];

    PROPENUMPROCEXA      = PROCEDURE(HWND,
                                     VAR ARRAY OF ACHAR,
                                     HANDLE,
                                     DWORD) : BOOL [EXPORT];

    PROPENUMPROCEXW      = PROCEDURE(HWND,
                                     VAR ARRAY OF UCHAR,
                                     HANDLE,
                                     DWORD) : BOOL [EXPORT];

    EDITWORDBREAKPROCA   = PROCEDURE(VAR ARRAY OF ACHAR,
                                     INTEGER,
                                     INTEGER,
                                     INTEGER) : INTEGER [EXPORT];

    EDITWORDBREAKPROCW   = PROCEDURE(VAR ARRAY OF UCHAR,
                                     INTEGER,
                                     INTEGER,
                                     INTEGER) : INTEGER [EXPORT];
    %IF UNICODE %THEN
    EDITWORDBREAKPROC    = EDITWORDBREAKPROCW;
    %ELSE
    EDITWORDBREAKPROC    = EDITWORDBREAKPROCA;
    %END

    NAMEENUMPROCA        = PROCEDURE(ARRAY OF ACHAR, LPARAM) : BOOL [EXPORT];
    WINSTAENUMPROCA      = NAMEENUMPROCA;
    DESKTOPENUMPROCA     = NAMEENUMPROCA;

    NAMEENUMPROCW        = PROCEDURE(ARRAY OF UCHAR, LPARAM) : BOOL [EXPORT];
    WINSTAENUMPROCW      = NAMEENUMPROCW;
    DESKTOPENUMPROCW     = NAMEENUMPROCW;
%IF UNICODE %THEN
    NAMEENUMPROC         = NAMEENUMPROCW;
    WINSTAENUMPROC       = WINSTAENUMPROCW;
    DESKTOPENUMPROC      = DESKTOPENUMPROCW;
%ELSE
    NAMEENUMPROC         = NAMEENUMPROCA;
    WINSTAENUMPROC       = WINSTAENUMPROCA;
    DESKTOPENUMPROC      = DESKTOPENUMPROCA;
%END

    DRAWSTATEPROC        = PROCEDURE(HDC,
                                     LPARAM,
                                     WPARAM,
                                     WINT,
                                     WINT) : BOOL [EXPORT];(*95*)

    %IF UNICODE %THEN
    PROPENUMPROC         = PROPENUMPROCW;
    PROPENUMPROCEX       = PROPENUMPROCEXW;
    %ELSE
    PROPENUMPROC         = PROPENUMPROCA;
    PROPENUMPROCEX       = PROPENUMPROCEXA;
    %END

PROCEDURE MAKEINTRESOURCEA(i : INTEGER) : LPSTR; MACRO;
BEGIN
    RETURN CAST(LPSTR, i);
END MAKEINTRESOURCEA;

PROCEDURE MAKEINTRESOURCEW(i : INTEGER) : LPWSTR; MACRO;
BEGIN
    RETURN CAST(LPWSTR, i);
END MAKEINTRESOURCEW;

PROCEDURE MAKEINTRESOURCE(i : INTEGER) : LPTSTR; MACRO;
BEGIN
    RETURN CAST(LPTSTR, i);
END MAKEINTRESOURCE;

CONST
    RT_CURSOR           = CAST(LPTSTR,1);
    RT_BITMAP           = CAST(LPTSTR,2);
    RT_ICON             = CAST(LPTSTR,3);
    RT_MENU             = CAST(LPTSTR,4);
    RT_DIALOG           = CAST(LPTSTR,5);
    RT_STRING           = CAST(LPTSTR,6);
    RT_FONTDIR          = CAST(LPTSTR,7);
    RT_FONT             = CAST(LPTSTR,8);
    RT_ACCELERATOR      = CAST(LPTSTR,9);
    RT_RCDATA           = CAST(LPTSTR,10);
    RT_MESSAGETABLE     = CAST(LPTSTR,11);

    DIFFERENCE          = 11;
    RT_GROUP_CURSOR     = CAST(LPTSTR, 1 + DIFFERENCE);
    RT_GROUP_ICON       = CAST(LPTSTR, 3 + DIFFERENCE);

    RT_VERSION          = CAST(LPTSTR,16);
    RT_DLGINCLUDE       = CAST(LPTSTR,17);
    RT_PLUGPLAY         = CAST(LPTSTR,19);
    RT_VXD              = CAST(LPTSTR,20);
    RT_ANICURSOR    = CAST(LPTSTR, 21);
    RT_ANIICON      = CAST(LPTSTR, 22);
    RT_HTML         = CAST(LPTSTR, 23);


PROCEDURE wvsprintfA(VAR a : ARRAY OF ACHAR;
                     b : ARRAY OF ACHAR;
                     c : LPVOID) : INTEGER;

PROCEDURE wvsprintfW(VAR a : ARRAY OF UCHAR;
                     b : ARRAY OF UCHAR;
                     c : LPVOID) : INTEGER;

%IF UNICODE %THEN
PROCEDURE wvsprintf = wvsprintfW;
%ELSE
PROCEDURE wvsprintf = wvsprintfA;
%END

PROCEDURE wsprintfA(VAR a : ARRAY OF ACHAR;
                    b : ARRAY OF ACHAR) : INTEGER [VARIABLE, msCdecl];

PROCEDURE wsprintfW(VAR a : ARRAY OF UCHAR;
                    b : ARRAY OF UCHAR) : INTEGER [VARIABLE, msCdecl];

%IF UNICODE %THEN
PROCEDURE wsprintf = wsprintfW;
%ELSE
PROCEDURE wsprintf = wsprintfA;
%END

CONST
    SB_HORZ              = 0;
    SB_VERT              = 1;
    SB_CTL               = 2;
    SB_BOTH              = 3;
    SB_LINEUP            = 0;
    SB_LINELEFT          = 0;
    SB_LINEDOWN          = 1;
    SB_LINERIGHT         = 1;
    SB_PAGEUP            = 2;
    SB_PAGELEFT          = 2;
    SB_PAGEDOWN          = 3;
    SB_PAGERIGHT         = 3;
    SB_THUMBPOSITION     = 4;
    SB_THUMBTRACK        = 5;
    SB_TOP               = 6;
    SB_LEFT              = 6;
    SB_BOTTOM            = 7;
    SB_RIGHT             = 7;
    SB_ENDSCROLL         = 8;

    SW_HIDE              = 0;
    SW_SHOWNORMAL        = 1;
    SW_NORMAL            = 1;
    SW_SHOWMINIMIZED     = 2;
    SW_SHOWMAXIMIZED     = 3;
    SW_MAXIMIZE          = 3;
    SW_SHOWNOACTIVATE    = 4;
    SW_SHOW              = 5;
    SW_MINIMIZE          = 6;
    SW_SHOWMINNOACTIVE   = 7;
    SW_SHOWNA            = 8;
    SW_RESTORE           = 9;
    SW_SHOWDEFAULT       = 10;
    SW_FORCEMINIMIZE     = 11;
    SW_MAX               = 11;

    HIDE_WINDOW          = 0;

    SHOW_OPENWINDOW      = 1;
    SHOW_ICONWINDOW      = 2;
    SHOW_FULLSCREEN      = 3;
    SHOW_OPENNOACTIVATE  = 4;

    SW_PARENTCLOSING     = 1;
    SW_OTHERZOOM         = 2;
    SW_PARENTOPENING     = 3;
    SW_OTHERUNZOOM       = 4;

%IF WIN5 %THEN
(*
 * AnimateWindow() Commands
 *)
    AW_HOR_POSITIVE             = 00000001h;
    AW_HOR_NEGATIVE             = 00000002h;
    AW_VER_POSITIVE             = 00000004h;
    AW_VER_NEGATIVE             = 00000008h;
    AW_CENTER                   = 00000010h;
    AW_HIDE                     = 00010000h;
    AW_ACTIVATE                 = 00020000h;
    AW_SLIDE                    = 00040000h;
    AW_BLEND                    = 00080000h;
%END

    KF_EXTENDED          = 00100h;
    KF_DLGMODE           = 00800h;
    KF_MENUMODE          = 01000h;
    KF_ALTDOWN           = 02000h;
    KF_REPEAT            = 04000h;
    KF_UP                = 08000h;

    VK_LBUTTON           = 001h;
    VK_RBUTTON           = 002h;
    VK_CANCEL            = 003h;
    VK_MBUTTON           = 004h;
    VK_BACK              = 008h;
    VK_TAB               = 009h;
    VK_CLEAR             = 00Ch;
    VK_RETURN            = 00Dh;
    VK_SHIFT             = 010h;
    VK_CONTROL           = 011h;
    VK_MENU              = 012h;
    VK_PAUSE             = 013h;
    VK_CAPITAL           = 014h;
    VK_KANA           = 15h;
    VK_HANGEUL        = 15h;  (* old name - should be here for compatibility *)
    VK_HANGUL         = 15h;
    VK_JUNJA          = 17h;
    VK_FINAL          = 18h;
    VK_HANJA          = 19h;
    VK_KANJI          = 19h;
    VK_ESCAPE            = 01Bh;
    VK_CONVERT        = 1Ch;
    VK_NONCONVERT     = 1Dh;
    VK_ACCEPT         = 1Eh;
    VK_MODECHANGE     = 1Fh;
    VK_SPACE             = 020h;
    VK_PRIOR             = 021h;
    VK_NEXT              = 022h;
    VK_END               = 023h;
    VK_HOME              = 024h;
    VK_LEFT              = 025h;
    VK_UP                = 026h;
    VK_RIGHT             = 027h;
    VK_DOWN              = 028h;
    VK_SELECT            = 029h;
    VK_PRINT             = 02Ah;
    VK_EXECUTE           = 02Bh;
    VK_SNAPSHOT          = 02Ch;
    VK_INSERT            = 02Dh;
    VK_DELETE            = 02Eh;
    VK_HELP              = 02Fh;

    VK_LWIN              = 05Bh;
    VK_RWIN              = 05Ch;
    VK_APPS              = 05Dh;

    VK_NUMPAD0           = 060h;
    VK_NUMPAD1           = 061h;
    VK_NUMPAD2           = 062h;
    VK_NUMPAD3           = 063h;
    VK_NUMPAD4           = 064h;
    VK_NUMPAD5           = 065h;
    VK_NUMPAD6           = 066h;
    VK_NUMPAD7           = 067h;
    VK_NUMPAD8           = 068h;
    VK_NUMPAD9           = 069h;
    VK_MULTIPLY          = 06Ah;
    VK_ADD               = 06Bh;
    VK_SEPARATOR         = 06Ch;
    VK_SUBTRACT          = 06Dh;
    VK_DECIMAL           = 06Eh;
    VK_DIVIDE            = 06Fh;
    VK_F1                = 070h;
    VK_F2                = 071h;
    VK_F3                = 072h;
    VK_F4                = 073h;
    VK_F5                = 074h;
    VK_F6                = 075h;
    VK_F7                = 076h;
    VK_F8                = 077h;
    VK_F9                = 078h;
    VK_F10               = 079h;
    VK_F11               = 07Ah;
    VK_F12               = 07Bh;
    VK_F13               = 07Ch;
    VK_F14               = 07Dh;
    VK_F15               = 07Eh;
    VK_F16               = 07Fh;
    VK_F17               = 080h;
    VK_F18               = 081h;
    VK_F19               = 082h;
    VK_F20               = 083h;
    VK_F21               = 084h;
    VK_F22               = 085h;
    VK_F23               = 086h;
    VK_F24               = 087h;
    VK_NUMLOCK           = 090h;
    VK_SCROLL            = 091h;
    VK_LSHIFT            = 0A0h;
    VK_RSHIFT            = 0A1h;
    VK_LCONTROL          = 0A2h;
    VK_RCONTROL          = 0A3h;
    VK_LMENU             = 0A4h;
    VK_RMENU             = 0A5h;

(* if WIN32_WINNT >= 0x0500)*)
    VK_BROWSER_BACK        = 0A6h;
    VK_BROWSER_FORWARD     = 0A7h;
    VK_BROWSER_REFRESH     = 0A8h;
    VK_BROWSER_STOP        = 0A9h;
    VK_BROWSER_SEARCH      = 0AAh;
    VK_BROWSER_FAVORITES   = 0ABh;
    VK_BROWSER_HOME        = 0ACh;

    VK_VOLUME_MUTE         = 0ADh;
    VK_VOLUME_DOWN         = 0AEh;
    VK_VOLUME_UP           = 0AFh;
    VK_MEDIA_NEXT_TRACK    = 0B0h;
    VK_MEDIA_PREV_TRACK    = 0B1h;
    VK_MEDIA_STOP          = 0B2h;
    VK_MEDIA_PLAY_PAUSE    = 0B3h;
    VK_LAUNCH_MAIL         = 0B4h;
    VK_LAUNCH_MEDIA_SELECT = 0B5h;
    VK_LAUNCH_APP1         = 0B6h;
    VK_LAUNCH_APP2         = 0B7h;

(* end _WIN32_WINNT >= 0x0500 *)

    VK_PROCESSKEY        = 0E5h;(*95*)

    VK_ATTN              = 0F6h;
    VK_CRSEL             = 0F7h;
    VK_EXSEL             = 0F8h;
    VK_EREOF             = 0F9h;
    VK_PLAY              = 0FAh;
    VK_ZOOM              = 0FBh;
    VK_NONAME            = 0FCh;
    VK_PA1               = 0FDh;
    VK_OEM_CLEAR         = 0FEh;

    WH_MIN               = ( - 1 ) ;
    WH_MSGFILTER         = ( - 1 ) ;
    WH_JOURNALRECORD     = 0;
    WH_JOURNALPLAYBACK   = 1;
    WH_KEYBOARD          = 2;
    WH_GETMESSAGE        = 3;
    WH_CALLWNDPROC       = 4;
    WH_CBT               = 5;
    WH_SYSMSGFILTER      = 6;
    WH_MOUSE             = 7;
    WH_HARDWARE          = 8;
    WH_DEBUG             = 9;
    WH_SHELL             = 10;
    WH_FOREGROUNDIDLE    = 11;


%IF WIN4 %THEN
    WH_CALLWNDPROCRET    = 12;
    WH_KEYBOARD_LL     =13;(*NT only*)
    WH_MOUSE_LL        =14;(*NT only*)
    WH_MAX               = 14;
%ELSE
    WH_MAX               = 11;
%END

    WH_MINHOOK           = WH_MIN;
    WH_MAXHOOK           = WH_MAX;


    HC_ACTION            = 0;
    HC_GETNEXT           = 1;
    HC_SKIP              = 2;
    HC_NOREMOVE          = 3;
    HC_NOREM             = HC_NOREMOVE;(*95*)
    HC_SYSMODALON        = 4;
    HC_SYSMODALOFF       = 5;

    HCBT_MOVESIZE        = 0;
    HCBT_MINMAX          = 1;
    HCBT_QS              = 2;
    HCBT_CREATEWND       = 3;
    HCBT_DESTROYWND      = 4;
    HCBT_ACTIVATE        = 5;
    HCBT_CLICKSKIPPED    = 6;
    HCBT_KEYSKIPPED      = 7;
    HCBT_SYSCOMMAND      = 8;
    HCBT_SETFOCUS        = 9;

TYPE
    CREATESTRUCTA        = RECORD
        lpCreateParams       : LPVOID;
        hInstance            : HINSTANCE;
        hMenu                : HMENU;
        hwndParent           : HWND;
        cy                   : INTEGER;
        cx                   : INTEGER;
        y                    : INTEGER;
        x                    : INTEGER;
        style                : LONG;
        lpszName             : LPCSTR;
        lpszClass            : LPCSTR;
        dwExStyle            : DWORD;
    END;
    LPCREATESTRUCTA      = POINTER TO CREATESTRUCTA;

    CREATESTRUCTW        = RECORD
        lpCreateParams       : LPVOID;
        hInstance            : HINSTANCE;
        hMenu                : HMENU;
        hwndParent           : HWND;
        cy                   : INTEGER;
        cx                   : INTEGER;
        y                    : INTEGER;
        x                    : INTEGER;
        style                : LONG;
        lpszName             : LPCWSTR;
        lpszClass            : LPCWSTR;
        dwExStyle            : DWORD;
    END;
    LPCREATESTRUCTW      = POINTER TO CREATESTRUCTW;

    %IF UNICODE %THEN
    CREATESTRUCT = CREATESTRUCTW;
    LPCREATESTRUCT = LPCREATESTRUCTW;
    %ELSE
    CREATESTRUCT = CREATESTRUCTA;
    LPCREATESTRUCT = LPCREATESTRUCTA;
    %END

    CBT_CREATEWNDA = RECORD
          lpcs           : POINTER TO CREATESTRUCTA;
          hwndInsertAfter: HWND;
    END;
    LPCBT_CREATEWNDA     = POINTER TO CBT_CREATEWNDA;

    CBT_CREATEWNDW = RECORD
          lpcs           : POINTER TO CREATESTRUCTW;
          hwndInsertAfter: HWND;
    END;
    LPCBT_CREATEWNDW     = POINTER TO CBT_CREATEWNDW;

    %IF UNICODE %THEN
    CBT_CREATEWND        = CBT_CREATEWNDW;
    LPCBT_CREATEWND      = LPCBT_CREATEWNDW;
    %ELSE
    CBT_CREATEWND        = CBT_CREATEWNDA;
    LPCBT_CREATEWND      = LPCBT_CREATEWNDA;
    %END

    CBTACTIVATESTRUCT = RECORD
          fMouse         : BOOL;
          hWndActive     : HWND;
    END;
    LPCBTACTIVATESTRUCT  = POINTER TO CBTACTIVATESTRUCT;

CONST
    MSGF_DIALOGBOX       = 0;
    MSGF_MESSAGEBOX      = 1;
    MSGF_MENU            = 2;
    MSGF_MOVE            = 3;
    MSGF_SIZE            = 4;
    MSGF_SCROLLBAR       = 5;
    MSGF_NEXTWINDOW      = 6;
    MSGF_MAINLOOP        = 8;
    MSGF_MAX             = 8;
    MSGF_USER            = 4096;

    HSHELL_WINDOWCREATED        = 1;
    HSHELL_WINDOWDESTROYED      = 2;
    HSHELL_ACTIVATESHELLWINDOW  = 3;

    HSHELL_WINDOWACTIVATED      = 4;
    HSHELL_GETMINRECT           = 5;
    HSHELL_REDRAW               = 6;
    HSHELL_TASKMAN              = 7;
    HSHELL_LANGUAGE             = 8;

%IF WIN5 %THEN
    HSHELL_ACCESSIBILITYSTATE   = 11;(*NT only*)
       ACCESS_STICKYKEYS            =00001h;(*NT only*)
       ACCESS_FILTERKEYS            =00002h;(*NT only*)
       ACCESS_MOUSEKEYS             =00003h;(*NT only*)
%END


TYPE
    EVENTMSG = RECORD
          message        : UINT;
          paramL         : UINT;
          paramH         : UINT;
          time           : DWORD;
          hwnd           : HWND;
    END;
    PEVENTMSGMSG         = POINTER TO EVENTMSG;
    LPEVENTMSGMSG        = PEVENTMSGMSG;

    PEVENTMSG            = POINTER TO EVENTMSG;
    LPEVENTMSG           = PEVENTMSG;

    CWPSTRUCT = RECORD
          lParam         : LPARAM;
          wParam         : WPARAM;
          message        : DWORD;
          hwnd           : HWND;
    END;
    PCWPSTRUCT           = POINTER TO CWPSTRUCT;
    LPCWPSTRUCT          = PCWPSTRUCT;

    CWPRETSTRUCT = RECORD
        lResult         : LRESULT;
        lParam          : LPARAM;
        wParam          : WPARAM;
        message         : UINT;
        hwnd            : HWND;
    END;
    PCWPRETSTRUCT  = POINTER TO CWPRETSTRUCT;
    LPCWPRETSTRUCT = PCWPRETSTRUCT;

(*
 * Low level hook flags
 *)
CONST
    (*NT only*)
    LLKHF_EXTENDED       = 00000001h;
    LLKHF_INJECTED       = 00000010h;
    LLKHF_ALTDOWN        = 00000020h;
    LLKHF_UP             = 00000080h;

    LLMHF_INJECTED       = 00000001h;

TYPE
(*
 * Structure used by WH_KEYBOARD_LL
 *)
     (*NT only*)
    KBDLLHOOKSTRUCT = RECORD
    vkCode              : DWORD;
    scanCode            : DWORD;
    flags               : DWORD;
    time                : DWORD;
    dwExtraInfo         : DWORD;
    END;
    PKBDLLHOOKSTRUCT = POINTER TO KBDLLHOOKSTRUCT;
    LPKBDLLHOOKSTRUCT = PKBDLLHOOKSTRUCT;

(*
 * Structure used by WH_MOUSE_LL
 *)
     (*NT only*)
    MSLLHOOKSTRUCT = RECORD
    pt          : POINT;
    mouseData   : DWORD;
    flags       : DWORD;
    time        : DWORD;
    dwExtraInfo : DWORD;
    END;
    PMSLLHOOKSTRUCT = POINTER TO MSLLHOOKSTRUCT;
    LPMSLLHOOKSTRUCT = PMSLLHOOKSTRUCT;

    DEBUGHOOKINFO = RECORD
          idThread              : DWORD;
          idThreadInstaller     : DWORD;
          lParam                : LPARAM;
          wParam                : WPARAM;
          code                  : INTEGER;
    END;
    PDEBUGHOOKINFO       = POINTER TO DEBUGHOOKINFO;
    LPDEBUGHOOKINFO      = PDEBUGHOOKINFO;

    MOUSEHOOKSTRUCT = RECORD
          pt             : POINT;
          hwnd           : HWND;
          wHitTestCode   : UINT;
          dwExtraInfo    : DWORD;
    END;
    PMOUSEHOOKSTRUCT     = POINTER TO MOUSEHOOKSTRUCT;
    LPMOUSEHOOKSTRUCT    = PMOUSEHOOKSTRUCT;

    HARDWAREHOOKSTRUCT = RECORD
        hwnd    : HWND;
        message : UINT;
        wParam  : WPARAM;
        lParam  : LPARAM;
    END;
    PHARDWAREHOOKSTRUCT  = POINTER TO HARDWAREHOOKSTRUCT;
    LPHARDWAREHOOKSTRUCT = PHARDWAREHOOKSTRUCT;

CONST
    HKL_PREV             = 0;
    HKL_NEXT             = 1;
    KLF_ACTIVATE         = 000000001h;
    KLF_SUBSTITUTE_OK    = 000000002h;
    KLF_UNLOADPREVIOUS   = 000000004h;
    KLF_REORDER          = 000000008h;
    KLF_REPLACELANG      = 000000010h;
    KLF_NOTELLSHELL      = 000000080h;
    KLF_SETFORPROCESS    = 000000100h;
    KL_NAMELENGTH        = 9;

PROCEDURE LoadKeyboardLayoutA(pwszKLID : ARRAY OF ACHAR;
                              Flags : UINT) : HKL;

PROCEDURE LoadKeyboardLayoutW(pwszKLID : ARRAY OF UCHAR;
                              Flags : UINT) : HKL;

%IF UNICODE %THEN
PROCEDURE LoadKeyboardLayout = LoadKeyboardLayoutW;
%ELSE
PROCEDURE LoadKeyboardLayout = LoadKeyboardLayoutA;
%END

PROCEDURE ActivateKeyboardLayout(hkl : HKL;
                                 Flags : UINT) : BOOL;

PROCEDURE ToUnicodeEx(  wVirtKey : UINT;
                        wScanCode : UINT;
                        lpKeyState : PBYTE;
                        VAR pwszBuff : ARRAY OF UCHAR;
                        cchBuff : WINT;
                        wFlags : UINT;
                        dwhkl : HKL) : WINT;

PROCEDURE UnloadKeyboardLayout(hkl : HKL) : BOOL;

PROCEDURE GetKeyboardLayoutNameA(VAR pwszKLID : ARRAY OF ACHAR) : BOOL;

PROCEDURE GetKeyboardLayoutNameW(VAR pwszKLID : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetKeyboardLayoutName = GetKeyboardLayoutNameW;
%ELSE
PROCEDURE GetKeyboardLayoutName = GetKeyboardLayoutNameA;
%END



PROCEDURE GetKeyboardLayoutList(nBuff : WINT; VAR lpList : HKL) : WINT;

PROCEDURE GetKeyboardLayout(dwLayout : DWORD) : HKL;

%IF WIN5 %THEN
TYPE
    MOUSEMOVEPOINT = RECORD
    x           : WINT;
    y           : WINT;
    time        : DWORD;
    dwExtraInfo : DWORD;
    END;
    PMOUSEMOVEPOINT  = POINTER TO MOUSEMOVEPOINT;
    LPMOUSEMOVEPOINT = PMOUSEMOVEPOINT;

(*
 * Values for resolution parameter of GetMouseMovePoints
 *)
CONST
    GMMP_USE_DISPLAY_POINTS   =1;
    GMMP_USE_DRIVER_POINTS    =2;

PROCEDURE GetMouseMovePoints(cbSize : UINT;
                             VAR lpp : MOUSEMOVEPOINT;
                             VAR lpptBuf : ARRAY OF MOUSEMOVEPOINT;
                             nBufPoints : WINT;
                             resolution : DWORD) : WINT;

%END

CONST
    DESKTOP_READOBJECTS         = 00001h;
    DESKTOP_CREATEWINDOW        = 00002h;
    DESKTOP_CREATEMENU          = 00004h;
    DESKTOP_HOOKCONTROL         = 00008h;
    DESKTOP_JOURNALRECORD       = 00010h;
    DESKTOP_JOURNALPLAYBACK     = 00020h;
    DESKTOP_ENUMERATE           = 00040h;
    DESKTOP_WRITEOBJECTS        = 00080h;
    DESKTOP_SWITCHDESKTOP       = 00100h;

    DF_ALLOWOTHERACCOUNTHOOK    = 1;

PROCEDURE CreateDesktopA(lpszDesktop : ARRAY OF ACHAR;
                         lpszDevice : ARRAY OF ACHAR;
                         pDevmode : DEVMODEA;
                         dwFlags : DWORD;
                         dwDesiredAccess : DWORD;
                         lpsa : LPSECURITY_ATTRIBUTES) : HDESK;

PROCEDURE CreateDesktopW(lpszDesktop : ARRAY OF UCHAR;
                         lpszDevice : ARRAY OF UCHAR;
                         pDevmode : DEVMODEW;
                         dwFlags : DWORD;
                         dwDesiredAccess : DWORD;
                         lpsa : LPSECURITY_ATTRIBUTES) : HDESK;
%IF UNICODE %THEN
PROCEDURE CreateDesktop = CreateDesktopW;
%ELSE
PROCEDURE CreateDesktop = CreateDesktopA;
%END

PROCEDURE OpenDesktopA(lpszDesktop : ARRAY OF ACHAR;
                       dwFlags : DWORD;
                       fInherit : BOOL;
                       dwDesiredAccess : DWORD) : HDESK;

PROCEDURE OpenDesktopW(lpszDesktop : ARRAY OF UCHAR;
                       dwFlags : DWORD;
                       fInherit : BOOL;
                       dwDesiredAccess : DWORD) : HDESK;

%IF UNICODE %THEN
PROCEDURE OpenDesktop = OpenDesktopW;
%ELSE
PROCEDURE OpenDesktop = OpenDesktopA;
%END

PROCEDURE OpenInputDesktop(dwFlags : DWORD;
                           fInherit : BOOL;
                           dwDesiredAccess : DWORD) : HDESK;

PROCEDURE EnumDesktopsA(hwinsta : HWINSTA;
                        lpEnumFunc : DESKTOPENUMPROCA;
                        lParam : LPARAM) : BOOL;

PROCEDURE EnumDesktopsW(hwinsta : HWINSTA;
                        lpEnumFunc : DESKTOPENUMPROCW;
                        lParam : LPARAM) : BOOL;

%IF UNICODE %THEN
PROCEDURE EnumDesktops = EnumDesktopsW;
%ELSE
PROCEDURE EnumDesktops = EnumDesktopsA;
%END

PROCEDURE EnumDesktopWindows(hDesktop : HDESK;
                             lpfn : WNDENUMPROC;
                             lParam : LPARAM) : BOOL;

PROCEDURE SwitchDesktop(hDesktop : HDESK) : BOOL;

PROCEDURE SetThreadDesktop(hDesktop : HDESK) : BOOL;

PROCEDURE CloseDesktop(hDesktop : HDESK) : BOOL;

PROCEDURE GetThreadDesktop(a : DWORD) : HDESK;

CONST
    WINSTA_ENUMDESKTOPS  = 00001h;
    WINSTA_READATTRIBUTES= 00002h;
    WINSTA_ACCESSCLIPBOARD= 00004h;
    WINSTA_CREATEDESKTOP = 00008h;
    WINSTA_WRITEATTRIBUTES= 00010h;
    WINSTA_ACCESSGLOBALATOMS= 00020h;
    WINSTA_EXITWINDOWS   = 00040h;
    WINSTA_ENUMERATE     = 00100h;
    WINSTA_READSCREEN    = 00200h;
    WSF_VISIBLE          = 1;

PROCEDURE CreateWindowStationA(lpwinsta : ARRAY OF ACHAR;
                               dwReserved : DWORD;
                               dwDesiredAccess : DWORD;
                               lpsa : LPSECURITY_ATTRIBUTES) : HWINSTA;

PROCEDURE CreateWindowStationW(lpwinsta : ARRAY OF UCHAR;
                               dwReserved : DWORD;
                               dwDesiredAccess : DWORD;
                               lpsa : LPSECURITY_ATTRIBUTES) : HWINSTA;

%IF UNICODE %THEN
PROCEDURE CreateWindowStation = CreateWindowStationW;
%ELSE
PROCEDURE CreateWindowStation = CreateWindowStationA;
%END

PROCEDURE OpenWindowStationA(lpszWinSta : ARRAY OF ACHAR;
                             fInherit : BOOL;
                             dwDesiredAccess : DWORD) : HWINSTA;

PROCEDURE OpenWindowStationW(lpszWinSta : ARRAY OF UCHAR;
                             fInherit : BOOL;
                             dwDesiredAccess : DWORD) : HWINSTA;

%IF UNICODE %THEN
PROCEDURE OpenWindowStation = OpenWindowStationW;
%ELSE
PROCEDURE OpenWindowStation = OpenWindowStationA;
%END
PROCEDURE EnumWindowStationsW(lpEnumFunc : WINSTAENUMPROCW;
                              lParam : LPARAM) : BOOL;

PROCEDURE EnumWindowStationsA(lpEnumFunc : WINSTAENUMPROCA;
                              lParam : LPARAM) : BOOL;
%IF UNICODE %THEN
PROCEDURE EnumWindowStations = EnumWindowStationsW;
%ELSE
PROCEDURE EnumWindowStations = EnumWindowStationsA;
%END

PROCEDURE CloseWindowStation(hWinSta : HWINSTA) : BOOL;

PROCEDURE SetProcessWindowStation(hWinSta : HWINSTA) : BOOL;

PROCEDURE GetProcessWindowStation() : HWINSTA;

PROCEDURE SetUserObjectSecurity(hObj : HANDLE;
                                pSIRequested : PSECURITY_INFORMATION;
                                pSID : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE GetUserObjectSecurity(hObj : HANDLE;
                                pSIRequested : PSECURITY_INFORMATION;
                                pSID : PSECURITY_DESCRIPTOR;
                                nLength : DWORD;
                                VAR lpnLengthNeeded : DWORD) : BOOL;

CONST
    UOI_FLAGS            = 1;
    UOI_NAME             = 2;
    UOI_TYPE             = 3;
    UOI_USER_SID    = 4;

TYPE
    USEROBJECTFLAGS = RECORD
        fInherit        : BOOL;
        fReserved       : BOOL;
        dwFlags         : DWORD;
    END;
    PUSEROBJECTFLAGS    = POINTER TO USEROBJECTFLAGS;

PROCEDURE GetUserObjectInformationA(hObj : HANDLE;
                                    nIndex : WINT;
                                    pvInfo : PVOID;
                                    nLength : DWORD;
                                    VAR lpnLengthNeeded : DWORD) : BOOL;

PROCEDURE GetUserObjectInformationW(hObj : HANDLE;
                                    nIndex : WINT;
                                    pvInfo : PVOID;
                                    nLength : DWORD;
                                    VAR lpnLengthNeeded : DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE GetUserObjectInformation = GetUserObjectInformationW;
%ELSE
PROCEDURE GetUserObjectInformation = GetUserObjectInformationA;
%END

PROCEDURE SetUserObjectInformationA(hObj : HANDLE;
                                    nIndex : WINT;
                                    pvInfo : PVOID;
                                    nLength : DWORD) : BOOL;

PROCEDURE SetUserObjectInformationW(hObj : HANDLE;
                                    nIndex : WINT;
                                    pvInfo : PVOID;
                                    nLength : DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE SetUserObjectInformation = SetUserObjectInformationW;
%ELSE
PROCEDURE SetUserObjectInformation = SetUserObjectInformationA;
%END

TYPE
    WNDCLASSA = RECORD
          style          : UINT;
          lpfnWndProc    : WNDPROC;
          cbClsExtra     : INTEGER;
          cbWndExtra     : INTEGER;
          hInstance      : HINSTANCE;
          hIcon          : HICON;
          hCursor        : HCURSOR;
          hbrBackground  : HBRUSH;
          lpszMenuName   : LPCSTR;
          lpszClassName  : LPCSTR;
    END;
    PWNDCLASSA           = POINTER TO WNDCLASSA;
    LPWNDCLASSA          = PWNDCLASSA;

    WNDCLASSW = RECORD
          style          : UINT;
          lpfnWndProc    : WNDPROC;
          cbClsExtra     : INTEGER;
          cbWndExtra     : INTEGER;
          hInstance      : HINSTANCE;
          hIcon          : HICON;
          hCursor        : HCURSOR;
          hbrBackground  : HBRUSH;
          lpszMenuName   : LPCWSTR;
          lpszClassName  : LPCWSTR;
    END;
    PWNDCLASSW           = POINTER TO WNDCLASSW;
    LPWNDCLASSW          = PWNDCLASSW;

    %IF UNICODE %THEN
    WNDCLASS             = WNDCLASSW;
    PWNDCLASS            = PWNDCLASSW;
    %ELSE
    WNDCLASS             = WNDCLASSA;
    PWNDCLASS            = PWNDCLASSA;
    %END
    LPWNDCLASS           = PWNDCLASS;

    MSG = RECORD
          hwnd           : HWND;
          message        : UINT;
          wParam         : WPARAM;
          lParam         : LPARAM;
          time           : DWORD;
          pt             : POINT;
    END;
    PMSG                 = POINTER TO MSG;
    LPMSG                = PMSG;


CONST
    GWL_WNDPROC          = - 4;
    GWL_HINSTANCE        = - 6;
    GWL_HWNDPARENT       = - 8;
    GWL_STYLE            = - 16;
    GWL_EXSTYLE          = - 20;
    GWL_USERDATA         = - 21;
    GWL_ID               = - 12;
    GCL_MENUNAME         = - 8;
    GCL_HBRBACKGROUND    = - 10;
    GCL_HCURSOR          = - 12;
    GCL_HICON            = - 14;
    GCL_HMODULE          = - 16;
    GCL_CBWNDEXTRA       = - 18;
    GCL_CBCLSEXTRA       = - 20;
    GCL_WNDPROC          = - 24;
    GCL_STYLE            = - 26;
    GCW_ATOM             = - 32;

    GCL_HICONSM          = - 34;(*95*)

    WM_NULL              = 00000h;
    WM_CREATE            = 00001h;
    WM_DESTROY           = 00002h;
    WM_MOVE              = 00003h;
    WM_SIZE              = 00005h;
    WM_ACTIVATE          = 00006h;
    WA_INACTIVE          = 0;
    WA_ACTIVE            = 1;
    WA_CLICKACTIVE       = 2;
    WM_SETFOCUS          = 00007h;
    WM_KILLFOCUS         = 00008h;
    WM_ENABLE            = 0000Ah;
    WM_SETREDRAW         = 0000Bh;
    WM_SETTEXT           = 0000Ch;
    WM_GETTEXT           = 0000Dh;
    WM_GETTEXTLENGTH     = 0000Eh;
    WM_PAINT             = 0000Fh;
    WM_CLOSE             = 00010h;
    WM_QUERYENDSESSION   = 00011h;
    WM_QUIT              = 00012h;
    WM_QUERYOPEN         = 00013h;
    WM_ERASEBKGND        = 00014h;
    WM_SYSCOLORCHANGE    = 00015h;
    WM_ENDSESSION        = 00016h;
    WM_SHOWWINDOW        = 00018h;
    WM_WININICHANGE      = 0001Ah;

    WM_SETTINGCHANGE     = WM_WININICHANGE;(*95*)

    WM_DEVMODECHANGE     = 0001Bh;
    WM_ACTIVATEAPP       = 0001Ch;
    WM_FONTCHANGE        = 0001Dh;
    WM_TIMECHANGE        = 0001Eh;
    WM_CANCELMODE        = 0001Fh;
    WM_SETCURSOR         = 00020h;
    WM_MOUSEACTIVATE     = 00021h;
    WM_CHILDACTIVATE     = 00022h;
    WM_QUEUESYNC         = 00023h;
    WM_GETMINMAXINFO     = 00024h;

TYPE
    MINMAXINFO = RECORD
          ptReserved     : POINT;
          ptMaxSize      : POINT;
          ptMaxPosition  : POINT;
          ptMinTrackSize : POINT;
          ptMaxTrackSize : POINT;
    END;
    PMINMAXINFO          = POINTER TO MINMAXINFO;
    LPMINMAXINFO         = PMINMAXINFO;

CONST
    WM_PAINTICON         = 00026h;
    WM_ICONERASEBKGND    = 00027h;
    WM_NEXTDLGCTL        = 00028h;
    WM_SPOOLERSTATUS     = 0002Ah;
    WM_DRAWITEM          = 0002Bh;
    WM_MEASUREITEM       = 0002Ch;
    WM_DELETEITEM        = 0002Dh;
    WM_VKEYTOITEM        = 0002Eh;
    WM_CHARTOITEM        = 0002Fh;
    WM_SETFONT           = 00030h;
    WM_GETFONT           = 00031h;
    WM_SETHOTKEY         = 00032h;
    WM_GETHOTKEY         = 00033h;
    WM_QUERYDRAGICON     = 00037h;
    WM_COMPAREITEM       = 00039h;
    %IF WIN5 %THEN
    WM_GETOBJECT                    = 003Dh;
    %END
    WM_COMPACTING        = 00041h;
    WM_OTHERWINDOWCREATED= 00042h;
    WM_OTHERWINDOWDESTROYED= 00043h;
    WM_COMMNOTIFY        = 00044h;
    WM_WINDOWPOSCHANGING = 00046h;
    WM_WINDOWPOSCHANGED  = 00047h;
    WM_POWER             = 00048h;
    PWR_OK               = 1;
    PWR_FAIL             = ( - 1 ) ;
    PWR_SUSPENDREQUEST   = 1;
    PWR_SUSPENDRESUME    = 2;
    PWR_CRITICALRESUME   = 3;
    WM_COPYDATA          = 0004Ah;
    WM_CANCELJOURNAL     = 0004Bh;

TYPE
    COPYDATASTRUCT = RECORD
          dwData         : DWORD;
          cbData         : DWORD;
          lpData         : PVOID;
    END;
    PCOPYDATASTRUCT      = POINTER TO COPYDATASTRUCT;


CONST

    WM_NOTIFY                       = 004Eh;
    WM_INPUTLANGCHANGEREQUEST       = 0050h;
    WM_INPUTLANGCHANGE              = 0051h;
    WM_TCARD                        = 0052h;
    WM_HELP                         = 0053h;
    WM_USERCHANGED                  = 0054h;
    WM_NOTIFYFORMAT                 = 0055h;

    NFR_ANSI                             = 1;
    NFR_UNICODE                          = 2;
    NF_QUERY                             = 3;
    NF_REQUERY                           = 4;

    WM_CONTEXTMENU                  = 007Bh;
    WM_STYLECHANGING                = 007Ch;
    WM_STYLECHANGED                 = 007Dh;
    WM_DISPLAYCHANGE                = 007Eh;
    WM_GETICON                      = 007Fh;
    WM_SETICON                      = 0080h;


    WM_NCCREATE          = 00081h;
    WM_NCDESTROY         = 00082h;
    WM_NCCALCSIZE        = 00083h;
    WM_NCHITTEST         = 00084h;
    WM_NCPAINT           = 00085h;
    WM_NCACTIVATE        = 00086h;
    WM_GETDLGCODE        = 00087h;
    WM_SYNCPAINT         = 00088h;
    WM_NCMOUSEMOVE       = 000A0h;
    WM_NCLBUTTONDOWN     = 000A1h;
    WM_NCLBUTTONUP       = 000A2h;
    WM_NCLBUTTONDBLCLK   = 000A3h;
    WM_NCRBUTTONDOWN     = 000A4h;
    WM_NCRBUTTONUP       = 000A5h;
    WM_NCRBUTTONDBLCLK   = 000A6h;
    WM_NCMBUTTONDOWN     = 000A7h;
    WM_NCMBUTTONUP       = 000A8h;
    WM_NCMBUTTONDBLCLK   = 000A9h;
    WM_KEYFIRST          = 00100h;
    WM_KEYDOWN           = 00100h;
    WM_KEYUP             = 00101h;
    WM_CHAR              = 00102h;
    WM_DEADCHAR          = 00103h;
    WM_SYSKEYDOWN        = 00104h;
    WM_SYSKEYUP          = 00105h;
    WM_SYSCHAR           = 00106h;
    WM_SYSDEADCHAR       = 00107h;
    WM_KEYLAST           = 00108h;


    WM_IME_STARTCOMPOSITION         = 010Dh;
    WM_IME_ENDCOMPOSITION           = 010Eh;
    WM_IME_COMPOSITION              = 010Fh;
    WM_IME_KEYLAST                  = 010Fh;


    WM_INITDIALOG        = 00110h;
    WM_COMMAND           = 00111h;
    WM_SYSCOMMAND        = 00112h;
    WM_TIMER             = 00113h;
    WM_HSCROLL           = 00114h;
    WM_VSCROLL           = 00115h;
    WM_INITMENU          = 00116h;
    WM_INITMENUPOPUP     = 00117h;
    WM_MENUSELECT        = 0011Fh;
    WM_MENUCHAR          = 00120h;
    WM_ENTERIDLE         = 00121h;
    %IF WIN5 %THEN
    WM_MENURBUTTONUP     = 00122h;
    WM_MENUDRAG          = 00123h;
    WM_MENUGETOBJECT     = 00124h;
    WM_UNINITMENUPOPUP   = 00125h;
    WM_MENUCOMMAND       = 00126h;
    %END
    WM_CTLCOLORMSGBOX    = 00132h;
    WM_CTLCOLOREDIT      = 00133h;
    WM_CTLCOLORLISTBOX   = 00134h;
    WM_CTLCOLORBTN       = 00135h;
    WM_CTLCOLORDLG       = 00136h;
    WM_CTLCOLORSCROLLBAR = 00137h;
    WM_CTLCOLORSTATIC    = 00138h;
    WM_MOUSEFIRST        = 00200h;
    WM_MOUSEMOVE         = 00200h;
    WM_LBUTTONDOWN       = 00201h;
    WM_LBUTTONUP         = 00202h;
    WM_LBUTTONDBLCLK     = 00203h;
    WM_RBUTTONDOWN       = 00204h;
    WM_RBUTTONUP         = 00205h;
    WM_RBUTTONDBLCLK     = 00206h;
    WM_MBUTTONDOWN       = 00207h;
    WM_MBUTTONUP         = 00208h;
    WM_MBUTTONDBLCLK     = 00209h;
    WM_MOUSEWHEEL        = 0020Ah;
    WM_MOUSELAST         = 0020Ah;

    WHEEL_DELTA          = 120;   (* Value for rolling one detent *)
    WHEEL_PAGESCROLL     = MAX(UINT); (* Scroll one page *)

    WM_PARENTNOTIFY      = 00210h;
    MENULOOP_WINDOW      = 0;
    MENULOOP_POPUP       = 1;
    WM_ENTERMENULOOP     = 00211h;
    WM_EXITMENULOOP      = 00212h;


    WM_NEXTMENU          = 00213h;

TYPE
    MDINEXTMENU = RECORD
        hmenuIn         : HMENU;
        hmenuNext       : HMENU;
        hwndNext        : HWND;
    END;
    PMDINEXTMENU        = POINTER TO MDINEXTMENU;
    LPMDINEXTMENU       = PMDINEXTMENU;

CONST
    WM_SIZING                       = 0214h;
    WM_CAPTURECHANGED               = 0215h;
    WM_MOVING                       = 0216h;
    WM_POWERBROADCAST               = 0218h;

    PBT_APMQUERYSUSPEND             = 0000h;
    PBT_APMQUERYSTANDBY             = 0001h;

    PBT_APMQUERYSUSPENDFAILED       = 0002h;
    PBT_APMQUERYSTANDBYFAILED       = 0003h;

    PBT_APMSUSPEND                  = 0004h;
    PBT_APMSTANDBY                  = 0005h;

    PBT_APMRESUMECRITICAL           = 0006h;
    PBT_APMRESUMESUSPEND            = 0007h;
    PBT_APMRESUMESTANDBY            = 0008h;

    PBTF_APMRESUMEFROMFAILURE       = 00000001h;

    PBT_APMBATTERYLOW               = 0009h;
    PBT_APMPOWERSTATUSCHANGE        = 000Ah;

    PBT_APMOEMEVENT                 = 000Bh;
    PBT_APMRESUMEAUTOMATIC          = 0012h;

    WM_DEVICECHANGE                 = 0219h;

    WM_IME_SETCONTEXT               = 0281h;
    WM_IME_NOTIFY                   = 0282h;
    WM_IME_CONTROL                  = 0283h;
    WM_IME_COMPOSITIONFULL          = 0284h;
    WM_IME_SELECT                   = 0285h;
    WM_IME_CHAR                     = 0286h;
%IF WIN5 %THEN
    WM_IME_REQUEST                  = 0288h;
%END
    WM_IME_KEYDOWN                  = 0290h;
    WM_IME_KEYUP                    = 0291h;


    WM_MDICREATE         = 00220h;
    WM_MDIDESTROY        = 00221h;
    WM_MDIACTIVATE       = 00222h;
    WM_MDIRESTORE        = 00223h;
    WM_MDINEXT           = 00224h;
    WM_MDIMAXIMIZE       = 00225h;
    WM_MDITILE           = 00226h;
    WM_MDICASCADE        = 00227h;
    WM_MDIICONARRANGE    = 00228h;
    WM_MDIGETACTIVE      = 00229h;
    WM_MDISETMENU        = 00230h;
    WM_ENTERSIZEMOVE     = 00231h;
    WM_EXITSIZEMOVE      = 00232h;
    WM_DROPFILES         = 00233h;
    WM_MDIREFRESHMENU    = 00234h;
    WM_CUT               = 00300h;
    WM_COPY              = 00301h;
    WM_PASTE             = 00302h;
    WM_CLEAR             = 00303h;
    WM_UNDO              = 00304h;
    WM_RENDERFORMAT      = 00305h;
    WM_RENDERALLFORMATS  = 00306h;
    WM_DESTROYCLIPBOARD  = 00307h;
    WM_DRAWCLIPBOARD     = 00308h;
    WM_PAINTCLIPBOARD    = 00309h;
    WM_VSCROLLCLIPBOARD  = 0030Ah;
    WM_SIZECLIPBOARD     = 0030Bh;
    WM_ASKCBFORMATNAME   = 0030Ch;
    WM_CHANGECBCHAIN     = 0030Dh;
    WM_HSCROLLCLIPBOARD  = 0030Eh;
    WM_QUERYNEWPALETTE   = 0030Fh;
    WM_PALETTEISCHANGING = 00310h;
    WM_PALETTECHANGED    = 00311h;
    WM_HOTKEY            = 00312h;

    WM_PRINT             = 00317h;
    WM_PRINTCLIENT       = 00318h;

    WM_HANDHELDFIRST     = 00358h;
    WM_HANDHELDLAST      = 0035Fh;

    WM_AFXFIRST          = 00360h;
    WM_AFXLAST           = 0037Fh;

    WM_PENWINFIRST       = 00380h;
    WM_PENWINLAST        = 0038Fh;

    WM_APP               = 08000h;(*95*)

    WM_USER              = 00400h;


    WMSZ_LEFT           = 1;
    WMSZ_RIGHT          = 2;
    WMSZ_TOP            = 3;
    WMSZ_TOPLEFT        = 4;
    WMSZ_TOPRIGHT       = 5;
    WMSZ_BOTTOM         = 6;
    WMSZ_BOTTOMLEFT     = 7;
    WMSZ_BOTTOMRIGHT    = 8;


    ST_BEGINSWP          = 0;
    ST_ENDSWP            = 1;
    HTERROR              = -2;
    HTTRANSPARENT        = -1;
    HTNOWHERE            = 0;
    HTCLIENT             = 1;
    HTCAPTION            = 2;
    HTSYSMENU            = 3;
    HTGROWBOX            = 4;
    HTSIZE               = HTGROWBOX;(*95*)
    HTMENU               = 5;
    HTHSCROLL            = 6;
    HTVSCROLL            = 7;
    HTMINBUTTON          = 8;
    HTMAXBUTTON          = 9;
    HTLEFT               = 10;
    HTRIGHT              = 11;
    HTTOP                = 12;
    HTTOPLEFT            = 13;
    HTTOPRIGHT           = 14;
    HTBOTTOM             = 15;
    HTBOTTOMLEFT         = 16;
    HTBOTTOMRIGHT        = 17;
    HTBORDER             = 18;

    HTREDUCE             = HTMINBUTTON;
    HTZOOM               = HTMAXBUTTON;
    HTSIZEFIRST          = HTLEFT;
    HTSIZELAST           = HTBOTTOMRIGHT;
    HTOBJECT             = 19;
    HTCLOSE              = 20;
    HTHELP               = 21;


    SMTO_NORMAL          = 00000h;
    SMTO_BLOCK           = 00001h;
    SMTO_ABORTIFHUNG     = 00002h;
%IF WIN5 %THEN
    SMTO_NOTIMEOUTIFNOTHUNG = 00008h;
%END

    MA_ACTIVATE          = 1;
    MA_ACTIVATEANDEAT    = 2;
    MA_NOACTIVATE        = 3;
    MA_NOACTIVATEANDEAT  = 4;

(*
 * WM_SETICON / WM_GETICON Type Codes
 *)
    ICON_SMALL          =0;
    ICON_BIG            =1;

PROCEDURE RegisterWindowMessageA(lpString : ARRAY OF ACHAR) : UINT;

PROCEDURE RegisterWindowMessageW(lpString : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE RegisterWindowMessage = RegisterWindowMessageW;
%ELSE
PROCEDURE RegisterWindowMessage = RegisterWindowMessageA;
%END

CONST
    SIZE_RESTORED        = 0;
    SIZE_MINIMIZED       = 1;
    SIZE_MAXIMIZED       = 2;
    SIZE_MAXSHOW         = 3;
    SIZE_MAXHIDE         = 4;
    SIZENORMAL           = SIZE_RESTORED;
    SIZEICONIC           = SIZE_MINIMIZED;
    SIZEFULLSCREEN       = SIZE_MAXIMIZED;
    SIZEZOOMSHOW         = SIZE_MAXSHOW;
    SIZEZOOMHIDE         = SIZE_MAXHIDE;


TYPE
    WINDOWPOS = RECORD
          hwnd           : HWND;
          hwndInsertAfter: HWND;
          x              : INTEGER;
          y              : INTEGER;
          cx             : INTEGER;
          cy             : INTEGER;
          flags          : UINT;
    END;
    PWINDOWPOS           = POINTER TO WINDOWPOS;
    LPWINDOWPOS          = PWINDOWPOS;


    NCCALCSIZE_PARAMS = RECORD
          rgrc           : ARRAY [0..3 - 1] OF RECT;
          lppos          : PWINDOWPOS;
    END;
    LPNCCALCSIZE_PARAMS  = POINTER TO NCCALCSIZE_PARAMS;

CONST
    WVR_ALIGNTOP         = 00010h;
    WVR_ALIGNLEFT        = 00020h;
    WVR_ALIGNBOTTOM      = 00040h;
    WVR_ALIGNRIGHT       = 00080h;
    WVR_HREDRAW          = 00100h;
    WVR_VREDRAW          = 00200h;
    WVR_REDRAW           = ( WVR_HREDRAW BOR WVR_VREDRAW ) ;
    WVR_VALIDRECTS       = 00400h;

    MK_LBUTTON           = 00001h;
    MK_RBUTTON           = 00002h;
    MK_SHIFT             = 00004h;
    MK_CONTROL           = 00008h;
    MK_MBUTTON           = 00010h;

    TME_HOVER       =000000001h;
    TME_LEAVE       =000000002h;
    TME_QUERY       =040000000h;
    TME_CANCEL      =080000000h;


    HOVER_DEFAULT   =0FFFFFFFFh;

TYPE
    TRACKMOUSEEVENT = RECORD
    cbSize : DWORD;
    dwFlags : DWORD;
    hwndTrack : HWND;
    dwHoverTime : DWORD;
    END;
    LPTRACKMOUSEEVENT = TRACKMOUSEEVENT;


PROCEDURE TrackMouseEvent(VAR lpEventTrack : TRACKMOUSEEVENT) : BOOL;

CONST
    WS_OVERLAPPED        = 000000000h;
    WS_POPUP             = 080000000h;
    WS_CHILD             = 040000000h;
    WS_MINIMIZE          = 020000000h;
    WS_VISIBLE           = 010000000h;
    WS_DISABLED          = 008000000h;
    WS_CLIPSIBLINGS      = 004000000h;
    WS_CLIPCHILDREN      = 002000000h;
    WS_MAXIMIZE          = 001000000h;
    WS_CAPTION           = 000C00000h;
    WS_BORDER            = 000800000h;
    WS_DLGFRAME          = 000400000h;
    WS_VSCROLL           = 000200000h;
    WS_HSCROLL           = 000100000h;
    WS_SYSMENU           = 000080000h;
    WS_THICKFRAME        = 000040000h;
    WS_GROUP             = 000020000h;
    WS_TABSTOP           = 000010000h;
    WS_MINIMIZEBOX       = 000020000h;
    WS_MAXIMIZEBOX       = 000010000h;
    WS_TILED             = WS_OVERLAPPED;
    WS_ICONIC            = WS_MINIMIZE;
    WS_SIZEBOX           = WS_THICKFRAME;

    WS_OVERLAPPEDWINDOW  =   WS_OVERLAPPED BOR
                             WS_CAPTION BOR
                             WS_SYSMENU BOR
                             WS_THICKFRAME BOR
                             WS_MINIMIZEBOX BOR
                             WS_MAXIMIZEBOX;

    WS_POPUPWINDOW       = WS_POPUP BOR WS_BORDER BOR WS_SYSMENU;

    WS_TILEDWINDOW       = WS_OVERLAPPEDWINDOW;

    WS_CHILDWINDOW       = WS_CHILD;

    WS_EX_DLGMODALFRAME  = 000000001h;
    WS_EX_NOPARENTNOTIFY = 000000004h;
    WS_EX_TOPMOST        = 000000008h;
    WS_EX_ACCEPTFILES    = 000000010h;
    WS_EX_TRANSPARENT    = 000000020h;


    WS_EX_MDICHILD          = 00000040h;
    WS_EX_TOOLWINDOW        = 00000080h;
    WS_EX_WINDOWEDGE        = 00000100h;
    WS_EX_CLIENTEDGE        = 00000200h;
    WS_EX_CONTEXTHELP       = 00000400h;

    WS_EX_RIGHT             = 00001000h;
    WS_EX_LEFT              = 00000000h;
    WS_EX_RTLREADING        = 00002000h;
    WS_EX_LTRREADING        = 00000000h;
    WS_EX_LEFTSCROLLBAR     = 00004000h;
    WS_EX_RIGHTSCROLLBAR    = 00000000h;

    WS_EX_CONTROLPARENT     = 00010000h;
    WS_EX_STATICEDGE        = 00020000h;
    WS_EX_APPWINDOW         = 00040000h;

    WS_EX_OVERLAPPEDWINDOW  = (WS_EX_WINDOWEDGE BOR WS_EX_CLIENTEDGE);
    WS_EX_PALETTEWINDOW     = (WS_EX_WINDOWEDGE BOR
                               WS_EX_TOOLWINDOW BOR
                               WS_EX_TOPMOST);


    CS_VREDRAW           = 00001h;
    CS_HREDRAW           = 00002h;
    CS_KEYCVTWINDOW      = 00004h;
    CS_DBLCLKS           = 00008h;
    CS_OWNDC             = 00020h;
    CS_CLASSDC           = 00040h;
    CS_PARENTDC          = 00080h;
    CS_NOKEYCVT          = 00100h;
    CS_NOCLOSE           = 00200h;
    CS_SAVEBITS          = 00800h;
    CS_BYTEALIGNCLIENT   = 01000h;
    CS_BYTEALIGNWINDOW   = 02000h;
    CS_GLOBALCLASS       = 04000h;


    CS_IME              = 00010000h;

    PRF_CHECKVISIBLE    = 00000001h;
    PRF_NONCLIENT       = 00000002h;
    PRF_CLIENT          = 00000004h;
    PRF_ERASEBKGND      = 00000008h;
    PRF_CHILDREN        = 00000010h;
    PRF_OWNED           = 00000020h;

    BDR_RAISEDOUTER = 0001h;
    BDR_SUNKENOUTER = 0002h;
    BDR_RAISEDINNER = 0004h;
    BDR_SUNKENINNER = 0008h;

    BDR_OUTER       = 0003h;
    BDR_INNER       = 000ch;
    BDR_RAISED      = 0005h;
    BDR_SUNKEN      = 000ah;

    EDGE_RAISED     = (BDR_RAISEDOUTER BOR BDR_RAISEDINNER);
    EDGE_SUNKEN     = (BDR_SUNKENOUTER BOR BDR_SUNKENINNER);
    EDGE_ETCHED     = (BDR_SUNKENOUTER BOR BDR_RAISEDINNER);
    EDGE_BUMP       = (BDR_RAISEDOUTER BOR BDR_SUNKENINNER);

    BF_LEFT         = 0001h;
    BF_TOP          = 0002h;
    BF_RIGHT        = 0004h;
    BF_BOTTOM       = 0008h;

    BF_TOPLEFT      = (BF_TOP BOR BF_LEFT);
    BF_TOPRIGHT     = (BF_TOP BOR BF_RIGHT);
    BF_BOTTOMLEFT   = (BF_BOTTOM BOR BF_LEFT);
    BF_BOTTOMRIGHT  = (BF_BOTTOM BOR BF_RIGHT);
    BF_RECT         = (BF_LEFT BOR BF_TOP BOR BF_RIGHT BOR BF_BOTTOM);

    BF_DIAGONAL     = 0010h;

    BF_DIAGONAL_ENDTOPRIGHT     = (BF_DIAGONAL BOR BF_TOP BOR BF_RIGHT);
    BF_DIAGONAL_ENDTOPLEFT      = (BF_DIAGONAL BOR BF_TOP BOR BF_LEFT);
    BF_DIAGONAL_ENDBOTTOMLEFT   = (BF_DIAGONAL BOR BF_BOTTOM BOR BF_LEFT);
    BF_DIAGONAL_ENDBOTTOMRIGHT  = (BF_DIAGONAL BOR BF_BOTTOM BOR BF_RIGHT);

    BF_MIDDLE       = 0800h;
    BF_SOFT         = 1000h;
    BF_ADJUST       = 2000h;
    BF_FLAT         = 4000h;
    BF_MONO         = 8000h;

PROCEDURE DrawEdge(hdc: HDC;
                   qrc: RECT;
                   edge: UINT;
                   grfFlags: UINT) : BOOL;

CONST
    DFC_CAPTION             = 1;
    DFC_MENU                = 2;
    DFC_SCROLL              = 3;
    DFC_BUTTON              = 4;
%IF WIN5 %THEN
    DFC_POPUPMENU           = 5;
%END

    DFCS_CAPTIONCLOSE       = 0000h;
    DFCS_CAPTIONMIN         = 0001h;
    DFCS_CAPTIONMAX         = 0002h;
    DFCS_CAPTIONRESTORE     = 0003h;
    DFCS_CAPTIONHELP        = 0004h;

    DFCS_MENUARROW          = 0000h;
    DFCS_MENUCHECK          = 0001h;
    DFCS_MENUBULLET         = 0002h;
    DFCS_MENUARROWRIGHT     = 0004h;

    DFCS_SCROLLUP           = 0000h;
    DFCS_SCROLLDOWN         = 0001h;
    DFCS_SCROLLLEFT         = 0002h;
    DFCS_SCROLLRIGHT        = 0003h;
    DFCS_SCROLLCOMBOBOX     = 0005h;
    DFCS_SCROLLSIZEGRIP     = 0008h;
    DFCS_SCROLLSIZEGRIPRIGHT = 0010h;

    DFCS_BUTTONCHECK        = 0000h;
    DFCS_BUTTONRADIOIMAGE   = 0001h;
    DFCS_BUTTONRADIOMASK    = 0002h;
    DFCS_BUTTONRADIO        = 0004h;
    DFCS_BUTTON3STATE       = 0008h;
    DFCS_BUTTONPUSH         = 0010h;

    DFCS_INACTIVE           = 0100h;
    DFCS_PUSHED             = 0200h;
    DFCS_CHECKED            = 0400h;
    DFCS_ADJUSTRECT         = 2000h;
    DFCS_FLAT               = 4000h;
    DFCS_MONO               = 8000h;

%IF WIN5 %THEN
    DFCS_TRANSPARENT        =00800h;
    DFCS_HOT                =01000h;
%END

PROCEDURE DrawFrameControl(a: HDC; b: RECT; c: UINT; d: UINT) : BOOL;

CONST
    DC_ACTIVE           = 0001h;
    DC_SMALLCAP         = 0002h;
    DC_ICON             = 0004h;
    DC_TEXT             = 0008h;
    DC_INBUTTON         = 0010h;
%IF WIN5 %THEN
    DC_GRADIENT         = 0020h;
%END
    (*??
    DC_CAPTION          = (DC_ICON BOR DC_TEXT BOR DC_BUTTONS);
    DC_NC               = (DC_CAPTION BOR DC_FRAME);
    *)

PROCEDURE DrawCaption(a: HWND; b: HDC; c: RECT; d: UINT) : BOOL;

CONST
    IDANI_OPEN          = 1;
    IDANI_CLOSE         = 2;
    IDANI_CAPTION       = 3;

PROCEDURE DrawAnimatedRects(hwnd : HWND;
                            idAni : WINT;
                            lprcFrom : RECT;
                            lprcTo : RECT) : BOOL;


CONST
    CF_TEXT              = 1;
    CF_BITMAP            = 2;
    CF_METAFILEPICT      = 3;
    CF_SYLK              = 4;
    CF_DIF               = 5;
    CF_TIFF              = 6;
    CF_OEMTEXT           = 7;
    CF_DIB               = 8;
    CF_PALETTE           = 9;
    CF_PENDATA           = 10;
    CF_RIFF              = 11;
    CF_WAVE              = 12;
    CF_UNICODETEXT       = 13;
    CF_ENHMETAFILE       = 14;

    CF_HDROP             = 15;
    CF_LOCALE            = 16;
    CF_MAX               = 17;

    CF_OWNERDISPLAY      = 00080h;
    CF_DSPTEXT           = 00081h;
    CF_DSPBITMAP         = 00082h;
    CF_DSPMETAFILEPICT   = 00083h;
    CF_DSPENHMETAFILE    = 0008Eh;

    CF_PRIVATEFIRST      = 00200h;
    CF_PRIVATELAST       = 002FFh;
    CF_GDIOBJFIRST       = 00300h;
    CF_GDIOBJLAST        = 003FFh;

    FVIRTKEY             = 001h;(*95*)
    FNOINVERT            = 002h;
    FSHIFT               = 004h;
    FCONTROL             = 008h;
    FALT                 = 010h;

TYPE
    ACCEL = RECORD
          fVirt          : BYTE;
          key            : WORD;
          cmd            : WORD;
    END;
    LPACCEL              = POINTER TO ACCEL;

    PAINTSTRUCT = RECORD
          hdc            : HDC;
          fErase         : BOOL;
          rcPaint        : RECT;
          fRestore       : BOOL;
          fIncUpdate     : BOOL;
          rgbReserved    : ARRAY [0..32 - 1] OF BYTE;
    END;
    PPAINTSTRUCT         = POINTER TO PAINTSTRUCT;
    LPPAINTSTRUCT        = PPAINTSTRUCT;


TYPE
    WINDOWPLACEMENT = RECORD
          length         : UINT;
          flags          : UINT;
          showCmd        : UINT;
          ptMinPosition  : POINT;
          ptMaxPosition  : POINT;
          rcNormalPosition: RECT;
    END;
    PWINDOWPLACEMENT     = POINTER TO WINDOWPLACEMENT;
    LPWINDOWPLACEMENT    = PWINDOWPLACEMENT;

CONST
    WPF_SETMINPOSITION   = 00001h;
    WPF_RESTORETOMAXIMIZED= 00002h;

TYPE
    NMHDR = RECORD
        hwndFrom        : HWND;
        idFrom          : UINT;
        code            : UINT;
    END;
    LPNMHDR = POINTER TO NMHDR;

    STYLESTRUCT = RECORD
        styleOld        : DWORD;
        styleNew        : DWORD;
    END;
    LPSTYLESTRUCT       = POINTER TO STYLESTRUCT;

CONST
    ODT_MENU             = 1;
    ODT_LISTBOX          = 2;
    ODT_COMBOBOX         = 3;
    ODT_BUTTON           = 4;
    ODT_STATIC           = 5;(*95*)

    ODA_DRAWENTIRE       = 00001h;
    ODA_SELECT           = 00002h;
    ODA_FOCUS            = 00004h;
    ODS_SELECTED         = 00001h;
    ODS_GRAYED           = 00002h;
    ODS_DISABLED         = 00004h;
    ODS_CHECKED          = 00008h;
    ODS_FOCUS            = 00010h;

    ODS_DEFAULT          = 00020h;
    ODS_COMBOBOXEDIT     = 01000h;
%IF WIN5 %THEN
    ODS_HOTLIGHT        = 00040h;
    ODS_INACTIVE        = 00080h;
%END


TYPE
    MEASUREITEMSTRUCT = RECORD
          CtlType        : UINT;
          CtlID          : UINT;
          itemID         : UINT;
          itemWidth      : UINT;
          itemHeight     : UINT;
          itemData       : DWORD;
    END;
    PMEASUREITEMSTRUCT   = POINTER TO MEASUREITEMSTRUCT;
    LPMEASUREITEMSTRUCT  = PMEASUREITEMSTRUCT;

    DRAWITEMSTRUCT = RECORD
          CtlType        : UINT;
          CtlID          : UINT;
          itemID         : UINT;
          itemAction     : UINT;
          itemState      : UINT;
          hwndItem       : HWND;
          hDC            : HDC;
          rcItem         : RECT;
          itemData       : DWORD;
    END;
    PDRAWITEMSTRUCT      = POINTER TO DRAWITEMSTRUCT;
    LPDRAWITEMSTRUCT     = PDRAWITEMSTRUCT;

    DELETEITEMSTRUCT = RECORD
          CtlType        : UINT;
          CtlID          : UINT;
          itemID         : UINT;
          hwndItem       : HWND;
          itemData       : UINT;
    END;
    PDELETEITEMSTRUCT    = POINTER TO DELETEITEMSTRUCT;
    LPDELETEITEMSTRUCT   = PDELETEITEMSTRUCT;

    COMPAREITEMSTRUCT = RECORD
          CtlType        : UINT;
          CtlID          : UINT;
          hwndItem       : HWND;
          itemID1        : UINT;
          itemData1      : DWORD;
          itemID2        : UINT;
          itemData2      : DWORD;
          dwLocaleId     : DWORD;
    END;
    PCOMPAREITEMSTRUCT   = POINTER TO COMPAREITEMSTRUCT;
    LPCOMPAREITEMSTRUCT  = PCOMPAREITEMSTRUCT;

PROCEDURE GetMessageA(VAR lpMsg : MSG;
                      hWnd : HWND;
                      wMsgFilterMin : UINT;
                      wMsgFilterMax : UINT) : BOOL;

PROCEDURE GetMessageW(VAR lpMsg : MSG;
                      hWnd : HWND;
                      wMsgFilterMin : UINT;
                      wMsgFilterMax : UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetMessage = GetMessageW;
%ELSE
PROCEDURE GetMessage = GetMessageA;
%END

PROCEDURE TranslateMessage(VAR lpMsg : MSG) : BOOL;

PROCEDURE DispatchMessageA(VAR lpMsg : MSG) : LONG;

PROCEDURE DispatchMessageW(VAR lpMsg : MSG) : LONG;

%IF UNICODE %THEN
PROCEDURE DispatchMessage = DispatchMessageW;
%ELSE
PROCEDURE DispatchMessage = DispatchMessageA;
%END

PROCEDURE SetMessageQueue(cMessagesMax : INTEGER) : BOOL;

PROCEDURE PeekMessageA(VAR lpMsg : MSG;
                       hWnd : HWND;
                       wMsgFilterMin : UINT;
                       wMsgFilterMax : UINT;
                       wRemoveMsg : UINT) : BOOL;

PROCEDURE PeekMessageW(VAR lpMsg : MSG;
                       hWnd : HWND;
                       wMsgFilterMin : UINT;
                       wMsgFilterMax : UINT;
                       wRemoveMsg : UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE PeekMessage = PeekMessageW;
%ELSE
PROCEDURE PeekMessage = PeekMessageA;
%END

CONST
    PM_NOREMOVE          = 00000h;
    PM_REMOVE            = 00001h;
    PM_NOYIELD           = 00002h;

PROCEDURE RegisterHotKey(hWnd : HWND;
                         id : INTEGER;
                         fsModifiers : UINT;
                         vk : UINT) : BOOL;

PROCEDURE UnregisterHotKey(hWnd : HWND;
                           id : INTEGER) : BOOL;


CONST
    MOD_ALT              = 00001h;
    MOD_CONTROL          = 00002h;
    MOD_SHIFT            = 00004h;
    MOD_WIN              = 00008h;

    IDHOT_SNAPWINDOW     = -1;
    IDHOT_SNAPDESKTOP    = -2;


    EW_RESTARTWINDOWS    = 00042h;
    EW_REBOOTSYSTEM      = 00043h;
    EW_EXITANDEXECAPP    = 00044h;


    ENDSESSION_LOGOFF    = 080000000h;

    EWX_LOGOFF           = 0h;
    EWX_SHUTDOWN         = 1h;
    EWX_REBOOT           = 2h;
    EWX_FORCE            = 4h;
    EWX_POWEROFF         = 8h;
%IF WIN5 %THEN
    EWX_FORCEIFHUNG      = 000000010h;(*NT only*)
%END

PROCEDURE ExitWindowsEx(uFlags : UINT;
                        dwReserved : DWORD) : BOOL;

PROCEDURE SwapMouseButton(fSwap : BOOL) : BOOL;

PROCEDURE GetMessagePos() : DWORD;

PROCEDURE GetMessageTime() : LONG;

PROCEDURE GetMessageExtraInfo() : LONG;


PROCEDURE SetMessageExtraInfo(lParam : LPARAM) : LPARAM;


PROCEDURE SendMessageA(hWnd : HWND;
                       Msg : UINT;
                       wParam : WPARAM;
                       lParam : LPARAM) : LRESULT;

PROCEDURE SendMessageW(hWnd : HWND;
                       Msg : UINT;
                       wParam : WPARAM;
                       lParam : LPARAM) : LRESULT;

%IF UNICODE %THEN
PROCEDURE SendMessage = SendMessageW;
%ELSE
PROCEDURE SendMessage = SendMessageA;
%END

PROCEDURE SendMessageTimeoutA(hWnd : HWND;
                              Msg : UINT;
                              wParam : WPARAM;
                              lParam : LPARAM;
                              fuFlags : UINT;
                              uTimeout : UINT;
                              VAR lpdwResult : DWORD) : LRESULT;

PROCEDURE SendMessageTimeoutW(hWnd : HWND;
                              Msg : UINT;
                              wParam : WPARAM;
                              lParam : LPARAM;
                              fuFlags : UINT;
                              uTimeout : UINT;
                              VAR lpdwResult : DWORD) : LRESULT;


%IF UNICODE %THEN
PROCEDURE SendMessageTimeout = SendMessageTimeoutW;
%ELSE
PROCEDURE SendMessageTimeout = SendMessageTimeoutA;
%END

PROCEDURE SendNotifyMessageA(hWnd : HWND;
                             Msg : UINT;
                             wParam : WPARAM;
                             lParam : LPARAM) : BOOL;

PROCEDURE SendNotifyMessageW(hWnd : HWND;
                             Msg : UINT;
                             wParam : WPARAM;
                             lParam : LPARAM) : BOOL;

%IF UNICODE %THEN
PROCEDURE SendNotifyMessage = SendNotifyMessageW;
%ELSE
PROCEDURE SendNotifyMessage = SendNotifyMessageA;
%END

PROCEDURE SendMessageCallbackA(hWnd : HWND;
                               Msg : UINT;
                               wParam : WPARAM;
                               lParam : LPARAM;
                               lpResultCallBack : SENDASYNCPROC;
                               dwData : DWORD) : BOOL;

PROCEDURE SendMessageCallbackW(hWnd : HWND;
                               Msg : UINT;
                               wParam : WPARAM;
                               lParam : LPARAM;
                               lpResultCallBack : SENDASYNCPROC;
                               dwData : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE SendMessageCallback = SendMessageCallbackW;
%ELSE
PROCEDURE SendMessageCallback = SendMessageCallbackA;
%END

(* only on NT *)
PROCEDURE BroadcastSystemMessageW(a: DWORD;
                                  VAR b: DWORD;
                                  c: UINT;
                                  d: WPARAM;
                                  e: LPARAM) : LONG;

(* only on NT *)
PROCEDURE BroadcastSystemMessageA(a: DWORD;
                                  VAR b: DWORD;
                                  c: UINT;
                                  d: WPARAM;
                                  e: LPARAM) : LONG;

(* only on Win9x*)
PROCEDURE BroadcastSystemMessage(a: DWORD;
                                 VAR b: DWORD;
                                 c: UINT;
                                 d: WPARAM;
                                 e: LPARAM) : LONG;

CONST
    BROADCAST_QUERY_DENY         = 424D5144h;(* Return this value to deny a query.*)

(*Broadcast Special Message Recipient list*)
    BSM_ALLCOMPONENTS       = 00000000h;
    BSM_VXDS                = 00000001h;
    BSM_NETDRIVER           = 00000002h;
    BSM_INSTALLABLEDRIVERS  = 00000004h;
    BSM_APPLICATIONS        = 00000008h;
    BSM_ALLDESKTOPS         = 00000010h;

(*Broadcast Special Message Flags*)
    BSF_QUERY               = 00000001h;
    BSF_IGNORECURRENTTASK   = 00000002h;
    BSF_FLUSHDISK           = 00000004h;
    BSF_NOHANG              = 00000008h;
    BSF_POSTMESSAGE         = 00000010h;
    BSF_FORCEIFHUNG         = 00000020h;
    BSF_NOTIMEOUTIFNOTHUNG  = 00000040h;

    DBWF_LPARAMPOINTER          = 08000h;

TYPE
    BROADCASTSYSMSG = RECORD
        uiMessage : UINT;
        wParam  : WPARAM;
        lParam  : LPARAM;
    END;
    LPBROADCASTSYSMSG   = POINTER TO BROADCASTSYSMSG;

%IF WIN5 %THEN
TYPE
    HDEVNOTIFY = PVOID;
    PHDEVNOTIFY = POINTER TO HDEVNOTIFY;

CONST
    EVICE_NOTIFY_WINDOW_HANDLE     = 00000000h;

PROCEDURE RegisterDeviceNotificationA(hRecipient : HANDLE;
                                      NotificationFilter : LPVOID;
                                      Flags : DWORD) : HDEVNOTIFY;

PROCEDURE RegisterDeviceNotificationW(hRecipient : HANDLE;
                                      NotificationFilter : LPVOID;
                                      Flags : DWORD) : HDEVNOTIFY;

%IF UNICODE %THEN
PROCEDURE RegisterDeviceNotification = RegisterDeviceNotificationW;
%ELSE
PROCEDURE RegisterDeviceNotification = RegisterDeviceNotificationA;
%END

PROCEDURE UnregisterDeviceNotification(Handle : HDEVNOTIFY) : BOOL;
%END

PROCEDURE PostMessageA(hWnd : HWND;
                       Msg : UINT;
                       wParam : WPARAM;
                       lParam : LPARAM) : BOOL;

PROCEDURE PostMessageW(hWnd : HWND;
                       Msg : UINT;
                       wParam : WPARAM;
                       lParam : LPARAM) : BOOL;

%IF UNICODE %THEN
PROCEDURE PostMessage = PostMessageW;
%ELSE
PROCEDURE PostMessage = PostMessageA;
%END

PROCEDURE PostThreadMessageA(idThread : DWORD;
                             Msg : UINT;
                             wParam : WPARAM;
                             lParam : LPARAM) : BOOL;

PROCEDURE PostThreadMessageW(idThread : DWORD;
                             Msg : UINT;
                             wParam : WPARAM;
                             lParam : LPARAM) : BOOL;

%IF UNICODE %THEN
PROCEDURE PostThreadMessage = PostThreadMessageW;
%ELSE
PROCEDURE PostThreadMessage = PostThreadMessageA;
%END

CONST
    HWND_BROADCAST   =  CAST(HWND,0ffffH);
%IF WIN5 %THEN
    HWND_MESSAGE     = CAST(HWND, -3);
%END

PROCEDURE AttachThreadInput(idAttach : DWORD;
                            idAttachTo : DWORD;
                            fAttach : BOOL) : BOOL;

PROCEDURE ReplyMessage(lResult : LRESULT) : BOOL;

PROCEDURE WaitMessage() : BOOL;

PROCEDURE WaitForInputIdle(hProcess : HANDLE;
                           dwMilliseconds : DWORD) : DWORD;

PROCEDURE DefWindowProcA(hWnd : HWND;
                         Msg : UINT;
                         wParam : WPARAM;
                         lParam : LPARAM) : LRESULT;

PROCEDURE DefWindowProcW(hWnd : HWND;
                         Msg : UINT;
                         wParam : WPARAM;
                         lParam : LPARAM) : LRESULT;

%IF UNICODE %THEN
PROCEDURE DefWindowProc = DefWindowProcW;
%ELSE
PROCEDURE DefWindowProc = DefWindowProcA;
%END

PROCEDURE PostQuitMessage(nExitCode : INTEGER);

PROCEDURE CallWindowProcA(lpPrevWndFunc : WNDPROC;
                          hWnd : HWND;
                          Msg : UINT;
                          wParam : WPARAM;
                          lParam : LPARAM) : LRESULT;

PROCEDURE CallWindowProcW(lpPrevWndFunc : WNDPROC;
                          hWnd : HWND;
                          Msg : UINT;
                          wParam : WPARAM;
                          lParam : LPARAM) : LRESULT;

%IF UNICODE %THEN
PROCEDURE CallWindowProc = CallWindowProcW;
%ELSE
PROCEDURE CallWindowProc = CallWindowProcA;
%END

PROCEDURE InSendMessage() : BOOL;

%IF WIN5 %THEN
PROCEDURE InSendMessageEx(lpReserved : LPVOID) : DWORD;

(*
 * InSendMessageEx return value
 *)
CONST
    ISMEX_NOSEND      = 00000000h;
    ISMEX_SEND        = 00000001h;
    ISMEX_NOTIFY      = 00000002h;
    ISMEX_CALLBACK    = 00000004h;
    ISMEX_REPLIED     = 00000008h;
%END

PROCEDURE GetDoubleClickTime() : UINT;

PROCEDURE SetDoubleClickTime(a : UINT) : BOOL;

PROCEDURE RegisterClassA(lpWndClass : WNDCLASSA) : ATOM;

PROCEDURE RegisterClassW(lpWndClass : WNDCLASSW) : ATOM;

%IF UNICODE %THEN
PROCEDURE RegisterClass = RegisterClassW;
%ELSE
PROCEDURE RegisterClass = RegisterClassA;
%END

PROCEDURE UnregisterClassA(lpClassName : ARRAY OF ACHAR;
                           a : HINSTANCE) : BOOL;

PROCEDURE UnregisterClassW(lpClassName : ARRAY OF UCHAR;
                           a : HINSTANCE) : BOOL;

%IF UNICODE %THEN
PROCEDURE UnregisterClass = UnregisterClassW;
%ELSE
PROCEDURE UnregisterClass = UnregisterClassA;
%END

PROCEDURE GetClassInfoA(a : HINSTANCE;
                        lpClassName : ARRAY OF ACHAR;
                        VAR lpWndClass : WNDCLASSA) : BOOL;

PROCEDURE GetClassInfoW(a : HINSTANCE;
                        lpClassName : ARRAY OF UCHAR;
                        VAR lpWndClass : WNDCLASSW) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetClassInfo = GetClassInfoW;
%ELSE
PROCEDURE GetClassInfo = GetClassInfoA;
%END



TYPE
    WNDCLASSEXA = RECORD
        cbSize          : UINT;

        style           : UINT;
        lpfnWndProc     : WNDPROC;
        cbClsExtra      : WINT;
        cbWndExtra      : WINT;
        hInstance       : HINSTANCE;
        hIcon           : HICON;
        hCursor         : HCURSOR;
        hbrBackground   : HBRUSH;
        lpszMenuName    : LPCSTR;
        lpszClassName   : LPCSTR;

        hIconSm         : HICON;
    END;
    PWNDCLASSEXA  = POINTER TO WNDCLASSEXA;
    LPWNDCLASSEXA = PWNDCLASSEXA;

    WNDCLASSEXW = RECORD
        cbSize          : UINT;

        style           : UINT;
        lpfnWndProc     : WNDPROC;
        cbClsExtra      : WINT;
        cbWndExtra      : WINT;
        hInstance       : HINSTANCE;
        hIcon           : HICON;
        hCursor         : HCURSOR;
        hbrBackground   : HBRUSH;
        lpszMenuName    : LPCWSTR;
        lpszClassName   : LPCWSTR;

        hIconSm         : HICON;
    END;
    PWNDCLASSEXW  = POINTER TO WNDCLASSEXW;
    LPWNDCLASSEXW = PWNDCLASSEXW;

%IF UNICODE %THEN
    WNDCLASSEX = WNDCLASSEXW;
    PWNDCLASSEX  = PWNDCLASSEXW;
%ELSE
    WNDCLASSEX = WNDCLASSEXA;
    PWNDCLASSEX  = PWNDCLASSEXA;
%END
    LPWNDCLASSEX = PWNDCLASSEX;

PROCEDURE RegisterClassExA(a: WNDCLASSEXA) : ATOM;

PROCEDURE RegisterClassExW(a: WNDCLASSEXW) : ATOM;

%IF UNICODE %THEN
PROCEDURE RegisterClassEx = RegisterClassExW;
%ELSE
PROCEDURE RegisterClassEx = RegisterClassExA;
%END

PROCEDURE GetClassInfoExA(a: HINSTANCE;
                          b: ARRAY OF ACHAR;
                          VAR c: WNDCLASSEXA) : BOOL;

PROCEDURE GetClassInfoExW(a: HINSTANCE;
                          b: ARRAY OF UCHAR;
                          VAR c: WNDCLASSEXW) : BOOL;
%IF UNICODE %THEN
PROCEDURE GetClassInfoEx = GetClassInfoExW;
%ELSE
PROCEDURE GetClassInfoEx = GetClassInfoExA;
%END




CONST
    CW_USEDEFAULT   = CAST(INTEGER, 080000000H);
    HWND_DESKTOP    = CAST(HWND, 0);

PROCEDURE CreateWindowExA(a : DWORD;
                          lpClassName : ARRAY OF ACHAR;
                          lpWindowName : ARRAY OF ACHAR;
                          dwStyle : DWORD;
                          X : INTEGER;
                          Y : INTEGER;
                          nWidth : INTEGER;
                          nHeight : INTEGER;
                          hWndParent : HWND;
                          b : HMENU;
                          c : HINSTANCE;
                          lpParam : LPVOID) : HWND;

PROCEDURE CreateWindowExW(a : DWORD;
                          lpClassName : ARRAY OF UCHAR;
                          lpWindowName : ARRAY OF UCHAR;
                          dwStyle : DWORD;
                          X : INTEGER;
                          Y : INTEGER;
                          nWidth : INTEGER;
                          nHeight : INTEGER;
                          hWndParent : HWND;
                          b : HMENU;
                          c : HINSTANCE;
                          lpParam : LPVOID) : HWND;

%IF UNICODE %THEN
PROCEDURE CreateWindowEx = CreateWindowExW;
%ELSE
PROCEDURE CreateWindowEx = CreateWindowExA;
%END


PROCEDURE IsWindow(hWnd : HWND) : BOOL;

PROCEDURE IsMenu(a : HMENU) : BOOL;

PROCEDURE IsChild(hWndParent : HWND;
                  hWnd : HWND) : BOOL;

PROCEDURE DestroyWindow(hWnd : HWND) : BOOL;

PROCEDURE ShowWindow(hWnd : HWND;
                     nCmdShow : INTEGER) : BOOL;


PROCEDURE ShowWindowAsync(hWnd : HWND; nCmdShow : WINT) : BOOL;

%IF WIN5 %THEN
PROCEDURE AnimateWindow(hWnd : HWND;
                        dwTime : DWORD;
                        dwFlags : DWORD) : BOOL;
%END

%IF WIN5 %THEN
CONST
    FLASHW_STOP         =0h;
    FLASHW_CAPTION      =000000001h;
    FLASHW_TRAY         =000000002h;
    FLASHW_ALL          =(FLASHW_CAPTION BOR FLASHW_TRAY);
    FLASHW_TIMER        =000000004h;
    FLASHW_TIMERNOFG    =00000000Ch;
%END

PROCEDURE FlashWindow(hWnd : HWND;
                    %IF WIN5 %THEN
                     dwFlags : DWORD
                    %ELSE
                      bInvert : BOOL
                    %END
                    ) : BOOL;

PROCEDURE ShowOwnedPopups(hWnd : HWND;
                          fShow : BOOL) : BOOL;

PROCEDURE OpenIcon(hWnd : HWND) : BOOL;

PROCEDURE CloseWindow(hWnd : HWND) : BOOL;

PROCEDURE MoveWindow(hWnd : HWND;
                     X : INTEGER;
                     Y : INTEGER;
                     nWidth : INTEGER;
                     nHeight : INTEGER;
                     bRepaint : BOOL) : BOOL;

PROCEDURE SetWindowPos(hWnd : HWND;
                       hWndInsertAfter : HWND;
                       X : INTEGER;
                       Y : INTEGER;
                       cx : INTEGER;
                       cy :INTEGER;
                       uFlags : UINT) : BOOL;

PROCEDURE GetWindowPlacement(hWnd : HWND;
                             VAR lpwndpl : WINDOWPLACEMENT) : BOOL;

PROCEDURE SetWindowPlacement(hWnd : HWND;
                             VAR lpwndpl : WINDOWPLACEMENT) : BOOL;

PROCEDURE BeginDeferWindowPos(nNumWindows : INTEGER) : HDWP;

PROCEDURE DeferWindowPos(hWinPosInfo : HDWP;
                         hWnd : HWND;
                         hWndInsertAfter : HWND;
                         x : INTEGER;
                         y :INTEGER ;
                         cx : INTEGER;
                         cy : INTEGER;
                         uFlags : UINT) : HDWP;

PROCEDURE EndDeferWindowPos(hWinPosInfo : HDWP) : BOOL;

PROCEDURE IsWindowVisible(hWnd : HWND) : BOOL;

PROCEDURE IsIconic(hWnd : HWND) : BOOL;

PROCEDURE AnyPopup() : BOOL;

PROCEDURE BringWindowToTop(hWnd : HWND) : BOOL;

PROCEDURE IsZoomed(hWnd : HWND) : BOOL;


CONST
    SWP_NOSIZE           = 00001h;
    SWP_NOMOVE           = 00002h;
    SWP_NOZORDER         = 00004h;
    SWP_NOREDRAW         = 00008h;
    SWP_NOACTIVATE       = 00010h;
    SWP_FRAMECHANGED     = 00020h;
    SWP_SHOWWINDOW       = 00040h;
    SWP_HIDEWINDOW       = 00080h;
    SWP_NOCOPYBITS       = 00100h;
    SWP_NOOWNERZORDER    = 00200h;
    SWP_NOSENDCHANGING   = 00400h;


    SWP_DRAWFRAME       = SWP_FRAMECHANGED;
    SWP_NOREPOSITION    = SWP_NOOWNERZORDER;

    SWP_DEFERERASE      = 02000h;
    SWP_ASYNCWINDOWPOS  = 04000h;


    HWND_TOP     = CAST(HWND, 0);
    HWND_BOTTOM          = CAST(HWND, 1);
    HWND_TOPMOST         = CAST(HWND, -1);
    HWND_NOTOPMOST       = CAST(HWND, -2);

TYPE
    <*/PUSH/PACK*>
    DLGTEMPLATE = RECORD
        style                   : DWORD;
        dwExtendedStyle         : DWORD;
        cdit                    : WORD;
        x                       : SHORT;
        y                       : SHORT;
        cx                      : SHORT;
        cy                      : SHORT;
    END;

    DLGITEMTEMPLATE = RECORD
          style          : DWORD;
          dwExtendedStyle: DWORD;
          x              : INTEGER16;
          y              : INTEGER16;
          cx              : INTEGER16;
          cy              : INTEGER16;
          id             : WORD;
    END;
    <*/POP*>

    LPDLGTEMPLATEW = POINTER TO DLGTEMPLATE;
    LPCDLGTEMPLATEW = LPDLGTEMPLATEW;
    LPDLGTEMPLATEA = LPDLGTEMPLATEW;
    LPCDLGTEMPLATEA = LPCDLGTEMPLATEW;

    LPDLGTEMPLATE = LPDLGTEMPLATEW;
    LPCDLGTEMPLATE = LPCDLGTEMPLATEW;

    PDLGITEMTEMPLATEW    = POINTER TO DLGITEMTEMPLATE;
    PDLGITEMTEMPLATEA    = PDLGITEMTEMPLATEW;
    PDLGITEMTEMPLATE     = PDLGITEMTEMPLATEW;

    LPDLGITEMTEMPLATEW   = PDLGITEMTEMPLATEW;
    LPDLGITEMTEMPLATEA   = PDLGITEMTEMPLATEW;
    LPDLGITEMTEMPLATE    = PDLGITEMTEMPLATEW;

PROCEDURE CreateDialogParamA(a : HINSTANCE;
                             lpTemplateName : ARRAY OF ACHAR;
                             hWndParent : HWND;
                             lpDialogFunc : DLGPROC;
                             dwInitParam : LPARAM) : HWND;

PROCEDURE CreateDialogParamW(a : HINSTANCE;
                             lpTemplateName : ARRAY OF UCHAR;
                             hWndParent : HWND;
                             lpDialogFunc : DLGPROC;
                             dwInitParam : LPARAM) : HWND;

%IF UNICODE %THEN
PROCEDURE CreateDialogParam = CreateDialogParamW;
%ELSE
PROCEDURE CreateDialogParam = CreateDialogParamA;
%END

PROCEDURE CreateDialogIndirectParamA(a : HINSTANCE;
                                     lpTemplate : LPCDLGTEMPLATEA;
                                     hWndParent : HWND;
                                     lpDialogFunc : DLGPROC;
                                     dwInitParam : LPARAM) : HWND;

PROCEDURE CreateDialogIndirectParamW(a : HINSTANCE;
                                     lpTemplate : LPCDLGTEMPLATEW;
                                     hWndParent : HWND;
                                     lpDialogFunc : DLGPROC;
                                     dwInitParam : LPARAM) : HWND;

%IF UNICODE %THEN
PROCEDURE CreateDialogIndirectParam = CreateDialogIndirectParamW;
%ELSE
PROCEDURE CreateDialogIndirectParam = CreateDialogIndirectParamA;
%END

PROCEDURE DialogBoxParamA(a : HINSTANCE;
                          lpTemplateName : ARRAY OF ACHAR;
                          hWndParent : HWND;
                          lpDialogFunc : DLGPROC;
                          dwInitParam : LPARAM) : INTEGER;

PROCEDURE DialogBoxParamW(a : HINSTANCE;
                          lpTemplateName : ARRAY OF UCHAR;
                          hWndParent : HWND;
                          lpDialogFunc : DLGPROC;
                          dwInitParam : LPARAM) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DialogBoxParam = DialogBoxParamW;
%ELSE
PROCEDURE DialogBoxParam = DialogBoxParamA;
%END

PROCEDURE DialogBoxIndirectParamA(a : HINSTANCE;
                                  hDialogTemplate : LPCDLGTEMPLATEA;
                                  hWndParent : HWND;
                                  lpDialogFunc : DLGPROC;
                                  dwInitParam : LPARAM) : INTEGER;

PROCEDURE DialogBoxIndirectParamW(a : HINSTANCE;
                                  hDialogTemplate : LPCDLGTEMPLATEW;
                                  hWndParent : HWND;
                                  lpDialogFunc : DLGPROC;
                                  dwInitParam : LPARAM) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DialogBoxIndirectParam = DialogBoxIndirectParamW;
%ELSE
PROCEDURE DialogBoxIndirectParam = DialogBoxIndirectParamA;
%END

PROCEDURE EndDialog(hDlg : HWND;
                    nResult : INTEGER) : BOOL;

PROCEDURE GetDlgItem(hDlg : HWND;
                     nIDDlgItem : INTEGER) : HWND [Invariant];

PROCEDURE SetDlgItemInt(hDlg : HWND;
                        nIDDlgItem : INTEGER;
                        uValue : UINT;
                        bSigned : BOOL) : BOOL;

PROCEDURE GetDlgItemInt(hDlg : HWND;
                        nIDDlgItem : INTEGER;
                        VAR lpTranslated : BOOL;
                        bSigned : BOOL) : UINT;

PROCEDURE SetDlgItemTextA(hDlg : HWND;
                          nIDDlgItem : INTEGER;
                          lpString : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetDlgItemTextW(hDlg : HWND;
                          nIDDlgItem : INTEGER;
                          lpString : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetDlgItemText = SetDlgItemTextW;
%ELSE
PROCEDURE SetDlgItemText = SetDlgItemTextA;
%END


PROCEDURE GetDlgItemTextW(hDlg : HWND;
                          nIDDlgItem : INTEGER;
                          VAR lpString : ARRAY OF UCHAR;
                          nMaxCount : INTEGER) : UINT;

PROCEDURE GetDlgItemTextA(hDlg : HWND;
                          nIDDlgItem : INTEGER;
                          VAR lpString : ARRAY OF ACHAR;
                          nMaxCount : INTEGER) : UINT;

%IF UNICODE %THEN
PROCEDURE GetDlgItemText = GetDlgItemTextW;
%ELSE
PROCEDURE GetDlgItemText = GetDlgItemTextA;
%END

PROCEDURE CheckDlgButton(hDlg : HWND;
                         nIDButton : INTEGER;
                         uCheck : UINT) : BOOL;

PROCEDURE CheckRadioButton(hDlg : HWND;
                           nIDFirstButton : INTEGER;
                           nIDLastButton : INTEGER;
                           nIDCheckButton : INTEGER) : BOOL;

PROCEDURE IsDlgButtonChecked(hDlg : HWND;
                             nIDButton : INTEGER) : UINT;

PROCEDURE SendDlgItemMessageA(hDlg : HWND;
                              nIDDlgItem : INTEGER;
                              Msg : UINT;
                              wParam : WPARAM;
                              lParam : LPARAM) : LONG;

PROCEDURE SendDlgItemMessageW(hDlg : HWND;
                              nIDDlgItem : INTEGER;
                              Msg : UINT;
                              wParam : WPARAM;
                              lParam : LPARAM) : LONG;

%IF UNICODE %THEN
PROCEDURE SendDlgItemMessage = SendDlgItemMessageW;
%ELSE
PROCEDURE SendDlgItemMessage = SendDlgItemMessageA;
%END

PROCEDURE GetNextDlgGroupItem(hDlg : HWND;
                              hCtl : HWND;
                              bPrevious : BOOL) : HWND;

PROCEDURE GetNextDlgTabItem(hDlg : HWND;
                            hCtl : HWND;
                            bPrevious : BOOL) : HWND;

PROCEDURE GetDlgCtrlID(hWnd : HWND) : INTEGER;

PROCEDURE GetDialogBaseUnits() : CARDINAL32;

PROCEDURE DefDlgProcA(hDlg : HWND;
                      Msg : UINT;
                      wParam : WPARAM;
                      lParam : LPARAM) : LRESULT;

PROCEDURE DefDlgProcW(hDlg : HWND;
                      Msg : UINT;
                      wParam : WPARAM;
                      lParam : LPARAM) : LRESULT;

%IF UNICODE %THEN
PROCEDURE DefDlgProc = DefDlgProcW;
%ELSE
PROCEDURE DefDlgProc = DefDlgProcA;
%END


CONST
    DLGWINDOWEXTRA       = 30;

PROCEDURE CallMsgFilterA(VAR lpMsg : MSG;
                         nCode : INTEGER) : BOOL;

PROCEDURE CallMsgFilterW(VAR lpMsg : MSG;
                         nCode : INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE CallMsgFilter = CallMsgFilterW;
%ELSE
PROCEDURE CallMsgFilter = CallMsgFilterA;
%END

PROCEDURE OpenClipboard(hWndNewOwner : HWND) : BOOL;

PROCEDURE CloseClipboard() : BOOL;

%IF WIN5 %THEN
PROCEDURE GetClipboardSequenceNumber() : DWORD;
%END

PROCEDURE GetClipboardOwner() : HWND;

PROCEDURE SetClipboardViewer(hWndNewViewer : HWND) : HWND;

PROCEDURE GetClipboardViewer() : HWND;

PROCEDURE ChangeClipboardChain(hWndRemove : HWND;
                               hWndNewNext : HWND) : BOOL;

PROCEDURE SetClipboardData(uFormat : UINT;
                           hMem : HANDLE) : HANDLE;

PROCEDURE GetClipboardData(uFormat : UINT) : HANDLE;

PROCEDURE RegisterClipboardFormatA(lpszFormat : ARRAY OF ACHAR) : UINT;

PROCEDURE RegisterClipboardFormatW(lpszFormat : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE RegisterClipboardFormat = RegisterClipboardFormatW;
%ELSE
PROCEDURE RegisterClipboardFormat = RegisterClipboardFormatA;
%END


PROCEDURE CountClipboardFormats() : INTEGER;

PROCEDURE EnumClipboardFormats(format : UINT) : UINT;

PROCEDURE GetClipboardFormatNameA(format : UINT;
                                  VAR lpszFormatName : ARRAY OF ACHAR;
                                  cchMaxCount : INTEGER) : INTEGER;

PROCEDURE GetClipboardFormatNameW(format : UINT;
                                  VAR lpszFormatName : ARRAY OF UCHAR;
                                  cchMaxCount : INTEGER) : INTEGER;
%IF UNICODE %THEN
PROCEDURE GetClipboardFormatName = GetClipboardFormatNameW;
%ELSE
PROCEDURE GetClipboardFormatName = GetClipboardFormatNameA;
%END


PROCEDURE EmptyClipboard() : BOOL;

PROCEDURE IsClipboardFormatAvailable(format : UINT) : BOOL;

PROCEDURE GetPriorityClipboardFormat(VAR paFormatPriorityList : UINT;
                                     cFormats : INTEGER) : INTEGER;

PROCEDURE GetOpenClipboardWindow() : HWND;

PROCEDURE CharToOemA(lpszSrc : ARRAY OF ACHAR;
                     VAR lpszDst : ARRAY OF ACHAR) : BOOL;

PROCEDURE CharToOemW(lpszSrc : ARRAY OF UCHAR;
                     VAR lpszDst : ARRAY OF ACHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE CharToOem = CharToOemW;
%ELSE
PROCEDURE CharToOem = CharToOemA;
%END

PROCEDURE OemToCharA(lpszSrc : ARRAY OF ACHAR;
                     VAR lpszDst : ARRAY OF ACHAR) : BOOL;

PROCEDURE OemToCharW(lpszSrc : ARRAY OF ACHAR;
                     VAR lpszDst : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE OemToChar = OemToCharW;
%ELSE
PROCEDURE OemToChar = OemToCharA;
%END

PROCEDURE CharToOemBuffA(lpszSrc : ARRAY OF ACHAR;
                         VAR lpszDst : ARRAY OF ACHAR;
                         cchDstLength : DWORD) : BOOL;

PROCEDURE CharToOemBuffW(lpszSrc : ARRAY OF UCHAR;
                         VAR lpszDst : ARRAY OF ACHAR;
                         cchDstLength : DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE CharToOemBuff = CharToOemBuffW;
%ELSE
PROCEDURE CharToOemBuff = CharToOemBuffA;
%END

PROCEDURE OemToCharBuffA(lpszSrc : ARRAY OF ACHAR;
                         VAR lpszDst : ARRAY OF ACHAR;
                         cchDstLength : DWORD) : BOOL;

PROCEDURE OemToCharBuffW(lpszSrc : ARRAY OF ACHAR;
                         VAR lpszDst : ARRAY OF UCHAR;
                         cchDstLength : DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE OemToCharBuff = OemToCharBuffW;
%ELSE
PROCEDURE OemToCharBuff = OemToCharBuffA;
%END

PROCEDURE CharUpperA(VAR lpsz : ARRAY OF ACHAR) : ACHAR;

PROCEDURE CharUpperW(VAR lpsz : ARRAY OF UCHAR) : UCHAR;

%IF UNICODE %THEN
PROCEDURE CharUpper = CharUpperW;
%ELSE
PROCEDURE CharUpper = CharUpperA;
%END

PROCEDURE CharUpperBuffA(VAR lpsz : ARRAY OF ACHAR;
                         cchLength : DWORD) : DWORD;

PROCEDURE CharUpperBuffW(VAR lpsz : ARRAY OF UCHAR;
                         cchLength : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE CharUpperBuff = CharUpperBuffW;
%ELSE
PROCEDURE CharUpperBuff = CharUpperBuffA;
%END

PROCEDURE CharLowerA(VAR lpsz : ARRAY OF ACHAR) : ACHAR;

PROCEDURE CharLowerW(VAR lpsz : ARRAY OF UCHAR) : UCHAR;

%IF UNICODE %THEN
PROCEDURE CharLower = CharLowerW;
%ELSE
PROCEDURE CharLower = CharLowerA;
%END

PROCEDURE CharLowerBuffA(VAR lpsz : ARRAY OF ACHAR;
                         cchLength : DWORD) : DWORD;

PROCEDURE CharLowerBuffW(VAR lpsz : ARRAY OF UCHAR;
                         cchLength : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE CharLowerBuff = CharLowerBuffW;
%ELSE
PROCEDURE CharLowerBuff = CharLowerBuffA;
%END

PROCEDURE CharNextA(lpsz : ARRAY OF ACHAR) : LPSTR;

PROCEDURE CharNextW(lpsz : ARRAY OF UCHAR) : LPWSTR;

%IF UNICODE %THEN
PROCEDURE CharNext = CharNextW;
%ELSE
PROCEDURE CharNext = CharNextA;
%END

PROCEDURE CharPrevA(lpszStart : ARRAY OF ACHAR;
                    lpszCurrent : ARRAY OF ACHAR) : LPSTR;

PROCEDURE CharPrevW(lpszStart : ARRAY OF UCHAR;
                    lpszCurrent : ARRAY OF UCHAR) : LPWSTR;

%IF UNICODE %THEN
PROCEDURE CharPrev = CharPrevW;
%ELSE
PROCEDURE CharPrev = CharPrevA;
%END


PROCEDURE CharNextExA(
                     CodePage : WORD;
                     lpCurrentChar : ARRAY OF ACHAR;
                     dwFlags : DWORD) : LPSTR;

PROCEDURE CharNextExW(
                     CodePage : WORD;
                     lpCurrentChar : ARRAY OF UCHAR;
                     dwFlags : DWORD) : LPWSTR;

%IF UNICODE %THEN
PROCEDURE CharNextEx = CharNextExW;
%ELSE
PROCEDURE CharNextEx = CharNextExA;
%END

PROCEDURE CharPrevExA(CodePage : WORD;
                      lpStart : ARRAY OF ACHAR;
                      lpCurrentChar : ARRAY OF ACHAR;
                      dwFlags : DWORD) : LPSTR;



PROCEDURE IsCharAlphaA(ch : ACHAR) : BOOL;

PROCEDURE IsCharAlphaW(ch : WCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE IsCharAlpha = IsCharAlphaW;
%ELSE
PROCEDURE IsCharAlpha = IsCharAlphaA;
%END

PROCEDURE IsCharAlphaNumericA(ch : ACHAR) : BOOL;

PROCEDURE IsCharAlphaNumericW(ch : WCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE IsCharAlphaNumeric = IsCharAlphaNumericW;
%ELSE
PROCEDURE IsCharAlphaNumeric = IsCharAlphaNumericA;
%END

PROCEDURE IsCharUpperA(ch : ACHAR) : BOOL;

PROCEDURE IsCharUpperW(ch : WCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE IsCharUpper = IsCharUpperW;
%ELSE
PROCEDURE IsCharUpper = IsCharUpperA;
%END

PROCEDURE IsCharLowerA(ch : ACHAR) : BOOL;

PROCEDURE IsCharLowerW(ch : WCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE IsCharLower = IsCharLowerW;
%ELSE
PROCEDURE IsCharLower = IsCharLowerA;
%END

PROCEDURE SetFocus(hWnd : HWND) : HWND;

PROCEDURE GetActiveWindow() : HWND;

PROCEDURE GetFocus() : HWND;

PROCEDURE GetKBCodePage() : UINT;

PROCEDURE GetKeyState(nVirtKey : INTEGER) : SHORT;

PROCEDURE GetAsyncKeyState(vKey : INTEGER) : SHORT;

PROCEDURE GetKeyboardState(VAR OUT lpKeyState : ARRAY OF SYSTEM.BYTE) : BOOL;

PROCEDURE SetKeyboardState(lpKeyState : ARRAY OF SYSTEM.BYTE) : BOOL;

PROCEDURE GetKeyNameTextA(lParam : LONG;
                          VAR lpString : ARRAY OF ACHAR;
                          nSize : INTEGER) : INTEGER;

PROCEDURE GetKeyNameTextW(lParam : LONG;
                          VAR lpString : ARRAY OF UCHAR;
                          nSize : INTEGER) : INTEGER;

%IF UNICODE %THEN
PROCEDURE GetKeyNameText = GetKeyNameTextW;
%ELSE
PROCEDURE GetKeyNameText = GetKeyNameTextA;
%END

PROCEDURE GetKeyboardType(nTypeFlag : INTEGER) : INTEGER;

PROCEDURE ToAscii(uVirtKey : UINT;
                  uScanCode : UINT;
                  lpKeyState : ARRAY OF SYSTEM.BYTE;
                  VAR OUT lpChar : ARRAY OF WORD;
                  uFlags : UINT) : INTEGER;


PROCEDURE ToAsciiEx(
            uVirtKey : UINT;
            uScanCode : UINT;
            lpKeyState : ARRAY OF SYSTEM.BYTE;
            VAR OUT lpChar : ARRAY OF WORD;
            uFlags : UINT;
            dwhkl : HKL) : WINT;


PROCEDURE ToUnicode(wVirtKey : UINT;
                    wScanCode : UINT;
                    lpKeyState : ARRAY OF  SYSTEM.BYTE;
                    VAR pwszBuff : ARRAY OF UCHAR;
                    cchBuff : INTEGER;
                    wFlags : UINT) : INTEGER;

PROCEDURE OemKeyScan(wOemChar : WORD) : DWORD;

PROCEDURE VkKeyScanA(ch : ACHAR) : SHORT;

PROCEDURE VkKeyScanW(ch : WCHAR) : SHORT;

%IF UNICODE %THEN
PROCEDURE VkKeyScan = VkKeyScanW;
%ELSE
PROCEDURE VkKeyScan = VkKeyScanA;
%END


PROCEDURE VkKeyScanExA(ch : ACHAR; dwhkl : HKL) : SHORT;

PROCEDURE VkKeyScanExW(ch : ACHAR; dwhkl : HKL) : SHORT;

%IF UNICODE %THEN
PROCEDURE VkKeyScanEx = VkKeyScanExW;
%ELSE
PROCEDURE VkKeyScanEx = VkKeyScanExA;
%END


CONST
    KEYEVENTF_EXTENDEDKEY= 00001h;
    KEYEVENTF_KEYUP      = 00002h;

PROCEDURE keybd_event(bVk : BYTE;
                      bScan : BYTE;
                      dwFlags : DWORD;
                      dwExtraInfo : DWORD);


CONST
    MOUSEEVENTF_MOVE     = 00001h;
    MOUSEEVENTF_LEFTDOWN = 00002h;
    MOUSEEVENTF_LEFTUP   = 00004h;
    MOUSEEVENTF_RIGHTDOWN= 00008h;
    MOUSEEVENTF_RIGHTUP  = 00010h;
    MOUSEEVENTF_MIDDLEDOWN= 00020h;
    MOUSEEVENTF_MIDDLEUP = 00040h;
    MOUSEEVENTF_WHEEL       = 00800h; (* wheel button rolled **)
    MOUSEEVENTF_ABSOLUTE = 08000h;

PROCEDURE mouse_event(dwFlags : DWORD;
                      dx : DWORD;
                      dy : DWORD;
                      cButtons : DWORD;
                      dwExtraInfo : DWORD);

TYPE
    (*NT only*)
    MOUSEINPUT = RECORD
    dx          : LONG;
    dy          : LONG;
    mouseData   : DWORD;
    dwFlags     : DWORD;
    time        : DWORD;
    dwExtraInfo : DWORD;
    END;
    PMOUSEINPUT = POINTER TO MOUSEINPUT;
    LPMOUSEINPUT = PMOUSEINPUT;

    (*NT only*)
    KEYBDINPUT = RECORD
    wVk         : WORD;
    wScan       : WORD;
    dwFlags     : DWORD;
    time        : DWORD;
    dwExtraInfo : DWORD;
    END;
    PKEYBDINPUT = POINTER TO KEYBDINPUT;
    LPKEYBDINPUT = PKEYBDINPUT;

    (*NT only*)
    HARDWAREINPUT = RECORD
    uMsg        : DWORD;
    wParamL     : WORD;
    wParamH     : WORD;
    END;
    PHARDWAREINPUT = POINTER TO HARDWAREINPUT;
    LPHARDWAREINPUT = PHARDWAREINPUT;

    (*NT only*)
    INPUT = RECORD
    type        : DWORD;

    CASE : CARDINAL OF
        0: mi : MOUSEINPUT;|
        1: ki : KEYBDINPUT;|
        2: hi : HARDWAREINPUT;
    ELSE
    END;
    END;
    PINPUT = POINTER TO INPUT;
    LPINPUT = PINPUT;

CONST
    INPUT_MOUSE     =0;
    INPUT_KEYBOARD  =1;
    INPUT_HARDWARE  =2;

(*NT only*)
PROCEDURE SendInput(cInputs : UINT;     (* number of input in the array*)
                    pInputs : INPUT;     (* array of inputs*)
                    cbSize : WINT) : UINT;    (* sizeof(INPUT)*)

%IF WIN5 %THEN
TYPE
    (*NT only*)
    LASTINPUTINFO = RECORD
    cbSize      : UINT;
    dwTime      : DWORD;
    END;
    PLASTINPUTINFO = POINTER TO LASTINPUTINFO;

(*NT only*)
PROCEDURE GetLastInputInfo(plii : LASTINPUTINFO) : BOOL;
%END

PROCEDURE MapVirtualKeyA(uCode : UINT;
                         uMapType : UINT) : UINT;

PROCEDURE MapVirtualKeyW(uCode : UINT;
                         uMapType : UINT) : UINT;

%IF UNICODE %THEN
PROCEDURE MapVirtualKey = MapVirtualKeyW;
%ELSE
PROCEDURE MapVirtualKey = MapVirtualKeyA;
%END


PROCEDURE MapVirtualKeyExA(
                            uCode : UINT;
                            uMapType : UINT;
                            dwhkl : HKL) : UINT;

PROCEDURE MapVirtualKeyExW(
                            uCode : UINT;
                            uMapType : UINT;
                            dwhkl : HKL) : UINT;

%IF UNICODE %THEN
PROCEDURE MapVirtualKeyEx = MapVirtualKeyExW;
%ELSE
PROCEDURE MapVirtualKeyEx = MapVirtualKeyExA;
%END



PROCEDURE GetInputState() : BOOL;

PROCEDURE GetQueueStatus(flags : UINT) : DWORD;

PROCEDURE GetCapture() : HWND;

PROCEDURE SetCapture(hWnd : HWND) : HWND;

PROCEDURE ReleaseCapture() : BOOL;

PROCEDURE MsgWaitForMultipleObjects(nCount : DWORD;
                                    pHandles : ARRAY OF HANDLE;
                                    fWaitAll : BOOL;
                                    dwMilliseconds : DWORD;
                                    dwWakeMask : DWORD) : DWORD;


PROCEDURE MsgWaitForMultipleObjectsEx(nCount : DWORD;
                                      pHandles : ARRAY OF HANDLE;
                                      dwMilliseconds : DWORD;
                                      dwWakeMask : DWORD;
                                      dwFlags : DWORD) : DWORD;

CONST
    MWMO_WAITALL        = 0001h;
    MWMO_ALERTABLE      = 0002h;
    MWMO_INPUTAVAILABLE = 0004h;

    QS_KEY               = 001h;
    QS_MOUSEMOVE         = 002h;
    QS_MOUSEBUTTON       = 004h;
    QS_POSTMESSAGE       = 008h;
    QS_TIMER             = 010h;
    QS_PAINT             = 020h;
    QS_SENDMESSAGE       = 040h;
    QS_HOTKEY            = 080h;
    QS_ALLPOSTMESSAGE    = 0100h;

    QS_MOUSE             =  QS_MOUSEMOVE BOR QS_MOUSEBUTTON;
    QS_INPUT             =  QS_MOUSE BOR QS_KEY;
    QS_ALLEVENTS         =      QS_INPUT BOR
                                QS_POSTMESSAGE BOR
                                QS_TIMER BOR
                                QS_PAINT BOR
                                QS_HOTKEY;
    QS_ALLINPUT          =      QS_SENDMESSAGE BOR
                                QS_PAINT BOR
                                QS_TIMER BOR
                                QS_POSTMESSAGE BOR
                                QS_MOUSEBUTTON BOR
                                QS_MOUSEMOVE BOR
                                QS_HOTKEY BOR
                                QS_KEY;

PROCEDURE SetTimer(hWnd : HWND;
                   nIDEvent : UINT;
                   uElapse : UINT;
                   lpTimerFunc : TIMERPROC) : UINT;

PROCEDURE KillTimer(hWnd : HWND;
                    uIDEvent : UINT) : BOOL;

PROCEDURE IsWindowUnicode(hWnd : HWND) : BOOL;

PROCEDURE EnableWindow(hWnd : HWND;
                       bEnable : BOOL) : BOOL;

PROCEDURE IsWindowEnabled(hWnd : HWND) : BOOL;

PROCEDURE LoadAcceleratorsA(a : HINSTANCE;
                            lpTableName : ARRAY OF ACHAR) : HACCEL;

PROCEDURE LoadAcceleratorsW(a : HINSTANCE;
                            lpTableName : ARRAY OF UCHAR) : HACCEL;

%IF UNICODE %THEN
PROCEDURE LoadAccelerators = LoadAcceleratorsW;
%ELSE
PROCEDURE LoadAccelerators = LoadAcceleratorsA;
%END

PROCEDURE CreateAcceleratorTableA(a : LPACCEL;
                                  b : INTEGER) : HACCEL;

PROCEDURE CreateAcceleratorTableW(a : LPACCEL;
                                  b : INTEGER) : HACCEL;

%IF UNICODE %THEN
PROCEDURE CreateAcceleratorTable = CreateAcceleratorTableW;
%ELSE
PROCEDURE CreateAcceleratorTable = CreateAcceleratorTableA;
%END

PROCEDURE DestroyAcceleratorTable(hAccel : HACCEL) : BOOL;

PROCEDURE CopyAcceleratorTableA(hAccelSrc : HACCEL;
                                VAR lpAccelDst : ARRAY OF ACCEL;
                                cAccelEntries : INTEGER) : INTEGER;

PROCEDURE CopyAcceleratorTableW(hAccelSrc : HACCEL;
                                VAR lpAccelDst : ARRAY OF ACCEL;
                                cAccelEntries : INTEGER) : INTEGER;

%IF UNICODE %THEN
PROCEDURE CopyAcceleratorTable = CopyAcceleratorTableW;
%ELSE
PROCEDURE CopyAcceleratorTable = CopyAcceleratorTableA;
%END

PROCEDURE TranslateAcceleratorA(hWnd : HWND;
                                hAccTable : HACCEL;
                                VAR lpMsg : MSG) : INTEGER;

PROCEDURE TranslateAcceleratorW(hWnd : HWND;
                                hAccTable : HACCEL;
                                VAR lpMsg : MSG) : INTEGER;

%IF UNICODE %THEN
PROCEDURE TranslateAccelerator = TranslateAcceleratorW;
%ELSE
PROCEDURE TranslateAccelerator = TranslateAcceleratorA;
%END

CONST
    SM_CXSCREEN          = 0;
    SM_CYSCREEN          = 1;
    SM_CXVSCROLL         = 2;
    SM_CYHSCROLL         = 3;
    SM_CYCAPTION         = 4;
    SM_CXBORDER          = 5;
    SM_CYBORDER          = 6;
    SM_CXDLGFRAME        = 7;
    SM_CYDLGFRAME        = 8;
    SM_CYVTHUMB          = 9;
    SM_CXHTHUMB          = 10;
    SM_CXICON            = 11;
    SM_CYICON            = 12;
    SM_CXCURSOR          = 13;
    SM_CYCURSOR          = 14;
    SM_CYMENU            = 15;
    SM_CXFULLSCREEN      = 16;
    SM_CYFULLSCREEN      = 17;
    SM_CYKANJIWINDOW     = 18;
    SM_MOUSEPRESENT      = 19;
    SM_CYVSCROLL         = 20;
    SM_CXHSCROLL         = 21;
    SM_DEBUG             = 22;
    SM_SWAPBUTTON        = 23;
    SM_RESERVED1         = 24;
    SM_RESERVED2         = 25;
    SM_RESERVED3         = 26;
    SM_RESERVED4         = 27;
    SM_CXMIN             = 28;
    SM_CYMIN             = 29;
    SM_CXSIZE            = 30;
    SM_CYSIZE            = 31;
    SM_CXFRAME           = 32;
    SM_CYFRAME           = 33;
    SM_CXMINTRACK        = 34;
    SM_CYMINTRACK        = 35;
    SM_CXDOUBLECLK       = 36;
    SM_CYDOUBLECLK       = 37;
    SM_CXICONSPACING     = 38;
    SM_CYICONSPACING     = 39;
    SM_MENUDROPALIGNMENT = 40;
    SM_PENWINDOWS        = 41;
    SM_DBCSENABLED       = 42;
    SM_CMOUSEBUTTONS     = 43;

    SM_CXFIXEDFRAME      = SM_CXDLGFRAME;
    SM_CYFIXEDFRAME      = SM_CYDLGFRAME;
    SM_CXSIZEFRAME       = SM_CXFRAME;
    SM_CYSIZEFRAME       = SM_CYFRAME;
    SM_SECURE            = 44;
    SM_CXEDGE            = 45;
    SM_CYEDGE            = 46;
    SM_CXMINSPACING      = 47;
    SM_CYMINSPACING      = 48;
    SM_CXSMICON          = 49;
    SM_CYSMICON          = 50;
    SM_CYSMCAPTION       = 51;
    SM_CXSMSIZE          = 52;
    SM_CYSMSIZE          = 53;
    SM_CXMENUSIZE        = 54;
    SM_CYMENUSIZE        = 55;
    SM_ARRANGE           = 56;
    SM_CXMINIMIZED       = 57;
    SM_CYMINIMIZED       = 58;
    SM_CXMAXTRACK        = 59;
    SM_CYMAXTRACK        = 60;
    SM_CXMAXIMIZED       = 61;
    SM_CYMAXIMIZED       = 62;
    SM_NETWORK           = 63;
    SM_CLEANBOOT         = 67;
    SM_CXDRAG            = 68;
    SM_CYDRAG            = 69;
    SM_SHOWSOUNDS        = 70;
    SM_CXMENUCHECK       = 71;
    SM_CYMENUCHECK       = 72;
    SM_SLOWMACHINE       = 73;
    SM_MIDEASTENABLED    = 74;
%IF WIN5 %THEN
    SM_MOUSEWHEELPRESENT    = 75;
%END
    SM_XVIRTUALSCREEN       =76;
    SM_YVIRTUALSCREEN       =77;
    SM_CXVIRTUALSCREEN      =78;
    SM_CYVIRTUALSCREEN      =79;
    SM_CMONITORS            =80;
    SM_SAMEDISPLAYFORMAT    =81;

%IF WIN5 %THEN
    SM_CMETRICS          = 83;
%ELSE
    SM_CMETRICS          = 76;
%END

PROCEDURE GetSystemMetrics(nIndex : INTEGER) : INTEGER;

PROCEDURE LoadMenuA(a : HINSTANCE; lpMenuName : ARRAY OF ACHAR) : HMENU;

PROCEDURE LoadMenuW(a : HINSTANCE; lpMenuName : ARRAY OF UCHAR) : HMENU;

%IF UNICODE %THEN
PROCEDURE LoadMenu = LoadMenuW;
%ELSE
PROCEDURE LoadMenu = LoadMenuA;
%END

PROCEDURE LoadMenuIndirectA(VAR lpMenuTemplate : MENUTEMPLATEA) : HMENU;

PROCEDURE LoadMenuIndirectW(VAR lpMenuTemplate : MENUTEMPLATEW) : HMENU;

%IF UNICODE %THEN
PROCEDURE LoadMenuIndirect = LoadMenuIndirectW;
%ELSE
PROCEDURE LoadMenuIndirect = LoadMenuIndirectA;
%END

PROCEDURE GetMenu(hWnd : HWND) : HMENU;

PROCEDURE SetMenu(hWnd : HWND;
                  a : HMENU) : BOOL;

PROCEDURE ChangeMenuA(a : HMENU;
                      cmd : UINT;
                      lpszNewItem : ARRAY OF ACHAR;
                      cmdInsert : UINT;
                      flags : UINT) : BOOL;

PROCEDURE ChangeMenuW(a : HMENU;
                      cmd : UINT;
                      lpszNewItem : ARRAY OF UCHAR;
                      cmdInsert : UINT;
                      flags : UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE ChangeMenu = ChangeMenuW;
%ELSE
PROCEDURE ChangeMenu = ChangeMenuA;
%END

PROCEDURE HiliteMenuItem(hWnd : HWND;
                         a : HMENU;
                         uIDHiliteItem : UINT;
                         uHilite : UINT) : BOOL;

PROCEDURE GetMenuStringA(a : HMENU;
                         uIDItem : UINT;
                         VAR lpString : ARRAY OF ACHAR;
                         nMaxCount : INTEGER;
                         uFlag : UINT) : INTEGER;

PROCEDURE GetMenuStringW(a : HMENU;
                         uIDItem : UINT;
                         VAR lpString : ARRAY OF UCHAR;
                         nMaxCount : INTEGER;
                         uFlag : UINT) : INTEGER;

%IF UNICODE %THEN
PROCEDURE GetMenuString = GetMenuStringW;
%ELSE
PROCEDURE GetMenuString = GetMenuStringA;
%END

PROCEDURE GetMenuState(a : HMENU;
                       uId : UINT;
                       uFlags : UINT) : UINT;

PROCEDURE DrawMenuBar(hWnd : HWND) : BOOL;

PROCEDURE GetSystemMenu(hWnd : HWND;
                        bRevert : BOOL) : HMENU;

PROCEDURE CreateMenu() : HMENU;

PROCEDURE CreatePopupMenu() : HMENU;

PROCEDURE DestroyMenu(a : HMENU) : BOOL;

PROCEDURE CheckMenuItem(a : HMENU;
                        uIDCheckItem : UINT;
                        uCheck : UINT) : DWORD;

PROCEDURE EnableMenuItem(a : HMENU;
                         uIDEnableItem : UINT;
                         uEnable : UINT) : DWORD;

PROCEDURE GetSubMenu(a : HMENU;
                     nPos : INTEGER) : HMENU;

PROCEDURE GetMenuItemID(a : HMENU;
                        nPos : INTEGER) : UINT;

PROCEDURE GetMenuItemCount(a : HMENU) : INTEGER;

PROCEDURE InsertMenuA(a : HMENU;
                      uPosition : UINT;
                      uFlags : UINT;
                      uIDNewItem : UINT;
                      lpNewItem : ARRAY OF ACHAR) : BOOL;

PROCEDURE InsertMenuW(a : HMENU;
                      uPosition : UINT;
                      uFlags : UINT;
                      uIDNewItem : UINT;
                      lpNewItem : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE InsertMenu = InsertMenuW;
%ELSE
PROCEDURE InsertMenu = InsertMenuA;
%END

PROCEDURE AppendMenuA(a : HMENU;
                      uFlags : UINT;
                      uIDNewItem : UINT;
                      lpNewItem : ARRAY OF ACHAR) : BOOL;

PROCEDURE AppendMenuW(a : HMENU;
                      uFlags : UINT;
                      uIDNewItem : UINT;
                      lpNewItem : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE AppendMenu = AppendMenuW;
%ELSE
PROCEDURE AppendMenu = AppendMenuA;
%END

PROCEDURE ModifyMenuA(hMnu : HMENU;
                      uPosition : UINT;
                      uFlags : UINT;
                      uIDNewItem : UINT;
                      lpNewItem : ARRAY OF ACHAR) : BOOL;

PROCEDURE ModifyMenuW(hMnu : HMENU;
                      uPosition : UINT;
                      uFlags : UINT;
                      uIDNewItem : UINT;
                      lpNewItem : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE ModifyMenu = ModifyMenuW;
%ELSE
PROCEDURE ModifyMenu = ModifyMenuA;
%END

PROCEDURE RemoveMenu(a : HMENU;
                     uPosition : UINT;
                     uFlags : UINT) : BOOL;

PROCEDURE DeleteMenu(a : HMENU;
                     uPosition : UINT;
                     uFlags : UINT) : BOOL;

PROCEDURE SetMenuItemBitmaps(a : HMENU;
                             uPosition : UINT;
                             uFlags : UINT;
                             hBitmapUnchecked : HBITMAP;
                             hBitmapChecked : HBITMAP) : BOOL;

PROCEDURE GetMenuCheckMarkDimensions() : LONG;

PROCEDURE TrackPopupMenu(a : HMENU;
                         uFlags : UINT;
                         x : INTEGER;
                         y : INTEGER;
                         nReserved : INTEGER;
                         hWnd : HWND;
                         prcRect : RECT) : BOOL;


CONST
    MNC_IGNORE  = 0;
    MNC_CLOSE   = 1;
    MNC_EXECUTE = 2;
    MNC_SELECT  = 3;

TYPE
    TPMPARAMS = RECORD
        cbSize          : UINT;
        rcExclude       : RECT;
    END;
    LPTPMPARAMS = POINTER TO TPMPARAMS;

PROCEDURE TrackPopupMenuEx(a: HMENU;
                           b: UINT;
                           c: WINT;
                           d: WINT;
                           e: HWND;
                           VAR f: TPMPARAMS) : BOOL;

%IF WIN5 %THEN
CONST
    MNS_NOCHECK         = 80000000h;
    MNS_MODELESS        = 40000000h;
    MNS_DRAGDROP        = 20000000h;
    MNS_AUTODISMISS     = 10000000h;
    MNS_NOTIFYBYPOS     = 08000000h;
    MNS_CHECKORBMP      = 04000000h;

    MIM_MAXHEIGHT               = 00000001h;
    MIM_BACKGROUND              = 00000002h;
    MIM_HELPID                  = 00000004h;
    MIM_MENUDATA                =00000008h;
    MIM_STYLE                   = 00000010h;
    MIM_APPLYTOSUBMENUS         = 80000000h;

TYPE
    MENUINFO = RECORD
    cbSize      : DWORD;
    fMask       : DWORD;
    dwStyle     : DWORD;
    cyMax       : UINT;
    hbrBack     : HBRUSH;
    dwContextHelpID : DWORD;
    dwMenuData : DWORD;
    END;
    LPMENUINFO = POINTER TO MENUINFO;
    LPCMENUINFO = LPMENUINFO;

PROCEDURE GetMenuInfo(a : HMENU; VAR b : MENUINFO) : BOOL;

PROCEDURE SetMenuInfo(a : HMENU; b : MENUINFO);

PROCEDURE EndMenu() : BOOL;

(*
 * WM_MENUDRAG return values.
 *)
CONST
    MND_CONTINUE       =0;
    MND_ENDMENU        =1;

TYPE
    MENUGETOBJECTINFO = RECORD
    dwFlags : DWORD;
    uPos : UINT;
    hmenu : HMENU;
    riid : PVOID;
    pvObj : PVOID;
    END;
    PMENUGETOBJECTINFO = POINTER TO MENUGETOBJECTINFO;

(*
 * MENUGETOBJECTINFO dwFlags values
 *)

CONST
    MNGOF_GAP            = 00000003h;

(*
 * WM_MENUGETOBJECT return values
 *)
    MNGO_NOINTERFACE     = 00000000h;
    MNGO_NOERROR         = 00000001h;

%END

CONST
    MIIM_STATE       = 000000001h;
    MIIM_ID          = 000000002h;
    MIIM_SUBMENU     = 000000004h;
    MIIM_CHECKMARKS  = 000000008h;
    MIIM_TYPE        = 000000010h;
    MIIM_DATA        = 000000020h;

%IF WIN5 %THEN
    MIIM_STRING      = 00000040h;
    MIIM_BITMAP      = 00000080h;
    MIIM_FTYPE       = 00000100h;

    HBMMENU_CALLBACK            =CAST(HBITMAP, -1);
    HBMMENU_SYSTEM              =CAST(HBITMAP,  1);
    HBMMENU_MBAR_RESTORE        =CAST(HBITMAP,  2);
    HBMMENU_MBAR_MINIMIZE       =CAST(HBITMAP,  3);
    HBMMENU_MBAR_CLOSE          =CAST(HBITMAP,  5);
    HBMMENU_MBAR_CLOSE_D        =CAST(HBITMAP,  6);
    HBMMENU_MBAR_MINIMIZE_D     =CAST(HBITMAP,  7);
    HBMMENU_POPUP_CLOSE         =CAST(HBITMAP,  8);
    HBMMENU_POPUP_RESTORE       =CAST(HBITMAP,  9);
    HBMMENU_POPUP_MAXIMIZE      =CAST(HBITMAP, 10);
    HBMMENU_POPUP_MINIMIZE      =CAST(HBITMAP, 11);
%END

TYPE
    MENUITEMINFOA = RECORD
        cbSize          : UINT;
        fMask           : UINT;
        fType           : UINT;
        fState          : UINT;
        wID             : UINT;
        hSubMenu        : HMENU;
        hbmpChecked     : HBITMAP;
        hbmpUnchecked   : HBITMAP;
        dwItemData      : DWORD;
        dwTypeData      : LPSTR;
        cch             : UINT;
        %IF WIN5 %THEN
        (*NT only*)
        hbmpItem        : HBITMAP; (* used if MIIM_BITMAP*)
        %END
    END;
    LPMENUITEMINFOA     = POINTER TO MENUITEMINFOA;
    LPCMENUITEMINFOA    = LPMENUITEMINFOA;

    MENUITEMINFOW = RECORD
        cbSize          : UINT;
        fMask           : UINT;
        fType           : UINT;
        fState          : UINT;
        wID             : UINT;
        hSubMenu        : HMENU;
        hbmpChecked     : HBITMAP;
        hbmpUnchecked   : HBITMAP;
        dwItemData      : DWORD;
        dwTypeData      : LPWSTR;
        cch             : UINT;
        %IF WIN5 %THEN
        (*NT only*)
        hbmpItem        : HBITMAP; (* used if MIIM_BITMAP*)
        %END
    END;
    LPMENUITEMINFOW     = POINTER TO MENUITEMINFOW;
    LPCMENUITEMINFOW    = LPMENUITEMINFOW;

%IF UNICODE %THEN
    MENUITEMINFO        = MENUITEMINFOW;
    LPMENUITEMINFO      = LPMENUITEMINFOW;
%ELSE
    MENUITEMINFO        = MENUITEMINFOA;
    LPMENUITEMINFO      = LPMENUITEMINFOA;
%END
    LPCMENUITEMINFO     = LPMENUITEMINFO;

PROCEDURE InsertMenuItemA(
                        a: HMENU;
                        b: UINT;
                        c: BOOL;
                        d: MENUITEMINFOA
                        ) : BOOL;

PROCEDURE InsertMenuItemW(
                        a: HMENU;
                        b: UINT;
                        c: BOOL;
                        d: MENUITEMINFOW
                        ) : BOOL;

%IF UNICODE %THEN
PROCEDURE InsertMenuItem = InsertMenuItemW;
%ELSE
PROCEDURE InsertMenuItem = InsertMenuItemA;
%END

PROCEDURE GetMenuItemInfoA(
                            a: HMENU;
                            b: UINT;
                            c: BOOL;
                            VAR d: MENUITEMINFOA
                            ) : BOOL;

PROCEDURE GetMenuItemInfoW(
                            a: HMENU;
                            b: UINT;
                            c: BOOL;
                            VAR d: MENUITEMINFOW
                            ) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetMenuItemInfo = GetMenuItemInfoW;
%ELSE
PROCEDURE GetMenuItemInfo = GetMenuItemInfoA;
%END

PROCEDURE SetMenuItemInfoA(
                            a: HMENU;
                            b: UINT;
                            c: BOOL;
                            d: MENUITEMINFOA
                            ) : BOOL;

PROCEDURE SetMenuItemInfoW(
                            a: HMENU;
                            b: UINT;
                            c: BOOL;
                            d: MENUITEMINFOW
                            ) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetMenuItemInfo = SetMenuItemInfoW;
%ELSE
PROCEDURE SetMenuItemInfo = SetMenuItemInfoA;
%END

CONST
    GMDI_USEDISABLED    = 00001h;
    GMDI_GOINTOPOPUPS   = 00002h;

PROCEDURE GetMenuDefaultItem(hMenu : HMENU;
                             fByPos : UINT;
                             gmdiFlags : UINT) : UINT;

PROCEDURE SetMenuDefaultItem(hMenu : HMENU;
                             uItem : UINT;
                             fByPos :  UINT) : BOOL;

PROCEDURE GetMenuItemRect(hWnd : HWND;
                          hMenu : HWND;
                          uItem : UINT;
                          VAR lprcItem : RECT ) : BOOL;

PROCEDURE MenuItemFromPoint(hWnd : HWND;
                            hMenu : HMENU;
                            ptScreen : VALUE POINT) : WINT;


CONST
    TPM_LEFTBUTTON       = 00000h;
    TPM_RIGHTBUTTON      = 00002h;
    TPM_LEFTALIGN        = 00000h;
    TPM_CENTERALIGN      = 00004h;
    TPM_RIGHTALIGN       = 00008h;

    TPM_TOPALIGN        = 0000h;
    TPM_VCENTERALIGN    = 0010h;
    TPM_BOTTOMALIGN     = 0020h;

    TPM_HORIZONTAL      = 0000h;
    TPM_VERTICAL        = 0040h;
    TPM_NONOTIFY        = 0080h;
    TPM_RETURNCMD       = 0100h;

%IF WIN5 %THEN
    TPM_RECURSE         = 0001h;
%END

TYPE
    DROPSTRUCT = RECORD
        hwndSource      : HWND;
        hwndSink        : HWND;
        wFmt            : DWORD;
        dwData          : DWORD;
        ptDrop          : POINT;
        dwControlData   : DWORD;
    END;
    PDROPSTRUCT         = POINTER TO DROPSTRUCT;
    LPDROPSTRUCT        = PDROPSTRUCT;

CONST
    DOF_EXECUTABLE      = 8001h;
    DOF_DOCUMENT        = 8002h;
    DOF_DIRECTORY       = 8003h;
    DOF_MULTIPLE        = 8004h;
    DOF_PROGMAN         = 0001h;
    DOF_SHELLDATA       = 0002h;

    DO_DROPFILE         = 454C4946h;
    DO_PRINTFILE        = 544E5250h;

PROCEDURE DragObject(a: HWND;
                     b: HWND;
                     c: UINT;
                     d: DWORD;
                     e: HCURSOR) : DWORD;

PROCEDURE DragDetect(a: HWND; b: VALUE POINT) : BOOL;


PROCEDURE DrawIcon(hDC : HDC;
                   X : INTEGER;
                   Y : INTEGER;
                   hIcon : HICON) : BOOL;


CONST
    DT_TOP               = 00000h;
    DT_LEFT              = 00000h;
    DT_CENTER            = 00001h;
    DT_RIGHT             = 00002h;
    DT_VCENTER           = 00004h;
    DT_BOTTOM            = 00008h;
    DT_WORDBREAK         = 00010h;
    DT_SINGLELINE        = 00020h;
    DT_EXPANDTABS        = 00040h;
    DT_TABSTOP           = 00080h;
    DT_NOCLIP            = 00100h;
    DT_EXTERNALLEADING   = 00200h;
    DT_CALCRECT          = 00400h;
    DT_NOPREFIX          = 00800h;
    DT_INTERNAL          = 01000h;

    DT_EDITCONTROL       = 00002000h;
    DT_PATH_ELLIPSIS     = 00004000h;
    DT_END_ELLIPSIS      = 00008000h;
    DT_MODIFYSTRING      = 00010000h;
    DT_RTLREADING        = 00020000h;
    DT_WORD_ELLIPSIS     = 00040000h;

TYPE
    DRAWTEXTPARAMS = RECORD
        cbSize          : UINT;
        iTabLength      : WINT;
        iLeftMargin     : WINT;
        iRightMargin    : WINT;
        uiLengthDrawn   : UINT;
    END;
    LPDRAWTEXTPARAMS    = POINTER TO DRAWTEXTPARAMS;


PROCEDURE DrawTextA(hDC : HDC;
                    lpString : ARRAY OF ACHAR;
                    nCount : INTEGER;
                    lpRect : RECT;
                    uFormat : UINT) : INTEGER;

PROCEDURE DrawTextW(hDC : HDC;
                    lpString : ARRAY OF UCHAR;
                    nCount : INTEGER;
                    lpRect : RECT;
                    uFormat : UINT) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DrawText = DrawTextW;
%ELSE
PROCEDURE DrawText = DrawTextA;
%END


PROCEDURE DrawTextExA(a: HDC;
                      b: ARRAY OF ACHAR;
                      c: WINT;
                      d: RECT;
                      e: UINT;
                      VAR f: DRAWTEXTPARAMS) : WINT;

PROCEDURE DrawTextExW(a: HDC;
                      b: ARRAY OF UCHAR;
                      c: WINT;
                      d: RECT;
                      e: UINT;
                      VAR f: DRAWTEXTPARAMS) : WINT;
%IF UNICODE %THEN
PROCEDURE DrawTextEx = DrawTextExW;
%ELSE
PROCEDURE DrawTextEx = DrawTextExA;
%END



PROCEDURE GrayStringA(hDC : HDC;
                      hBrush : HBRUSH;
                      lpOutputFunc : GRAYSTRINGPROC;
                      lpData : LPARAM;
                      nCount : INTEGER;
                      X : INTEGER;
                      Y : INTEGER;
                      nWidth : INTEGER;
                      nHeight : INTEGER) : BOOL;

PROCEDURE GrayStringW(hDC : HDC;
                      hBrush : HBRUSH;
                      lpOutputFunc : GRAYSTRINGPROC;
                      lpData : LPARAM;
                      nCount : INTEGER;
                      X : INTEGER;
                      Y : INTEGER;
                      nWidth : INTEGER;
                      nHeight : INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE GrayString = GrayStringW;
%ELSE
PROCEDURE GrayString = GrayStringA;
%END

CONST
    DST_COMPLEX     = 0000h;
    DST_TEXT        = 0001h;
    DST_PREFIXTEXT  = 0002h;
    DST_ICON        = 0003h;
    DST_BITMAP      = 0004h;

    DSS_NORMAL      = 0000h;
    DSS_UNION       = 0010h;
    DSS_DISABLED    = 0020h;
    DSS_MONO        = 0080h;
    DSS_RIGHT       = 8000h;

PROCEDURE DrawStateA(a: HDC;
                     b: HBRUSH;
                     c: DRAWSTATEPROC;
                     d: LPARAM;
                     e: WPARAM;
                     f: WINT;
                     g: WINT;
                     h: WINT;
                     i: WINT;
                     j: UINT) : BOOL;

PROCEDURE DrawStateW(a: HDC;
                     b: HBRUSH;
                     c: DRAWSTATEPROC;
                     d: LPARAM;
                     e: WPARAM;
                     f: WINT;
                     g: WINT;
                     h: WINT;
                     i: WINT;
                     j: UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE DrawState = DrawStateW;
%ELSE
PROCEDURE DrawState = DrawStateA;
%END

PROCEDURE TabbedTextOutA(hDC : HDC;
                         X : INTEGER;
                         Y : INTEGER;
                         lpString : ARRAY OF ACHAR;
                         nCount : INTEGER;
                         nTabPositions : INTEGER;
                         lpnTabStopPositions : ARRAY OF WINT;
                         nTabOrigin : INTEGER) : LONG;

PROCEDURE TabbedTextOutW(hDC : HDC;
                         X : INTEGER;
                         Y : INTEGER;
                         lpString : ARRAY OF UCHAR;
                         nCount : INTEGER;
                         nTabPositions : INTEGER;
                         lpnTabStopPositions : ARRAY OF WINT;
                         nTabOrigin : INTEGER) : LONG;

%IF UNICODE %THEN
PROCEDURE TabbedTextOut = TabbedTextOutW;
%ELSE
PROCEDURE TabbedTextOut = TabbedTextOutA;
%END

PROCEDURE GetTabbedTextExtentA(hDC : HDC;
                               lpString : ARRAY OF ACHAR;
                               nCount : INTEGER;
                               nTabPositions : INTEGER;
                               VAR lpnTabStopPositions : ARRAY OF WINT) : DWORD;

PROCEDURE GetTabbedTextExtentW(hDC : HDC;
                               lpString : ARRAY OF UCHAR;
                               nCount : INTEGER;
                               nTabPositions : INTEGER;
                               VAR lpnTabStopPositions : ARRAY OF WINT) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetTabbedTextExtent = GetTabbedTextExtentW;
%ELSE
PROCEDURE GetTabbedTextExtent = GetTabbedTextExtentA;
%END

PROCEDURE UpdateWindow(hWnd : HWND) : BOOL;

PROCEDURE SetActiveWindow(hWnd : HWND) : HWND;

PROCEDURE GetForegroundWindow() : HWND;


PROCEDURE PaintDesktop(hdc : HDC) : BOOL;

PROCEDURE SwitchToThisWindow(hwnd : HWND; fUnknown : BOOL);


PROCEDURE SetForegroundWindow(hWnd : HWND) : BOOL;

PROCEDURE WindowFromDC(hDC : HDC) : HWND;

PROCEDURE GetDC(hWnd : HWND) : HDC;

PROCEDURE GetDCEx(hWnd : HWND;
                  hrgnClip : HRGN;
                  flags : DWORD) : HDC;


CONST
    DCX_WINDOW           = 000000001h;
    DCX_CACHE            = 000000002h;
    DCX_NORESETATTRS     = 000000004h;
    DCX_CLIPCHILDREN     = 000000008h;
    DCX_CLIPSIBLINGS     = 000000010h;
    DCX_PARENTCLIP       = 000000020h;
    DCX_EXCLUDERGN       = 000000040h;
    DCX_INTERSECTRGN     = 000000080h;
    DCX_EXCLUDEUPDATE    = 000000100h;
    DCX_INTERSECTUPDATE  = 000000200h;
    DCX_LOCKWINDOWUPDATE = 000000400h;
    DCX_NORECOMPUTE      = 000100000h;
    DCX_VALIDATE         = 000200000h;

PROCEDURE AlignRects(arc : RECT;
                     cCount : DWORD;
                     iPrimary : DWORD;
                     dwFlags : DWORD) : BOOL;

(*
 AlignRects flags
*)
CONST
    CUDR_NORMAL             =00000h;
    CUDR_NOSNAPTOGRID       =00001h;
    CUDR_NORESOLVEPOSITIONS =00002h;
    CUDR_NOCLOSEGAPS        =00004h;
    CUDR_NEGATIVECOORDS     =00008h;
    CUDR_NOPRIMARY          =00010h;

PROCEDURE GetWindowDC(hWnd : HWND) : HDC;

PROCEDURE ReleaseDC(hWnd : HWND;
                    hDC : HDC) : INTEGER;

PROCEDURE BeginPaint(hWnd : HWND;
                     VAR lpPaint : PAINTSTRUCT) : HDC;

PROCEDURE EndPaint(hWnd : HWND;
                   VAR lpPaint : PAINTSTRUCT) : BOOL;

PROCEDURE GetUpdateRect(hWnd : HWND;
                        VAR LPRect : RECT;
                        bErase : BOOL) : BOOL;

PROCEDURE GetUpdateRgn(hWnd : HWND;
                       hRgn : HRGN;
                       bErase : BOOL) : INTEGER;

PROCEDURE SetWindowRgn(hWnd : HWND;
                       hRgn : HRGN;
                       bRedraw : BOOL) : WINT;

PROCEDURE GetWindowRgn(hWnd : HWND;
                       hRgn : HRGN) : WINT;

PROCEDURE ExcludeUpdateRgn(hDC : HDC;
                           hWnd : HWND) : INTEGER;

PROCEDURE InvalidateRect(hWnd : HWND;
                         lpRect : RECT;
                         bErase : BOOL) : BOOL;

PROCEDURE ValidateRect(hWnd : HWND;
                       lpRect : RECT) : BOOL;

PROCEDURE InvalidateRgn(hWnd : HWND;
                        hRgn : HRGN;
                        bErase : BOOL) : BOOL;

PROCEDURE ValidateRgn(hWnd : HWND;
                      hRgn : HRGN) : BOOL;

PROCEDURE RedrawWindow(hWnd : HWND;
                       lprcUpdate : RECT;
                       hrgnUpdate : HRGN;
                       flags : UINT) : BOOL;


CONST
    RDW_INVALIDATE       = 00001h;
    RDW_INTERNALPAINT    = 00002h;
    RDW_ERASE            = 00004h;
    RDW_VALIDATE         = 00008h;
    RDW_NOINTERNALPAINT  = 00010h;
    RDW_NOERASE          = 00020h;
    RDW_NOCHILDREN       = 00040h;
    RDW_ALLCHILDREN      = 00080h;
    RDW_UPDATENOW        = 00100h;
    RDW_ERASENOW         = 00200h;
    RDW_FRAME            = 00400h;
    RDW_NOFRAME          = 00800h;

PROCEDURE LockWindowUpdate(hWndLock : HWND) : BOOL;

PROCEDURE ScrollWindow(hWnd : HWND;
                       XAmount : INTEGER;
                       YAmount : INTEGER;
                       lpRect : RECT;
                       lpClipRect : RECT) : BOOL;

PROCEDURE ScrollDC(hDC : HDC;
                   dx : INTEGER;
                   dy : INTEGER;
                   lprcScroll : RECT;
                   lprcClip : RECT;
                   hrgnUpdate : HRGN;
                   VAR lprcUpdate : RECT) : BOOL;

PROCEDURE ScrollWindowEx(hWnd : HWND;
                         dx : INTEGER;
                         dy : INTEGER;
                         prcScroll : RECT;
                         prcClip : RECT;
                         hrgnUpdate : HRGN;
                         VAR prcUpdate : RECT;
                         flags : UINT) : INTEGER;


CONST
    SW_SCROLLCHILDREN    = 00001h;
    SW_INVALIDATE        = 00002h;
    SW_ERASE             = 00004h;
%IF WIN5 %THEN
    SW_SMOOTHSCROLL     = 0010h;  (* Use smooth scrolling *)
%END

PROCEDURE SetScrollPos(hWnd : HWND;
                       nBar : INTEGER;
                       nPos : INTEGER;
                       bRedraw : BOOL) : INTEGER;

PROCEDURE GetScrollPos(hWnd : HWND;
                       nBar : INTEGER) : INTEGER;

PROCEDURE SetScrollRange(hWnd : HWND;
                         nBar : INTEGER;
                         nMinPos : INTEGER;
                         nMaxPos : INTEGER;
                         bRedraw : BOOL) : BOOL;

PROCEDURE GetScrollRange(hWnd : HWND;
                         nBar : INTEGER;
                         VAR lpMinPos : WINT;
                         VAR lpMaxPos : WINT) : BOOL;

PROCEDURE ShowScrollBar(hWnd : HWND;
                        wBar : INTEGER;
                        bShow : BOOL) : BOOL;

PROCEDURE EnableScrollBar(hWnd : HWND;
                          wSBflags : UINT;
                          wArrows : UINT) : BOOL;


CONST
    ESB_ENABLE_BOTH      = 00000h;
    ESB_DISABLE_BOTH     = 00003h;
    ESB_DISABLE_LEFT     = 00001h;
    ESB_DISABLE_RIGHT    = 00002h;
    ESB_DISABLE_UP       = 00001h;
    ESB_DISABLE_DOWN     = 00002h;
    ESB_DISABLE_LTUP     = ESB_DISABLE_LEFT;
    ESB_DISABLE_RTDN     = ESB_DISABLE_RIGHT;


PROCEDURE SetPropA(hWnd : HWND;
                   lpString : ARRAY OF ACHAR;
                   hData : HANDLE) : BOOL;

PROCEDURE SetPropW(hWnd : HWND;
                   lpString : ARRAY OF UCHAR;
                   hData : HANDLE) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetProp = SetPropW;
%ELSE
PROCEDURE SetProp = SetPropA;
%END


PROCEDURE GetPropA(hWnd : HWND;
                   lpString : ARRAY OF ACHAR) : HANDLE;

PROCEDURE GetPropW(hWnd : HWND;
                   lpString : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE GetProp = GetPropW;
%ELSE
PROCEDURE GetProp = GetPropA;
%END

PROCEDURE RemovePropA(hWnd : HWND;
                      lpString : ARRAY OF ACHAR) : HANDLE;

PROCEDURE RemovePropW(hWnd : HWND;
                      lpString : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE RemoveProp = RemovePropW;
%ELSE
PROCEDURE RemoveProp = RemovePropA;
%END

PROCEDURE EnumPropsExA(hWnd : HWND;
                       lpEnumFunc : PROPENUMPROCEXA;
                       lParam : LPARAM) : INTEGER;

PROCEDURE EnumPropsExW(hWnd : HWND;
                       lpEnumFunc : PROPENUMPROCEXW;
                       lParam : LPARAM) : INTEGER;

%IF UNICODE %THEN
PROCEDURE EnumPropsEx = EnumPropsExW;
%ELSE
PROCEDURE EnumPropsEx = EnumPropsExA;
%END

PROCEDURE EnumPropsA(hWnd : HWND;
                     lpEnumFunc : PROPENUMPROCA) : INTEGER;

PROCEDURE EnumPropsW(hWnd : HWND;
                     lpEnumFunc : PROPENUMPROCW) : INTEGER;

%IF UNICODE %THEN
PROCEDURE EnumProps = EnumPropsW;
%ELSE
PROCEDURE EnumProps = EnumPropsA;
%END

PROCEDURE SetWindowTextA(hWnd : HWND;
                         lpString : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetWindowTextW(hWnd : HWND;
                         lpString : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetWindowText = SetWindowTextW;
%ELSE
PROCEDURE SetWindowText = SetWindowTextA;
%END

PROCEDURE GetWindowTextA(hWnd : HWND;
                         VAR lpString : ARRAY OF ACHAR;
                         nMaxCount : INTEGER) : INTEGER;

PROCEDURE GetWindowTextW(hWnd : HWND;
                         VAR lpString : ARRAY OF UCHAR;
                         nMaxCount : INTEGER) : INTEGER;

%IF UNICODE %THEN
PROCEDURE GetWindowText = GetWindowTextW;
%ELSE
PROCEDURE GetWindowText = GetWindowTextA;
%END

PROCEDURE GetWindowTextLengthA(hWnd : HWND) : INTEGER;

PROCEDURE GetWindowTextLengthW(hWnd : HWND) : INTEGER;

%IF UNICODE %THEN
PROCEDURE GetWindowTextLength = GetWindowTextLengthW;
%ELSE
PROCEDURE GetWindowTextLength = GetWindowTextLengthA;
%END

PROCEDURE GetClientRect(hWnd : HWND;
                        VAR lpRect : RECT) : BOOL;

PROCEDURE GetWindowRect(hWnd : HWND;
                        VAR lpRect : RECT) : BOOL;

PROCEDURE AdjustWindowRect(VAR lpRect : RECT;
                           dwStyle : DWORD;
                           bMenu : BOOL) : BOOL;

PROCEDURE AdjustWindowRectEx(VAR lpRect : RECT;
                             dwStyle : DWORD;
                             bMenu : BOOL;
                             dwExStyle : DWORD) : BOOL;

CONST
    HELPINFO_WINDOW    = 1;
    HELPINFO_MENUITEM  = 2;

TYPE
    HELPINFO = RECORD
        cbSize  : UINT;
        iContextType: WINT;
        iCtrlId : WINT;
        hItemHandle     : HANDLE;
        dwContextId     : DWORD;
        MousePos        : POINT;
    END;
    LPHELPINFO = POINTER TO HELPINFO;

PROCEDURE SetWindowContextHelpId(a: HWND; b: DWORD) : BOOL;

PROCEDURE GetWindowContextHelpId(a: HWND) : DWORD;

PROCEDURE SetMenuContextHelpId(a: HMENU; b: DWORD) : BOOL;

PROCEDURE GetMenuContextHelpId(a: HMENU) : DWORD;


CONST
    MB_OK                = 000000000h;
    MB_OKCANCEL          = 000000001h;
    MB_ABORTRETRYIGNORE  = 000000002h;
    MB_YESNOCANCEL       = 000000003h;
    MB_YESNO             = 000000004h;
    MB_RETRYCANCEL       = 000000005h;
    MB_ICONHAND          = 000000010h;
    MB_ICONSTOP          = MB_ICONHAND;
    MB_ICONQUESTION      = 000000020h;
    MB_ICONEXCLAMATION   = 000000030h;
    MB_ICONASTERISK      = 000000040h;

    MB_ICONWARNING       = MB_ICONEXCLAMATION;
    MB_ICONERROR         = MB_ICONHAND;

    MB_ICONINFORMATION   = MB_ICONASTERISK;

    MB_DEFBUTTON1        = 000000000h;
    MB_DEFBUTTON2        = 000000100h;
    MB_DEFBUTTON3        = 000000200h;
    MB_DEFBUTTON4        = 000000300h;(*95*)

    MB_APPLMODAL         = 000000000h;
    MB_SYSTEMMODAL       = 000001000h;
    MB_TASKMODAL         = 000002000h;

    MB_HELP              = 000004000h;
    MB_RIGHT             = 000080000h;
    MB_RTLREADING        = 000100000h;


    MB_NOFOCUS                  = 000008000h;
    MB_SETFOREGROUND            = 000010000h;
    MB_DEFAULT_DESKTOP_ONLY     = 000020000h;
    MB_TOPMOST                  = 000040000h;

    MB_SERVICE_NOTIFICATION     = 00200000h;(*NT*)
    MB_SERVICE_NOTIFICATION_NT3X= 00040000h;(*NT*)

    MB_TYPEMASK          = 00000000Fh;
    MB_USERICON          = 000000080h;(*95*)

    MB_ICONMASK          = 0000000F0h;
    MB_DEFMASK           = 000000F00h;
    MB_MODEMASK          = 000003000h;
    MB_MISCMASK          = 00000C000h;

PROCEDURE MessageBoxA(hWnd : HWND;
                      lpText : ARRAY OF ACHAR;
                      lpCaption : ARRAY OF ACHAR;
                      uType : UINT) : INTEGER;

PROCEDURE MessageBoxW(hWnd : HWND;
                      lpText : ARRAY OF UCHAR;
                      lpCaption : ARRAY OF UCHAR;
                      uType : UINT) : INTEGER;

%IF UNICODE %THEN
PROCEDURE MessageBox = MessageBoxW;
%ELSE
PROCEDURE MessageBox = MessageBoxA;
%END

PROCEDURE MessageBoxExA(hWnd : HWND;
                        lpText : ARRAY OF ACHAR;
                        lpCaption : ARRAY OF ACHAR;
                        uType : UINT;
                        wLanguageId : WORD) : INTEGER;

PROCEDURE MessageBoxExW(hWnd : HWND;
                        lpText : ARRAY OF UCHAR;
                        lpCaption : ARRAY OF UCHAR;
                        uType : UINT;
                        wLanguageId : WORD) : INTEGER;

%IF UNICODE %THEN
PROCEDURE MessageBoxEx = MessageBoxExW;
%ELSE
PROCEDURE MessageBoxEx = MessageBoxExA;
%END

TYPE
    MSGBOXCALLBACK      = PROCEDURE(VAR HELPINFO) [EXPORT];

    MSGBOXPARAMSA = RECORD
        cbSize          : UINT;
        hwndOwner       : HWND;
        hInstance       : HINSTANCE;
        lpszText        : LPCSTR;
        lpszCaption     : LPCSTR;
        dwStyle         : DWORD;
        lpszIcon        : LPCSTR;
        dwContextHelpId : DWORD;
        lpfnMsgBoxCallback : MSGBOXCALLBACK;
        dwLanguageId    : DWORD;
    END;
    PMSGBOXPARAMSA   = POINTER TO MSGBOXPARAMSA;
    LPMSGBOXPARAMSA  = PMSGBOXPARAMSA;

    MSGBOXPARAMSW = RECORD
        cbSize          : UINT;
        hwndOwner       : HWND;
        hInstance       : HINSTANCE;
        lpszText        : LPCWSTR;
        lpszCaption     : LPCWSTR;
        dwStyle         : DWORD;
        lpszIcon        : LPCWSTR;
        dwContextHelpId : DWORD;
        lpfnMsgBoxCallback : MSGBOXCALLBACK;
        dwLanguageId    : DWORD;
    END;
    PMSGBOXPARAMSW   = POINTER TO MSGBOXPARAMSW;
    LPMSGBOXPARAMSW  = PMSGBOXPARAMSW;

%IF UNICODE %THEN
    MSGBOXPARAMS   = MSGBOXPARAMSW;
    PMSGBOXPARAMS   = PMSGBOXPARAMSW;
%ELSE
    MSGBOXPARAMS   = MSGBOXPARAMSA;
    PMSGBOXPARAMS   = PMSGBOXPARAMSA;
%END
    LPMSGBOXPARAMS  = PMSGBOXPARAMS;

PROCEDURE MessageBoxIndirectA(VAR a: MSGBOXPARAMSA) : WINT;

PROCEDURE MessageBoxIndirectW(VAR a: MSGBOXPARAMSW) : WINT;

%IF UNICODE %THEN
PROCEDURE MessageBoxIndirect = MessageBoxIndirectW;
%ELSE
PROCEDURE MessageBoxIndirect = MessageBoxIndirectA;
%END

PROCEDURE MessageBeep(uType : UINT) : BOOL;

PROCEDURE ShowCursor(bShow : BOOL) : INTEGER;

PROCEDURE SetCursorPos(X : INTEGER;
                       Y : INTEGER) : BOOL;

PROCEDURE SetCursor(hCursor : HCURSOR) : HCURSOR;

PROCEDURE GetCursorPos(VAR lpPoint : POINT) : BOOL;

PROCEDURE ClipCursor(lpRect : RECT) : BOOL;

PROCEDURE GetClipCursor(VAR lpRect : RECT) : BOOL;

PROCEDURE GetCursor() : HCURSOR;

PROCEDURE CreateCaret(hWnd : HWND;
                      hBitmap : HBITMAP;
                      nWidth : INTEGER;
                      nHeight : INTEGER) : BOOL;

PROCEDURE GetCaretBlinkTime() : UINT;

PROCEDURE SetCaretBlinkTime(uMSeconds : UINT) : BOOL;

PROCEDURE DestroyCaret() : BOOL;

PROCEDURE HideCaret(hWnd : HWND) : BOOL;

PROCEDURE ShowCaret(hWnd : HWND) : BOOL;

PROCEDURE SetCaretPos(X : INTEGER;
                      Y : INTEGER) : BOOL;

PROCEDURE GetCaretPos(VAR lpPoint : POINT) : BOOL;

PROCEDURE ClientToScreen(hWnd : HWND;
                         VAR lpPoint : POINT) : BOOL;

PROCEDURE ScreenToClient(hWnd : HWND;
                         VAR lpPoint : POINT) : BOOL;

PROCEDURE MapWindowPoints(hWndFrom : HWND;
                          hWndTo : HWND;
                          VAR lpPoints : ARRAY OF POINT;
                          cPoints : UINT) : INTEGER;

PROCEDURE WindowFromPoint(Point : VALUE POINT) : HWND;

PROCEDURE ChildWindowFromPoint(hWndParent : HWND;
                               Point : VALUE POINT) : HWND;


CONST
    CWP_ALL             = 0000h;
    CWP_SKIPINVISIBLE   = 0001h;
    CWP_SKIPDISABLED    = 0002h;
    CWP_SKIPTRANSPARENT = 0004h;

PROCEDURE ChildWindowFromPointEx(a: HWND; b: VALUE POINT; c: UINT) : HWND;




CONST
    CTLCOLOR_MSGBOX      = 0;
    CTLCOLOR_EDIT        = 1;
    CTLCOLOR_LISTBOX     = 2;
    CTLCOLOR_BTN         = 3;
    CTLCOLOR_DLG         = 4;
    CTLCOLOR_SCROLLBAR   = 5;
    CTLCOLOR_STATIC      = 6;
    CTLCOLOR_MAX         = 8;

    COLOR_SCROLLBAR      = 0;
    COLOR_BACKGROUND     = 1;
    COLOR_ACTIVECAPTION  = 2;
    COLOR_INACTIVECAPTION= 3;
    COLOR_MENU           = 4;
    COLOR_WINDOW         = 5;
    COLOR_WINDOWFRAME    = 6;
    COLOR_MENUTEXT       = 7;
    COLOR_WINDOWTEXT     = 8;
    COLOR_CAPTIONTEXT    = 9;
    COLOR_ACTIVEBORDER   = 10;
    COLOR_INACTIVEBORDER = 11;
    COLOR_APPWORKSPACE   = 12;
    COLOR_HIGHLIGHT      = 13;
    COLOR_HIGHLIGHTTEXT  = 14;
    COLOR_BTNFACE        = 15;
    COLOR_BTNSHADOW      = 16;
    COLOR_GRAYTEXT       = 17;
    COLOR_BTNTEXT        = 18;
    COLOR_INACTIVECAPTIONTEXT= 19;
    COLOR_BTNHIGHLIGHT   = 20;

    COLOR_3DDKSHADOW        = 21;
    COLOR_3DLIGHT           = 22;
    COLOR_INFOTEXT          = 23;
    COLOR_INFOBK            = 24;

%IF WIN5 %THEN
    COLOR_HOTLIGHT                  =26;
    COLOR_GRADIENTACTIVECAPTION     =27;
    COLOR_GRADIENTINACTIVECAPTION   =28;
%END

    COLOR_DESKTOP           = COLOR_BACKGROUND;
    COLOR_3DFACE            = COLOR_BTNFACE;
    COLOR_3DSHADOW          = COLOR_BTNSHADOW;
    COLOR_3DHIGHLIGHT       = COLOR_BTNHIGHLIGHT;
    COLOR_3DHILIGHT         = COLOR_BTNHIGHLIGHT;
    COLOR_BTNHILIGHT        = COLOR_BTNHIGHLIGHT;


PROCEDURE GetSysColor(nIndex : INTEGER) : DWORD;


PROCEDURE GetSysColorBrush(nIndex : WINT) : HBRUSH;


PROCEDURE SetSysColors(cElements : INTEGER;
                       lpaElements : ARRAY OF WINT;
                       lpaRgbValues : ARRAY OF COLORREF) : BOOL;

PROCEDURE DrawFocusRect(hDC : HDC;
                        lprc : RECT) : BOOL;

PROCEDURE FillRect(hDC : HDC;
                   lprc : RECT;
                   hbr : HBRUSH) : INTEGER;

PROCEDURE FrameRect(hDC : HDC;
                    lprc : RECT;
                    hbr : HBRUSH) : INTEGER;

PROCEDURE InvertRect(hDC : HDC;
                     lprc : RECT) : BOOL;

PROCEDURE SetRect(VAR lprc : RECT;
                  xLeft : INTEGER;
                  yTop : INTEGER;
                  xRight : INTEGER;
                  yBottom : INTEGER) : BOOL;

PROCEDURE SetRectEmpty(VAR lprc : RECT) : BOOL;

PROCEDURE CopyRect(VAR LPRCDST : RECT;
                   lprcSrc : RECT) : BOOL;

PROCEDURE InflateRect(VAR lprc : RECT;
                      dx : INTEGER;
                      dy : INTEGER) : BOOL;

PROCEDURE IntersectRect(VAR lprcDst : RECT;
                        lprcSrc1 : RECT;
                        lprcSrc2 : RECT) : BOOL;

PROCEDURE UnionRect(VAR lprcDst : RECT;
                    lprcSrc1 : RECT;
                    lprcSrc2 : RECT) : BOOL;

PROCEDURE SubtractRect(VAR lprcDst : RECT;
                       lprcSrc1 : RECT;
                       lprcSrc2 : RECT) : BOOL;

PROCEDURE OffsetRect(VAR lprc : RECT;
                     dx : INTEGER;
                     dy : INTEGER) : BOOL;

PROCEDURE IsRectEmpty(lprc : RECT) : BOOL;

PROCEDURE EqualRect(lprc1 : RECT;
                    lprc2 : RECT) : BOOL;

PROCEDURE PtInRect(lprc : RECT;
                   pt : VALUE POINT) : BOOL;

PROCEDURE GetWindowWord(hWnd : HWND;
                        nIndex : INTEGER) : WORD;

PROCEDURE SetWindowWord(hWnd : HWND;
                        nIndex : INTEGER;
                        wNewWord : WORD) : WORD;

PROCEDURE GetWindowLongA(hWnd : HWND;
                         nIndex : INTEGER) : LONG;

PROCEDURE GetWindowLongW(hWnd : HWND;
                         nIndex : INTEGER) : LONG;

%IF UNICODE %THEN
PROCEDURE GetWindowLong = GetWindowLongW;
%ELSE
PROCEDURE GetWindowLong = GetWindowLongA;
%END

PROCEDURE SetWindowLongA(hWnd : HWND;
                         nIndex : INTEGER;
                         dwNewLong : LONG) : LONG;

PROCEDURE SetWindowLongW(hWnd : HWND;
                         nIndex : INTEGER;
                         dwNewLong : LONG) : LONG;

%IF UNICODE %THEN
PROCEDURE SetWindowLong = SetWindowLongW;
%ELSE
PROCEDURE SetWindowLong = SetWindowLongA;
%END

PROCEDURE GetClassWord(hWnd : HWND;
                       nIndex : INTEGER) : WORD;

PROCEDURE SetClassWord(hWnd : HWND;
                       nIndex : INTEGER;
                       wNewWord : WORD) : WORD;

PROCEDURE GetClassLongA(hWnd : HWND;
                        nIndex : INTEGER) : DWORD;

PROCEDURE GetClassLongW(hWnd : HWND;
                        nIndex : INTEGER) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetClassLong = GetClassLongW;
%ELSE
PROCEDURE GetClassLong = GetClassLongA;
%END

PROCEDURE SetClassLongA(hWnd : HWND;
                        nIndex : INTEGER;
                        dwNewLong : LONG) : DWORD;

PROCEDURE SetClassLongW(hWnd : HWND;
                        nIndex : INTEGER;
                        dwNewLong : LONG) : DWORD;

%IF UNICODE %THEN
PROCEDURE SetClassLong = SetClassLongW;
%ELSE
PROCEDURE SetClassLong = SetClassLongA;
%END

PROCEDURE GetDesktopWindow() : HWND;

PROCEDURE GetParent(hWnd : HWND) : HWND;

PROCEDURE SetParent(hWndChild : HWND;
                    hWndNewParent : HWND) : HWND;

PROCEDURE EnumChildWindows(hWndParent : HWND;
                           lpEnumFunc : WNDENUMPROC;
                           lParam : LPARAM) : BOOL;

PROCEDURE FindWindowA(lpClassName : ARRAY OF ACHAR;
                      lpWindowName : ARRAY OF ACHAR) : HWND;

PROCEDURE FindWindowW(lpClassName : ARRAY OF UCHAR;
                      lpWindowName : ARRAY OF UCHAR) : HWND;

%IF UNICODE %THEN
PROCEDURE FindWindow = FindWindowW;
%ELSE
PROCEDURE FindWindow = FindWindowA;
%END

PROCEDURE FindWindowExA(a: HWND;
                        b: HWND;
                        c: ARRAY OF ACHAR;
                        d: ARRAY OF ACHAR) : HWND;

PROCEDURE FindWindowExW(a: HWND;
                        b: HWND;
                        c: ARRAY OF UCHAR;
                        d: ARRAY OF UCHAR) : HWND;

%IF UNICODE %THEN
PROCEDURE FindWindowEx = FindWindowExW;
%ELSE
PROCEDURE FindWindowEx = FindWindowExA;
%END


PROCEDURE EnumWindows(lpEnumFunc : WNDENUMPROC;
                      lParam : LPARAM) : BOOL;

PROCEDURE EnumThreadWindows(dwThreadId : DWORD;
                            lpfn : WNDENUMPROC;
                            lParam : LPARAM) : BOOL;

PROCEDURE GetClassNameA(hWnd : HWND;
                        VAR lpClassName : ARRAY OF ACHAR;
                        nMaxCount : INTEGER) : INTEGER;

PROCEDURE GetClassNameW(hWnd : HWND;
                        VAR lpClassName : ARRAY OF UCHAR;
                        nMaxCount : INTEGER) : INTEGER;

%IF UNICODE %THEN
PROCEDURE GetClassName = GetClassNameW;
%ELSE
PROCEDURE GetClassName = GetClassNameA;
%END

PROCEDURE GetTopWindow(hWnd : HWND) : HWND;


PROCEDURE GetWindowThreadProcessId(hWnd : HWND;
                                   VAR lpdwProcessId : DWORD) : DWORD;

PROCEDURE GetLastActivePopup(hWnd : HWND) : HWND;


CONST
    GW_HWNDFIRST         = 0;
    GW_HWNDLAST          = 1;
    GW_HWNDNEXT          = 2;
    GW_HWNDPREV          = 3;
    GW_OWNER             = 4;
    GW_CHILD             = 5;
%IF WIN5 %THEN
    GW_ENABLEDPOPUP      = 6;
    GW_MAX               = 6;
%ELSE
    GW_MAX               = 5;
%END

PROCEDURE GetWindow(hWnd : HWND;
                    uCmd : UINT) : HWND;

PROCEDURE SetWindowsHookA(nFilterType : INTEGER;
                          pfnFilterProc : HOOKPROC) : HHOOK;

PROCEDURE SetWindowsHookW(nFilterType : INTEGER;
                          pfnFilterProc : HOOKPROC) : HHOOK;

%IF UNICODE %THEN
PROCEDURE SetWindowsHook = SetWindowsHookW;
%ELSE
PROCEDURE SetWindowsHook = SetWindowsHookA;
%END

PROCEDURE UnhookWindowsHook(nCode : INTEGER;
                            pfnFilterProc : HOOKPROC) : BOOL;

PROCEDURE SetWindowsHookExA(idHook : INTEGER;
                            lpfn : HOOKPROC;
                            hmod : HINSTANCE;
                            dwThreadId : DWORD) : HHOOK;

PROCEDURE SetWindowsHookExW(idHook : INTEGER;
                            lpfn : HOOKPROC;
                            hmod : HINSTANCE;
                            dwThreadId : DWORD) : HHOOK;

%IF UNICODE %THEN
PROCEDURE SetWindowsHookEx = SetWindowsHookExW;
%ELSE
PROCEDURE SetWindowsHookEx = SetWindowsHookExA;
%END

PROCEDURE UnhookWindowsHookEx(hhk : HHOOK) : BOOL;

PROCEDURE CallNextHookEx(hhk : HHOOK;
                         nCode : INTEGER;
                         wParam : WPARAM;
                         lParam : LPARAM) : LRESULT;

CONST
    MF_INSERT            = 000000000h;
    MF_CHANGE            = 000000080h;
    MF_APPEND            = 000000100h;
    MF_DELETE            = 000000200h;
    MF_REMOVE            = 000001000h;
    MF_BYCOMMAND         = 000000000h;
    MF_BYPOSITION        = 000000400h;
    MF_SEPARATOR         = 000000800h;
    MF_ENABLED           = 000000000h;
    MF_GRAYED            = 000000001h;
    MF_DISABLED          = 000000002h;
    MF_UNCHECKED         = 000000000h;
    MF_CHECKED           = 000000008h;
    MF_USECHECKBITMAPS   = 000000200h;
    MF_STRING            = 000000000h;
    MF_BITMAP            = 000000004h;
    MF_OWNERDRAW         = 000000100h;
    MF_POPUP             = 000000010h;
    MF_MENUBARBREAK      = 000000020h;
    MF_MENUBREAK         = 000000040h;
    MF_UNHILITE          = 000000000h;
    MF_HILITE            = 000000080h;
    MF_SYSMENU           = 000002000h;
    MF_HELP              = 000004000h;
    MF_MOUSESELECT       = 000008000h;

    MF_DEFAULT           = 000001000h;
    MF_RIGHTJUSTIFY      = 000004000h;
    MF_END               = 000000080h;

    MFT_STRING           = MF_STRING;
    MFT_BITMAP           = MF_BITMAP;
    MFT_MENUBARBREAK     = MF_MENUBARBREAK;
    MFT_MENUBREAK        = MF_MENUBREAK;
    MFT_OWNERDRAW        = MF_OWNERDRAW;
    MFT_RADIOCHECK       = 000000200h;
    MFT_SEPARATOR        = MF_SEPARATOR;
    MFT_RIGHTORDER       = 000002000h;
    MFT_RIGHTJUSTIFY     = MF_RIGHTJUSTIFY;

    MFS_GRAYED           = 000000003h;
    MFS_DISABLED         = MFS_GRAYED;
    MFS_CHECKED          = MF_CHECKED;
    MFS_HILITE           = MF_HILITE;
    MFS_ENABLED          = MF_ENABLED;
    MFS_UNCHECKED        = MF_UNCHECKED;
    MFS_UNHILITE         = MF_UNHILITE;
    MFS_DEFAULT          = MF_DEFAULT;

%IF WIN5 %THEN
    MFS_MASK            = 0000108Bh;
    MFS_HOTTRACKDRAWN   = 10000000h;
    MFS_CACHEDBMP       = 20000000h;
    MFS_BOTTOMGAPDROP   = 40000000h;
    MFS_TOPGAPDROP      = 80000000h;
    MFS_GAPDROP         = 0C0000000h;
%ELSE
%END

    MFR_POPUP            = 1h;
    MFR_END              = MF_END;

PROCEDURE CheckMenuRadioItem(a: HMENU;
                             b: UINT;
                             c: UINT;
                             d: UINT;
                             e: UINT) : BOOL;



TYPE
    MENUITEMTEMPLATEHEADER = RECORD
          versionNumber  : WORD;
          offset         : WORD;
    END;
    PMENUITEMTEMPLATEHEADER     = POINTER TO MENUITEMTEMPLATEHEADER;

    MENUITEMTEMPLATE = RECORD
          mtOption       : WORD;
          mtID           : WORD;
          mtString       : ARRAY [0..1 - 1] OF WCHAR;
    END;
    PMENUITEMTEMPLATE   = POINTER TO MENUITEMTEMPLATE;

CONST
    SC_SIZE              = 0F000h;
    SC_MOVE              = 0F010h;
    SC_MINIMIZE          = 0F020h;
    SC_MAXIMIZE          = 0F030h;
    SC_NEXTWINDOW        = 0F040h;
    SC_PREVWINDOW        = 0F050h;
    SC_CLOSE             = 0F060h;
    SC_VSCROLL           = 0F070h;
    SC_HSCROLL           = 0F080h;
    SC_MOUSEMENU         = 0F090h;
    SC_KEYMENU           = 0F100h;
    SC_ARRANGE           = 0F110h;
    SC_RESTORE           = 0F120h;
    SC_TASKLIST          = 0F130h;
    SC_SCREENSAVE        = 0F140h;
    SC_HOTKEY            = 0F150h;


    SC_DEFAULT           = 0F160h;
    SC_MONITORPOWER      = 0F170h;
    SC_CONTEXTHELP       = 0F180h;
    SC_SEPARATOR         = 0F00Fh;
    SC_ICON              = SC_MINIMIZE;
    SC_ZOOM              = SC_MAXIMIZE;


PROCEDURE LoadBitmapA(a : HINSTANCE;
                      lpBitmapName : ARRAY OF ACHAR) : HBITMAP;

PROCEDURE LoadBitmapW(a : HINSTANCE;
                      lpBitmapName : ARRAY OF UCHAR) : HBITMAP;

%IF UNICODE %THEN
PROCEDURE LoadBitmap = LoadBitmapW;
%ELSE
PROCEDURE LoadBitmap = LoadBitmapA;
%END

PROCEDURE LoadCursorA(a : HINSTANCE;
                      lpCursorName : ARRAY OF ACHAR) : HCURSOR;

PROCEDURE LoadCursorW(a : HINSTANCE;
                      lpCursorName : ARRAY OF UCHAR) : HCURSOR;

%IF UNICODE %THEN
PROCEDURE LoadCursor = LoadCursorW;
%ELSE
PROCEDURE LoadCursor = LoadCursorA;
%END


PROCEDURE LoadCursorFromFileA(lpFileName : ARRAY OF ACHAR) : HCURSOR;

PROCEDURE LoadCursorFromFileW(lpFileName : ARRAY OF UCHAR) : HCURSOR;

%IF UNICODE %THEN
PROCEDURE LoadCursorFromFile = LoadCursorFromFileW;
%ELSE
PROCEDURE LoadCursorFromFile = LoadCursorFromFileA;
%END



PROCEDURE CreateCursor(hInst : HINSTANCE;
                       xHotSpot : INTEGER;
                       yHotSpot : INTEGER;
                       nWidth : INTEGER;
                       nHeight : INTEGER;
                       pvANDPlane : LPVOID;
                       pvXORPlane : LPVOID) : HCURSOR;

PROCEDURE DestroyCursor(hCursor : HCURSOR) : BOOL;

CONST
    IDC_ARROW           = CAST(LPTSTR, 32512);
    IDC_IBEAM           = CAST(LPTSTR, 32513);
    IDC_WAIT            = CAST(LPTSTR, 32514);
    IDC_CROSS           = CAST(LPTSTR, 32515);
    IDC_UPARROW         = CAST(LPTSTR, 32516);
    (* Fixed wrong #'s*)
    IDC_SIZE            = CAST(LPTSTR, 32640);
    IDC_ICON            = CAST(LPTSTR, 32641);
    IDC_SIZENWSE        = CAST(LPTSTR, 32642);
    IDC_SIZENESW        = CAST(LPTSTR, 32643);
    IDC_SIZEWE          = CAST(LPTSTR, 32644);
    IDC_SIZENS          = CAST(LPTSTR, 32645);
    IDC_SIZEALL         = CAST(LPTSTR, 32646);
    IDC_NO              = CAST(LPTSTR, 32648);
    IDC_APPSTARTING     = CAST(LPTSTR, 32650);
    IDC_HELP            = CAST(LPTSTR, 32651);

%IF WIN5 %THEN
    IDC_HAND            = CAST(LPTSTR, 32649);
%END

(*95*)
PROCEDURE SetSystemCursor(
                            hcur : HCURSOR;
                            id : DWORD) : BOOL;

TYPE
    ICONINFO = RECORD
          fIcon          : BOOL;
          xHotspot       : DWORD;
          yHotspot       : DWORD;
          hbmMask        : HBITMAP;
          hbmColor       : HBITMAP;
    END;
    PICONINFO            = POINTER TO ICONINFO;

PROCEDURE LoadIconA(a : HINSTANCE;
                    lpIconName : ARRAY OF ACHAR) : HICON;

PROCEDURE LoadIconW(a : HINSTANCE;
                    lpIconName : ARRAY OF UCHAR) : HICON;

%IF UNICODE %THEN
PROCEDURE LoadIcon = LoadIconW;
%ELSE
PROCEDURE LoadIcon = LoadIconA;
%END

PROCEDURE CreateIcon(a : HINSTANCE;
                     nWidth : INTEGER;
                     nHeight : INTEGER;
                     cPlanes : BYTE;
                     cBitsPixel : BYTE;
                     lpbANDbits : LPVOID;
                     lpbXORbits : LPVOID) : HICON;

PROCEDURE DestroyIcon(hIcon : HICON) : BOOL;

PROCEDURE LookupIconIdFromDirectory(presbits : PBYTE;
                                    fIcon : BOOL) : INTEGER;


PROCEDURE LookupIconIdFromDirectoryEx(presbits : PBYTE;
                                      fIcon : BOOL;
                                      cxDesired : WINT;
                                      cyDesired : WINT;
                                      Flags : UINT) : WINT;

PROCEDURE CreateIconFromResource(presbits : PBYTE;
                                 dwResSize : DWORD;
                                 fIcon : BOOL;
                                 dwVer : DWORD) : HICON;

PROCEDURE CreateIconFromResourceEx(presbits : PBYTE;
                                   dwResSize : DWORD;
                                   fIcon : BOOL;
                                   dwVer : DWORD;
                                   cxDesired : WINT;
                                   cyDesired : WINT;
                                   Flags : UINT) : HICON;

TYPE
    CURSORSHAPE = RECORD
        xHotSpot        : WINT;
        yHotSpot        : WINT;
        cx              : WINT;
        cy              : WINT;
        cbWidth         : WINT;
        Planes          : BYTE;
        BitsPixel       : BYTE;
    END;
    LPCURSORSHAPE       = POINTER TO CURSORSHAPE;

CONST
    IMAGE_BITMAP        = 0;
    IMAGE_ICON          = 1;
    IMAGE_CURSOR        = 2;
    IMAGE_ENHMETAFILE   = 3;

    LR_DEFAULTCOLOR     = 0000h;
    LR_MONOCHROME       = 0001h;
    LR_COLOR            = 0002h;
    LR_COPYRETURNORG    = 0004h;
    LR_COPYDELETEORG    = 0008h;
    LR_LOADFROMFILE     = 0010h;
    LR_LOADTRANSPARENT  = 0020h;
    LR_DEFAULTSIZE      = 0040h;
    LR_LOADREALSIZE     = 0080h;
    LR_LOADMAP3DCOLORS  = 1000h;
    LR_CREATEDIBSECTION = 2000h;
    LR_VGACOLOR         = 0080h;
    LR_COPYFROMRESOURCE = 4000h;
    LR_SHARED           = 8000h;

PROCEDURE LoadImageA(
        a: HINSTANCE;
        b: ARRAY OF ACHAR;
        c: UINT;
        d: WINT;
        e: WINT;
        f: UINT) : HANDLE;

PROCEDURE LoadImageW(
        a: HINSTANCE;
        b: ARRAY OF UCHAR;
        c: UINT;
        d: WINT;
        e: WINT;
        f: UINT) : HANDLE;

%IF UNICODE %THEN
PROCEDURE LoadImage = LoadImageW;
%ELSE
PROCEDURE LoadImage = LoadImageA;
%END

PROCEDURE CopyImage(a: HANDLE;
                    b: UINT;
                    c: WINT;
                    d: WINT;
                    e: UINT) : HICON;

CONST
    DI_MASK         = 0001h;
    DI_IMAGE        = 0002h;
    DI_NORMAL       = 0003h;
    DI_COMPAT       = 0004h;
    DI_DEFAULTSIZE  = 0008h;

PROCEDURE DrawIconEx(hdc : HDC;
                     xLeft : WINT;
                     yTop : WINT;
                     hIcon : HICON;
                     cxWidth : WINT;
                     cyWidth : WINT;
                     istepIfAniCur : UINT;
                     hbrFlickerFreeDraw : HBRUSH;
                     diFlags : UINT) : BOOL;



PROCEDURE CreateIconIndirect(piconinfo : PICONINFO) : HICON;

PROCEDURE CopyIcon(hIcon : HICON) : HICON;

PROCEDURE GetIconInfo(hIcon : HICON;
                      piconinfo : PICONINFO) : BOOL;


CONST

    RES_ICON             = 1;
    RES_CURSOR           = 2;


    OBM_CLOSE            = 32754;
    OBM_UPARROW          = 32753;
    OBM_DNARROW          = 32752;
    OBM_RGARROW          = 32751;
    OBM_LFARROW          = 32750;
    OBM_REDUCE           = 32749;
    OBM_ZOOM             = 32748;
    OBM_RESTORE          = 32747;
    OBM_REDUCED          = 32746;
    OBM_ZOOMD            = 32745;
    OBM_RESTORED         = 32744;
    OBM_UPARROWD         = 32743;
    OBM_DNARROWD         = 32742;
    OBM_RGARROWD         = 32741;
    OBM_LFARROWD         = 32740;
    OBM_MNARROW          = 32739;
    OBM_COMBO            = 32738;
    OBM_UPARROWI         = 32737;
    OBM_DNARROWI         = 32736;
    OBM_RGARROWI         = 32735;
    OBM_LFARROWI         = 32734;
    OBM_OLD_CLOSE        = 32767;
    OBM_SIZE             = 32766;
    OBM_OLD_UPARROW      = 32765;
    OBM_OLD_DNARROW      = 32764;
    OBM_OLD_RGARROW      = 32763;
    OBM_OLD_LFARROW      = 32762;
    OBM_BTSIZE           = 32761;
    OBM_CHECK            = 32760;
    OBM_CHECKBOXES       = 32759;
    OBM_BTNCORNERS       = 32758;
    OBM_OLD_REDUCE       = 32757;
    OBM_OLD_ZOOM         = 32756;
    OBM_OLD_RESTORE      = 32755;

    OCR_NORMAL           = 32512;
    OCR_IBEAM            = 32513;
    OCR_WAIT             = 32514;
    OCR_CROSS            = 32515;
    OCR_UP               = 32516;
    OCR_SIZE             = 32640;
    OCR_ICON             = 32641;
    OCR_SIZENWSE         = 32642;
    OCR_SIZENESW         = 32643;
    OCR_SIZEWE           = 32644;
    OCR_SIZENS           = 32645;
    OCR_SIZEALL          = 32646;
    OCR_ICOCUR           = 32647;
    OCR_NO               = 32648;
    OCR_APPSTARTING      = 32650;
%IF WIN5 %THEN
    OCR_HAND             = 32649;
%END

    OIC_SAMPLE           = 32512;
    OIC_HAND             = 32513;
    OIC_QUES             = 32514;
    OIC_BANG             = 32515;
    OIC_NOTE             = 32516;

    OIC_WINLOGO          = 32517;
    OIC_WARNING          = OIC_BANG;
    OIC_ERROR            = OIC_HAND;
    OIC_INFORMATION      = OIC_NOTE;


    ORD_LANGDRIVER       = 1;

    IDI_APPLICATION             = CAST(LPTSTR, 32512);
    IDI_HAND                    = CAST(LPTSTR, 32513);
    IDI_QUESTION                = CAST(LPTSTR, 32514);
    IDI_EXCLAMATION             = CAST(LPTSTR, 32515);
    IDI_ASTERISK                = CAST(LPTSTR, 32516);
    IDI_WINLOGO                 = CAST(LPTSTR, 32517);(*95*)


    IDI_WARNING                 = IDI_EXCLAMATION;
    IDI_ERROR                   = IDI_HAND;
    IDI_INFORMATION             = IDI_ASTERISK;


PROCEDURE LoadStringA(a : HINSTANCE;
                      uID : UINT;
                      VAR lpBuffer : ARRAY OF ACHAR;
                      nBufferMax : INTEGER) : INTEGER;

PROCEDURE LoadStringW(a : HINSTANCE;
                      uID : UINT;
                      VAR lpBuffer : ARRAY OF UCHAR;
                      nBufferMax : INTEGER) : INTEGER;

%IF UNICODE %THEN
PROCEDURE LoadString = LoadStringW;
%ELSE
PROCEDURE LoadString = LoadStringA;
%END

CONST
    IDOK                 = 1;
    IDCANCEL             = 2;
    IDABORT              = 3;
    IDRETRY              = 4;
    IDIGNORE             = 5;
    IDYES                = 6;
    IDNO                 = 7;

    IDCLOSE              = 8;
    IDHELP               = 9;


    ES_LEFT              = 00000h;
    ES_CENTER            = 00001h;
    ES_RIGHT             = 00002h;
    ES_MULTILINE         = 00004h;
    ES_UPPERCASE         = 00008h;
    ES_LOWERCASE         = 00010h;
    ES_PASSWORD          = 00020h;
    ES_AUTOVSCROLL       = 00040h;
    ES_AUTOHSCROLL       = 00080h;
    ES_NOHIDESEL         = 00100h;
    ES_OEMCONVERT        = 00400h;
    ES_READONLY          = 00800h;
    ES_WANTRETURN        = 01000h;
    ES_NUMBER            = 02000h;(*95*)

    EN_SETFOCUS          = 00100h;
    EN_KILLFOCUS         = 00200h;
    EN_CHANGE            = 00300h;
    EN_UPDATE            = 00400h;
    EN_ERRSPACE          = 00500h;
    EN_MAXTEXT           = 00501h;
    EN_HSCROLL           = 00601h;
    EN_VSCROLL           = 00602h;


    EC_LEFTMARGIN        = 00001h;
    EC_RIGHTMARGIN       = 00002h;
    EC_USEFONTINFO       = 0ffffh;

%IF WIN5 %THEN
(* wParam of EM_GET/SETIMESTATUS  *)
    EMSIS_COMPOSITIONSTRING        = 0001h;

(* lParam for EMSIS_COMPOSITIONSTRING  *)
    EIMES_GETCOMPSTRATONCE         = 0001h;
    EIMES_CANCELCOMPSTRINFOCUS     = 0002h;
    EIMES_COMPLETECOMPSTRKILLFOCUS = 0004h;
%END

    EM_GETSEL            = 000B0h;
    EM_SETSEL            = 000B1h;
    EM_GETRECT           = 000B2h;
    EM_SETRECT           = 000B3h;
    EM_SETRECTNP         = 000B4h;
    EM_SCROLL            = 000B5h;
    EM_LINESCROLL        = 000B6h;
    EM_SCROLLCARET       = 000B7h;
    EM_GETMODIFY         = 000B8h;
    EM_SETMODIFY         = 000B9h;
    EM_GETLINECOUNT      = 000BAh;
    EM_LINEINDEX         = 000BBh;
    EM_SETHANDLE         = 000BCh;
    EM_GETHANDLE         = 000BDh;
    EM_GETTHUMB          = 000BEh;
    EM_LINELENGTH        = 000C1h;
    EM_REPLACESEL        = 000C2h;
    EM_GETLINE           = 000C4h;
    EM_LIMITTEXT         = 000C5h;
    EM_CANUNDO           = 000C6h;
    EM_UNDO              = 000C7h;
    EM_FMTLINES          = 000C8h;
    EM_LINEFROMCHAR      = 000C9h;
    EM_SETTABSTOPS       = 000CBh;
    EM_SETPASSWORDCHAR   = 000CCh;
    EM_EMPTYUNDOBUFFER   = 000CDh;
    EM_GETFIRSTVISIBLELINE= 000CEh;
    EM_SETREADONLY       = 000CFh;
    EM_SETWORDBREAKPROC  = 000D0h;
    EM_GETWORDBREAKPROC  = 000D1h;
    EM_GETPASSWORDCHAR   = 000D2h;

    EM_SETMARGINS        = 000D3h;
    EM_GETMARGINS        = 000D4h;
    EM_SETLIMITTEXT      = EM_LIMITTEXT;
    EM_GETLIMITTEXT      = 000D5h;
    EM_POSFROMCHAR       = 000D6h;
    EM_CHARFROMPOS       = 000D7h;

%IF WIN5 %THEN
    EM_SETIMESTATUS         =000D8h;
    EM_GETIMESTATUS         =000D9h;
%END

    WB_LEFT              = 0;
    WB_RIGHT             = 1;
    WB_ISDELIMITER       = 2;

    BS_PUSHBUTTON        = 000h;
    BS_DEFPUSHBUTTON     = 001h;
    BS_CHECKBOX          = 002h;
    BS_AUTOCHECKBOX      = 003h;
    BS_RADIOBUTTON       = 004h;
    BS_3STATE            = 005h;
    BS_AUTO3STATE        = 006h;
    BS_GROUPBOX          = 007h;
    BS_USERBUTTON        = 008h;
    BS_AUTORADIOBUTTON   = 009h;
    BS_OWNERDRAW         = 00Bh;
    BS_LEFTTEXT          = 020h;

    BS_TEXT              = 00000000h;
    BS_ICON              = 00000040h;
    BS_BITMAP            = 00000080h;
    BS_LEFT              = 00000100h;
    BS_RIGHT             = 00000200h;
    BS_CENTER            = 00000300h;
    BS_TOP               = 00000400h;
    BS_BOTTOM            = 00000800h;
    BS_VCENTER           = 00000C00h;
    BS_PUSHLIKE          = 00001000h;
    BS_MULTILINE         = 00002000h;
    BS_NOTIFY            = 00004000h;
    BS_FLAT              = 00008000h;
    BS_RIGHTBUTTON       = BS_LEFTTEXT;


    BN_CLICKED           = 0;
    BN_PAINT             = 1;
    BN_HILITE            = 2;
    BN_UNHILITE          = 3;
    BN_DISABLE           = 4;
    BN_DOUBLECLICKED     = 5;

    BN_PUSHED            = BN_HILITE;
    BN_UNPUSHED          = BN_UNHILITE;
    BN_DBLCLK            = BN_DOUBLECLICKED;
    BN_SETFOCUS          = 6;
    BN_KILLFOCUS         = 7;


    BM_GETCHECK          = 000F0h;
    BM_SETCHECK          = 000F1h;
    BM_GETSTATE          = 000F2h;
    BM_SETSTATE          = 000F3h;
    BM_SETSTYLE          = 000F4h;

    BM_CLICK             = 00F5h;
    BM_GETIMAGE          = 00F6h;
    BM_SETIMAGE          = 00F7h;

    BST_UNCHECKED        = 0000h;
    BST_CHECKED          = 0001h;
    BST_INDETERMINATE    = 0002h;
    BST_PUSHED           = 0004h;
    BST_FOCUS            = 0008h;


    SS_LEFT              = 000h;
    SS_CENTER            = 001h;
    SS_RIGHT             = 002h;
    SS_ICON              = 003h;
    SS_BLACKRECT         = 004h;
    SS_GRAYRECT          = 005h;
    SS_WHITERECT         = 006h;
    SS_BLACKFRAME        = 007h;
    SS_GRAYFRAME         = 008h;
    SS_WHITEFRAME        = 009h;
    SS_USERITEM          = 00Ah;
    SS_SIMPLE            = 00Bh;
    SS_LEFTNOWORDWRAP    = 00Ch;

    SS_BITMAP            = 0000000Eh;
    SS_OWNERDRAW         = 0000000Dh;
    SS_ENHMETAFILE       = 0000000Fh;
    SS_ETCHEDHORZ        = 00000010h;
    SS_ETCHEDVERT        = 00000011h;
    SS_ETCHEDFRAME       = 00000012h;
    SS_TYPEMASK          = 0000001Fh;

    SS_NOPREFIX          = 080h;

    SS_NOTIFY            = 00000100h;
    SS_CENTERIMAGE       = 00000200h;
    SS_RIGHTJUST         = 00000400h;
    SS_REALSIZEIMAGE     = 00000800h;
    SS_SUNKEN            = 00001000h;
    SS_RAISED            = 00002000h;
    SS_ENDELLIPSIS      = 00004000h;
    SS_PATHELLIPSIS     = 00008000h;
    SS_WORDELLIPSIS     = 0000C000h;
    SS_ELLIPSISMASK     = 0000C000h;


    STM_SETICON          = 0170h;
    STM_GETICON          = 0171h;

    STM_SETIMAGE         = 00172h;
    STM_GETIMAGE         = 00173h;
    STM_MSGMAX           = 00174h;

    STN_CLICKED          = 0;
    STN_DBLCLK           = 1;
    STN_ENABLE           = 2;
    STN_DISABLE          = 3;


    WC_DIALOG    = CAST(LPATOM, 08002H);

    DWL_MSGRESULT        = 0;
    DWL_DLGPROC          = 4;
    DWL_USER             = 8;

PROCEDURE IsDialogMessageA(hDlg : HWND;
                           VAR lpMsg : MSG) : BOOL;

PROCEDURE IsDialogMessageW(hDlg : HWND;
                           VAR lpMsg : MSG) : BOOL;

%IF UNICODE %THEN
PROCEDURE IsDialogMessage = IsDialogMessageW;
%ELSE
PROCEDURE IsDialogMessage = IsDialogMessageA;
%END

PROCEDURE MapDialogRect(hDlg : HWND;
                        VAR lpRect : RECT) : BOOL;

PROCEDURE DlgDirListA(hDlg : HWND;
                      VAR lpPathSpec : ARRAY OF ACHAR;
                      nIDListBox : INTEGER;
                      nIDStaticPath : INTEGER;
                      uFileType : UINT) : INTEGER;

PROCEDURE DlgDirListW(hDlg : HWND;
                      VAR lpPathSpec : ARRAY OF UCHAR;
                      nIDListBox : INTEGER;
                      nIDStaticPath : INTEGER;
                      uFileType : UINT) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DlgDirList = DlgDirListW;
%ELSE
PROCEDURE DlgDirList = DlgDirListA;
%END

CONST
    DDL_READWRITE        = 00000h;
    DDL_READONLY         = 00001h;
    DDL_HIDDEN           = 00002h;
    DDL_SYSTEM           = 00004h;
    DDL_DIRECTORY        = 00010h;
    DDL_ARCHIVE          = 00020h;
    DDL_POSTMSGS         = 02000h;
    DDL_DRIVES           = 04000h;
    DDL_EXCLUSIVE        = 08000h;

PROCEDURE DlgDirSelectExA(hDlg : HWND;
                          VAR lpString : ARRAY OF ACHAR;
                          nCount : INTEGER;
                          nIDListBox : INTEGER) : BOOL;

PROCEDURE DlgDirSelectExW(hDlg : HWND;
                          VAR lpString : ARRAY OF UCHAR;
                          nCount : INTEGER;
                          nIDListBox : INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE DlgDirSelectEx = DlgDirSelectExW;
%ELSE
PROCEDURE DlgDirSelectEx = DlgDirSelectExA;
%END

PROCEDURE DlgDirListComboBoxA(hDlg : HWND;
                              VAR lpPathSpec : ARRAY OF ACHAR;
                              nIDComboBox : INTEGER;
                              nIDStaticPath : INTEGER;
                              uFiletype : UINT) : INTEGER;

PROCEDURE DlgDirListComboBoxW(hDlg : HWND;
                              VAR lpPathSpec : ARRAY OF UCHAR;
                              nIDComboBox : INTEGER;
                              nIDStaticPath : INTEGER;
                              uFiletype : UINT) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DlgDirListComboBox = DlgDirListComboBoxW;
%ELSE
PROCEDURE DlgDirListComboBox = DlgDirListComboBoxA;
%END

PROCEDURE DlgDirSelectComboBoxExA(hDlg : HWND;
                                  VAR lpString : ARRAY OF ACHAR;
                                  nCount : INTEGER;
                                  nIDComboBox : INTEGER) : BOOL;

PROCEDURE DlgDirSelectComboBoxExW(hDlg : HWND;
                                  VAR lpString : ARRAY OF UCHAR;
                                  nCount : INTEGER;
                                  nIDComboBox : INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExW;
%ELSE
PROCEDURE DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExA;
%END

CONST
    DS_ABSALIGN          = 001h;
    DS_SYSMODAL          = 002h;
    DS_LOCALEDIT         = 020h;
    DS_SETFONT           = 040h;
    DS_MODALFRAME        = 080h;
    DS_NOIDLEMSG         = 0100h;
    DS_SETFOREGROUND     = 0200h;

    DS_3DLOOK            = 00004h;
    DS_FIXEDSYS          = 00008h;
    DS_NOFAILCREATE      = 00010h;
    DS_CONTROL           = 00400h;
    DS_CENTER            = 00800h;
    DS_CENTERMOUSE       = 01000h;

    DS_CONTEXTHELP       = 02000h;
    DS_SHELLFONT         = DS_SETFONT BOR DS_FIXEDSYS;

    DM_GETDEFID          = WM_USER + 0;
    DM_SETDEFID          = WM_USER + 1;

    DM_REPOSITION        = WM_USER + 2;

    PSM_PAGEINFO         = WM_USER + 100;
    PSM_SHEETINFO        = WM_USER + 101;

    PSI_SETACTIVE        = 0001h;
    PSI_KILLACTIVE       = 0002h;
    PSI_APPLY            = 0003h;
    PSI_RESET            = 0004h;
    PSI_HASHELP          = 0005h;
    PSI_HELP             = 0006h;

    PSI_CHANGED          = 0001h;
    PSI_GUISTART         = 0002h;
    PSI_REBOOT           = 0003h;
    PSI_GETSIBLINGS      = 0004h;


    DC_HASDEFID          = 0534Bh;

    DLGC_WANTARROWS      = 00001h;
    DLGC_WANTTAB         = 00002h;
    DLGC_WANTALLKEYS     = 00004h;
    DLGC_WANTMESSAGE     = 00004h;
    DLGC_HASSETSEL       = 00008h;
    DLGC_DEFPUSHBUTTON   = 00010h;
    DLGC_UNDEFPUSHBUTTON = 00020h;
    DLGC_RADIOBUTTON     = 00040h;
    DLGC_WANTCHARS       = 00080h;
    DLGC_STATIC          = 00100h;
    DLGC_BUTTON          = 02000h;
    DLGC_RECURSE         = 08000h;(*95*)

    LB_CTLCODE           = 0;
    LB_OKAY              = 0;
    LB_ERR               = -1;
    LB_ERRSPACE          = -2;

    LBN_ERRSPACE         = -2;
    LBN_SELCHANGE        = 1;
    LBN_DBLCLK           = 2;
    LBN_SELCANCEL        = 3;
    LBN_SETFOCUS         = 4;
    LBN_KILLFOCUS        = 5;

    LB_ADDSTRING         = 00180h;
    LB_INSERTSTRING      = 00181h;
    LB_DELETESTRING      = 00182h;
    LB_SELITEMRANGEEX    = 00183h;
    LB_RESETCONTENT      = 00184h;
    LB_SETSEL            = 00185h;
    LB_SETCURSEL         = 00186h;
    LB_GETSEL            = 00187h;
    LB_GETCURSEL         = 00188h;
    LB_GETTEXT           = 00189h;
    LB_GETTEXTLEN        = 0018Ah;
    LB_GETCOUNT          = 0018Bh;
    LB_SELECTSTRING      = 0018Ch;
    LB_DIR               = 0018Dh;
    LB_GETTOPINDEX       = 0018Eh;
    LB_FINDSTRING        = 0018Fh;
    LB_GETSELCOUNT       = 00190h;
    LB_GETSELITEMS       = 00191h;
    LB_SETTABSTOPS       = 00192h;
    LB_GETHORIZONTALEXTENT= 00193h;
    LB_SETHORIZONTALEXTENT= 00194h;
    LB_SETCOLUMNWIDTH    = 00195h;
    LB_ADDFILE           = 00196h;
    LB_SETTOPINDEX       = 00197h;
    LB_GETITEMRECT       = 00198h;
    LB_GETITEMDATA       = 00199h;
    LB_SETITEMDATA       = 0019Ah;
    LB_SELITEMRANGE      = 0019Bh;
    LB_SETANCHORINDEX    = 0019Ch;
    LB_GETANCHORINDEX    = 0019Dh;
    LB_SETCARETINDEX     = 0019Eh;
    LB_GETCARETINDEX     = 0019Fh;
    LB_SETITEMHEIGHT     = 001A0h;
    LB_GETITEMHEIGHT     = 001A1h;
    LB_FINDSTRINGEXACT   = 001A2h;
    LB_SETLOCALE         = 001A5h;
    LB_GETLOCALE         = 001A6h;
    LB_SETCOUNT          = 001A7h;

    LB_INITSTORAGE       = 001A8h;
    LB_ITEMFROMPOINT     = 001A9h;
%IF WIN4 %THEN
    LB_MSGMAX            = 001B0h;
%ELSE
    LB_MSGMAX            = 001A8h;
%END


    LBS_NOTIFY           = 00001h;
    LBS_SORT             = 00002h;
    LBS_NOREDRAW         = 00004h;
    LBS_MULTIPLESEL      = 00008h;
    LBS_OWNERDRAWFIXED   = 00010h;
    LBS_OWNERDRAWVARIABLE= 00020h;
    LBS_HASSTRINGS       = 00040h;
    LBS_USETABSTOPS      = 00080h;
    LBS_NOINTEGRALHEIGHT = 00100h;
    LBS_MULTICOLUMN      = 00200h;
    LBS_WANTKEYBOARDINPUT= 00400h;
    LBS_EXTENDEDSEL      = 00800h;
    LBS_DISABLENOSCROLL  = 01000h;
    LBS_NODATA           = 02000h;
    LBS_STANDARD         = LBS_NOTIFY BOR
                           LBS_SORT BOR
                           WS_VSCROLL BOR
                           WS_BORDER;
    LBS_NOSEL            = 04000h;(*95*)

    CB_OKAY              = 0;
    CB_ERR               = -1;
    CB_ERRSPACE          = -2;

    CBN_ERRSPACE         = -1;
    CBN_SELCHANGE        = 1;
    CBN_DBLCLK           = 2;
    CBN_SETFOCUS         = 3;
    CBN_KILLFOCUS        = 4;
    CBN_EDITCHANGE       = 5;
    CBN_EDITUPDATE       = 6;
    CBN_DROPDOWN         = 7;
    CBN_CLOSEUP          = 8;
    CBN_SELENDOK         = 9;
    CBN_SELENDCANCEL     = 10;

    CBS_SIMPLE           = 00001h;
    CBS_DROPDOWN         = 00002h;
    CBS_DROPDOWNLIST     = 00003h;
    CBS_OWNERDRAWFIXED   = 00010h;
    CBS_OWNERDRAWVARIABLE= 00020h;
    CBS_AUTOHSCROLL      = 00040h;
    CBS_OEMCONVERT       = 00080h;
    CBS_SORT             = 00100h;
    CBS_HASSTRINGS       = 00200h;
    CBS_NOINTEGRALHEIGHT = 00400h;
    CBS_DISABLENOSCROLL  = 00800h;

    CBS_UPPERCASE        = 02000h;
    CBS_LOWERCASE        = 04000h;


    CB_GETEDITSEL        = 00140h;
    CB_LIMITTEXT         = 00141h;
    CB_SETEDITSEL        = 00142h;
    CB_ADDSTRING         = 00143h;
    CB_DELETESTRING      = 00144h;
    CB_DIR               = 00145h;
    CB_GETCOUNT          = 00146h;
    CB_GETCURSEL         = 00147h;
    CB_GETLBTEXT         = 00148h;
    CB_GETLBTEXTLEN      = 00149h;
    CB_INSERTSTRING      = 0014Ah;
    CB_RESETCONTENT      = 0014Bh;
    CB_FINDSTRING        = 0014Ch;
    CB_SELECTSTRING      = 0014Dh;
    CB_SETCURSEL         = 0014Eh;
    CB_SHOWDROPDOWN      = 0014Fh;
    CB_GETITEMDATA       = 00150h;
    CB_SETITEMDATA       = 00151h;
    CB_GETDROPPEDCONTROLRECT= 00152h;
    CB_SETITEMHEIGHT     = 00153h;
    CB_GETITEMHEIGHT     = 00154h;
    CB_SETEXTENDEDUI     = 00155h;
    CB_GETEXTENDEDUI     = 00156h;
    CB_GETDROPPEDSTATE   = 00157h;
    CB_FINDSTRINGEXACT   = 00158h;
    CB_SETLOCALE         = 00159h;
    CB_GETLOCALE         = 0015ah;

    CB_GETTOPINDEX              = 015bh;
    CB_SETTOPINDEX              = 015ch;
    CB_GETHORIZONTALEXTENT      = 015dh;
    CB_SETHORIZONTALEXTENT      = 015eh;
    CB_GETDROPPEDWIDTH          = 015fh;
    CB_SETDROPPEDWIDTH          = 0160h;
    CB_INITSTORAGE              = 0161h;
%IF WIN4 %THEN
    CB_MSGMAX            = 00162h;
%ELSE
    CB_MSGMAX            = 0015bh;
%END


    SBS_HORZ             = 00000h;
    SBS_VERT             = 00001h;
    SBS_TOPALIGN         = 00002h;
    SBS_LEFTALIGN        = 00002h;
    SBS_BOTTOMALIGN      = 00004h;
    SBS_RIGHTALIGN       = 00004h;
    SBS_SIZEBOXTOPLEFTALIGN= 00002h;
    SBS_SIZEBOXBOTTOMRIGHTALIGN= 00004h;
    SBS_SIZEBOX          = 00008h;
    SBS_SIZEGRIP         = 00010h;

    SBM_SETPOS           = 000E0h;
    SBM_GETPOS           = 000E1h;
    SBM_SETRANGE         = 000E2h;
    SBM_SETRANGEREDRAW   = 000E6h;
    SBM_GETRANGE         = 000E3h;
    SBM_ENABLE_ARROWS    = 000E4h;

    SBM_SETSCROLLINFO    = 000E9h;
    SBM_GETSCROLLINFO    = 000EAh;

    SIF_RANGE            = 00001h;
    SIF_PAGE             = 00002h;
    SIF_POS              = 00004h;
    SIF_DISABLENOSCROLL  = 00008h;
    SIF_TRACKPOS         = 00010h;
    SIF_ALL              = SIF_RANGE BOR
                           SIF_PAGE BOR
                           SIF_POS BOR
                           SIF_TRACKPOS;

TYPE
    SCROLLINFO = RECORD
        cbSize  : UINT;
        fMask   : UINT;
        nMin    : WINT;
        nMax    : WINT;
        nPage   : UINT;
        nPos    : WINT;
        nTrackPos : WINT;
    END;
    LPSCROLLINFO        = POINTER TO SCROLLINFO;
    LPCSCROLLINFO       = LPSCROLLINFO;

PROCEDURE SetScrollInfo(a: HWND;
                        b: WINT;
                        c: SCROLLINFO;
                        d: BOOL) :  WINT;

PROCEDURE GetScrollInfo(a: HWND;
                        b: WINT;
                        VAR c: SCROLLINFO) : BOOL;


CONST
    MDIS_ALLCHILDSTYLES  = 00001h;
    MDITILE_VERTICAL     = 00000h;
    MDITILE_HORIZONTAL   = 00001h;
    MDITILE_SKIPDISABLED = 00002h;

TYPE
    MDICREATESTRUCTA = RECORD
          szClass        : LPCSTR;
          szTitle        : LPCSTR;
          hOwner         : HANDLE;
          x              : INTEGER;
          y              : INTEGER;
          cx             : INTEGER;
          cy             : INTEGER;
          style          : DWORD;
          lParam         : LPARAM;
    END;
    LPMDICREATESTRUCTA   = POINTER TO MDICREATESTRUCTA;

    MDICREATESTRUCTW = RECORD
          szClass        : LPCWSTR;
          szTitle        : LPCWSTR;
          hOwner         : HANDLE;
          x              : INTEGER;
          y              : INTEGER;
          cx             : INTEGER;
          cy             : INTEGER;
          style          : DWORD;
          lParam         : LPARAM;
    END;
    LPMDICREATESTRUCTW   = POINTER TO MDICREATESTRUCTW;

    %IF UNICODE %THEN
    MDICREATESTRUCT      = MDICREATESTRUCTW;
    LPMDICREATESTRUCT    = LPMDICREATESTRUCTW;
    %ELSE
    MDICREATESTRUCT      = MDICREATESTRUCTA;
    LPMDICREATESTRUCT    = LPMDICREATESTRUCTA;
    %END

    CLIENTCREATESTRUCT = RECORD
          hWindowMenu    : HMENU;
          idFirstChild   : UINT;
    END;
    LPCLIENTCREATESTRUCT = POINTER TO CLIENTCREATESTRUCT;

PROCEDURE DefFrameProcA(hWnd : HWND;
                        hWndMDIClient : HWND;
                        uMsg : UINT;
                        wParam : WPARAM;
                        lParam : LPARAM) : LRESULT;

PROCEDURE DefFrameProcW(hWnd : HWND;
                        hWndMDIClient : HWND;
                        uMsg : UINT;
                        wParam : WPARAM;
                        lParam : LPARAM) : LRESULT;

%IF UNICODE %THEN
PROCEDURE DefFrameProc = DefFrameProcW;
%ELSE
PROCEDURE DefFrameProc = DefFrameProcA;
%END

PROCEDURE DefMDIChildProcA(hWnd : HWND;
                           uMsg : UINT;
                           wParam : WPARAM;
                           lParam : LPARAM) : LRESULT;

PROCEDURE DefMDIChildProcW(hWnd : HWND;
                           uMsg : UINT;
                           wParam : WPARAM;
                           lParam : LPARAM) : LRESULT;

%IF UNICODE %THEN
PROCEDURE DefMDIChildProc = DefMDIChildProcW;
%ELSE
PROCEDURE DefMDIChildProc = DefMDIChildProcA;
%END

PROCEDURE TranslateMDISysAccel(hWndClient : HWND;
                               VAR lpMsg : MSG) : BOOL;

PROCEDURE ArrangeIconicWindows(hWnd : HWND) : UINT;

PROCEDURE CreateMDIWindowA(lpClassName : ARRAY OF ACHAR;
                           lpWindowName : ARRAY OF ACHAR;
                           dwStyle : DWORD;
                           X : INTEGER;
                           Y : INTEGER;
                           nWidth : INTEGER;
                           nHeight : INTEGER;
                           hWndParent : HWND;
                           a : HINSTANCE;
                           lParam : LPARAM) : HWND;

PROCEDURE CreateMDIWindowW(lpClassName : ARRAY OF UCHAR;
                           lpWindowName : ARRAY OF UCHAR;
                           dwStyle : DWORD;
                           X : INTEGER;
                           Y : INTEGER;
                           nWidth : INTEGER;
                           nHeight : INTEGER;
                           hWndParent : HWND;
                           a : HINSTANCE;
                           lParam : LPARAM) : HWND;

%IF UNICODE %THEN
PROCEDURE CreateMDIWindow = CreateMDIWindowW;
%ELSE
PROCEDURE CreateMDIWindow = CreateMDIWindowA;
%END


PROCEDURE TileWindows(hwndParent : HWND;
                      wHow : UINT;
                      lpRect : RECT;
                      cKids : UINT;
                      lpKids : ARRAY OF HWND) : WORD;

PROCEDURE CascadeWindows(hwndParent : HWND;
                         wHow : UINT;
                         lpRect : RECT;
                         cKids : UINT;
                         lpKids : ARRAY OF HWND) : WORD;



CONST
    IMC_GETCONVERSIONMODE           = 0001h;
    IMC_SETCONVERSIONMODE           = 0002h;
    IMC_GETSENTENCEMODE             = 0003h;
    IMC_SETSENTENCEMODE             = 0004h;
    IMC_GETOPENSTATUS               = 0005h;
    IMC_SETOPENSTATUS               = 0006h;
    IMC_GETCANDIDATEPOS             = 0007h;
    IMC_SETCANDIDATEPOS             = 0008h;
    IMC_GETCOMPOSITIONFONT          = 0009h;
    IMC_SETCOMPOSITIONFONT          = 000Ah;
    IMC_GETCOMPOSITIONWINDOW        = 000Bh;
    IMC_SETCOMPOSITIONWINDOW        = 000Ch;
    IMC_GETSTATUSWINDOWPOS          = 000Fh;
    IMC_SETSTATUSWINDOWPOS          = 0010h;
    IMC_CLOSESTATUSWINDOW           = 0021h;
    IMC_OPENSTATUSWINDOW            = 0022h;

    IMN_CLOSESTATUSWINDOW      = 0001h;
    IMN_OPENSTATUSWINDOW       = 0002h;
    IMN_CHANGECANDIDATE        = 0003h;
    IMN_CLOSECANDIDATE         = 0004h;
    IMN_OPENCANDIDATE          = 0005h;
    IMN_SETCONVERSIONMODE      = 0006h;
    IMN_SETSENTENCEMODE        = 0007h;
    IMN_SETOPENSTATUS          = 0008h;
    IMN_SETCANDIDATEPOS        = 0009h;
    IMN_SETCOMPOSITIONFONT     = 000Ah;
    IMN_SETCOMPOSITIONWINDOW   = 000Bh;
    IMN_SETSTATUSWINDOWPOS     = 000Ch;
    IMN_GUIDELINE              = 000Dh;
    IMN_PRIVATE                = 000Eh;


TYPE
    HELPPOLY             = DWORD;

    MULTIKEYHELPA = RECORD
          mkSize         : DWORD;
          mkKeylist      : ACHAR;
          szKeyphrase    : ARRAY [0..1 - 1] OF ACHAR;
    END;
    PMULTIKEYHELPA       = POINTER TO MULTIKEYHELPA;
    LPMULTIKEYHELPA      = PMULTIKEYHELPA;

    MULTIKEYHELPW = RECORD
          mkSize         : DWORD;
          mkKeylist      : WCHAR;
          szKeyphrase    : ARRAY [0..1 - 1] OF WCHAR;
    END;
    PMULTIKEYHELPW       = POINTER TO MULTIKEYHELPW;
    LPMULTIKEYHELPW      = PMULTIKEYHELPW;

    %IF UNICODE %THEN
    MULTIKEYHELP         = MULTIKEYHELPW;
    PMULTIKEYHELP        = PMULTIKEYHELPW;
    %ELSE
    MULTIKEYHELP         = MULTIKEYHELPA;
    PMULTIKEYHELP        = PMULTIKEYHELPA;
    %END
    LPMULTIKEYHELP       = PMULTIKEYHELP;

    HELPWININFOA = RECORD
          wStructSize    : INTEGER;
          x              : INTEGER;
          y              : INTEGER;
          dx             : INTEGER;
          dy             : INTEGER;
          wMax           : INTEGER;
          rgchMember     : ARRAY [0..2 - 1] OF ACHAR;
    END;
    PHELPWININFOA        = POINTER TO HELPWININFOA;
    LPHELPWININFOA       = PHELPWININFOA;

    HELPWININFOW = RECORD
          wStructSize    : INTEGER;
          x              : INTEGER;
          y              : INTEGER;
          dx             : INTEGER;
          dy             : INTEGER;
          wMax           : INTEGER;
          rgchMember     : ARRAY [0..2 - 1] OF WCHAR;
    END;
    PHELPWININFOW        = POINTER TO HELPWININFOW;
    LPHELPWININFOW       = PHELPWININFOW;

    %IF UNICODE %THEN
    HELPWININFO          = HELPWININFOW;
    PHELPWININFO         = PHELPWININFOW;
    %ELSE
    HELPWININFO          = HELPWININFOA;
    PHELPWININFO         = PHELPWININFOA;
    %END
    LPHELPWININFO        = PHELPWININFO;

CONST
    HELP_CONTEXT         = 00001h;
    HELP_QUIT            = 00002h;
    HELP_INDEX           = 00003h;
    HELP_CONTENTS        = 00003h;
    HELP_HELPONHELP      = 00004h;
    HELP_SETINDEX        = 00005h;
    HELP_SETCONTENTS     = 00005h;
    HELP_CONTEXTPOPUP    = 00008h;
    HELP_FORCEFILE       = 00009h;
    HELP_KEY             = 00101h;
    HELP_COMMAND         = 00102h;
    HELP_PARTIALKEY      = 00105h;
    HELP_MULTIKEY        = 00201h;
    HELP_SETWINPOS       = 00203h;

    HELP_CONTEXTMENU     = 000ah;
    HELP_FINDER          = 000bh;
    HELP_WM_HELP         = 000ch;
    HELP_SETPOPUP_POS    = 000dh;

    HELP_TCARD              = 8000h;
    HELP_TCARD_DATA         = 0010h;
    HELP_TCARD_OTHER_CALLER = 0011h;

    IDH_NO_HELP                     = 28440;
    IDH_MISSING_CONTEXT             = 28441;
    IDH_GENERIC_HELP_BUTTON         = 28442;
    IDH_OK                          = 28443;
    IDH_CANCEL                      = 28444;
    IDH_HELP                        = 28445;


PROCEDURE WinHelpA(hWndMain : HWND;
                   lpszHelp : ARRAY OF ACHAR;
                   uCommand : UINT;
                   dwData : DWORD) : BOOL;

PROCEDURE WinHelpW(hWndMain : HWND;
                   lpszHelp : ARRAY OF UCHAR;
                   uCommand : UINT;
                   dwData : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE WinHelp = WinHelpW;
%ELSE
PROCEDURE WinHelp = WinHelpA;
%END

%IF WIN5 %THEN
CONST
    GR_GDIOBJECTS     =0;       (* Count of GDI objects *)
    GR_USEROBJECTS    =1;       (* Count of USER objects *)

PROCEDURE GetGuiResources(hProcess : HANDLE; uiFlags : DWORD) : DWORD;
%END

CONST
    SPI_GETBEEP          = 1;
    SPI_SETBEEP          = 2;
    SPI_GETMOUSE         = 3;
    SPI_SETMOUSE         = 4;
    SPI_GETBORDER        = 5;
    SPI_SETBORDER        = 6;
    SPI_GETKEYBOARDSPEED = 10;
    SPI_SETKEYBOARDSPEED = 11;
    SPI_LANGDRIVER       = 12;
    SPI_ICONHORIZONTALSPACING= 13;
    SPI_GETSCREENSAVETIMEOUT= 14;
    SPI_SETSCREENSAVETIMEOUT= 15;
    SPI_GETSCREENSAVEACTIVE= 16;
    SPI_SETSCREENSAVEACTIVE= 17;
    SPI_GETGRIDGRANULARITY= 18;
    SPI_SETGRIDGRANULARITY= 19;
    SPI_SETDESKWALLPAPER = 20;
    SPI_SETDESKPATTERN   = 21;
    SPI_GETKEYBOARDDELAY = 22;
    SPI_SETKEYBOARDDELAY = 23;
    SPI_ICONVERTICALSPACING= 24;
    SPI_GETICONTITLEWRAP = 25;
    SPI_SETICONTITLEWRAP = 26;
    SPI_GETMENUDROPALIGNMENT= 27;
    SPI_SETMENUDROPALIGNMENT= 28;
    SPI_SETDOUBLECLKWIDTH= 29;
    SPI_SETDOUBLECLKHEIGHT= 30;
    SPI_GETICONTITLELOGFONT= 31;
    SPI_SETDOUBLECLICKTIME= 32;
    SPI_SETMOUSEBUTTONSWAP= 33;
    SPI_SETICONTITLELOGFONT= 34;
    SPI_GETFASTTASKSWITCH= 35;
    SPI_SETFASTTASKSWITCH= 36;

    SPI_SETDRAGFULLWINDOWS     = 37;
    SPI_GETDRAGFULLWINDOWS     = 38;
    SPI_GETNONCLIENTMETRICS    = 41;
    SPI_SETNONCLIENTMETRICS    = 42;
    SPI_GETMINIMIZEDMETRICS    = 43;
    SPI_SETMINIMIZEDMETRICS    = 44;
    SPI_GETICONMETRICS         = 45;
    SPI_SETICONMETRICS         = 46;
    SPI_SETWORKAREA            = 47;
    SPI_GETWORKAREA            = 48;
    SPI_SETPENWINDOWS          = 49;

    SPI_GETHIGHCONTRAST        = 66;
    SPI_SETHIGHCONTRAST        = 67;
    SPI_GETKEYBOARDPREF        = 68;
    SPI_SETKEYBOARDPREF        = 69;
    SPI_GETSCREENREADER        = 70;
    SPI_SETSCREENREADER        = 71;
    SPI_GETANIMATION           = 72;
    SPI_SETANIMATION           = 73;
    SPI_GETFONTSMOOTHING       = 74;
    SPI_SETFONTSMOOTHING       = 75;
    SPI_SETDRAGWIDTH           = 76;
    SPI_SETDRAGHEIGHT          = 77;
    SPI_SETHANDHELD            = 78;
    SPI_GETLOWPOWERTIMEOUT     = 79;
    SPI_GETPOWEROFFTIMEOUT     = 80;
    SPI_SETLOWPOWERTIMEOUT     = 81;
    SPI_SETPOWEROFFTIMEOUT     = 82;
    SPI_GETLOWPOWERACTIVE      = 83;
    SPI_GETPOWEROFFACTIVE      = 84;
    SPI_SETLOWPOWERACTIVE      = 85;
    SPI_SETPOWEROFFACTIVE      = 86;
    SPI_SETCURSORS             = 87;
    SPI_SETICONS               = 88;
    SPI_GETDEFAULTINPUTLANG    = 89;
    SPI_SETDEFAULTINPUTLANG    = 90;
    SPI_SETLANGTOGGLE          = 91;
    SPI_GETWINDOWSEXTENSION    = 92;
    SPI_SETMOUSETRAILS         = 93;
    SPI_GETMOUSETRAILS         = 94;
    SPI_SCREENSAVERUNNING      = 97;
    SPI_SETSCREENSAVERRUNNING  = 97;
    SPI_SCREENSAVERRUNNING     = SPI_SETSCREENSAVERRUNNING;

    SPI_GETFILTERKEYS          = 50;
    SPI_SETFILTERKEYS          = 51;
    SPI_GETTOGGLEKEYS          = 52;
    SPI_SETTOGGLEKEYS          = 53;
    SPI_GETMOUSEKEYS           = 54;
    SPI_SETMOUSEKEYS           = 55;
    SPI_GETSHOWSOUNDS          = 56;
    SPI_SETSHOWSOUNDS          = 57;
    SPI_GETSTICKYKEYS          = 58;
    SPI_SETSTICKYKEYS          = 59;
    SPI_GETACCESSTIMEOUT       = 60;
    SPI_SETACCESSTIMEOUT       = 61;
    SPI_GETSERIALKEYS          = 62;
    SPI_SETSERIALKEYS          = 63;
    SPI_GETSOUNDSENTRY         = 64;
    SPI_SETSOUNDSENTRY         = 65;

    SPI_GETMOUSEHOVERWIDTH     =98;
    SPI_SETMOUSEHOVERWIDTH     =99;
    SPI_GETMOUSEHOVERHEIGHT   =100;
    SPI_SETMOUSEHOVERHEIGHT   =101;
    SPI_GETMOUSEHOVERTIME     =102;
    SPI_SETMOUSEHOVERTIME     =103;
    SPI_GETWHEELSCROLLLINES   =104;
    SPI_SETWHEELSCROLLLINES   =105;

    SPI_GETSHOWIMEUI          =110;
    SPI_SETSHOWIMEUI          =111;

    SPI_GETMOUSESPEED         =112;
    SPI_SETMOUSESPEED         =113;
    SPI_GETSCREENSAVERRUNNING =114;

    SPI_GETACTIVEWINDOWTRACKING         =01000h;
    SPI_SETACTIVEWINDOWTRACKING         =01001h;
    SPI_GETMENUANIMATION                =01002h;
    SPI_SETMENUANIMATION                =01003h;
    SPI_GETCOMBOBOXANIMATION            =01004h;
    SPI_SETCOMBOBOXANIMATION            =01005h;
    SPI_GETLISTBOXSMOOTHSCROLLING       =01006h;
    SPI_SETLISTBOXSMOOTHSCROLLING       =01007h;
    SPI_GETGRADIENTCAPTIONS             =01008h;
    SPI_SETGRADIENTCAPTIONS             =01009h;
    SPI_GETMENUUNDERLINES               =0100Ah;
    SPI_SETMENUUNDERLINES               =0100Bh;
    SPI_GETACTIVEWNDTRKZORDER           =0100Ch;
    SPI_SETACTIVEWNDTRKZORDER           =0100Dh;
    SPI_GETHOTTRACKING                  =0100Eh;
    SPI_SETHOTTRACKING                  =0100Fh;
    SPI_GETFOREGROUNDLOCKTIMEOUT        =02000h;
    SPI_SETFOREGROUNDLOCKTIMEOUT        =02001h;
    SPI_GETACTIVEWNDTRKTIMEOUT          =02002h;
    SPI_SETACTIVEWNDTRKTIMEOUT          =02003h;
    SPI_GETFOREGROUNDFLASHCOUNT         =02004h;
    SPI_SETFOREGROUNDFLASHCOUNT         =02005h;

    SPIF_UPDATEINIFILE   = 00001h;
    SPIF_SENDWININICHANGE= 00002h;
    SPIF_SENDCHANGE      = SPIF_SENDWININICHANGE;


    METRICS_USEDEFAULT   = -1;

TYPE
    NONCLIENTMETRICSA = RECORD
        cbSize          : UINT;
        iBorderWidth    : WINT;
        iScrollWidth    : WINT;
        iScrollHeight   : WINT;
        iCaptionWidth   : WINT;
        iCaptionHeight  : WINT;
        lfCaptionFont   : LOGFONTA;
        iSmCaptionWidth : WINT;
        iSmCaptionHeight: WINT;
        lfSmCaptionFont : LOGFONTA;
        iMenuWidth      : WINT;
        iMenuHeight     : WINT;
        lfMenuFont      : LOGFONTA;
        lfStatusFont    : LOGFONTA;
        lfMessageFont   : LOGFONTA;
    END;
    PNONCLIENTMETRICSA          = POINTER TO NONCLIENTMETRICSA;
    LPNONCLIENTMETRICSA         = PNONCLIENTMETRICSA;

    NONCLIENTMETRICSW = RECORD
        cbSize          : UINT;
        iBorderWidth    : WINT;
        iScrollWidth    : WINT;
        iScrollHeight   : WINT;
        iCaptionWidth   : WINT;
        iCaptionHeight  : WINT;
        lfCaptionFont   : LOGFONTW;
        iSmCaptionWidth : WINT;
        iSmCaptionHeight: WINT;
        lfSmCaptionFont : LOGFONTW;
        iMenuWidth      : WINT;
        iMenuHeight     : WINT;
        lfMenuFont      : LOGFONTW;
        lfStatusFont    : LOGFONTW;
        lfMessageFont   : LOGFONTW;
    END;
    PNONCLIENTMETRICSW          = POINTER TO NONCLIENTMETRICSW;
    LPNONCLIENTMETRICSW         = PNONCLIENTMETRICSW;

%IF UNICODE %THEN
    NONCLIENTMETRICS            = NONCLIENTMETRICSW;
    PNONCLIENTMETRICS           = PNONCLIENTMETRICSW;
%ELSE
    NONCLIENTMETRICS            = NONCLIENTMETRICSA;
    PNONCLIENTMETRICS           = PNONCLIENTMETRICSA;
%END
    LPNONCLIENTMETRICS          = PNONCLIENTMETRICS;

CONST
    ARW_BOTTOMLEFT              = 0000h;
    ARW_BOTTOMRIGHT             = 0001h;
    ARW_TOPLEFT                 = 0002h;
    ARW_TOPRIGHT                = 0003h;
    ARW_STARTMASK               = 0003h;
    ARW_STARTRIGHT              = 0001h;
    ARW_STARTTOP                = 0002h;

    ARW_LEFT                    = 0000h;
    ARW_RIGHT                   = 0000h;
    ARW_UP                      = 0004h;
    ARW_DOWN                    = 0004h;
    ARW_HIDE                    = 0008h;
    ARW_VALID                   = 000Fh;

TYPE
    MINIMIZEDMETRICS = RECORD
        cbSize  : UINT;
        iWidth  : WINT;
        iHorzGap: WINT;
        iVertGap: WINT;
        iArrange: WINT;
    END;
    PMINIMIZEDMETRICS   = POINTER TO MINIMIZEDMETRICS;
    LPMINIMIZEDMETRICS  = PMINIMIZEDMETRICS;

    ICONMETRICSA = RECORD
        cbSize          : UINT;
        iHorzSpacing    : WINT;
        iVertSpacing    : WINT;
        iTitleWrap      : WINT;
        lfFont          : LOGFONTA;
    END;
    PICONMETRICSA       = POINTER TO ICONMETRICSA;
    LPICONMETRICSA      = PICONMETRICSA;

    ICONMETRICSW = RECORD
        cbSize          : UINT;
        iHorzSpacing    : WINT;
        iVertSpacing    : WINT;
        iTitleWrap      : WINT;
        lfFont          : LOGFONTW;
    END;
    PICONMETRICSW       = POINTER TO ICONMETRICSW;
    LPICONMETRICSW      = PICONMETRICSW;

%IF UNICODE %THEN
    ICONMETRICS         = ICONMETRICSW;
    PICONMETRICS        = PICONMETRICSW;
%ELSE
    ICONMETRICS         = ICONMETRICSA;
    PICONMETRICS        = PICONMETRICSA;
%END
    LPICONMETRICS       = PICONMETRICS;

    ANIMATIONINFO = RECORD
        cbSize          : UINT;
        iMinAnimate     : WINT;
    END;
    LPANIMATIONINFO     = POINTER TO ANIMATIONINFO;

    SERIALKEYSA = RECORD
        cbSize          : UINT;
        dwFlags         : DWORD;
        lpszActivePort  : LPSTR;
        lpszPort        : LPSTR;
        iBaudRate       : UINT;
        iPortState      : UINT;
        iActive         : UINT;
    END;
    LPSERIALKEYSA       = POINTER TO SERIALKEYSA;

    SERIALKEYSW = RECORD
        cbSize          : UINT;
        dwFlags         : DWORD;
        lpszActivePort  : LPWSTR;
        lpszPort        : LPWSTR;
        iBaudRate       : UINT;
        iPortState      : UINT;
        iActive         : UINT;
    END;
    LPSERIALKEYSW       = POINTER TO SERIALKEYSW;

%IF UNICODE %THEN
    SERIALKEYS          = SERIALKEYSW;
    LPSERIALKEYS        = LPSERIALKEYSW;
%ELSE
    SERIALKEYS          = SERIALKEYSA;
    LPSERIALKEYS        = LPSERIALKEYSA;
%END

CONST
    SERKF_SERIALKEYSON  = 000000001h;
    SERKF_AVAILABLE     = 000000002h;
    SERKF_INDICATOR     = 000000004h;

TYPE
    HIGHCONTRASTA = RECORD
        cbSize  : UINT;
        dwFlags : DWORD;
        lpszDefaultScheme : LPSTR;
    END;
    LPHIGHCONTRASTA     = POINTER TO HIGHCONTRASTA;

    HIGHCONTRASTW = RECORD
        cbSize  : UINT;
        dwFlags : DWORD;
        lpszDefaultScheme : LPWSTR;
    END;
    LPHIGHCONTRASTW     = POINTER TO HIGHCONTRASTW;

%IF UNICODE %THEN
    HIGHCONTRAST        = HIGHCONTRASTW;
    LPHIGHCONTRAST      = LPHIGHCONTRASTW;
%ELSE
    HIGHCONTRAST        = HIGHCONTRASTA;
    LPHIGHCONTRAST      = LPHIGHCONTRASTA;
%END

CONST
    HCF_HIGHCONTRASTON  = 00000001h;
    HCF_AVAILABLE       = 00000002h;
    HCF_HOTKEYACTIVE    = 00000004h;
    HCF_CONFIRMHOTKEY   = 00000008h;
    HCF_HOTKEYSOUND     = 00000010h;
    HCF_INDICATOR       = 00000020h;
    HCF_HOTKEYAVAILABLE = 00000040h;

    CDS_UPDATEREGISTRY  = 00000001h;
    CDS_TEST            = 00000002h;
    CDS_FULLSCREEN      = 00000004h;
    CDS_GLOBAL          =000000008h;
    CDS_SET_PRIMARY     =000000010h;
    CDS_RESET           =040000000h;
    CDS_SETRECT         =020000000h;
    CDS_NORESET         =010000000h;

    DISP_CHANGE_SUCCESSFUL   =    0;
    DISP_CHANGE_RESTART      =    1;
    DISP_CHANGE_FAILED       =   -1;
    DISP_CHANGE_BADMODE      =   -2;
    DISP_CHANGE_NOTUPDATED   =   -3;
    DISP_CHANGE_BADFLAGS     =   -4;
    DISP_CHANGE_BADPARAM     =   -5;

PROCEDURE ChangeDisplaySettingsA(VAR lpDevMode : DEVMODEA;
                                 dwFlags : DWORD) : LONG;

PROCEDURE ChangeDisplaySettingsW(VAR lpDevMode : DEVMODEW;
                                 dwFlags : DWORD) : LONG;

%IF UNICODE %THEN
PROCEDURE ChangeDisplaySettings = ChangeDisplaySettingsW;
%ELSE
PROCEDURE ChangeDisplaySettings = ChangeDisplaySettingsA;
%END

PROCEDURE ChangeDisplaySettingsExA(lpszDeviceName : ARRAY OF ACHAR;
                                   lpDevMode : DEVMODEA;
                                   hwnd : HWND;
                                   dwflags : DWORD;
                                   lParam : LPVOID) : LONG;

PROCEDURE ChangeDisplaySettingsExW(lpszDeviceName : ARRAY OF UCHAR;
                                   lpDevMode : DEVMODEW;
                                   hwnd : HWND;
                                   dwflags : DWORD;
                                   lParam : LPVOID) : LONG;

%IF UNICODE %THEN
PROCEDURE ChangeDisplaySettingsEx = ChangeDisplaySettingsExW;
%ELSE
PROCEDURE ChangeDisplaySettingsEx = ChangeDisplaySettingsExA;
%END

CONST
    ENUM_CURRENT_SETTINGS       = CAST(DWORD, -1);
    ENUM_REGISTRY_SETTINGS      = CAST(DWORD, -2);

PROCEDURE EnumDisplaySettingsA( lpszDeviceName : ARRAY OF ACHAR;
                                iModeNum : DWORD;
                                VAR lpDevMode : DEVMODEA) : BOOL;

PROCEDURE EnumDisplaySettingsW( lpszDeviceName : ARRAY OF UCHAR;
                                iModeNum : DWORD;
                                VAR lpDevMode : DEVMODEW) : BOOL;

%IF UNICODE %THEN
PROCEDURE EnumDisplaySettings = EnumDisplaySettingsW;
%ELSE
PROCEDURE EnumDisplaySettings = EnumDisplaySettingsA;
%END


%IF WIN5 %THEN
PROCEDURE EnumDisplayDevicesA(Unused : PVOID;
                              iDevNum : DWORD;
                              lpDisplayDevice : DISPLAY_DEVICEA;
                              dwFlags : DWORD) : BOOL;

PROCEDURE EnumDisplayDevicesW(Unused : PVOID;
                              iDevNum : DWORD;
                              lpDisplayDevice : DISPLAY_DEVICEW;
                              dwFlags : DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE EnumDisplayDevices = EnumDisplayDevicesW;
%ELSE
PROCEDURE EnumDisplayDevices = EnumDisplayDevicesA;
%END
%END

PROCEDURE SystemParametersInfoA(uiAction : UINT;
                                uiParam : UINT;
                                pvParam : PVOID;
                                fWinIni : UINT) : BOOL;

PROCEDURE SystemParametersInfoW(uiAction : UINT;
                                uiParam : UINT;
                                pvParam : PVOID;
                                fWinIni : UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE SystemParametersInfo = SystemParametersInfoW;
%ELSE
PROCEDURE SystemParametersInfo = SystemParametersInfoA;
%END


TYPE
    FILTERKEYS = RECORD
        cbSize          : UINT;
        dwFlags         : DWORD;
        iWaitMSec       : DWORD;
        iDelayMSec      : DWORD;
        iRepeatMSec     : DWORD;
        iBounceMSec     : DWORD;
    END;
    LPFILTERKEYS        = POINTER TO FILTERKEYS;

CONST
    FKF_FILTERKEYSON    = 00000001h;
    FKF_AVAILABLE       = 00000002h;
    FKF_HOTKEYACTIVE    = 00000004h;
    FKF_CONFIRMHOTKEY   = 00000008h;
    FKF_HOTKEYSOUND     = 00000010h;
    FKF_INDICATOR       = 00000020h;
    FKF_CLICKON         = 00000040h;

TYPE
    STICKYKEYS = RECORD
        cbSize  : UINT;
        dwFlags : DWORD;
    END;
    LPSTICKYKEYS = POINTER TO STICKYKEYS;

CONST
    SKF_STICKYKEYSON    = 00000001h;
    SKF_AVAILABLE       = 00000002h;
    SKF_HOTKEYACTIVE    = 00000004h;
    SKF_CONFIRMHOTKEY   = 00000008h;
    SKF_HOTKEYSOUND     = 00000010h;
    SKF_INDICATOR       = 00000020h;
    SKF_AUDIBLEFEEDBACK = 00000040h;
    SKF_TRISTATE        = 00000080h;
    SKF_TWOKEYSOFF      = 00000100h;

%IF WIN5 %THEN
    (*NT only*)
    SKF_LALTLATCHED       =010000000h;
    SKF_LCTLLATCHED       =004000000h;
    SKF_LSHIFTLATCHED     =001000000h;
    SKF_RALTLATCHED       =020000000h;
    SKF_RCTLLATCHED       =008000000h;
    SKF_RSHIFTLATCHED     =002000000h;
    SKF_LWINLATCHED       =040000000h;
    SKF_RWINLATCHED       =080000000h;
    SKF_LALTLOCKED        =000100000h;
    SKF_LCTLLOCKED        =000040000h;
    SKF_LSHIFTLOCKED      =000010000h;
    SKF_RALTLOCKED        =000200000h;
    SKF_RCTLLOCKED        =000080000h;
    SKF_RSHIFTLOCKED      =000020000h;
    SKF_LWINLOCKED        =000400000h;
    SKF_RWINLOCKED        =000800000h;
%END

TYPE
    MOUSEKEYS = RECORD
        cbSize          : UINT;
        dwFlags         : DWORD;
        iMaxSpeed       : DWORD;
        iTimeToMaxSpeed : DWORD;
        iCtrlSpeed      : DWORD;
        dwReserved1     : DWORD;
        dwReserved2     : DWORD;
    END;
    LPMOUSEKEYS = POINTER TO MOUSEKEYS;

CONST
    MKF_MOUSEKEYSON     = 00000001h;
    MKF_AVAILABLE       = 00000002h;
    MKF_HOTKEYACTIVE    = 00000004h;
    MKF_CONFIRMHOTKEY   = 00000008h;
    MKF_HOTKEYSOUND     = 00000010h;
    MKF_INDICATOR       = 00000020h;
    MKF_MODIFIERS       = 00000040h;
    MKF_REPLACENUMBERS  = 00000080h;

%IF WIN5 %THEN
    (*NT only*)
    MKF_LEFTBUTTONSEL   = 010000000h;
    MKF_RIGHTBUTTONSEL  = 020000000h;
    MKF_LEFTBUTTONDOWN  = 001000000h;
    MKF_RIGHTBUTTONDOWN = 002000000h;
    MKF_MOUSEMODE       = 080000000h;
%END

TYPE
    ACCESSTIMEOUT = RECORD
        cbSize          : UINT;
        dwFlags         : DWORD;
        iTimeOutMSec    : DWORD;
    END;
    LPACCESSTIMEOUT     = POINTER TO ACCESSTIMEOUT;

CONST
    ATF_TIMEOUTON       = 00000001h;
    ATF_ONOFFFEEDBACK   = 00000002h;

    SSGF_NONE           = 0;
    SSGF_DISPLAY        = 3;

    SSTF_NONE           = 0;
    SSTF_CHARS          = 1;
    SSTF_BORDER         = 2;
    SSTF_DISPLAY        = 3;

    SSWF_NONE           = 0;
    SSWF_TITLE          = 1;
    SSWF_WINDOW         = 2;
    SSWF_DISPLAY        = 3;
    SSWF_CUSTOM         = 4;

TYPE
    SOUNDSENTRYA = RECORD
        cbSize                  : UINT;
        dwFlags                 : DWORD;
        iFSTextEffect           : DWORD;
        iFSTextEffectMSec       : DWORD;
        iFSTextEffectColorBits  : DWORD;
        iFSGrafEffect           : DWORD;
        iFSGrafEffectMSec       : DWORD;
        iFSGrafEffectColor      : DWORD;
        iWindowsEffect          : DWORD;
        iWindowsEffectMSec      : DWORD;
        lpszWindowsEffectDLL    : LPSTR;
        iWindowsEffectOrdinal   : DWORD;
    END;
    LPSOUNDSENTRYA = POINTER TO SOUNDSENTRYA;

    SOUNDSENTRYW = RECORD
        cbSize                  : UINT;
        dwFlags                 : DWORD;
        iFSTextEffect           : DWORD;
        iFSTextEffectMSec       : DWORD;
        iFSTextEffectColorBits  : DWORD;
        iFSGrafEffect           : DWORD;
        iFSGrafEffectMSec       : DWORD;
        iFSGrafEffectColor      : DWORD;
        iWindowsEffect          : DWORD;
        iWindowsEffectMSec      : DWORD;
        lpszWindowsEffectDLL    : LPWSTR;
        iWindowsEffectOrdinal   : DWORD;
    END;
    LPSOUNDSENTRYW = POINTER TO SOUNDSENTRYW;

%IF UNICODE %THEN
    SOUNDSENTRY = SOUNDSENTRYW;
    LPSOUNDSENTRY = LPSOUNDSENTRYW;
%ELSE
    SOUNDSENTRY = SOUNDSENTRYA;
    LPSOUNDSENTRY = LPSOUNDSENTRYA;
%END

CONST
    SSF_SOUNDSENTRYON   = 00000001h;
    SSF_AVAILABLE       = 00000002h;
    SSF_INDICATOR       = 00000004h;

TYPE
    TOGGLEKEYS = RECORD
        cbSize  : UINT;
        dwFlags : DWORD;
    END;
    LPTOGGLEKEYS        = POINTER TO TOGGLEKEYS;

CONST
    TKF_TOGGLEKEYSON    = 00000001h;
    TKF_AVAILABLE       = 00000002h;
    TKF_HOTKEYACTIVE    = 00000004h;
    TKF_CONFIRMHOTKEY   = 00000008h;
    TKF_HOTKEYSOUND     = 00000010h;
    TKF_INDICATOR       = 00000020h;

CONST
    ctlFirst             = 00400h;
    ctlLast              = 004ffh;
    psh1                 = 00400h;
    psh2                 = 00401h;
    psh3                 = 00402h;
    psh4                 = 00403h;
    psh5                 = 00404h;
    psh6                 = 00405h;
    psh7                 = 00406h;
    psh8                 = 00407h;
    psh9                 = 00408h;
    psh10                = 00409h;
    psh11                = 0040ah;
    psh12                = 0040bh;
    psh13                = 0040ch;
    psh14                = 0040dh;
    psh15                = 0040eh;
    psh16                = 0040fh;
    chx1                 = 00410h;
    chx2                 = 00411h;
    chx3                 = 00412h;
    chx4                 = 00413h;
    chx5                 = 00414h;
    chx6                 = 00415h;
    chx7                 = 00416h;
    chx8                 = 00417h;
    chx9                 = 00418h;
    chx10                = 00419h;
    chx11                = 0041ah;
    chx12                = 0041bh;
    chx13                = 0041ch;
    chx14                = 0041dh;
    chx15                = 0041eh;
    chx16                = 0041fh;
    rad1                 = 00420h;
    rad2                 = 00421h;
    rad3                 = 00422h;
    rad4                 = 00423h;
    rad5                 = 00424h;
    rad6                 = 00425h;
    rad7                 = 00426h;
    rad8                 = 00427h;
    rad9                 = 00428h;
    rad10                = 00429h;
    rad11                = 0042ah;
    rad12                = 0042bh;
    rad13                = 0042ch;
    rad14                = 0042dh;
    rad15                = 0042eh;
    rad16                = 0042fh;
    grp1                 = 00430h;
    grp2                 = 00431h;
    grp3                 = 00432h;
    grp4                 = 00433h;
    frm1                 = 00434h;
    frm2                 = 00435h;
    frm3                 = 00436h;
    frm4                 = 00437h;
    rct1                 = 00438h;
    rct2                 = 00439h;
    rct3                 = 0043ah;
    rct4                 = 0043bh;
    ico1                 = 0043ch;
    ico2                 = 0043dh;
    ico3                 = 0043eh;
    ico4                 = 0043fh;
    stc1                 = 00440h;
    stc2                 = 00441h;
    stc3                 = 00442h;
    stc4                 = 00443h;
    stc5                 = 00444h;
    stc6                 = 00445h;
    stc7                 = 00446h;
    stc8                 = 00447h;
    stc9                 = 00448h;
    stc10                = 00449h;
    stc11                = 0044ah;
    stc12                = 0044bh;
    stc13                = 0044ch;
    stc14                = 0044dh;
    stc15                = 0044eh;
    stc16                = 0044fh;
    stc17                = 00450h;
    stc18                = 00451h;
    stc19                = 00452h;
    stc20                = 00453h;
    stc21                = 00454h;
    stc22                = 00455h;
    stc23                = 00456h;
    stc24                = 00457h;
    stc25                = 00458h;
    stc26                = 00459h;
    stc27                = 0045ah;
    stc28                = 0045bh;
    stc29                = 0045ch;
    stc30                = 0045dh;
    stc31                = 0045eh;
    stc32                = 0045fh;
    lst1                 = 00460h;
    lst2                 = 00461h;
    lst3                 = 00462h;
    lst4                 = 00463h;
    lst5                 = 00464h;
    lst6                 = 00465h;
    lst7                 = 00466h;
    lst8                 = 00467h;
    lst9                 = 00468h;
    lst10                = 00469h;
    lst11                = 0046ah;
    lst12                = 0046bh;
    lst13                = 0046ch;
    lst14                = 0046dh;
    lst15                = 0046eh;
    lst16                = 0046fh;
    cmb1                 = 00470h;
    cmb2                 = 00471h;
    cmb3                 = 00472h;
    cmb4                 = 00473h;
    cmb5                 = 00474h;
    cmb6                 = 00475h;
    cmb7                 = 00476h;
    cmb8                 = 00477h;
    cmb9                 = 00478h;
    cmb10                = 00479h;
    cmb11                = 0047ah;
    cmb12                = 0047bh;
    cmb13                = 0047ch;
    cmb14                = 0047dh;
    cmb15                = 0047eh;
    cmb16                = 0047fh;
    edt1                 = 00480h;
    edt2                 = 00481h;
    edt3                 = 00482h;
    edt4                 = 00483h;
    edt5                 = 00484h;
    edt6                 = 00485h;
    edt7                 = 00486h;
    edt8                 = 00487h;
    edt9                 = 00488h;
    edt10                = 00489h;
    edt11                = 0048ah;
    edt12                = 0048bh;
    edt13                = 0048ch;
    edt14                = 0048dh;
    edt15                = 0048eh;
    edt16                = 0048fh;
    scr1                 = 00490h;
    scr2                 = 00491h;
    scr3                 = 00492h;
    scr4                 = 00493h;
    scr5                 = 00494h;
    scr6                 = 00495h;
    scr7                 = 00496h;
    scr8                 = 00497h;
    FILEOPENORD          = 1536;
    MULTIFILEOPENORD     = 1537;
    PRINTDLGORD          = 1538;
    PRNSETUPDLGORD       = 1539;
    FINDDLGORD           = 1540;
    REPLACEDLGORD        = 1541;
    FONTDLGORD           = 1542;
    FORMATDLGORD31       = 1543;
    FORMATDLGORD30       = 1544;
    PAGESETUPDLGORD      = 1546;

TYPE
    CRGB = RECORD
          bRed           : BYTE;
          bGreen         : BYTE;
          bBlue          : BYTE;
          bExtra         : BYTE;
    END;

CONST
    DLG_COLOR            = 10;
    COLOR_HUESCROLL      = 700;
    COLOR_SATSCROLL      = 701;
    COLOR_LUMSCROLL      = 702;
    COLOR_HUE            = 703;
    COLOR_SAT            = 704;
    COLOR_LUM            = 705;
    COLOR_RED            = 706;
    COLOR_GREEN          = 707;
    COLOR_BLUE           = 708;
    COLOR_CURRENT        = 709;
    COLOR_RAINBOW        = 710;
    COLOR_SAVE           = 711;
    COLOR_ADD            = 712;
    COLOR_SOLID          = 713;
    COLOR_TUNE           = 714;
    COLOR_SCHEMES        = 715;
    COLOR_ELEMENT        = 716;
    COLOR_SAMPLES        = 717;
    COLOR_PALETTE        = 718;
    COLOR_MIX            = 719;
    COLOR_BOX1           = 720;
    COLOR_CUSTOM1        = 721;
    COLOR_HUEACCEL       = 723;
    COLOR_SATACCEL       = 724;
    COLOR_LUMACCEL       = 725;
    COLOR_REDACCEL       = 726;
    COLOR_GREENACCEL     = 727;
    COLOR_BLUEACCEL      = 728;
    NUM_BASIC_COLORS     = 48;
    NUM_CUSTOM_COLORS    = 16;


PROCEDURE PostAppMessageA(a : HTASK;
                         b : UINT;
                         c : WPARAM;
                         d : LPARAM) : BOOL;
PROCEDURE PostAppMessageW(a : HTASK;
                         b : UINT;
                         c : WPARAM;
                         d : LPARAM) : BOOL;
%IF UNICODE %THEN
PROCEDURE PostAppMessage = PostAppMessageW;
%ELSE
PROCEDURE PostAppMessage = PostAppMessageA;
%END

PROCEDURE CreateWindowA(a : ARRAY OF ACHAR;
                       b : ARRAY OF ACHAR;
                       c : DWORD;
                       d : INTEGER;
                       e : INTEGER;
                       f : INTEGER;
                       g : INTEGER;
                       h : HWND;
                       i : HMENU;
                       j : HINSTANCE;
                       k : LPVOID) : HWND;

PROCEDURE CreateWindowW(a : ARRAY OF UCHAR;
                       b : ARRAY OF UCHAR;
                       c : DWORD;
                       d : INTEGER;
                       e : INTEGER;
                       f : INTEGER;
                       g : INTEGER;
                       h : HWND;
                       i : HMENU;
                       j : HINSTANCE;
                       k : LPVOID) : HWND;

%IF UNICODE %THEN
PROCEDURE CreateWindow = CreateWindowW;
%ELSE
PROCEDURE CreateWindow = CreateWindowA;
%END

PROCEDURE CreateDialogA(a : HINSTANCE;
                       b : ARRAY OF ACHAR;
                       c : HWND;
                       d : DLGPROC) : HWND;

PROCEDURE CreateDialogW(a : HINSTANCE;
                       b : ARRAY OF UCHAR;
                       c : HWND;
                       d : DLGPROC) : HWND;

%IF UNICODE %THEN
PROCEDURE CreateDialog = CreateDialogW;
%ELSE
PROCEDURE CreateDialog = CreateDialogA;
%END

PROCEDURE CreateDialogIndirectW(a : HINSTANCE;
                               lpTemplate : LPCDLGTEMPLATEW;
                               c : HWND;
                               d : DLGPROC) : HWND;

PROCEDURE CreateDialogIndirectA(a : HINSTANCE;
                               lpTemplate : LPCDLGTEMPLATEA;
                               c : HWND;
                               d : DLGPROC) : HWND;

%IF UNICODE %THEN
PROCEDURE CreateDialogIndirect = CreateDialogIndirectW;
%ELSE
PROCEDURE CreateDialogIndirect = CreateDialogIndirectA;
%END

PROCEDURE DialogBoxA(a : HINSTANCE;
                    b : ARRAY OF ACHAR;
                    c : HWND;
                    d : DLGPROC) : INTEGER;

PROCEDURE DialogBoxW(a : HINSTANCE;
                    b : ARRAY OF UCHAR;
                    c : HWND;
                    d : DLGPROC) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DialogBox = DialogBoxW;
%ELSE
PROCEDURE DialogBox = DialogBoxA;
%END

PROCEDURE DialogBoxIndirectA(a : HINSTANCE;
                            b : HGLOBAL;
                            c : HWND;
                            d : DLGPROC) : INTEGER;

PROCEDURE DialogBoxIndirectW(a : HINSTANCE;
                            b : HGLOBAL;
                            c : HWND;
                            d : DLGPROC) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DialogBoxIndirect = DialogBoxIndirectW;
%ELSE
PROCEDURE DialogBoxIndirect = DialogBoxIndirectA;
%END

PROCEDURE DefHookProc(a : INTEGER;
                      b : WPARAM;
                      c : LPARAM;
                      VAR d : HOOKPROC) : LRESULT;

PROCEDURE ExitWindows(a : DWORD; b : UINT) : BOOL;

PROCEDURE EnumTaskWindows["_EnumThreadWindows@12"]
        (a : HTASK; a : WNDENUMPROC; c : LPARAM) : BOOL;

PROCEDURE GetNextWindow["_GetWindow@8"]
            (a : HWND; b: UINT) : HWND;

PROCEDURE GetSysModalWindow() : HWND;

PROCEDURE SetSysModalWindow(a : HWND) : HWND;

PROCEDURE GetWindowTask(a : HWND) : HTASK;

PROCEDURE CopyCursor(a : HCURSOR): HCURSOR;

(* MACROS *)
<*/PUSH/PACK*>
TYPE Wtype =
    RECORD
        CASE : INTEGER OF
            1: W                : CARDINAL16;
            |
            2: B1,B2            : SHORTCARD;
        ELSE
      END;
   END;

TYPE Ltype =
    RECORD
        CASE : INTEGER OF
            0: L                : CARDINAL32;
            |
            1: W1, W2           : CARDINAL16;
            |
            2: B1,B2,B3,B4      : BYTE;
        ELSE
      END;
   END;
<*/POP*>

PROCEDURE MAKELONG(LowWord, HiWord : WORD): DWORD; MACRO;
VAR
    Result: Ltype;
BEGIN
    Result.W1 := LowWord;
    Result.W2 := HiWord;
    RETURN Result.L;
END MAKELONG;

PROCEDURE MAKELPARAM(LowWord, HiWord : WORD): LPARAM; MACRO;
VAR
    Result: Ltype;
BEGIN
    Result.W1 := LowWord;
    Result.W2 := HiWord;
    RETURN Result.L;
END MAKELPARAM;

PROCEDURE MAKEWPARAM(LowWord, HiWord : WORD): WPARAM; MACRO;
VAR
    Result: Ltype;
BEGIN
    Result.W1 := LowWord;
    Result.W2 := HiWord;
    RETURN Result.L;
END MAKEWPARAM;

PROCEDURE MAKELRESULT(LowWord, HiWord : WORD): LRESULT; MACRO;
VAR
    Result: Ltype;
BEGIN
    Result.W1 := LowWord;
    Result.W2 := HiWord;
    RETURN Result.L;
END MAKELRESULT;

PROCEDURE MAKEWORD(lowbyte, highbyte : SYSTEM.BYTE) : WORD; MACRO;
VAR
    result : Wtype;
BEGIN
    result.B1 := lowbyte;
    result.B2 := highbyte;
    RETURN result.W;
END MAKEWORD;

PROCEDURE LOWORD(l : SYSTEM.DWORD): WORD; MACRO;
BEGIN
    RETURN l[0]:WORD;
END LOWORD;

PROCEDURE HIWORD(l : SYSTEM.DWORD): WORD; MACRO;
BEGIN
    RETURN l[2]:WORD;
END HIWORD;

PROCEDURE LOBYTE(w : SYSTEM.WORD) : BYTE; MACRO;
BEGIN
    RETURN CAST(BYTE, w[0]);
END LOBYTE;

PROCEDURE HIBYTE(w : SYSTEM.WORD) : BYTE; MACRO;
BEGIN
    RETURN CAST(BYTE, w[1]);
END HIBYTE;

PROCEDURE AnsiToOem(lpszSrc : ARRAY OF ACHAR;
                    VAR lpszDst : ARRAY OF ACHAR) : BOOL;

PROCEDURE OemToAnsi(lpszSrc : ARRAY OF ACHAR;
                    VAR lpszDst : ARRAY OF ACHAR) : BOOL;

PROCEDURE AnsiToOemBuff(lpszSrc : ARRAY OF ACHAR;
                         VAR lpszDst : ARRAY OF ACHAR;
                         cchDstLength : DWORD) : BOOL;

PROCEDURE OemToAnsiBuff(lpszSrc : ARRAY OF ACHAR;
                         VAR lpszDst : ARRAY OF ACHAR;
                         cchDstLength : DWORD) : BOOL;

PROCEDURE AnsiUpper(VAR lpsz : ARRAY OF ACHAR) : ACHAR;

PROCEDURE AnsiUpperBuff(VAR lpsz : ARRAY OF ACHAR;
                         cchLength : DWORD) : DWORD;

PROCEDURE AnsiLower(VAR lpsz : ARRAY OF ACHAR) : ACHAR;

PROCEDURE AnsiLowerBuff(VAR lpsz : ARRAY OF ACHAR;
                         cchLength : DWORD) : DWORD;

PROCEDURE AnsiNext(lpsz : ARRAY OF ACHAR) : LPSTR;

PROCEDURE AnsiPrev(lpszStart : ARRAY OF ACHAR;
                    lpszCurrent : ARRAY OF ACHAR) : LPSTR;



 (*Duplicated in WIN32*)
CONST
    SLE_ERROR            = 000000001h;
    SLE_MINORERROR       = 000000002h;
    SLE_WARNING          = 000000003h;

PROCEDURE SetLastErrorEx(dwErrCode : DWORD;
                         dwType : DWORD);


%IF WIN5 %THEN
(*
 * Multimonitor API.
 *)
CONST
    MONITOR_DEFAULTTONULL       = 00000000h;
    MONITOR_DEFAULTTOPRIMARY    = 00000001h;
    MONITOR_DEFAULTTONEAREST    = 00000002h;

PROCEDURE MonitorFromPoint(pt : VALUE POINT; dwFlags : DWORD) : HMONITOR;

PROCEDURE MonitorFromRect(lprc : RECT; dwFlags : DWORD) : HMONITOR;

PROCEDURE MonitorFromWindow(hwnd : HWND; dwFlags : DWORD) : HMONITOR;

CONST
    MONITORINFOF_PRIMARY        = 00000001h;

TYPE
    MONITORINFO = RECORD
    cbSize      : DWORD;
    rcMonitor   : RECT;
    rcWork      : RECT;
    dwFlags     : DWORD;
    END;
    LPMONITORINFO = POINTER TO MONITORINFO;

    MONITORINFOEXA = RECORD
    cbSize      : DWORD;
    rcMonitor   : RECT;
    rcWork      : RECT;
    dwFlags     : DWORD;
    szDevice    : ARRAY [0..CCHDEVICENAME-1] OF ACHAR;
    END;
    LPMONITORINFOEXA = POINTER TO MONITORINFOEXA;

    MONITORINFOEXW = RECORD
    cbSize      : DWORD;
    rcMonitor   : RECT;
    rcWork      : RECT;
    dwFlags     : DWORD;
    szDevice    : ARRAY [0..CCHDEVICENAME-1] OF UCHAR;
    END;
    LPMONITORINFOEXW = POINTER TO MONITORINFOEXW;

    %IF UNICODE %THEN
    MONITORINFOEX = MONITORINFOEXW;
    LPMONITORINFOEX = LPMONITORINFOEXW;
    %ELSE
    MONITORINFOEX = MONITORINFOEXA;
    LPMONITORINFOEX = LPMONITORINFOEXA;
    %END

PROCEDURE GetMonitorInfoA(hMonitor : HMONITOR; VAR lpmi : MONITORINFO) : BOOL;
PROCEDURE GetMonitorInfoW(hMonitor : HMONITOR; VAR lpmi : MONITORINFO) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetMonitorInfo = GetMonitorInfoW;
%ELSE
PROCEDURE GetMonitorInfo = GetMonitorInfoA;
%END

TYPE MONITORENUMPROC = PROCEDURE(HMONITOR, HDC, VAR RECT, LPARAM) : BOOL [EXPORT];

PROCEDURE EnumDisplayMonitors(hdc : HDC;
                              lprcClip : RECT;
                              lpfnEnum : MONITORENUMPROC;
                              dwData : LPARAM) : BOOL;

%END

PROCEDURE SetDebugErrorLevel(dwLevel : DWORD);


%IF WIN5 %THEN
(*
 * WinEvents - Active Accessibility hooks
 *)

PROCEDURE NotifyWinEvent(event : DWORD;
                         hwnd : HWND;
                         idObject : LONG;
                         idChild : LONG);

TYPE
    WINEVENTPROC = PROCEDURE(HWINEVENTHOOK(*hWinEventHook*),
                             DWORD         (*event*),
                             HWND          (*hwnd*),
                             LONG          (*idObject*),
                             LONG          (*idChild*),
                             DWORD         (*idEventThread*),
                             DWORD         (*dwmsEventTime*)) [EXPORT];

(*
 * idObject values for WinEventProc and NotifyWinEvent
 *)

(*
 * hwnd + idObject can be used with OLEACC.DLL's OleGetObjectFromWindow()
 * to get an interface pointer to the container.  indexChild is the item
 * within the container in question.  Setup a VARIANT with vt VT_I4 and
 * lVal the indexChild and pass that in to all methods.  Then you
 * are raring to go.
 *)


(*
 * Common object IDs (cookies, only for sending WM_GETOBJECT to get at the
 * thing in question).  Positive IDs are reserved for apps (app specific),
 * negative IDs are system things and are global, 0 means "just little old
 * me".
 *)

CONST
    CHILDID_SELF        =0;
    INDEXID_OBJECT      =0;
    INDEXID_CONTAINER   =0;

(*
 * Reserved IDs for system objects
 *)
    OBJID_WINDOW        =000000000h;
    OBJID_SYSMENU       =0FFFFFFFFh;
    OBJID_TITLEBAR      =0FFFFFFFEh;
    OBJID_MENU          =0FFFFFFFDh;
    OBJID_CLIENT        =0FFFFFFFCh;
    OBJID_VSCROLL       =0FFFFFFFBh;
    OBJID_HSCROLL       =0FFFFFFFAh;
    OBJID_SIZEGRIP      =0FFFFFFF9h;
    OBJID_CARET         =0FFFFFFF8h;
    OBJID_CURSOR        =0FFFFFFF7h;
    OBJID_ALERT         =0FFFFFFF6h;
    OBJID_SOUND         =0FFFFFFF5h;

(*
 * EVENT DEFINITION
 *)
    EVENT_MIN           =000000001h;
    EVENT_MAX           =07FFFFFFFh;


(*
 *  EVENT_SYSTEM_SOUND
 *  Sent when a sound is played.  Currently nothing is generating this, we
 *  this event when a system sound (for menus, etc) is played.  Apps
 *  generate this, if accessible, when a private sound is played.  For
 *  example, if Mail plays a "New Mail" sound.
 *
 *  System Sounds:
 *  (Generated by PlaySoundEvent in USER itself)
 *      hwnd            is NULL
 *      idObject        is OBJID_SOUND
 *      idChild         is sound child ID if one
 *  App Sounds:
 *  (PlaySoundEvent won't generate notification; up to app)
 *      hwnd + idObject gets interface pointer to Sound object
 *      idChild identifies the sound in question
 *  are going to be cleaning up the SOUNDSENTRY feature in the control panel
 *  and will use this at that time.  Applications implementing WinEvents
 *  are perfectly welcome to use it.  Clients of IAccessible* will simply
 *  turn around and get back a non-visual object that describes the sound.
 *)

    EVENT_SYSTEM_SOUND              =00001h;

(*
 * EVENT_SYSTEM_ALERT
 * System Alerts:
 * (Generated by MessageBox() calls for example)
 *      hwnd            is hwndMessageBox
 *      idObject        is OBJID_ALERT
 * App Alerts:
 * (Generated whenever)
 *      hwnd+idObject gets interface pointer to Alert
 *)

    EVENT_SYSTEM_ALERT              = 00002h;

(*
 * EVENT_SYSTEM_FOREGROUND
 * Sent when the foreground (active) window changes, even if it is changing
 * to another window in the same thread as the previous one.
 *      hwnd            is hwndNewForeground
 *      idObject        is OBJID_WINDOW
 *      idChild    is INDEXID_OBJECT
 *)

    EVENT_SYSTEM_FOREGROUND         = 00003h;

(*
 * Menu
 *      hwnd            is window (top level window or popup menu window)
 *      idObject        is ID of control (OBJID_MENU, OBJID_SYSMENU, OBJID_SELF for popup)
 *      idChild         is CHILDID_SELF
 *
 * EVENT_SYSTEM_MENUSTART
 * EVENT_SYSTEM_MENUEND
 * For MENUSTART, hwnd+idObject+idChild refers to the control with the menu bar,
 *  or the control bringing up the context menu.
 *
 * Sent when entering into and leaving from menu mode (system, app bar, and
 * track popups).
 *)
    EVENT_SYSTEM_MENUSTART          =00004h;
    EVENT_SYSTEM_MENUEND            =00005h;

(*
 * EVENT_SYSTEM_MENUPOPUPSTART
 * EVENT_SYSTEM_MENUPOPUPEND
 * Sent when a menu popup comes up and just before it is taken down.  Note
 * that for a call to TrackPopupMenu(), a client will see EVENT_SYSTEM_MENUSTART
 * followed almost immediately by EVENT_SYSTEM_MENUPOPUPSTART for the popup
 * being shown.
 *
 * For MENUPOPUP, hwnd+idObject+idChild refers to the NEW popup coming up, not the
 * parent item which is hierarchical.  You can get the parent menu/popup by
 * asking for the accParent object.
 *)

    EVENT_SYSTEM_MENUPOPUPSTART     =00006h;
    EVENT_SYSTEM_MENUPOPUPEND       =00007h;


(*
 * EVENT_SYSTEM_CAPTURESTART
 * EVENT_SYSTEM_CAPTUREEND
 * Sent when a window takes the capture and releases the capture.
 *)
    EVENT_SYSTEM_CAPTURESTART       =00008h;
    EVENT_SYSTEM_CAPTUREEND         =00009h;

(*
 * Move Size
 * EVENT_SYSTEM_MOVESIZESTART
 * EVENT_SYSTEM_MOVESIZEEND
 * Sent when a window enters and leaves move-size dragging mode.
 *)

    EVENT_SYSTEM_MOVESIZESTART      =0000Ah;
    EVENT_SYSTEM_MOVESIZEEND        =0000Bh;

(*
 * Context Help
 * EVENT_SYSTEM_CONTEXTHELPSTART
 * EVENT_SYSTEM_CONTEXTHELPEND
 * Sent when a window enters and leaves context sensitive help mode.
 *)

    EVENT_SYSTEM_CONTEXTHELPSTART   =0000Ch;
    EVENT_SYSTEM_CONTEXTHELPEND     =0000Dh;

(*
 * Drag & Drop
 * EVENT_SYSTEM_DRAGDROPSTART
 * EVENT_SYSTEM_DRAGDROPEND
 * Send the START notification just before going into drag&drop loop.  Send
 * the END notification just after canceling out.
 * Note that it is up to apps and OLE to generate this, since the system
 * doesn't know.  Like EVENT_SYSTEM_SOUND, it will be a while before this
 * is prevalent.
 *)
    EVENT_SYSTEM_DRAGDROPSTART      =0000Eh;
    EVENT_SYSTEM_DRAGDROPEND        =0000Fh;

(*
 * Dialog
 * Send the START notification right after the dialog is completely
 *  initialized and visible.  Send the END right before the dialog
 *  is hidden and goes away.
 * EVENT_SYSTEM_DIALOGSTART
 * EVENT_SYSTEM_DIALOGEND
 *)

    EVENT_SYSTEM_DIALOGSTART        =00010h;
    EVENT_SYSTEM_DIALOGEND          =00011h;

(*
 * EVENT_SYSTEM_SCROLLING
 * EVENT_SYSTEM_SCROLLINGSTART
 * EVENT_SYSTEM_SCROLLINGEND
 * Sent when beginning and ending the tracking of a scrollbar in a window,
 * and also for scrollbar controls.
 *)
    EVENT_SYSTEM_SCROLLINGSTART     =00012h;
    EVENT_SYSTEM_SCROLLINGEND       =00013h;

(*
 * Alt-Tab Window
 * Send the START notification right after the switch window is initialized
 * and visible.  Send the END right before it is hidden and goes away.
 * EVENT_SYSTEM_SWITCHSTART
 * EVENT_SYSTEM_SWITCHEND
 *)
    EVENT_SYSTEM_SWITCHSTART        =00014h;
    EVENT_SYSTEM_SWITCHEND          =00015h;

(*
 * EVENT_SYSTEM_MINIMIZESTART
 * EVENT_SYSTEM_MINIMIZEEND
 * Sent when a window minimizes and just before it restores.
 *)
    EVENT_SYSTEM_MINIMIZESTART      =00016h;
    EVENT_SYSTEM_MINIMIZEEND        =00017h;

(*
 * Object events
 *
 * The system AND apps generate these.  The system generates these for
 * real windows.  Apps generate these for objects within their window which
 * act like a separate control, e.g. an item in a list view.
 *
 * When the system generate them, dwParam2 is always WMOBJID_SELF.  When
 * apps generate them, apps put the has-meaning-to-the-app-only ID value
 * in dwParam2.
 * For all events, if you want detailed accessibility information, callers
 * should
 *      * Call AccessibleObjectFromWindow() with the hwnd, idObject parameters
 *          of the event, and IID_IAccessible as the REFIID, to get back an
 *          IAccessible* to talk to
 *      * Initialize and fill in a VARIANT as VT_I4 with lVal the idChild
 *          parameter of the event.
 *      * If idChild isn't zero, call get_accChild() in the container to see
 *          if the child is an object in its own right.  If so, you will get
 *          back an IDispatch* object for the child.  You should release the
 *          parent, and call QueryInterface() on the child object to get its
 *          IAccessible*.  Then you talk directly to the child.  Otherwise,
 *          if get_accChild() returns you nothing, you should continue to
 *          use the child VARIANT.  You will ask the container for the properties
 *          of the child identified by the VARIANT.  In other words, the
 *          child in this case is accessible but not a full-blown object.
 *          Like a button on a titlebar which is 'small' and has no children.
 *)

(*
 * For all EVENT_OBJECT events,
 *      hwnd is the dude to Send the WM_GETOBJECT message to (unless NULL,
 *          see above for system things)
 *      idObject is the ID of the object that can resolve any queries a
 *          client might have.  It's a way to deal with windowless controls,
 *          controls that are just drawn on the screen in some larger parent
 *          window (like SDM), or standard frame elements of a window.
 *      idChild is the piece inside of the object that is affected.  This
 *          allows clients to access things that are too small to have full
 *          blown objects in their own right.  Like the thumb of a scrollbar.
 *          The hwnd/idObject pair gets you to the container, the dude you
 *          probably want to talk to most of the time anyway.  The idChild
 *          can then be passed into the acc properties to get the name/value
 *          of it as needed.
 *
 * Example #1:
 *      System propagating a listbox selection change
 *      EVENT_OBJECT_SELECTION
 *          hwnd == listbox hwnd
 *          idObject == OBJID_WINDOW
 *          idChild == new selected item, or CHILDID_SELF if
 *              nothing now selected within container.
 *      Word '97 propagating a listbox selection change
 *          hwnd == SDM window
 *          idObject == SDM ID to get at listbox 'control'
 *          idChild == new selected item, or CHILDID_SELF if
 *              nothing
 *
 * Example #2:
 *      System propagating a menu item selection on the menu bar
 *      EVENT_OBJECT_SELECTION
 *          hwnd == top level window
 *          idObject == OBJID_MENU
 *          idChild == ID of child menu bar item selected
 *
 * Example #3:
 *      System propagating a dropdown coming off of said menu bar item
 *      EVENT_OBJECT_CREATE
 *          hwnd == popup item
 *          idObject == OBJID_WINDOW
 *          idChild == CHILDID_SELF
 *
 * Example #4:
 *
 * For EVENT_OBJECT_REORDER, the object referred to by hwnd/idObject is the
 * PARENT container in which the zorder is occurring.  This is because if
 * one child is zordering, all of them are changing their relative zorder.
 *)
    EVENT_OBJECT_CREATE                 =08000h;  (* hwnd + ID + idChild is created item*)
    EVENT_OBJECT_DESTROY                =08001h;  (* hwnd + ID + idChild is destroyed item*)
    EVENT_OBJECT_SHOW                   =08002h;  (* hwnd + ID + idChild is shown item*)
    EVENT_OBJECT_HIDE                   =08003h;  (* hwnd + ID + idChild is hidden item*)
    EVENT_OBJECT_REORDER                =08004h;  (* hwnd + ID + idChild is parent of zordering children*)

(*
 * NOTE:
 * Minimize the number of notifications!
 *
 * When you are hiding a parent object, obviously all child objects are no
 * longer visible on screen.  They still have the same "visible" status,
 * but are not truly visible.  Hence do not send HIDE notifications for the
 * children also.  One implies all.  The same goes for SHOW.
 *)


    EVENT_OBJECT_FOCUS                  =08005h;  (* hwnd + ID + idChild is focused item*)
    EVENT_OBJECT_SELECTION              =08006h;  (* hwnd + ID + idChild is selected item (if only one), or idChild is OBJID_WINDOW if complex*)
    EVENT_OBJECT_SELECTIONADD           =08007h;  (* hwnd + ID + idChild is item added*)
    EVENT_OBJECT_SELECTIONREMOVE        =08008h;  (* hwnd + ID + idChild is item removed*)
    EVENT_OBJECT_SELECTIONWITHIN        =08009h;  (* hwnd + ID + idChild is parent of changed selected items*)

(*
 * NOTES:
 * There is only one "focused" child item in a parent.  This is the place
 * keystrokes are going at a given moment.  Hence only send a notification
 * about where the NEW focus is going.  A NEW item getting the focus already
 * implies that the OLD item is losing it.
 *
 * SELECTION however can be multiple.  Hence the different SELECTION
 * notifications.  Here's when to use each:
 *
 * (1) Send a SELECTION notification in the simple single selection
 *     case (like the focus) when the item with the selection is
 *     merely moving to a different item within a container.  hwnd + ID
 *     is the container control, idChildItem is the new child with the
 *     selection.
 *
 * (2) Send a SELECTIONADD notification when a new item has simply been added
 *     to the selection within a container.  This is appropriate when the
 *     number of newly selected items is very small.  hwnd + ID is the
 *     container control, idChildItem is the new child added to the selection.
 *
 * (3) Send a SELECTIONREMOVE notification when a new item has simply been
 *     removed from the selection within a container.  This is appropriate
 *     when the number of newly selected items is very small, just like
 *     SELECTIONADD.  hwnd + ID is the container control, idChildItem is the
 *     new child removed from the selection.
 *
 * (4) Send a SELECTIONWITHIN notification when the selected items within a
 *     control have changed substantially.  Rather than propagate a large
 *     number of changes to reflect removal for some items, addition of
 *     others, just tell somebody who cares that a lot happened.  It will
 *     be faster an easier for somebody watching to just turn around and
 *     query the container control what the new bunch of selected items
 *     are.
 *)

    EVENT_OBJECT_STATECHANGE            =0800Ah;  (* hwnd + ID + idChild is item w/ state change*)

(*
 * Examples of when to send an EVENT_OBJECT_STATECHANGE include
 *      * It is being enabled/disabled (USER does for windows)
 *      * It is being pressed/released (USER does for buttons)
 *      * It is being checked/unchecked (USER does for radio/check buttons)
 *)
    EVENT_OBJECT_LOCATIONCHANGE         =0800Bh;  (* hwnd + ID + idChild is moved/sized item*)

(*
 * Note:
 * A LOCATIONCHANGE is not sent for every child object when the parent
 * changes shape/moves.  Send one notification for the topmost object
 * that is changing.  For example, if the user resizes a top level window,
 * USER will generate a LOCATIONCHANGE for it, but not for the menu bar,
 * title bar, scrollbars, etc.  that are also changing shape/moving.
 *
 * In other words, it only generates LOCATIONCHANGE notifications for
 * real windows that are moving/sizing.  It will not generate a LOCATIONCHANGE
 * for every non-floating child window when the parent moves (the children are
 * logically moving also on screen, but not relative to the parent).
 *
 * Now, if the app itself resizes child windows as a result of being
 * sized, USER will generate LOCATIONCHANGEs for those dudes also because
 * it doesn't know better.
 *
 * Note also that USER will generate LOCATIONCHANGE notifications for two
 * non-window sys objects:
 *      (1) System caret
 *      (2) Cursor
 *)

    EVENT_OBJECT_NAMECHANGE             =0800Ch;  (* hwnd + ID + idChild is item w/ name change*)
    EVENT_OBJECT_DESCRIPTIONCHANGE      =0800Dh;  (* hwnd + ID + idChild is item w/ desc change*)
    EVENT_OBJECT_VALUECHANGE            =0800Eh;  (* hwnd + ID + idChild is item w/ value change*)
    EVENT_OBJECT_PARENTCHANGE           =0800Fh;  (* hwnd + ID + idChild is item w/ new parent*)
    EVENT_OBJECT_HELPCHANGE             =08010h;  (* hwnd + ID + idChild is item w/ help change*)
    EVENT_OBJECT_DEFACTIONCHANGE        =08011h;  (* hwnd + ID + idChild is item w/ def action change*)
    EVENT_OBJECT_ACCELERATORCHANGE      =08012h;  (* hwnd + ID + idChild is item w/ keybd accel change*)

(*
 * Child IDs
 *)

(*
 * System Sounds (idChild of system SOUND notification)
 *)
    SOUND_SYSTEM_STARTUP            =1;
    SOUND_SYSTEM_SHUTDOWN           =2;
    SOUND_SYSTEM_BEEP               =3;
    SOUND_SYSTEM_ERROR              =4;
    SOUND_SYSTEM_QUESTION           =5;
    SOUND_SYSTEM_WARNING            =6;
    SOUND_SYSTEM_INFORMATION        =7;
    SOUND_SYSTEM_MAXIMIZE           =8;
    SOUND_SYSTEM_MINIMIZE           =9;
    SOUND_SYSTEM_RESTOREUP          =10;
    SOUND_SYSTEM_RESTOREDOWN        =11;
    SOUND_SYSTEM_APPSTART           =12;
    SOUND_SYSTEM_FAULT              =13;
    SOUND_SYSTEM_APPEND             =14;
    SOUND_SYSTEM_MENUCOMMAND        =15;
    SOUND_SYSTEM_MENUPOPUP          =16;
    CSOUND_SYSTEM                   =16;

(*
 * System Alerts (indexChild of system ALERT notification)
 *)
    ALERT_SYSTEM_INFORMATIONAL      =1;       (* MB_INFORMATION*)
    ALERT_SYSTEM_WARNING            =2;       (* MB_WARNING*)
    ALERT_SYSTEM_ERROR              =3;       (* MB_ERROR*)
    ALERT_SYSTEM_QUERY              =4;       (* MB_QUESTION*)
    ALERT_SYSTEM_CRITICAL           =5;       (* HardSysErrBox*)
    CALERT_SYSTEM                   =6;

PROCEDURE SetWinEventHook(eventMin : DWORD;
                          eventMax : DWORD;
                          hmodWinEventProc : HMODULE;
                          pfnWinEventProc : WINEVENTPROC;
                          idProcess : DWORD;
                          idThread : DWORD;
                          dwFlags : DWORD) : HWINEVENTHOOK;

PROCEDURE UnhookWinEvent(hWinEventHook : HWINEVENTHOOK) : BOOL;

(*
 * dwFlags for SetWinEventHook
 *)
CONST
    WINEVENT_OUTOFCONTEXT   =00000h;  (* Events are ASYNC*)
    WINEVENT_SKIPOWNTHREAD  =00001h;  (* Don't call back for events on installer's thread*)
    WINEVENT_SKIPOWNPROCESS =00002h;  (* Don't call back for events on installer's process*)
    WINEVENT_INCONTEXT      =00004h;  (* Events are SYNC, this causes your dll to be injected into every process*)

TYPE
    GUITHREADINFO = RECORD
    cbSize              : DWORD;
    flags               : DWORD;
    hwndActive          : HWND;
    hwndFocus           : HWND;
    hwndCapture         : HWND;
    hwndMenuOwner       : HWND;
    hwndMoveSize        : HWND;
    hwndCaret           : HWND;
    rcCaret             : RECT;
    END;
    PGUITHREADINFO = POINTER TO GUITHREADINFO;

CONST
    GUI_CARETBLINKING   =000000001h;
    GUI_INMOVESIZE      =000000002h;
    GUI_INMENUMODE      =000000004h;
    GUI_SYSTEMMENUMODE  =000000008h;
    GUI_POPUPMENUMODE   =000000010h;

PROCEDURE GetGUIThreadInfo(idThread : DWORD;
                           VAR pgui : GUITHREADINFO) : BOOL;

PROCEDURE GetWindowModuleFileNameA(hwnd : HWND;
                                   VAR pszFileName : ARRAY OF ACHAR;
                                   cchFileNameMax : UINT) : UINT;

PROCEDURE GetWindowModuleFileNameW(hwnd : HWND;
                                   VAR pszFileName : ARRAY OF UCHAR;
                                   cchFileNameMax : UINT) : UINT;

%IF UNICODE %THEN
PROCEDURE GetWindowModuleFileName = GetWindowModuleFileNameW;
%ELSE
PROCEDURE GetWindowModuleFileName = GetWindowModuleFileNameA;
%END

CONST
    STATE_SYSTEM_UNAVAILABLE        = 00000001h;  (* Disabled*)
    STATE_SYSTEM_SELECTED           = 00000002h;
    STATE_SYSTEM_FOCUSED            = 00000004h;
    STATE_SYSTEM_PRESSED            = 00000008h;
    STATE_SYSTEM_CHECKED            = 00000010h;
    STATE_SYSTEM_MIXED              = 00000020h;  (* 3-state checkbox or toolbar button*)
    STATE_SYSTEM_READONLY           = 00000040h;
    STATE_SYSTEM_HOTTRACKED         = 00000080h;
    STATE_SYSTEM_DEFAULT            = 00000100h;
    STATE_SYSTEM_EXPANDED           = 00000200h;
    STATE_SYSTEM_COLLAPSED          = 00000400h;
    STATE_SYSTEM_BUSY               = 00000800h;
    STATE_SYSTEM_FLOATING           = 00001000h;  (* Children "owned" not "contained" by parent*)
    STATE_SYSTEM_MARQUEED           = 00002000h;
    STATE_SYSTEM_ANIMATED           = 00004000h;
    STATE_SYSTEM_INVISIBLE          = 00008000h;
    STATE_SYSTEM_OFFSCREEN          = 00010000h;
    STATE_SYSTEM_SIZEABLE           = 00020000h;
    STATE_SYSTEM_MOVEABLE           = 00040000h;
    STATE_SYSTEM_SELFVOICING        = 00080000h;
    STATE_SYSTEM_FOCUSABLE          = 00100000h;
    STATE_SYSTEM_SELECTABLE         = 00200000h;
    STATE_SYSTEM_LINKED             = 00400000h;
    STATE_SYSTEM_TRAVERSED          = 00800000h;
    STATE_SYSTEM_MULTISELECTABLE    = 01000000h;  (* Supports multiple selection*)
    STATE_SYSTEM_EXTSELECTABLE      = 02000000h;  (* Supports extended selection*)
    STATE_SYSTEM_ALERT_LOW          = 04000000h;  (* This information is of low priority*)
    STATE_SYSTEM_ALERT_MEDIUM       = 08000000h;  (* This information is of medium priority*)
    STATE_SYSTEM_ALERT_HIGH         = 10000000h;  (* This information is of high priority*)
    STATE_SYSTEM_VALID              = 0FFFFFFFh;

    CCHILDREN_TITLEBAR              =5;
    CCHILDREN_SCROLLBAR             =5;

(*
 * Information about the global cursor.
 *)
TYPE
    CURSORINFO = RECORD
    cbSize      : DWORD;
    flags       : DWORD;
    hCursor     : HCURSOR;
    ptScreenPos : POINT;
    END;
    PCURSORINFO = POINTER TO CURSORINFO;
    LPCURSORINFO  = PCURSORINFO;

CONST
    CURSOR_SHOWING     = 00000001h;

PROCEDURE GetCursorInfo(pci : CURSORINFO) : BOOL;

(*
 * Window information snapshot
 *)
TYPE
    WINDOWINFO = RECORD
    cbSize              : DWORD;
    rcWindow            : RECT;
    rcClient            : RECT;
    dwStyle             : DWORD;
    dwExStyle           : DWORD;
    dwOtherStuff        : DWORD;
    cxWindowBorders     : UINT;
    cyWindowBorders     : UINT;
    atomWindowType      : ATOM;
    wCreatorVersion     : WORD;
    END;
    PWINDOWINFO = POINTER TO WINDOWINFO;
    LPWINDOWINFO =  PWINDOWINFO;

CONST
    WS_ACTIVECAPTION    = 0001h;

PROCEDURE GetWindowInfo(hwnd : HWND; VAR pwi : WINDOWINFO) : BOOL;

(*
 * Titlebar information.
 *)
TYPE
    TITLEBARINFO = RECORD
    cbSize      : DWORD;
    rcTitleBar  : RECT;
    rgstate     : ARRAY [0..CCHILDREN_TITLEBAR+1-1] OF DWORD;
    END;
    PTITLEBARINFO = POINTER TO TITLEBARINFO;
    LPTITLEBARINFO = PTITLEBARINFO;

PROCEDURE GetTitleBarInfo(hwnd : HWND; VAR pti : TITLEBARINFO) : BOOL;

(*
 * Menubar information
 *)

TYPE
    MENUBARINFO = RECORD
    cbSize              : DWORD;
    rcBar               : RECT;  (* rect of bar, popup, item*)
    hMenu               : HMENU; (* real menu handle of bar, popup*)
    hwndMenu            : HWND;  (* hwnd of item submenu if one*)
    fBarFocused         : DWORD;
    (*
    BOOL  fBarFocused:1;  (* bar, popup has the focus*)
    BOOL  fFocused:1;     (* item has the focus*)
    *)
    END;
    PMENUBARINFO = POINTER TO MENUBARINFO;
    LPMENUBARINFO = PMENUBARINFO;

PROCEDURE GetMenuBarInfo(hwnd : HWND;
                         idObject : LONG;
                         idItem : LONG;
                         VAR pmbi : MENUBARINFO) : BOOL;

(*
 * Scrollbar information
 *)
TYPE
    SCROLLBARINFO = RECORD
    cbSize              : DWORD;
    rcScrollBar         : RECT;
    dxyLineButton       : WINT;
    xyThumbTop          : WINT;
    xyThumbBottom       : WINT;
    bogus               : WINT;
    rgstate             : ARRAY [0..CCHILDREN_SCROLLBAR+1-1] OF DWORD;
    END;
    PSCROLLBARINFO = POINTER TO SCROLLBARINFO;
    LPSCROLLBARINFO = PSCROLLBARINFO;

PROCEDURE GetScrollBarInfo(hwnd : HWND;
                           idObject : LONG;
                           VAR psbi : SCROLLBARINFO) : BOOL;

(*
 * Combobox information
 *)

TYPE
    COMBOBOXINFO = RECORD
    cbSize              : DWORD;
    rcItem              : RECT;
    rcButton            : RECT;
    stateButton         : DWORD;
    hwndCombo           : HWND;
    hwndItem            : HWND;
    hwndList            : HWND;
    END;
    PCOMBOBOXINFO = POINTER TO COMBOBOXINFO;
    LPCOMBOBOXINFO = PCOMBOBOXINFO;

PROCEDURE GetComboBoxInfo(hwndCombo : HWND;
                          VAR pcbi : COMBOBOXINFO) : BOOL;

(*
 * The "real" ancestor window
 *)
CONST
    GA_MIC          =1;
    GA_PARENT       =1;
    GA_ROOT         =2;
    GA_ROOTOWNER    =3;
    GA_MAC          =4;

PROCEDURE GetAncestor(hwnd : HWND;
                      gaFlags : UINT) : HWND;

(*
 * This gets the REAL child window at the point.  If it is in the dead
 * space of a group box, it will try a sibling behind it.  But static
 * fields will get returned.  In other words, it is kind of a cross between
 * ChildWindowFromPointEx and WindowFromPoint.
 *)

PROCEDURE RealChildWindowFromPoint(hwndParent : HWND;
                                   ptParentClientCoords : VALUE POINT) : HWND;


(*
 * This gets the name of the window TYPE, not class.  This allows us to
 * recognize ThunderButton32 et al.
 *)

PROCEDURE RealGetWindowClassA(hwnd : HWND;
                              VAR pszType : ARRAY OF ACHAR;
                              cchType : UINT) : UINT;

PROCEDURE RealGetWindowClassW(hwnd : HWND;
                              VAR pszType : ARRAY OF UCHAR;
                              cchType : UINT) : UINT;
(*
 * This gets the name of the window TYPE, not class.  This allows us to
 * recognize ThunderButton32 et al.
 *)

%IF UNICODE %THEN
PROCEDURE RealGetWindowClass = RealGetWindowClassW;
%ELSE
PROCEDURE RealGetWindowClass = RealGetWindowClassA;
%END

(*
 * Alt-Tab Switch window information.
 *)
TYPE
    ALTTABINFO = RECORD
    cbSize              : DWORD;
    cItems              : WINT;
    cColumns            : WINT;
    cRows               : WINT;
    iColFocus           : WINT;
    iRowFocus           : WINT;
    cxItem              : WINT;
    cyItem              : WINT;
    ptStart             : POINT;
    END;
    PALTTABINFO = POINTER TO ALTTABINFO;
    LPALTTABINFO = PALTTABINFO;

PROCEDURE GetAltTabInfoA(hwnd : HWND;
                         iItem : WINT;
                         pati : PALTTABINFO;
                         VAR pszItemText : ARRAY OF ACHAR;
                         cchItemText : UINT) : BOOL;

PROCEDURE GetAltTabInfoW(hwnd : HWND;
                         iItem : WINT;
                         pati : PALTTABINFO;
                         VAR pszItemText : ARRAY OF UCHAR;
                         cchItemText : UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetAltTabInfo = GetAltTabInfoW;
%ELSE
PROCEDURE GetAltTabInfo = GetAltTabInfoA;
%END

(*
 * Listbox information.
 * Returns the number of items per row.
 *)

PROCEDURE GetListBoxInfo(hwnd : HWND) : DWORD;

(*NT only*)
PROCEDURE LockWorkStation() : BOOL;

(*NT only*)
PROCEDURE UserHandleGrantAccess(hUserHandle : HANDLE;
                                hJob : HANDLE) : BOOL;
%END

END WINUSER.

(***************************************************************************)
(*                                                                         *)
(*                           Copyright (C) 1995-2000                       *)
(*                         by Stony Brook Software                         *)
(*                                                                         *)
(*                           All rights reserved.                          *)
(*                                                                         *)
(***************************************************************************)
DEFINITION MODULE WINX;

FROM SYSTEM IMPORT
    ADDRESS, CAST;
IMPORT SYSTEM;

%IF WIN32 %THEN
FROM WIN32 IMPORT
%ELSE
FROM Windows IMPORT
%END
    HINSTANCE, HMODULE, DWORD, BOOL, HGLOBAL, HPEN, HDC, HBRUSH, HRGN,
    HPALETTE, HGDIOBJ, HFONT, HBITMAP, RECT, HWND, WPARAM, LPARAM, POINT,
    WORD, LRESULT, UINT, HICON, HLOCAL, WINT, LPSTR, HMETAFILE,
    HANDLE, HCURSOR, HMENU, HACCEL, WSIZE, HHOOK, HRSRC, LONG;

%IF WIN32 %THEN
FROM WINUSER IMPORT
%ELSE
FROM Windows IMPORT
%END
    WNDPROC, DLGPROC, EDITWORDBREAKPROC;

%IF WIN32 %THEN
FROM WINGDI IMPORT
%ELSE
FROM Windows IMPORT
%END
    DEVMODE, LOGPEN, LOGBRUSH, LOGFONT, BITMAP;

%IF WIN32 %THEN

FROM WIN32 IMPORT
    FILETIME, PSECURITY_DESCRIPTOR;
FROM WINUSER IMPORT
    ACCEL;
FROM WINGDI IMPORT
    DEVMODEA, DEVMODEW;
IMPORT WIN32;

%ELSE

IMPORT Windows;

%END

VAR
    Instance            : HINSTANCE;
    PrevInstance        : HINSTANCE;
    CmdShow             : UINT;
    CmdLine             : LPSTR;

(* the various NULL_ constants provide a values to indicate *)
(* null pointer *)
(* in 16bit Windows the Modula-2 value is not the same a the operating *)
(* system null value, thus these constant need to be used *)
(* in 32bit Windows the Modula-2 NIL value is the same as the C null *)
(* value, therefore you need not use these constants *)

CONST
    %IF WIN32 %THEN
    NULL                = WIN32.NULL;
    %ELSE
    NULL                = Windows.NULL;
    %END
    NULL_HANDLE         = CAST(HANDLE, NULL);
    NULL_HWND           = CAST(HWND, NULL);
    NULL_HICON          = CAST(HICON, NULL);
    NULL_HCURSOR        = CAST(HCURSOR, NULL);
    NULL_HGLOBAL        = CAST(HGLOBAL, NULL);
    NULL_HINSTANCE      = CAST(HINSTANCE, NULL);
    NULL_HMODULE        = CAST(HMODULE,NULL);
    NULL_HMENU          = CAST(HMENU, NULL);
    NULL_HDC            = CAST(HDC, NULL);
    NULL_HBITMAP        = CAST(HBITMAP, NULL);
    NULL_HGDIOBJ        = CAST(HGDIOBJ, NULL);
    NULL_HPALETTE       = CAST(HPALETTE, NULL);
    NULL_HPEN           = CAST(HPEN, NULL);
    NULL_HBRUSH         = CAST(HBRUSH, NULL);
    NULL_HFONT          = CAST(HFONT, NULL);
    NULL_HRGN           = CAST(HRGN, NULL);
    NULL_HACCEL         = CAST(HACCEL, NULL);
    NULL_HHOOK          = CAST(HHOOK, NULL);
    NULL_HRSRC          = CAST(HRSRC, NULL);
    NULL_HMETAFILE      = CAST(HMETAFILE,NULL);

    %IF WIN32 %THEN
    NULL_SECURITY_DESCRIPTOR = CAST(PSECURITY_DESCRIPTOR, NULL);
    %END

(* the following NIL_ absolute variables are provided because we have *)
(* altered the API calls to use VAR and reference parameters to make *)
(* the resulting code be in a more Modula-2 programming style than a *)
(* C programming style. In the API some procedure have optional parameters *)
(* these optional parameters many times are documented as taking a null *)
(* pointer value, when the parameter was converted to a VAR or reference *)
(* parameter the compiler is taking the address of the passed variable *)
(* thus these NIL_ variables. Since these variables have an absolute *)
(* address of NULL, when the compiler takes their address a value of null *)
(* will be passed thus giving the desired effect *)

VAR
%IF WIN32 %THEN
    NIL_ASTR            [SYSTEM.MAKEADR(0)]  : ARRAY [0..0] OF ACHAR;
    NIL_USTR            [SYSTEM.MAKEADR(0)]  : ARRAY [0..0] OF UCHAR;
    NIL_STR             [SYSTEM.MAKEADR(0)]  : ARRAY [0..0] OF CHAR;
    NIL_SIZE            [SYSTEM.MAKEADR(0)]  : WSIZE;
    NIL_POINT           [SYSTEM.MAKEADR(0)]  : POINT;
    NIL_RECT            [SYSTEM.MAKEADR(0)]  : RECT;
    NIL_INT             [SYSTEM.MAKEADR(0)]  : INTEGER;
    NIL_WINT            [SYSTEM.MAKEADR(0)]  : WINT;
    NIL_DWORD           [SYSTEM.MAKEADR(0)]  : DWORD;
    NIL_BOOL            [SYSTEM.MAKEADR(0)]  : BOOL;
    NIL_ACCEL           [SYSTEM.MAKEADR(0)]  : ACCEL;
    NIL_LONG            [SYSTEM.MAKEADR(0)]  : LONG;
    NIL_DEVMODE         [SYSTEM.MAKEADR(0)]  : DEVMODE;
    NIL_DEVMODEA        [SYSTEM.MAKEADR(0)]  : DEVMODEA;
    NIL_DEVMODEW        [SYSTEM.MAKEADR(0)]  : DEVMODEW;

    NIL_OVERLAPPED      [SYSTEM.MAKEADR(0)]  : WIN32.OVERLAPPED;
    NIL_FILETIME        [SYSTEM.MAKEADR(0)]  : WIN32.FILETIME;
    NIL_SECURITY_ATTRIBUTES     [SYSTEM.MAKEADR(0)]  : WIN32.SECURITY_ATTRIBUTES;

%ELSE
    NIL_ASTR            [SYSTEM.MAKEADR(0,0)]  : ARRAY [0..0] OF ACHAR;
    NIL_USTR            [SYSTEM.MAKEADR(0,0)]  : ARRAY [0..0] OF UCHAR;
    NIL_STR             [SYSTEM.MAKEADR(0,0)]  : ARRAY [0..0] OF CHAR;
    NIL_SIZE            [SYSTEM.MAKEADR(0,0)]  : WSIZE;
    NIL_POINT           [SYSTEM.MAKEADR(0,0)]  : POINT;
    NIL_RECT            [SYSTEM.MAKEADR(0,0)]  : RECT;
    NIL_INT             [SYSTEM.MAKEADR(0,0)]  : INTEGER;
    NIL_WINT            [SYSTEM.MAKEADR(0,0)]  : WINT;
    NIL_DWORD           [SYSTEM.MAKEADR(0,0)]  : DWORD;
    NIL_BOOL            [SYSTEM.MAKEADR(0,0)]  : BOOL;
    NIL_LONG            [SYSTEM.MAKEADR(0,0)]  : LONG;
    NIL_DEVMODE         [SYSTEM.MAKEADR(0,0)]  : DEVMODE;
%END

PROCEDURE GetInstanceModule(hInstance : HINSTANCE) : HMODULE;
(* return the HMODULE handle associated with the HINSTANCE handle *)

PROCEDURE GlobalPtrHandle(lp : ADDRESS) : HGLOBAL;
(* takes a pointer address and returns the object handle *)

PROCEDURE GlobalLockPtr(lp : ADDRESS) : BOOL;
(* takes a pointer address and "locks" the memory location *)
(* returns TRUE if successfull *)

PROCEDURE GlobalUnlockPtr(lp : ADDRESS) : BOOL;
(* reverses a call to GlobalLockPtr *)
(* returns TRUE if successfull *)

PROCEDURE GlobalAllocPtr(flags, cb : DWORD) : ADDRESS;
(* allocates and locks memory returning a pointer address *)
(* flags = the allocation flags *)
(* cb = the size of the allocation in bytes *)

PROCEDURE GlobalReAllocPtr(lp : ADDRESS; cbNew, flags : DWORD) : ADDRESS;
(* changes the size of the allocation *)
(* the old address is invalid after this call *)
(* lp = the old address *)
(* flags = the allocation flags *)
(* cbNew = the size of the allocation in bytes *)

PROCEDURE GlobalFreePtr(lp : ADDRESS) : BOOL;
(* deallocates a previously allocated and locked memory location *)

PROCEDURE DeletePen(hpen : HPEN) : BOOL;
(* provides a type checked interface to the DeleteObject API *)

PROCEDURE SelectPen(hdc : HDC; hpen : HPEN) : HPEN;
(* provides a type checked interface to the SelectObject API *)

PROCEDURE GetStockPen(i : DWORD) : HPEN;
(* provides a type checked interface to the GetStockObject API *)

PROCEDURE GetLOGPEN(h : HPEN; VAR pen : LOGPEN) : BOOLEAN;
(* provides a type checked interface to the GetObject API *)
(* return TRUE if successfull, if FALSE then pen is undefined *)
(* returns the LOGPEN structure in pen *)

PROCEDURE DeleteBrush(hbrush : HBRUSH) : BOOL;
(* provides a type checked interface to the DeleteObject API *)

PROCEDURE SelectBrush(hdc : HDC; hbrush : HBRUSH) : HBRUSH;
(* provides a type checked interface to the SelectObject API *)

PROCEDURE GetStockBrush(i : DWORD) : HBRUSH;
(* provides a type checked interface to the GetStockObject API *)

PROCEDURE GetLOGBRUSH(h : HBRUSH; VAR br : LOGBRUSH) : BOOLEAN;
(* provides a type checked interface to the GetObject API *)
(* return TRUE if successfull, if FALSE then br is undefined *)
(* returns the LOGBRUSH structure in br *)

PROCEDURE DeleteRgn(hrgn : HRGN) : BOOL;
(* provides a type checked interface to the DeleteObject API *)

PROCEDURE CopyRgn(hrgnDst, hrgnSrc : HRGN) : INTEGER;
(* provides a simplified interface to the CombineRgn API *)
(* uses the RGN_COPY parameter *)

PROCEDURE IntersectRgn(hrgnResult, hrgnA, hrgnB : HRGN) : INTEGER;
(* provides a simplified interface to the CombineRgn API *)
(* uses the RGN_AND parameter *)

PROCEDURE SubtractRgn(hrgnResult, hrgnA, hrgnB : HRGN) : INTEGER;
(* provides a simplified interface to the CombineRgn API *)
(* uses the RGN_DIFF parameter *)

PROCEDURE UnionRgn(hrgnResult, hrgnA, hrgnB : HRGN) : INTEGER;
(* provides a simplified interface to the CombineRgn API *)
(* uses the RGN_OR parameter *)

PROCEDURE XorRgn(hrgnResult, hrgnA, hrgnB : HRGN) : INTEGER;
(* provides a simplified interface to the CombineRgn API *)
(* uses the RGN_XOR parameter *)

PROCEDURE DeletePalette(h : HPALETTE) : BOOL;
(* provides a type checked interface to the DeleteObject API *)

PROCEDURE GetPaletteSize(hpal : HPALETTE; VAR numEntries : CARDINAL) : BOOLEAN;
(* provides a type checked interface to the GetObject API *)
(* it returns the number of entries in the palette in the numEntries *)
(* parameter, and returns TRUE if successfull, if FALSE is returned *)
(* then numEntries is undefined *)

PROCEDURE DeleteFont(hfont : HFONT) : BOOL;
(* provides a type checked interface to the DeleteObject API *)

PROCEDURE SelectFont(hdc : HDC; hfont : HFONT) : HFONT;
(* provides a type checked interface to the SelectObject API *)

PROCEDURE GetStockFont(i : DWORD) : HFONT;
(* provides a type checked interface to the GetStockObject API *)

PROCEDURE GetLOGFONT(h : HFONT; VAR logfont : LOGFONT) : BOOLEAN;
(* provides a type checked interface to the GetObject API *)
(* return TRUE if successfull, if FALSE then logfont is undefined *)
(* returns the LOGFONT structure in logfont *)

PROCEDURE DeleteBitmap(h : HBITMAP) : BOOL;
(* provides a type checked interface to the DeleteObject API *)

PROCEDURE SelectBitmap(hdc : HDC; h : HBITMAP) : HBITMAP;
(* provides a type checked interface to the SelectObject API *)

PROCEDURE GetBITMAP(h : HBITMAP; VAR OUT map : BITMAP) : BOOLEAN;
(* provides a type checked interface to the GetObject API *)
(* return TRUE if successfull, if FALSE then map is undefined *)
(* returns the BITMAP structure in map *)

PROCEDURE InsetRect(VAR INOUT lprc : RECT; dx, dy : INTEGER);
(* implemented as *)
(*    InflateRect(lprc, -dx, -dy); *)

PROCEDURE GetWindowInstance(hwnd : HWND) : HMODULE;
(* return the instance and window is associated with *)

PROCEDURE GetWindowStyle(hwnd : HWND) : DWORD;
(* return the style flags associated with a window *)

PROCEDURE GetWindowExStyle(hwnd : HWND) : DWORD;
(* return the exstyle flags associated with a window *)

PROCEDURE GetWindowOwner(hwnd : HWND) : HWND;
(* return the owner of a window *)

PROCEDURE GetFirstChild(hwnd : HWND) : HWND;
(* return the window handle of the first child window contained in *)
(* the passed window *)

PROCEDURE GetFirstSibling(hwnd : HWND) : HWND;
(* return the window handle of the first child window contained in *)
(* the parent of the passed window *)

PROCEDURE GetLastSibling(hwnd : HWND) : HWND;
(* return the window handle of the last child window contained in *)
(* the parent of the passed window *)

PROCEDURE GetNextSibling(hwnd : HWND) : HWND;
(* child windows have a defined order, this procedure lets you walk *)
(* the list of child windows *)
(* return the window handle of the next child window contained in *)
(* the parent of the passed window *)
(* generally you will use FirstSibling and then call this procedure *)
(* until NULL_HWND is returned *)

PROCEDURE GetPrevSibling(hwnd : HWND) : HWND;
(* child windows have a defined order, this procedure lets you walk *)
(* the list of child windows *)
(* return the window handle of the previous child window contained in *)
(* the parent of the passed window *)

PROCEDURE GetWindowID(hwnd : HWND) : INTEGER;
(* implemented as *)
(* RETURN GetDlgCtrlID(hwnd); *)

PROCEDURE SetWindowRedraw(hwnd : HWND; fRedraw : BOOL);
(* if fRedraw = TRUE then painting will we enabled for the *)
(* specified window; otherwise painting will be disabled *)

PROCEDURE SubclassWindow(hwnd : HWND; lpfn : WNDPROC) : WNDPROC;
(* replace the window procedure of the specified window with lpfn *)
(* the previous window procedure is returned allowing you to *)
(* chain message calls *)

PROCEDURE IsMinimized(hwnd : HWND) : BOOL;
(* is the window minimized?, returns TRUE if it is *)

PROCEDURE IsMaximized(hwnd : HWND) : BOOL;
(* is the window maximized?, returns TRUE if it is *)

PROCEDURE IsRestored(hwnd : HWND) : BOOL;
(* is the window restored?, returns TRUE if it is *)

PROCEDURE SetWindowFont(hwnd : HWND; hfont : HFONT; fRedraw : BOOL);
(* set the defined font for a window *)
(* if fRedraw = TRUE then the window will repaint itself *)

PROCEDURE GetWindowFont(hwnd : HWND) : HFONT;
(* return the current set font for a window *)

PROCEDURE MapWindowRect(hwndFrom, hwndTo : HWND; VAR lprc : RECT);
(* implemented as a call to MapWindowPoints *)
(* this is a easy way to map a soingle rectangle *)

PROCEDURE IsLButtonDown() : BOOL;
(* returns TRUE if the left button state is down *)

PROCEDURE IsRButtonDown() : BOOL;
(* returns TRUE if the right button state is down *)

PROCEDURE IsMButtonDown() : BOOL;
(* returns TRUE if the middle button state is down *)

PROCEDURE IsShiftKeyDown() : BOOL;
(* returns TRUE if the shift key is pressed down *)

PROCEDURE IsControlKeyDown() : BOOL;
(* returns TRUE if the control key is pressed down *)

PROCEDURE CharUpperCase(ch : CHAR) : CHAR;
(* convert a character to upper case using the currently defined language *)

PROCEDURE CharLowerCase(ch : CHAR) : CHAR;
(* convert a character to lower case using the currently defined language *)

PROCEDURE SubclassDialog(hwndDlg : HWND; lpfn : DLGPROC) : DLGPROC;
(* replace the window procedure of the specified dialog with lpfn *)
(* the previous window procedure is returned allowing you to *)
(* chain message calls *)

PROCEDURE DialogBoxId(a : HINSTANCE;
                      idNum : CARDINAL;
                      hWndParent : HWND;
                      lpDialogFunc : DLGPROC) : INTEGER;
(* this is a typed call to DialogBox *)
(* the implementation does the necessary type casting *)
(* use this when a dialog box is identified by a numeric value *)
(* rather than a named string *)

PROCEDURE DialogBoxParamId(a : HINSTANCE;
                           idNum : CARDINAL;
                           hWndParent : HWND;
                           lpDialogFunc : DLGPROC;
                           dwInitParam : LPARAM) : INTEGER;
(* this is a typed call to DialogBoxParam *)
(* the implementation does the necessary type casting *)
(* use this when a dialog box is identified by a numeric value *)
(* rather than a named string *)

PROCEDURE LoadMenuId(inst : HINSTANCE; idNum : CARDINAL) : HMENU;
(* this is a typed call to LoadMenu *)
(* the implementation does the necessary type casting *)
(* use this when a menu is identified by a numeric value *)
(* rather than a named string *)

PROCEDURE LoadAcceleratorsId(inst : HINSTANCE; idNum : CARDINAL) : HACCEL;
(* this is a typed call to LoadAccelerators *)
(* the implementation does the necessary type casting *)
(* use this when an accelerator is identified by a numeric value *)
(* rather than a named string *)

PROCEDURE LoadIconId(inst : HINSTANCE; idNum : CARDINAL) : HICON;
(* this is a typed call to LoadIcon *)
(* the implementation does the necessary type casting *)
(* use this when a icon is identified by a numeric value *)
(* rather than a named string *)

PROCEDURE LoadImageId(a: HINSTANCE;
                      idNum: CARDINAL;
                      c: UINT;
                      d: WINT;
                      e: WINT;
                      f: UINT) : HANDLE;
(* this is a typed call to LoadImage *)
(* the implementation does the necessary type casting *)
(* use this when a icon is identified by a numeric value *)
(* rather than a named string *)

PROCEDURE LoadCursorId(inst : HINSTANCE; idNum : CARDINAL) : HCURSOR;
(* this is a typed call to LoadCursor *)
(* the implementation does the necessary type casting *)
(* use this when a cursor is identified by a numeric value *)
(* rather than a named string *)

PROCEDURE LoadBitmapId(inst : HINSTANCE; idNum : CARDINAL) : HBITMAP;
(* this is a typed call to LoadBitmap *)
(* the implementation does the necessary type casting *)
(* use this when a bitmap is identified by a numeric value *)
(* rather than a named string *)

(************* Win32/Win16 message crackers ********************************)

PROCEDURE WM_ACTIVATE_STATE ( wp : WPARAM; lp : LPARAM ) : CARDINAL;

PROCEDURE WM_ACTIVATE_FMINIMIZED ( wp : WPARAM; lp : LPARAM ) : BOOL;

PROCEDURE WM_ACTIVATE_HWND ( wp : WPARAM; lp : LPARAM ) : HWND;

PROCEDURE WM_CHARTOITEM_CHAR ( wp : WPARAM; lp : LPARAM ) : CHAR;

PROCEDURE WM_CHARTOITEM_POS ( wp : WPARAM; lp : LPARAM ) : WORD;

PROCEDURE WM_CHARTOITEM_HWND ( wp : WPARAM; lp : LPARAM ) : HWND;

PROCEDURE WM_COMMAND_ID ( wMsg : UINT; wp : WPARAM; lp : LPARAM ) : WORD;

PROCEDURE WM_COMMAND_HWND ( wMsg : UINT; wp : WPARAM; lp : LPARAM ) : HWND;

PROCEDURE WM_COMMAND_CMD ( wMsg : UINT; wp : WPARAM; lp : LPARAM ) : WORD;

PROCEDURE WM_CTLCOLOR_HDC ( wp : WPARAM; lp : LPARAM; msg : UINT ) : HDC;

PROCEDURE WM_CTLCOLOR_HWND ( wp : WPARAM; lp : LPARAM; msg : UINT ) : HWND;

PROCEDURE WM_CTLCOLOR_TYPE ( wp : WPARAM; lp : LPARAM; msg : UINT ) : WORD;

PROCEDURE WM_MENUSELECT_CMD ( wp : WPARAM; lp : LPARAM ) : UINT;

PROCEDURE WM_MENUSELECT_FLAGS ( wp : WPARAM; lp : LPARAM ) : UINT;

PROCEDURE WM_MENUSELECT_HMENU ( wp : WPARAM; lp : LPARAM ) : HMENU;

PROCEDURE WM_MDIACTIVATE_FACTIVATE ( hwnd : HWND; wp : WPARAM; lp : LPARAM ) : BOOL;

PROCEDURE WM_MDIACTIVATE_HWNDDEACT ( wp : WPARAM; lp : LPARAM ) : HWND;

PROCEDURE WM_MDIACTIVATE_HWNDACTIVATE ( wp : WPARAM; lp : LPARAM ) : HWND;

PROCEDURE WM_MENUCHAR_CHAR ( wp : WPARAM; lp : LPARAM ) : CHAR;

PROCEDURE WM_MENUCHAR_HMENU ( wp : WPARAM; lp : LPARAM ) : HMENU;

PROCEDURE WM_MENUCHAR_FMENU ( wp : WPARAM; lp : LPARAM ) : UINT;

PROCEDURE WM_PARENTNOTIFY_MSG ( wp : WPARAM; lp : LPARAM ) : WORD;

PROCEDURE WM_PARENTNOTIFY_ID ( wp : WPARAM; lp : LPARAM ) : WORD;

PROCEDURE WM_PARENTNOTIFY_HWNDCHILD ( wp : WPARAM; lp : LPARAM ) : HWND;

PROCEDURE WM_PARENTNOTIFY_X ( wp : WPARAM; lp : LPARAM ) : WINT;

PROCEDURE WM_PARENTNOTIFY_Y ( wp : WPARAM; lp : LPARAM ) : WINT;

PROCEDURE WM_VKEYTOITEM_CODE ( wp : WPARAM; lp : LPARAM ) : WORD;

PROCEDURE WM_VKEYTOITEM_ITEM ( wp : WPARAM; lp : LPARAM ) : WORD;

PROCEDURE WM_VKEYTOITEM_HWND ( wp : WPARAM; lp : LPARAM ) : HWND;

PROCEDURE EM_SETSEL_START ( wp : WPARAM; lp : LPARAM ) : WINT;

PROCEDURE EM_SETSEL_END ( wp : WPARAM; lp : LPARAM ) : WINT;

PROCEDURE WM_CHANGECBCHAIN_HWNDNEXT ( wp : WPARAM; lp : LPARAM ) : HWND;

PROCEDURE WM_HSCROLL_CODE ( wp : WPARAM; lp : LPARAM ) : WORD;

PROCEDURE WM_HSCROLL_POS ( wp : WPARAM; lp : LPARAM ) : WORD;

PROCEDURE WM_HSCROLL_HWND ( wp : WPARAM; lp : LPARAM ) : HWND;

PROCEDURE WM_VSCROLL_CODE ( wp : WPARAM; lp : LPARAM ) : WORD;

PROCEDURE WM_VSCROLL_POS ( wp : WPARAM; lp : LPARAM ) : WORD;

PROCEDURE WM_VSCROLL_HWND ( wp : WPARAM; lp : LPARAM ) : HWND;

(*******************************************************************)
(* the following sets of procedure are for interfacing with controls *)
(* each procedure is associated with a specific message and the *)
(* implementation performans the necessary typecasting and packing *)
(* to send the messages *)

(* Static_ = static text controls *)
(* Edit_ = edit controls *)
(* Button_ = buttons, check boxes, radio buttons *)
(* ListBox_ = list boxes *)
(* ComboBox_ = combo boxes *)
(* ScrollBar_ = scroll bars *)

PROCEDURE Static_Enable(hwndCtl : HWND; fEnable : BOOL) : BOOL;
(* implemented as a call EnableWindow *)
(* fEnable = TRUE to enable the window, FALSE to disable *)

PROCEDURE Static_GetText(hwndCtl : HWND;
                         VAR lpch : ARRAY OF CHAR;
                         cchMax : INTEGER) : INTEGER;
(* implemented as a call To GetWindowText *)
(* cchMax = the maximum number of character to retrieve *)

PROCEDURE Static_GetTextLength(hwndCtl : HWND) : INTEGER;
(* implemented as a call To GetWindowTextLength *)

PROCEDURE Static_SetText(hwndCtl : HWND; lpsz : ARRAY OF CHAR) : BOOL;
(* implemented as a call To SetWindowText *)
(* returns true if successfull *)

PROCEDURE Static_SetIcon(hwndCtl : HWND; hIcon : HICON) : HICON;
(* STM_SETICON *)

PROCEDURE Static_GetIcon(hwndCtl : HWND) : HICON;
(* STM_GETICON *)

PROCEDURE Static_SetBitmap(hwndCtl : HWND; hIcon : HBITMAP) : HBITMAP;
(* STM_SETBITMAP *)

PROCEDURE Static_GetBitmap(hwndCtl : HWND) : HBITMAP;
(* STM_GETBITMAP *)

PROCEDURE Button_Enable(hwndCtl : HWND; fEnable : BOOL) : BOOL;
(* implemented as a call EnableWindow *)
(* fEnable = TRUE to enable the window, FALSE to disable *)

PROCEDURE Button_GetText(hwndCtl : HWND;
                         VAR lpch : ARRAY OF CHAR;
                         cchMax : INTEGER) : INTEGER;
(* implemented as a call To GetWindowText *)
(* cchMax = the maximum number of character to retrieve *)

PROCEDURE Button_GetTextLength(hwndCtl : HWND) : INTEGER;
(* implemented as a call To GetWindowTextLength *)

PROCEDURE Button_SetText(hwndCtl : HWND; lpsz : ARRAY OF CHAR) : BOOL;
(* implemented as a call To SetWindowText *)
(* returns true if successfull *)

PROCEDURE Button_GetCheck(hwndCtl : HWND) : INTEGER;
(* BM_GETCHECK *)

PROCEDURE Button_SetCheck(hwndCtl : HWND; check : BOOL);
(* BM_SETCHECK *)

PROCEDURE Button_Click(hwndCtl : HWND);
(* BM_CLICK *)

PROCEDURE Button_GetState(hwndCtl : HWND) : INTEGER;
(* BM_GETSTATE *)

PROCEDURE Button_SetState(hwndCtl : HWND; state : INTEGER) : UINT;
(* BM_SETSTATE *)

PROCEDURE Button_SetStyle(hwndCtl : HWND; style : DWORD; fRedraw : BOOL);
(* BM_SETSTYLE *)

%IF WIN32 %THEN
PROCEDURE Button_SetImage_Bitmap(hwndCtl : HWND; image : HBITMAP) : HBITMAP;
PROCEDURE Button_SetImage_Icon(hwndCtl : HWND; image : HICON) : HICON;
(* BM_SETIMAGE *)
%END

PROCEDURE Edit_Enable(hwndCtl : HWND; fEnable : BOOL) : BOOL;
(* implemented as a call EnableWindow *)
(* fEnable = TRUE to enable the window, FALSE to disable *)

PROCEDURE Edit_GetText(hwndCtl : HWND;
                       VAR OUT lpch : ARRAY OF CHAR;
                       cchMax : INTEGER) : INTEGER;
(* implemented as a call To GetWindowText *)
(* cchMax = the maximum number of character to retrieve *)

PROCEDURE Edit_GetTextLength(hwndCtl : HWND) : INTEGER;
(* implemented as a call To GetWindowTextLength *)

PROCEDURE Edit_SetText(hwndCtl : HWND; lpsz : ARRAY OF CHAR) : BOOL;
(* implemented as a call To SetWindowText *)
(* returns true if successfull *)

PROCEDURE Edit_LimitText(hwndCtl : HWND; cchMax : DWORD);
(* EM_LIMITTEXT *)

PROCEDURE Edit_GetLineCount(hwndCtl : HWND) : INTEGER;
(* EM_GETLINECOUNT *)

PROCEDURE Edit_GetLine(hwndCtl : HWND;
                       line : DWORD;
                       VAR lpch : ARRAY OF CHAR;
                       cchMax : DWORD) : INTEGER;
(* EM_GETLINE *)

PROCEDURE Edit_GetRect(hwndCtl : HWND; VAR lprc : RECT);
(* EM_GETRECT *)

PROCEDURE Edit_SetRect(hwndCtl : HWND; lprc : RECT);
(* EM_SETRECT *)

PROCEDURE Edit_SetRectNoPaint(hwndCtl : HWND; lprc : RECT);
(* EM_SETRECTNP *)

PROCEDURE Edit_GetSel(hwndCtl : HWND; VAR startPos, endPos : INTEGER);
(* EM_GETSEL *)

PROCEDURE Edit_SetSel(hwndCtl : HWND; startPos, endPos : INTEGER);
(* EM_SETSEL *)

PROCEDURE Edit_ScrollCaret(hwndCtl : HWND) : BOOL;
(* EM_SCROLLCARET on Win32 *)
(* emulated on Win16 *)

PROCEDURE Edit_ReplaceSel(hwndCtl : HWND; lpszReplace : ARRAY OF CHAR);
(* EM_REPLACESEL *)

PROCEDURE Edit_GetModify(hwndCtl : HWND) : BOOL;
(* EM_GETMODIFY *)

PROCEDURE Edit_SetModify(hwndCtl : HWND; fModified : BOOL);
(* EM_SETMODIFY *)

PROCEDURE Edit_LineFromChar(hwndCtl : HWND; ich : DWORD) : INTEGER;
(* EM_LINEFROMCHAR *)

PROCEDURE Edit_LineIndex(hwndCtl : HWND; line : DWORD) : INTEGER;
(* EM_LINEINDEX *)

PROCEDURE Edit_LineLength(hwndCtl : HWND; line : DWORD) : INTEGER;
(* EM_LINELENGTH *)

PROCEDURE Edit_Scroll(hwndCtl : HWND; dv, dh : INTEGER);
(* EM_LINESCROLL *)

PROCEDURE Edit_CanUndo(hwndCtl : HWND) : BOOL;
(* EM_CANUNDO *)

PROCEDURE Edit_Undo(hwndCtl : HWND) : BOOL;
(* EN_UNDO *)

PROCEDURE Edit_EmptyUndoBuffer(hwndCtl : HWND);
(* EM_EMPTYUNDOBUFFER *)

PROCEDURE Edit_SetPasswordChar(hwndCtl : HWND; ch : CHAR);
(* EM_SETPASSWORDCHAR *)

PROCEDURE Edit_SetTabStops(hwndCtl : HWND;
                           cTabs : DWORD;
                           lpTabs : ARRAY OF DWORD);
(* EM_SETTABSTOPS *)

PROCEDURE Edit_FmtLines(hwndCtl : HWND; fAddEOL : BOOL) : BOOL;
(* EM_FMTLINES *)

PROCEDURE Edit_GetHandle(hwndCtl : HWND) : HLOCAL;
(* EM_GETHANDLE *)

PROCEDURE Edit_SetHandle(hwndCtl : HWND; h : HLOCAL);
(* EM_SETHANDLE *)

PROCEDURE Edit_GetFirstVisibleLine(hwndCtl : HWND) : INTEGER;
(* EM_GETFIRSTVISIBLELINE *)

PROCEDURE Edit_SetReadOnly(hwndCtl : HWND; fReadOnly : BOOL) : BOOL;
(* EM_SETREADONLY *)

PROCEDURE Edit_GetPasswordChar(hwndCtl : HWND) : CHAR;
(* EM_GETPASSWORDCHAR *)

PROCEDURE Edit_SetWordBreakProc(hwndCtl : HWND;
                                lpfnWordBreak : EDITWORDBREAKPROC);
(* EM_SETWORDBREAKPROC *)

PROCEDURE Edit_GetWordBreakProc(hwndCtl : HWND) : EDITWORDBREAKPROC;
(* EM_GETWORDBREAKPROC *)

PROCEDURE ScrollBar_Enable(hwndCtl : HWND; flags : INTEGER) : BOOL;
(* implemented as a call EnableWindow *)
(* fEnable = TRUE to enable the window, FALSE to disable *)

PROCEDURE ScrollBar_Show(hwndCtl : HWND; fShow : BOOL) : BOOL;
(* implemented as a call to ShowWindow, TRUE if visible *)

PROCEDURE ScrollBar_SetPos(hwndCtl : HWND;
                           pos : DWORD;
                           fRedraw : BOOL) : INTEGER;
(* implemented as a call to SetScrollPos with a SB_CTL parameter *)

PROCEDURE ScrollBar_GetPos(hwndCtl : HWND) : INTEGER;
(* implemented as a call to GetScrollPos with a SB_CTL parameter *)

PROCEDURE ScrollBar_SetRange(hwndCtl : HWND;
                             posMin, posMax : DWORD;
                             fRedraw : BOOL) : BOOL;
(* implemented as a call to SetScrollRange with a SB_CTL parameter *)

PROCEDURE ScrollBar_GetRange(hwndCtl : HWND;
                             VAR lpposMin : WINT;
                             VAR lpposMax : WINT) : BOOL;
(* implemented as a call to GetScrollRange with a SB_CTL parameter *)

PROCEDURE ListBox_Enable(hwndCtl : HWND; fEnable : BOOL) : BOOL;
(* implemented as a call EnableWindow *)
(* fEnable = TRUE to enable the window, FALSE to disable *)

PROCEDURE ListBox_GetCount(hwndCtl : HWND) : INTEGER;
(* LB_GETCOUNT *)

PROCEDURE ListBox_ResetContent(hwndCtl : HWND) : BOOL;
(* LB_RESETCONTENT *)

PROCEDURE ListBox_AddString(hwndCtl : HWND; lpsz : ARRAY OF CHAR) : INTEGER;
(* LB_ADDSTRING *)

PROCEDURE ListBox_InsertString(hwndCtl : HWND;
                               index : INTEGER;
                               lpsz : ARRAY OF CHAR) : INTEGER;
(* LB_INSERTSTRING *)

PROCEDURE ListBox_AddItemData(hwndCtl : HWND; data : INTEGER) : INTEGER;
(* LB_ADDSTRING *)

PROCEDURE ListBox_InsertItemData(hwndCtl : HWND;
                                 index, data : DWORD) : INTEGER;
(* LB_INSERTSTRING *)

PROCEDURE ListBox_DeleteString(hwndCtl : HWND; index : DWORD) : INTEGER;
(* LB_DELETESTRING *)

PROCEDURE ListBox_GetTextLen(hwndCtl : HWND; index : DWORD) : INTEGER;
(* LB_GETTEXTLEN *)

PROCEDURE ListBox_GetText(hwndCtl : HWND;
                          index : DWORD;
                          VAR lpszBuffer : ARRAY OF CHAR) : INTEGER;
(* LB_GETTEXT *)

PROCEDURE ListBox_GetItemData(hwndCtl : HWND; index : DWORD) : LRESULT;
(* LB_GETITEMDATA *)

PROCEDURE ListBox_SetItemData(hwndCtl : HWND;
                              index : DWORD;
                              data : DWORD) :INTEGER;
(* LB_SETITEMDATA *)

PROCEDURE ListBox_FindString(hwndCtl : HWND;
                             indexStart : INTEGER;
                             lpszFind : ARRAY OF CHAR) : INTEGER;
(* LB_FINDSTRING *)

PROCEDURE ListBox_FindItemData(hwndCtl : HWND;
                               indexStart : INTEGER;
                               data : DWORD) : INTEGER;
(* LB_FINDSTRING *)

PROCEDURE ListBox_SetSel(hwndCtl : HWND;
                         fSelect : BOOL;
                         index : DWORD) : INTEGER;
(* LB_SETSEL *)

PROCEDURE ListBox_SelItemRange(hwndCtl : HWND;
                               fSelect : BOOL;
                               first, last : WORD) : INTEGER;
(* LB_SETITEMRANGE *)

PROCEDURE ListBox_GetCurSel(hwndCtl : HWND) : INTEGER;
(* LB_GTECURSEL *)

PROCEDURE ListBox_SetCurSel(hwndCtl : HWND; index : DWORD) : INTEGER;
(* LB_SETCURSEL *)

PROCEDURE ListBox_SelectString(hwndCtl : HWND;
                               indexStart: INTEGER;
                               lpszFind : ARRAY OF CHAR) : INTEGER;
(* LB_SELECTSTRING *)

PROCEDURE ListBox_SelectItemData(hwndCtl : HWND;
                                 indexStart : DWORD;
                                 data : DWORD) : INTEGER;
(* LB_SELECTSTRING *)

PROCEDURE ListBox_GetSel(hwndCtl : HWND; index : DWORD) : INTEGER;
(* LB_GETSEL *)

PROCEDURE ListBox_GetSelCount(hwndCtl : HWND) : INTEGER;
(* LB_GETSELCOUNT *)

PROCEDURE ListBox_GetTopIndex(hwndCtl : HWND) : INTEGER;
(* LB_GETTOPINDEX *)

PROCEDURE ListBox_GetSelItems(hwndCtl : HWND;
                              cItems : DWORD;
                              VAR OUT lpItems : ARRAY OF INTEGER) : INTEGER;
(* LB_GETSELITEMS *)

PROCEDURE ListBox_SetTopIndex(hwndCtl : HWND; indexTop : DWORD) : INTEGER;
(* LB_SETTOPINDEX *)

PROCEDURE ListBox_SetColumnWidth(hwndCtl : HWND; cxColumn : DWORD);
(* LB_SETCOLUMNWIDTH *)

PROCEDURE ListBox_GetHorizontalExtent(hwndCtl : HWND) : INTEGER;
(* LB_GETHORIZONTALEXTENT *)

PROCEDURE ListBox_SetHorizontalExtent(hwndCtl : HWND; cxExtent : DWORD);
(* LB_SETHORIZONTALEXTENT *)

PROCEDURE ListBox_SetTabStops(hwndCtl : HWND;
                              cTabs : DWORD;
                              lpTabs : ARRAY OF INTEGER) : BOOL;
(* LB_SETTABSTOPS *)

PROCEDURE ListBox_GetItemRect(hwndCtl : HWND;
                              index : DWORD;
                              VAR lprc : RECT) : INTEGER;
(* LB_GETITEMRECT *)

PROCEDURE ListBox_SetCaretIndex(hwndCtl : HWND; index : DWORD) : INTEGER;
(* LB_SETCARETINDEX *)

PROCEDURE ListBox_GetCaretIndex(hwndCtl : HWND) : INTEGER;
(* LB_GETCARETINDEX *)

PROCEDURE ListBox_FindStringExact(hwndCtl : HWND;
                                  indexStart : DWORD;
                                  lpszFind : ARRAY OF CHAR) : INTEGER;
(* LB_FINDSTRINGEXACT *)

PROCEDURE ListBox_SetItemHeight(hwndCtl : HWND;
                                index : DWORD;
                                cy : WORD) : INTEGER;
(* LB_SETITEMHEIGHT *)

PROCEDURE ListBox_GetItemHeight(hwndCtl : HWND;
                                index : DWORD) : INTEGER;
(* LB_GETITEMHEIGHT *)

PROCEDURE ListBox_Dir(hwndCtl : HWND;
                      attrs : DWORD;
                      lpszFileSpec : ARRAY OF CHAR) : INTEGER;
(* LB_DIR *)

PROCEDURE ComboBox_Enable(hwndCtl : HWND; fEnable : BOOL) : BOOL;
(* implemented as a call EnableWindow *)
(* fEnable = TRUE to enable the window, FALSE to disable *)

PROCEDURE ComboBox_GetText(hwndCtl : HWND;
                           VAR lpch : ARRAY OF CHAR;
                           cchMax : INTEGER) : INTEGER;
(* implemented as a call To GetWindowText *)
(* cchMax = the maximum number of character to retrieve *)

PROCEDURE ComboBox_GetTextLength(hwndCtl : HWND) : INTEGER;
(* implemented as a call To GetWindowTextLength *)

PROCEDURE ComboBox_SetText(hwndCtl : HWND; lpsz : ARRAY OF CHAR) : BOOL;
(* implemented as a call To SetWindowText *)
(* returns true if successfull *)

PROCEDURE ComboBox_LimitText(hwndCtl : HWND; cchLimit : DWORD) : INTEGER;
(* CB_LIMITTEXT *)

PROCEDURE ComboBox_GetEditSel(hwndCtl : HWND; VAR startPos, endPos : INTEGER);
(* CB_GETEDITSEL *)

PROCEDURE ComboBox_SetEditSel(hwndCtl : HWND;
                              startPos, endPos : INTEGER) : BOOL;
(* CB_SETEDITSEL *)

PROCEDURE ComboBox_GetCount(hwndCtl : HWND) : INTEGER;
(* CB_GETCOUNT *)

PROCEDURE ComboBox_ResetContent(hwndCtl : HWND) : INTEGER;
(* CB_RESETCONTENT *)

PROCEDURE ComboBox_AddString(hwndCtl : HWND;
                             lpsz : ARRAY OF CHAR) : INTEGER;
(* CB_ADDSTRING *)

PROCEDURE ComboBox_InsertString(hwndCtl : HWND;
                                index : INTEGER;
                                lpsz : ARRAY OF CHAR) : INTEGER;
(* CB_INSERTSTRING *)

PROCEDURE ComboBox_AddItemData(hwndCtl : HWND; data : DWORD) : INTEGER;
(* CB_ADDSTRING *)

PROCEDURE ComboBox_InsertItemData(hwndCtl : HWND;
                                  index : DWORD;
                                  data : DWORD) : INTEGER;
(* CB_INSERTSTRING *)

PROCEDURE ComboBox_DeleteString(hwndCtl : HWND;
                                index : INTEGER) : INTEGER;
(* CB_DELETESTRING *)

PROCEDURE ComboBox_GetLBTextLen(hwndCtl : HWND; index : DWORD) : INTEGER;
(* CB_GETLBTEXTLN *)

PROCEDURE ComboBox_GetLBText(hwndCtl : HWND;
                             index : DWORD;
                             VAR OUT lpszBuffer : ARRAY OF CHAR) : INTEGER;
(* CB_GETLBTEXT *)

PROCEDURE ComboBox_GetItemData(hwndCtl : HWND; index : DWORD) : LRESULT;
(* CB_GETITEMDATA *)

PROCEDURE ComboBox_SetItemData(hwndCtl : HWND;
                               index, data : DWORD) : INTEGER;
(* CB_SETITEMDATA *)

PROCEDURE ComboBox_FindString(hwndCtl : HWND;
                              indexStart : INTEGER;
                              lpszFind : ARRAY OF CHAR) : INTEGER;
(* CB_FINDSTRING *)

PROCEDURE ComboBox_FindItemData(hwndCtl : HWND;
                                indexStart, data : INTEGER) : INTEGER;
(* CB_FINDSTRING *)

PROCEDURE ComboBox_GetCurSel(hwndCtl : HWND) : INTEGER;
(* CB_GETCURSEL *)

PROCEDURE ComboBox_SetCurSel(hwndCtl : HWND; index : DWORD) : INTEGER;
(* CB_SETCURSEL *)

PROCEDURE ComboBox_SelectString(hwndCtl : HWND;
                                indexStart : DWORD;
                                lpszSelect : ARRAY OF CHAR) : INTEGER;
(* CG_SELECTSTRING *)

PROCEDURE ComboBox_SelectItemData(hwndCtl : HWND;
                                  indexStart, data : DWORD) : INTEGER;
(* CB_SELECTSTRING *)

PROCEDURE ComboBox_Dir(hwndCtl : HWND;
                       attrs : DWORD;
                       lpszFileSpec : ARRAY OF CHAR) : INTEGER;
(* CB_DIR *)

PROCEDURE ComboBox_ShowDropdown(hwndCtl : HWND; fShow : BOOL) : BOOL;
(* CB_SHOWDROPDOWN *)

PROCEDURE ComboBox_FindStringExact(hwndCtl : HWND;
                                   indexStart : INTEGER;
                                   lpszFind : ARRAY OF CHAR) : INTEGER;
(* CB_FINDSTRINGEXACT *)

PROCEDURE ComboBox_GetDroppedState(hwndCtl : HWND) : BOOL;
(* CB_GETDROPPEDSTATE *)

PROCEDURE ComboBox_GetDroppedControlRect(hwndCtl : HWND; VAR lprc : RECT);
(* CB_GETDROPPEDCONTROLRECT *)

PROCEDURE ComboBox_GetItemHeight(hwndCtl : HWND) : INTEGER;
(* CB_GETITEMHEIGHT *)

PROCEDURE ComboBox_SetItemHeight(hwndCtl : HWND; cyItem : DWORD) : INTEGER;
(* CB_SETITEMHEIGHT *)

PROCEDURE ComboBox_GetExtendedUI(hwndCtl : HWND) : UINT;
(* CB_GETEXTENDEDUI *)

PROCEDURE ComboBox_SetExtendedUI(hwndCtl : HWND; flags : UINT) : INTEGER;
(* CB_SETEXTENDEDUI *)

PROCEDURE ComboBox_GetTopIndex(hwndCtl : HWND) : INTEGER;
(* CB_GETTOPINDEX *)

PROCEDURE ComboBox_SetTopIndex(hwndCtl : HWND; indexTop : DWORD) : INTEGER;
(* CB_SETTOPINDEX *)

END WINX.

(*
* Copyright (c) 1985-2000, Microsoft Corp. All rights reserved.             *
*)
(* Conversion from Microsoft WIN32 SDK C source to Modula-2 source *)
(* Copyright (c) 1995-2000, Stony Brook Software. All rights reserved. *)

DEFINITION MODULE WINVER;

FROM WIN32 IMPORT
    DWORD, UINT, LPVOID, BOOL;

FROM WINUSER IMPORT
    RT_VERSION;

<*/CALLS:WIN32SYSTEM*>
<*/NOHIGH*>
<*/ALIGN:8/NOPACK*>

CONST
    VS_FILE_INFO         = RT_VERSION;
    VS_VERSION_INFO      = 1;
    VS_USER_DEFINED      = 100;
    VS_FFI_SIGNATURE     = 0FEEF04BDh;
    VS_FFI_STRUCVERSION  = 000010000h;
    VS_FFI_FILEFLAGSMASK = 00000003Fh;
    VS_FF_DEBUG          = 000000001h;
    VS_FF_PRERELEASE     = 000000002h;
    VS_FF_PATCHED        = 000000004h;
    VS_FF_PRIVATEBUILD   = 000000008h;
    VS_FF_INFOINFERRED   = 000000010h;
    VS_FF_SPECIALBUILD   = 000000020h;
    VOS_UNKNOWN          = 000000000h;
    VOS_DOS              = 000010000h;
    VOS_OS216            = 000020000h;
    VOS_OS232            = 000030000h;
    VOS_NT               = 000040000h;

    VOS__BASE            = 00000000h;
    VOS__WINDOWS16       = 00000001h;
    VOS__PM16            = 00000002h;
    VOS__PM32            = 00000003h;
    VOS__WINDOWS32       = 00000004h;

    VOS_BASE            = 000000000h;
    VOS_WINDOWS16       = 000000001h;
    VOS_PM16            = 000000002h;
    VOS_PM32            = 000000003h;
    VOS_WINDOWS32       = 000000004h;
    VOS_DOS_WINDOWS16    = 000010001h;
    VOS_DOS_WINDOWS32    = 000010004h;
    VOS_OS216_PM16       = 000020002h;
    VOS_OS232_PM32       = 000030003h;
    VOS_NT_WINDOWS32     = 000040004h;
    VFT_UNKNOWN          = 000000000h;
    VFT_APP              = 000000001h;
    VFT_DLL              = 000000002h;
    VFT_DRV              = 000000003h;
    VFT_FONT             = 000000004h;
    VFT_VXD              = 000000005h;
    VFT_STATIC_LIB       = 000000007h;
    VFT2_UNKNOWN         = 000000000h;
    VFT2_DRV_PRINTER     = 000000001h;
    VFT2_DRV_KEYBOARD    = 000000002h;
    VFT2_DRV_LANGUAGE    = 000000003h;
    VFT2_DRV_DISPLAY     = 000000004h;
    VFT2_DRV_MOUSE       = 000000005h;
    VFT2_DRV_NETWORK     = 000000006h;
    VFT2_DRV_SYSTEM      = 000000007h;
    VFT2_DRV_INSTALLABLE = 000000008h;
    VFT2_DRV_SOUND       = 000000009h;
    VFT2_DRV_COMM        = 00000000Ah;
    VFT2_DRV_INPUTMETHOD = 00000000Bh;

    VFT2_FONT_RASTER     = 000000001h;
    VFT2_FONT_VECTOR     = 000000002h;
    VFT2_FONT_TRUETYPE   = 000000003h;
    VFFF_ISSHAREDFILE    = 00001h;
    VFF_CURNEDEST        = 00001h;
    VFF_FILEINUSE        = 00002h;
    VFF_BUFFTOOSMALL     = 00004h;
    VIFF_FORCEINSTALL    = 00001h;
    VIFF_DONTDELETEOLD   = 00002h;
    VIF_TEMPFILE         = 000000001h;
    VIF_MISMATCH         = 000000002h;
    VIF_SRCOLD           = 000000004h;
    VIF_DIFFLANG         = 000000008h;
    VIF_DIFFCODEPG       = 000000010h;
    VIF_DIFFTYPE         = 000000020h;
    VIF_WRITEPROT        = 000000040h;
    VIF_FILEINUSE        = 000000080h;
    VIF_OUTOFSPACE       = 000000100h;
    VIF_ACCESSVIOLATION  = 000000200h;
    VIF_SHARINGVIOLATION = 000000400h;
    VIF_CANNOTCREATE     = 000000800h;
    VIF_CANNOTDELETE     = 000001000h;
    VIF_CANNOTRENAME     = 000002000h;
    VIF_CANNOTDELETECUR  = 000004000h;
    VIF_OUTOFMEMORY      = 000008000h;
    VIF_CANNOTREADSRC    = 000010000h;
    VIF_CANNOTREADDST    = 000020000h;
    VIF_BUFFTOOSMALL     = 000040000h;

TYPE
    VS_FIXEDFILEINFO = RECORD
          dwSignature    : DWORD;
          dwStrucVersion : DWORD;
          dwFileVersionMS: DWORD;
          dwFileVersionLS: DWORD;
          dwProductVersionMS: DWORD;
          dwProductVersionLS: DWORD;
          dwFileFlagsMask: DWORD;
          dwFileFlags    : DWORD;
          dwFileOS       : DWORD;
          dwFileType     : DWORD;
          dwFileSubtype  : DWORD;
          dwFileDateMS   : DWORD;
          dwFileDateLS   : DWORD;
    END;


PROCEDURE VerFindFileA(uFlags : DWORD;
                       szFileName : ARRAY OF ACHAR;
                       szWinDir : ARRAY OF ACHAR;
                       VAR szAppDir : ARRAY OF ACHAR;
                       VAR szCurDir : ARRAY OF ACHAR;
                       VAR lpuCurDirLen : UINT;
                       VAR szDestDir : ARRAY OF ACHAR;
                       VAR lpuDestDirLen : UINT) : DWORD;

PROCEDURE VerFindFileW(uFlags : DWORD;
                       szFileName : ARRAY OF UCHAR;
                       szWinDir : ARRAY OF UCHAR;
                       VAR szAppDir : ARRAY OF UCHAR;
                       VAR szCurDir : ARRAY OF UCHAR;
                       VAR lpuCurDirLen : UINT;
                       VAR szDestDir : ARRAY OF UCHAR;
                       VAR lpuDestDirLen : UINT) : DWORD;

%IF UNICODE %THEN
PROCEDURE VerFindFile = VerFindFileW;
%ELSE
PROCEDURE VerFindFile = VerFindFileA;
%END

PROCEDURE VerInstallFileA(uFlags : DWORD;
                          szSrcFileName : ARRAY OF ACHAR;
                          szDestFileName : ARRAY OF ACHAR;
                          szSrcDir : ARRAY OF ACHAR;
                          szDestDir : ARRAY OF ACHAR;
                          szCurDir : ARRAY OF ACHAR;
                          VAR szTmpFile : ARRAY OF ACHAR;
                          VAR lpuTmpFileLen : UINT) : DWORD;

PROCEDURE VerInstallFileW(uFlags : DWORD;
                          szSrcFileName : ARRAY OF UCHAR;
                          szDestFileName : ARRAY OF UCHAR;
                          szSrcDir : ARRAY OF UCHAR;
                          szDestDir : ARRAY OF UCHAR;
                          szCurDir : ARRAY OF UCHAR;
                          VAR szTmpFile : ARRAY OF UCHAR;
                          VAR lpuTmpFileLen : UINT) : DWORD;

%IF UNICODE %THEN
PROCEDURE VerInstallFile = VerInstallFileW;
%ELSE
PROCEDURE VerInstallFile = VerInstallFileA;
%END


PROCEDURE GetFileVersionInfoSizeA(lptstrFilename : ARRAY OF ACHAR;
                                  VAR lpdwHandle : DWORD) : DWORD;

PROCEDURE GetFileVersionInfoSizeW(lptstrFilename : ARRAY OF UCHAR;
                                  VAR lpdwHandle : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetFileVersionInfoSize = GetFileVersionInfoSizeW;
%ELSE
PROCEDURE GetFileVersionInfoSize = GetFileVersionInfoSizeA;
%END

PROCEDURE GetFileVersionInfoA(lptstrFilename : ARRAY OF ACHAR;
                              dwHandle : DWORD;
                              dwLen : DWORD;
                              lpData : LPVOID) : BOOL;

PROCEDURE GetFileVersionInfoW(lptstrFilename : ARRAY OF UCHAR;
                              dwHandle : DWORD;
                              dwLen : DWORD;
                              lpData : LPVOID) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetFileVersionInfo = GetFileVersionInfoW;
%ELSE
PROCEDURE GetFileVersionInfo = GetFileVersionInfoA;
%END

PROCEDURE VerLanguageNameA(wLang : DWORD;
                           VAR szLang : ARRAY OF ACHAR;
                           nSize : DWORD) : DWORD;

PROCEDURE VerLanguageNameW(wLang : DWORD;
                           VAR szLang : ARRAY OF UCHAR;
                           nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE VerLanguageName = VerLanguageNameW;
%ELSE
PROCEDURE VerLanguageName = VerLanguageNameA;
%END

PROCEDURE VerQueryValueA(pBlock : LPVOID;
                         lpSubBlock : ARRAY OF ACHAR;
                         VAR lplpBuffer : LPVOID;
                         VAR puLen : UINT) : BOOL;

PROCEDURE VerQueryValueW(pBlock : LPVOID;
                         lpSubBlock : ARRAY OF UCHAR;
                         VAR lplpBuffer : LPVOID;
                         VAR puLen : UINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE VerQueryValue = VerQueryValueW;
%ELSE
PROCEDURE VerQueryValue = VerQueryValueA;
%END

END WINVER.

DEFINITION MODULE WINSOCK2;
(* Winsock2.h -- definitions to be used with the WinSock 2 DLL and
 *               WinSock 2 applications.
 *
 * This header file corresponds to version 2.2.x of the WinSock API
 * specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 *)
(* Conversion from Microsoft WIN32 SDK C source to Modula-2 source *)
(* Copyright (c) 1999-2000, Stony Brook Software. All rights reserved. *)

FROM SYSTEM IMPORT
    ADDRESS, CAST, LOC, SWAPENDIAN;

FROM WIN32 IMPORT
    BOOL, WINT, LPSTR, ULONG, LONG, WORD, FARPROC, HWND, LPARAM,
    HANDLE, LPHANDLE, DWORD, PVOID, OVERLAPPED, LPOVERLAPPED,
    NULL, MAXIMUM_WAIT_OBJECTS, WAIT_OBJECT_0, WAIT_IO_COMPLETION,
    WAIT_TIMEOUT, INFINITE, GUID, LPGUID, LPWSTR;

FROM WINERROR IMPORT
    ERROR_IO_PENDING, ERROR_IO_INCOMPLETE, ERROR_INVALID_HANDLE,
    ERROR_INVALID_PARAMETER, ERROR_NOT_ENOUGH_MEMORY, ERROR_OPERATION_ABORTED;

FROM QOS IMPORT
    FLOWSPEC;

(*
 * Ensure structures are packed consistently.
 *)

<*/CALLS:WIN32SYSTEM*>
<*/NOHIGH*>
<*/ALIGN:4/NOPACK*>

(*
 * Default: include function prototypes, don't include function typedefs.
 *)

(*
 * Define the current Winsock version. To build an earlier Winsock version
 * application redefine this value prior to including Winsock2.h.
 *)

CONST
    WINSOCK_VERSION = (2 SHL 8) BOR 2;

(*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 *)
TYPE
    u_char      = CARDINAL8;
    short       = INTEGER16;
    u_short     = CARDINAL16;
    int         = INTEGER32;
    u_int       = CARDINAL32;
    u_long      = CARDINAL32;
    long        = INTEGER32;

(*
 * The new type to be used in all
 * instances which refer to sockets.
 *)
    SOCKET              = u_int;

(*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be >= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK2.H EXACTLY AS SHOWN HERE.
 *)
CONST
    FD_SETSIZE       = 64;(*this can be set to larger values*)

TYPE
    fd_set =
    RECORD
    fd_count    : u_int;               (* how many are SET? *)
    fd_array    : ARRAY [0..FD_SETSIZE-1] OF SOCKET;   (* an array of SOCKETs *)
    END;
    LPFD_SET    = POINTER TO fd_set;
    PFD_SET     = LPFD_SET;

PROCEDURE __WSAFDIsSet(sock : SOCKET; fd_set : fd_set) : INTEGER;

<*/PUSH/CALLS:StonyBrook*>
(* macros *)
PROCEDURE FD_CLR(fd : SOCKET; VAR OUT set : fd_set);

PROCEDURE FD_SET(fd : SOCKET; VAR INOUT set : fd_set);

PROCEDURE FD_ZERO(VAR OUT set : fd_set); MACRO;
BEGIN
    set.fd_count := 0;
END FD_ZERO;

PROCEDURE FD_ISSET(fd : SOCKET; set : fd_set) : BOOL; MACRO;
BEGIN
    RETURN __WSAFDIsSet(fd, set) <> 0;
END FD_ISSET;
<*/POP*>

(*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 *)
TYPE
    timeval =
    RECORD
    tv_sec      : long;         (* seconds *)
    tv_usec     : long;        (* and microseconds *)
    END;
    TIMEVAL = timeval;
    PTIMEVAL = POINTER TO TIMEVAL;
    LPTIMEVAL = PTIMEVAL;

(*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 *)
<*/PUSH/CALLS:StonyBrook*>
(* macros *)
PROCEDURE timerisset(tvp : timeval) : BOOLEAN;

PROCEDURE timercmpequal(tvp : timeval; uvp : timeval) : BOOL;

PROCEDURE timercmpless(tvp : timeval; uvp : timeval) : BOOL;

PROCEDURE timercmpgreater(tvp : timeval; uvp : timeval) : BOOL;

PROCEDURE timerclear(VAR tvp : timeval);
<*/POP*>

(*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 *)
CONST
    IOCPARM_MASK    =07fh;            (* parameters must be < 128 bytes *)
    IOC_VOID        =VAL(LONG, 020000000h);      (* no parameters *)
    IOC_OUT         =VAL(LONG, 040000000h);      (* copy out parameters *)
    IOC_IN          =CAST(LONG, 080000000h);      (* copy in parameters *)
    IOC_INOUT       =(IOC_IN BOR IOC_OUT);
                                        (* 0x20000000 distinguishes new &
                                           old ioctl's *)

    FIONREAD    =IOC_OUT BOR(* get # bytes to read *)
                 ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                 (VAL(LONG, 'f') SHL 8) BOR 127;

    FIONBIO     =IOC_IN BOR(* set/clear non-blocking i/o *)
                 ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                 (VAL(LONG, 'f') SHL 8) BOR 126;

    FIOASYNC    =IOC_IN BOR(* set/clear async i/o *)
                 ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                 (VAL(LONG, 'f') SHL 8) BOR 125;

(* Socket I/O Controls *)
    SIOCSHIWAT  =IOC_IN BOR
                 ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                 (VAL(LONG, 's') SHL 8) BOR 0;

    SIOCGHIWAT =IOC_OUT BOR
                ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                (VAL(LONG, 's') SHL 8) BOR 1;

    SIOCSLOWAT  =IOC_IN BOR
                 ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                 (VAL(LONG, 's') SHL 8) BOR 2;

    SIOCGLOWAT =IOC_OUT BOR
                ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                (VAL(LONG, 's') SHL 8) BOR 3;

    SIOCATMARK =IOC_OUT BOR
                ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                (VAL(LONG, 's') SHL 8) BOR 7;

(*
 * Structures returned by network data base library, taken from the
 * BSD file netdb.h.  All addresses are supplied in host order, and
 * returned in network order (suitable for use in system calls).
 *)

TYPE
    hostent = RECORD
          h_name         : LPSTR;(* official name of host *)
          h_aliases      : POINTER TO ARRAY [0..0] OF LPSTR;(* alias list *)
          h_addrtype     : short;(* host address type *)
          h_length       : short;(* length of address *)
          h_addr_list    : POINTER TO ARRAY [0..0] OF ADDRESS;(* list of addresses *)
    END;

(*
 * It is assumed here that a network number
 * fits in 32 bits.
 *)
    <*/PUSH/NOWARN:A*>
    netent = RECORD
          n_name         : LPSTR;(* official name of net *)
          n_aliases      : POINTER TO ARRAY [0..0] OF LPSTR;(* alias list *)
          n_addrtype     : short;(* net address type *)
          n_net          : u_long;(* network # *)
    END;

    servent = RECORD
          s_name         : LPSTR;(* official service name *)
          s_aliases      : POINTER TO ARRAY [0..0] OF LPSTR;(* alias list *)
          s_port         : short;(* port # *)
          s_proto        : LPSTR;(* protocol to use *)
    END;
    <*/POP*>

    protoent = RECORD
          p_name         : LPSTR;(* official protocol name *)
          p_aliases      : POINTER TO ARRAY [0..0] OF LPSTR;(* alias list *)
          p_proto        : short;(* protocol # *)
    END;

    HOSTENT              = hostent;
    LPHOSTENT            = POINTER TO HOSTENT;
    SERVENT              = servent;
    LPSERVENT            = POINTER TO SERVENT;
    PROTOENT             = protoent;
    LPPROTOENT           = POINTER TO PROTOENT;
    PHOSTENT             = LPHOSTENT;
    PSERVENT             = LPSERVENT;
    PPROTOENT            = LPPROTOENT;

(*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 *)

(*
 * Protocols
 *)
CONST
    IPPROTO_IP              =0;               (* dummy for IP *)
    IPPROTO_ICMP            =1;               (* control message protocol *)
    IPPROTO_IGMP            =2;               (* internet group management protocol *)
    IPPROTO_GGP             =3;               (* gateway^2 (deprecated) *)
    IPPROTO_TCP             =6;               (* tcp *)
    IPPROTO_PUP             =12;              (* pup *)
    IPPROTO_UDP             =17;              (* user datagram protocol *)
    IPPROTO_IDP             =22;              (* xns idp *)
    IPPROTO_ND              =77;              (* UNOFFICIAL net disk proto *)

    IPPROTO_RAW             =255;             (* raw IP packet *)
    IPPROTO_MAX             =256;

(*
 * Port/socket numbers: network standard functions
 *)
    IPPORT_ECHO             =7;
    IPPORT_DISCARD          =9;
    IPPORT_SYSTAT           =11;
    IPPORT_DAYTIME          =13;
    IPPORT_NETSTAT          =15;
    IPPORT_FTP              =21;
    IPPORT_TELNET           =23;
    IPPORT_SMTP             =25;
    IPPORT_TIMESERVER       =37;
    IPPORT_NAMESERVER       =42;
    IPPORT_WHOIS            =43;
    IPPORT_MTP              =57;

(*
 * Port/socket numbers: host specific functions
 *)
    IPPORT_TFTP             =69;
    IPPORT_RJE              =77;
    IPPORT_FINGER           =79;
    IPPORT_TTYLINK          =87;
    IPPORT_SUPDUP           =95;

(*
 * UNIX TCP sockets
 *)
    IPPORT_EXECSERVER       =512;
    IPPORT_LOGINSERVER      =513;
    IPPORT_CMDSERVER        =514;
    IPPORT_EFSSERVER        =520;

(*
 * UNIX UDP sockets
 *)
    IPPORT_BIFFUDP          =512;
    IPPORT_WHOSERVER        =513;
    IPPORT_ROUTESERVER      =520;
                                        (* 520+1 also used *)

(*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 *)
    IPPORT_RESERVED         =1024;

(*
 * Link numbers
 *)
    IMPLINK_IP              =155;
    IMPLINK_LOWEXPER        =156;
    IMPLINK_HIGHEXPER       =158;

(*
 * Internet address (old style... should be updated)
 *)
TYPE
    S_un_dummy0 = RECORD
          s_b1           : u_char;
          s_b2           : u_char;
          s_b3           : u_char;
          s_b4           : u_char;
    END;

    S_un_dummy1 = RECORD
          s_w1           : u_short;
          s_w2           : u_short;
    END;

    S_un = RECORD
        CASE : CARDINAL OF
          0 : S_un_b     : S_un_dummy0;
          |
          1 : S_un_w     : S_un_dummy1;
          |
          2 : S_addr     : u_long;
          ELSE
        END;
    END;

    in_addr = RECORD
        CASE : CARDINAL OF
        1 : S_un_b     : S_un_dummy0;
        |
        2 : S_un_w     : S_un_dummy1;
        |
        4 : S_addr     : u_long;
        ELSE
        END;
    END;

    IN_ADDR              = in_addr;
    LPIN_ADDR            = POINTER TO in_addr;
    PIN_ADDR             = LPIN_ADDR;

(*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 *)
<*/PUSH/CALLS:StonyBrook*>
(* macros *)
PROCEDURE IN_CLASSA(i : LONG) : BOOL;

PROCEDURE IN_CLASSB(i : LONG) : BOOL;

PROCEDURE IN_CLASSC(i : LONG) : BOOL;

PROCEDURE IN_CLASSD(i : long) : BOOL;

PROCEDURE IN_MULTICAST(i : long) : BOOL;
<*/POP*>

CONST
    IN_CLASSA_NET        = 0ff000000h;
    IN_CLASSA_NSHIFT     = 24;
    IN_CLASSA_HOST       = 000ffffffh;
    IN_CLASSA_MAX        = 128;

    IN_CLASSB_NET        = 0ffff0000h;
    IN_CLASSB_NSHIFT     = 16;
    IN_CLASSB_HOST       = 00000ffffh;
    IN_CLASSB_MAX        = 65536;

    IN_CLASSC_NET        = 0ffffff00h;
    IN_CLASSC_NSHIFT     = 8;
    IN_CLASSC_HOST       = 0000000ffh;

    IN_CLASSD_NET        = 0f0000000h;       (* These ones aren't really *)
    IN_CLASSD_NSHIFT     = 28;               (* net and host fields, but *)
    IN_CLASSD_HOST       = 00fffffffh;       (* routing needn't know.    *)

    INADDR_ANY           = CAST(u_long, 0);
    INADDR_LOOPBACK      = 07f000001h;
    INADDR_BROADCAST     = CAST(u_long, 0ffffffffh);
    INADDR_NONE          = 0ffffffffh;

    ADDR_ANY             = INADDR_ANY;

(*
 * Socket address, internet style.
 *)
TYPE
    sockaddr_in =
        RECORD
        sin_family      : short;
        sin_port        : u_short;
        sin_addr        : in_addr;
        sin_zero        : ARRAY [0..7] OF CHAR;
        END;
    SOCKADDR_IN = sockaddr_in;
    PSOCKADDR_IN = POINTER TO SOCKADDR_IN;
    LPSOCKADDR_IN = PSOCKADDR_IN;

CONST
    WSADESCRIPTION_LEN      =256;
    WSASYS_STATUS_LEN       =128;

TYPE
    <*/PUSH/NOWARN:A*>
    WSADATA = RECORD
          wVersion       : WORD;
          wHighVersion   : WORD;
          szDescription  : ARRAY [0..WSADESCRIPTION_LEN + 1 - 1] OF ACHAR;
          szSystemStatus : ARRAY [0..WSASYS_STATUS_LEN + 1 - 1] OF ACHAR;
          iMaxSockets    : u_short;
          iMaxUdpDg      : u_short;
          lpVendorInfo   : ADDRESS;
    END;
    <*/POP*>
    LPWSADATA            = POINTER TO WSADATA;

(*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 *)

(*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 *)
CONST
    INVALID_SOCKET  = CAST(SOCKET, BNOT 0);
    SOCKET_ERROR    = (-1);

(*
 * The  following  may  be used in place of the address family, socket type, or
 * protocol  in  a  call  to WSASocket to indicate that the corresponding value
 * should  be taken from the supplied WSAPROTOCOL_INFO structure instead of the
 * parameter itself.
 *)
    FROM_PROTOCOL_INFO = (-1);

(*
 * Types
 *)
    SOCK_STREAM     =1;               (* stream socket *)
    SOCK_DGRAM      =2;               (* datagram socket *)
    SOCK_RAW        =3;               (* raw-protocol interface *)
    SOCK_RDM        =4;               (* reliably-delivered message *)
    SOCK_SEQPACKET  =5;               (* sequenced packet stream *)

(*
 * Option flags per-socket.
 *)
    SO_DEBUG        =00001h;          (* turn on debugging info recording *)
    SO_ACCEPTCONN   =00002h;          (* socket has had listen() *)
    SO_REUSEADDR    =00004h;          (* allow local address reuse *)
    SO_KEEPALIVE    =00008h;          (* keep connections alive *)
    SO_DONTROUTE    =00010h;          (* just use interface addresses *)
    SO_BROADCAST    =00020h;          (* permit sending of broadcast msgs *)
    SO_USELOOPBACK  =00040h;          (* bypass hardware when possible *)
    SO_LINGER       =00080h;          (* linger on close if data present *)
    SO_OOBINLINE    =00100h;          (* leave received OOB data in line *)

    SO_DONTLINGER   = BNOT SO_LINGER;

(*
 * Additional options.
 *)
    SO_SNDBUF       =01001h;          (* send buffer size *)
    SO_RCVBUF       =01002h;          (* receive buffer size *)
    SO_SNDLOWAT     =01003h;          (* send low-water mark *)
    SO_RCVLOWAT     =01004h;          (* receive low-water mark *)
    SO_SNDTIMEO     =01005h;          (* send timeout *)
    SO_RCVTIMEO     =01006h;          (* receive timeout *)
    SO_ERROR        =01007h;          (* get error status and clear *)
    SO_TYPE         =01008h;          (* get socket type *)

(*
 * WinSock 2 extension -- new options
 *)
    SO_GROUP_ID       = 02001h;      (* ID of a socket group *)
    SO_GROUP_PRIORITY = 02002h;      (* the relative priority within a group*)
    SO_MAX_MSG_SIZE   = 02003h;      (* maximum message size *)
    SO_PROTOCOL_INFOA = 02004h;      (* WSAPROTOCOL_INFOA structure *)
    SO_PROTOCOL_INFOW = 02005h;      (* WSAPROTOCOL_INFOW structure *)

%IF UNICODE %THEN
    SO_PROTOCOL_INFO  =SO_PROTOCOL_INFOW;
%ELSE
    SO_PROTOCOL_INFO  =SO_PROTOCOL_INFOA;
%END

    PVD_CONFIG        = 03001h;          (* configuration info for service provider *)

(*
 * TCP options.
 *)
    TCP_NODELAY     = 00001h;

(*
 * Address families.
 *)
    AF_UNSPEC       = 0;               (* unspecified *)
(*
 * Although  AF_UNSPEC  is  defined for backwards compatibility, using
 * AF_UNSPEC for the "af" parameter when creating a socket is STRONGLY
 * DISCOURAGED.    The  interpretation  of  the  "protocol"  parameter
 * depends  on the actual address family chosen.  As environments grow
 * to  include  more  and  more  address families that use overlapping
 * protocol  values  there  is  more  and  more  chance of choosing an
 * undesired address family when AF_UNSPEC is used.
 *)
    AF_UNIX         = 1;               (* local to host (pipes, portals) *)
    AF_INET         = 2;               (* internetwork: UDP, TCP, etc. *)
    AF_IMPLINK      = 3;               (* arpanet imp addresses *)
    AF_PUP          = 4;               (* pup protocols: e.g. BSP *)
    AF_CHAOS        = 5;               (* mit CHAOS protocols *)
    AF_NS           = 6;               (* XEROX NS protocols *)
    AF_IPX          = AF_NS;           (* IPX protocols: IPX, SPX, etc. *)
    AF_ISO          = 7;               (* ISO protocols *)
    AF_OSI          =AF_ISO;          (* OSI is ISO *)
    AF_ECMA         = 8;               (* european computer manufacturers *)
    AF_DATAKIT      = 9;               (* datakit protocols *)
    AF_CCITT        = 10;              (* CCITT protocols, X.25 etc *)
    AF_SNA          = 11;              (* IBM SNA *)
    AF_DECnet       = 12;              (* DECnet *)
    AF_DLI          = 13;              (* Direct data link interface *)
    AF_LAT          = 14;              (* LAT *)
    AF_HYLINK       = 15;              (* NSC Hyperchannel *)
    AF_APPLETALK    = 16;              (* AppleTalk *)
    AF_NETBIOS      = 17;              (* NetBios-style addresses *)
    AF_VOICEVIEW    = 18;              (* VoiceView *)
    AF_FIREFOX      = 19;              (* Protocols from Firefox *)
    AF_UNKNOWN1     = 20;              (* Somebody is using this! *)
    AF_BAN          = 21;              (* Banyan *)
    AF_ATM          = 22;              (* Native ATM Services *)
    AF_INET6        = 23;              (* Internetwork Version 6 *)
    AF_CLUSTER      = 24;              (* Microsoft Wolfpack *)
    AF_12844        = 25;              (* IEEE 1284.4 WG AF *)


    AF_MAX          = 26;

(*
 * Structure used by kernel to store most
 * addresses.
 *)
TYPE
    sockaddr =
    RECORD
    sa_family   : u_short;              (* address family *)
    sa_data     : ARRAY [0..13] OF CHAR;            (* up to 14 bytes of direct address *)
    END;

(*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 *)
    sockproto =
    RECORD
    sp_family   : u_short;              (* address family *)
    sp_protocol : u_short;            (* protocol *)
    END;

(*
 * Protocol families, same as address families for now.
 *)
CONST
    PF_UNSPEC       =AF_UNSPEC;
    PF_UNIX         =AF_UNIX;
    PF_INET         =AF_INET;
    PF_IMPLINK      =AF_IMPLINK;
    PF_PUP          =AF_PUP;
    PF_CHAOS        =AF_CHAOS;
    PF_NS           =AF_NS;
    PF_IPX          =AF_IPX;
    PF_ISO          =AF_ISO;
    PF_OSI          =AF_OSI;
    PF_ECMA         =AF_ECMA;
    PF_DATAKIT      =AF_DATAKIT;
    PF_CCITT        =AF_CCITT;
    PF_SNA          =AF_SNA;
    PF_DECnet       =AF_DECnet;
    PF_DLI          =AF_DLI;
    PF_LAT          =AF_LAT;
    PF_HYLINK       =AF_HYLINK;
    PF_APPLETALK    =AF_APPLETALK;
    PF_VOICEVIEW    =AF_VOICEVIEW;
    PF_FIREFOX      =AF_FIREFOX;
    PF_UNKNOWN1     =AF_UNKNOWN1;
    PF_BAN          =AF_BAN;
    PF_ATM          =AF_ATM;
    PF_INET6        =AF_INET6;

    PF_MAX          =AF_MAX;

(*
 * Structure used for manipulating linger option.
 *)
TYPE
    linger =
    RECORD
    l_onoff     : u_short;                (* option on/off *)
    l_linger    : u_short;               (* linger time *)
    END;
    LINGER = linger;
    PLINGER = POINTER TO LINGER;
    LPLINGER = PLINGER;

(*
 * Level number for (get/set)sockopt() to apply to socket itself.
 *)
CONST
    SOL_SOCKET      = 0ffffh;          (* options for socket level *)

(*
 * Maximum queue length specifiable by listen.
 *)
    SOMAXCONN       = 07fffffffh;

    MSG_OOB         = 01h;             (* process out-of-band data *)
    MSG_PEEK        = 02h;             (* peek at incoming message *)
    MSG_DONTROUTE   = 04h;             (* send without using routing tables *)

    MSG_PARTIAL     = 08000h;          (* partial send or recv for message xport *)

(*
 * WinSock 2 extension -- new flags for WSASend(), WSASendTo(), WSARecv() and
 *                          WSARecvFrom()
 *)
    MSG_INTERRUPT   = 010h;            (* send/recv in the interrupt context *)

    MSG_MAXIOVLEN   = 16;

(*
 * Define constant based on rfc883, used by gethostbyxxxx() calls.
 *)
    MAXGETHOSTSTRUCT        = 1024;

(*
 * WinSock 2 extension -- bit values and indices for FD_XXX network events
 *)
    FD_READ_BIT      = 0;
    FD_READ          =(1 SHL FD_READ_BIT);

    FD_WRITE_BIT     = 1;
    FD_WRITE         =(1 SHL FD_WRITE_BIT);

    FD_OOB_BIT       = 2;
    FD_OOB           =(1 SHL FD_OOB_BIT);

    FD_ACCEPT_BIT    = 3;
    FD_ACCEPT        =(1 SHL FD_ACCEPT_BIT);

    FD_CONNECT_BIT   = 4;
    FD_CONNECT       =(1 SHL FD_CONNECT_BIT);

    FD_CLOSE_BIT     = 5;
    FD_CLOSE         =(1 SHL FD_CLOSE_BIT);

    FD_QOS_BIT       = 6;
    FD_QOS           =(1 SHL FD_QOS_BIT);

    FD_GROUP_QOS_BIT = 7;
    FD_GROUP_QOS     =(1 SHL FD_GROUP_QOS_BIT);

    FD_ROUTING_INTERFACE_CHANGE_BIT = 8;
    FD_ROUTING_INTERFACE_CHANGE     =(1 SHL FD_ROUTING_INTERFACE_CHANGE_BIT);

    FD_ADDRESS_LIST_CHANGE_BIT = 9;
    FD_ADDRESS_LIST_CHANGE     =(1 SHL FD_ADDRESS_LIST_CHANGE_BIT);

    FD_MAX_EVENTS    = 10;
    FD_ALL_EVENTS    =((1 SHL FD_MAX_EVENTS) - 1);


(*
 * All Windows Sockets error constants are biased by WSABASEERR from
 * the "normal"
 *)
    WSABASEERR              = 10000;
(*
 * Windows Sockets definitions of regular Microsoft C error constants
 *)
    WSAEINTR                = WSABASEERR+4;
    WSAEBADF                = WSABASEERR+9;
    WSAEACCES               = WSABASEERR+13;
    WSAEFAULT               = WSABASEERR+14;
    WSAEINVAL               = WSABASEERR+22;
    WSAEMFILE               = WSABASEERR+24;

(*
 * Windows Sockets definitions of regular Berkeley error constants
 *)
    WSAEWOULDBLOCK          = WSABASEERR+35;
    WSAEINPROGRESS          = WSABASEERR+36;
    WSAEALREADY             = WSABASEERR+37;
    WSAENOTSOCK             = WSABASEERR+38;
    WSAEDESTADDRREQ         = WSABASEERR+39;
    WSAEMSGSIZE             = WSABASEERR+40;
    WSAEPROTOTYPE           = WSABASEERR+41;
    WSAENOPROTOOPT          = WSABASEERR+42;
    WSAEPROTONOSUPPORT      = WSABASEERR+43;
    WSAESOCKTNOSUPPORT      = WSABASEERR+44;
    WSAEOPNOTSUPP           = WSABASEERR+45;
    WSAEPFNOSUPPORT         = WSABASEERR+46;
    WSAEAFNOSUPPORT         = WSABASEERR+47;
    WSAEADDRINUSE           = WSABASEERR+48;
    WSAEADDRNOTAVAIL        = WSABASEERR+49;
    WSAENETDOWN             = WSABASEERR+50;
    WSAENETUNREACH          = WSABASEERR+51;
    WSAENETRESET            = WSABASEERR+52;
    WSAECONNABORTED         = WSABASEERR+53;
    WSAECONNRESET           = WSABASEERR+54;
    WSAENOBUFS              = WSABASEERR+55;
    WSAEISCONN              = WSABASEERR+56;
    WSAENOTCONN             = WSABASEERR+57;
    WSAESHUTDOWN            = WSABASEERR+58;
    WSAETOOMANYREFS         = WSABASEERR+59;
    WSAETIMEDOUT            = WSABASEERR+60;
    WSAECONNREFUSED         = WSABASEERR+61;
    WSAELOOP                = WSABASEERR+62;
    WSAENAMETOOLONG         = WSABASEERR+63;
    WSAEHOSTDOWN            = WSABASEERR+64;
    WSAEHOSTUNREACH         = WSABASEERR+65;
    WSAENOTEMPTY            = WSABASEERR+66;
    WSAEPROCLIM             = WSABASEERR+67;
    WSAEUSERS               = WSABASEERR+68;
    WSAEDQUOT               = WSABASEERR+69;
    WSAESTALE               = WSABASEERR+70;
    WSAEREMOTE              = WSABASEERR+71;

(*
 * Extended Windows Sockets error constant definitions
 *)
    WSASYSNOTREADY          = WSABASEERR+91;
    WSAVERNOTSUPPORTED      = WSABASEERR+92;
    WSANOTINITIALISED       = WSABASEERR+93;
    WSAEDISCON              = WSABASEERR+101;
    WSAENOMORE              = WSABASEERR+102;
    WSAECANCELLED           = WSABASEERR+103;
    WSAEINVALIDPROCTABLE    = WSABASEERR+104;
    WSAEINVALIDPROVIDER     = WSABASEERR+105;
    WSAEPROVIDERFAILEDINIT  = WSABASEERR+106;
    WSASYSCALLFAILURE       = WSABASEERR+107;
    WSASERVICE_NOT_FOUND    = WSABASEERR+108;
    WSATYPE_NOT_FOUND       = WSABASEERR+109;
    WSA_E_NO_MORE           = WSABASEERR+110;
    WSA_E_CANCELLED         = WSABASEERR+111;
    WSAEREFUSED             = WSABASEERR+112;

(*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (when using the resolver). Note that these errors are
 * retrieved via WSAGetLastError() and must therefore follow
 * the rules for avoiding clashes with error numbers from
 * specific implementations or language run-time systems.
 * For this reason the codes are based at WSABASEERR+1001.
 * Note also that [WSA]NO_ADDRESS is defined only for
 * compatibility purposes.
 *)

(* macros *)
PROCEDURE h_errno() : CARDINAL [StonyBrook];

CONST
(* Authoritative Answer: Host not found *)
    WSAHOST_NOT_FOUND       = WSABASEERR+1001;
    HOST_NOT_FOUND          = WSAHOST_NOT_FOUND;

(* Non-Authoritative: Host not found, or SERVERFAIL *)
    WSATRY_AGAIN            = WSABASEERR+1002;
    TRY_AGAIN               = WSATRY_AGAIN;

(* Non-recoverable errors, FORMERR, REFUSED, NOTIMP *)
    WSANO_RECOVERY          = WSABASEERR+1003;
    NO_RECOVERY             = WSANO_RECOVERY;

(* Valid name, no data record of requested type *)
    WSANO_DATA              = WSABASEERR+1004;
    NO_DATA                 = WSANO_DATA;

(* no address, look for MX record *)
    WSANO_ADDRESS           =WSANO_DATA;
    NO_ADDRESS              =WSANO_ADDRESS;

(*
 * Define QOS related error return codes
 *
 *)
     WSA_QOS_RECEIVERS               = WSABASEERR + 1005;
         (* at least one Reserve has arrived *)
     WSA_QOS_SENDERS                 = WSABASEERR + 1006;
         (* at least one Path has arrived *)
     WSA_QOS_NO_SENDERS              = WSABASEERR + 1007;
         (* there are no senders *)
     WSA_QOS_NO_RECEIVERS            = WSABASEERR + 1008;
         (* there are no receivers *)
     WSA_QOS_REQUEST_CONFIRMED       = WSABASEERR + 1009;
         (* Reserve has been confirmed *)
     WSA_QOS_ADMISSION_FAILURE       = WSABASEERR + 1010;
         (* error due to lack of resources *)
     WSA_QOS_POLICY_FAILURE          = WSABASEERR + 1011;
         (* rejected for administrative reasons - bad credentials *)
     WSA_QOS_BAD_STYLE               = WSABASEERR + 1012;
         (* unknown or conflicting style *)
     WSA_QOS_BAD_OBJECT              = WSABASEERR + 1013;
         (* problem with some part of the filterspec or providerspecific
          * buffer in general *)
     WSA_QOS_TRAFFIC_CTRL_ERROR      = WSABASEERR + 1014;
         (* problem with some part of the flowspec *)
     WSA_QOS_GENERIC_ERROR           = WSABASEERR + 1015;
         (* general error *)

(*
 * Windows Sockets errors redefined as regular Berkeley error constants.
 * These are commented out in Windows NT to avoid conflicts with errno.h.
 * Use the WSA constants instead.
 *)
(*
    EWOULDBLOCK             WSAEWOULDBLOCK
    EINPROGRESS             WSAEINPROGRESS
    EALREADY                WSAEALREADY
    ENOTSOCK                WSAENOTSOCK
    EDESTADDRREQ            WSAEDESTADDRREQ
    EMSGSIZE                WSAEMSGSIZE
    EPROTOTYPE              WSAEPROTOTYPE
    ENOPROTOOPT             WSAENOPROTOOPT
    EPROTONOSUPPORT         WSAEPROTONOSUPPORT
    ESOCKTNOSUPPORT         WSAESOCKTNOSUPPORT
    EOPNOTSUPP              WSAEOPNOTSUPP
    EPFNOSUPPORT            WSAEPFNOSUPPORT
    EAFNOSUPPORT            WSAEAFNOSUPPORT
    EADDRINUSE              WSAEADDRINUSE
    EADDRNOTAVAIL           WSAEADDRNOTAVAIL
    ENETDOWN                WSAENETDOWN
    ENETUNREACH             WSAENETUNREACH
    ENETRESET               WSAENETRESET
    ECONNABORTED            WSAECONNABORTED
    ECONNRESET              WSAECONNRESET
    ENOBUFS                 WSAENOBUFS
    EISCONN                 WSAEISCONN
    ENOTCONN                WSAENOTCONN
    ESHUTDOWN               WSAESHUTDOWN
    ETOOMANYREFS            WSAETOOMANYREFS
    ETIMEDOUT               WSAETIMEDOUT
    ECONNREFUSED            WSAECONNREFUSED
    ELOOP                   WSAELOOP
    ENAMETOOLONG            WSAENAMETOOLONG
    EHOSTDOWN               WSAEHOSTDOWN
    EHOSTUNREACH            WSAEHOSTUNREACH
    ENOTEMPTY               WSAENOTEMPTY
    EPROCLIM                WSAEPROCLIM
    EUSERS                  WSAEUSERS
    EDQUOT                  WSAEDQUOT
    ESTALE                  WSAESTALE
    EREMOTE                 WSAEREMOTE
*)

(*
 * WinSock 2 extension -- new error codes and type definition
 *)

TYPE
    WSAEVENT                = HANDLE;
    LPWSAEVENT              = LPHANDLE;
    WSAOVERLAPPED           = OVERLAPPED;
    LPWSAOVERLAPPED         = LPOVERLAPPED;

CONST
    WSA_IO_PENDING          = ERROR_IO_PENDING;
    WSA_IO_INCOMPLETE       = ERROR_IO_INCOMPLETE;
    WSA_INVALID_HANDLE      = ERROR_INVALID_HANDLE;
    WSA_INVALID_PARAMETER   = ERROR_INVALID_PARAMETER;
    WSA_NOT_ENOUGH_MEMORY   = ERROR_NOT_ENOUGH_MEMORY;
    WSA_OPERATION_ABORTED   = ERROR_OPERATION_ABORTED;

    WSA_INVALID_EVENT       =CAST(WSAEVENT,NULL);
    WSA_MAXIMUM_WAIT_EVENTS = MAXIMUM_WAIT_OBJECTS;
    WSA_WAIT_FAILED         =CAST(DWORD, -1);
    WSA_WAIT_EVENT_0        = WAIT_OBJECT_0;
    WSA_WAIT_IO_COMPLETION  = WAIT_IO_COMPLETION;
    WSA_WAIT_TIMEOUT        = WAIT_TIMEOUT;
    WSA_INFINITE            = INFINITE;

(*
 * WinSock 2 extension -- WSABUF and QOS struct, include qos.h
 * to pull in FLOWSPEC and related definitions
 *)
TYPE
    WSABUF =
    RECORD
    len         : u_long;     (* the length of the buffer *)
    buf         : ADDRESS;     (* the pointer to the buffer *)
    END;
    LPWSABUF = POINTER TO WSABUF;

    QOS =
    RECORD
    SendingFlowspec     : FLOWSPEC;       (* the flow spec for data sending *)
    ReceivingFlowspec   : FLOWSPEC;     (* the flow spec for data receiving *)
    ProviderSpecific    : WSABUF;      (* additional provider specific stuff *)
    END;
    LPQOS = POINTER TO QOS;

(*
 * WinSock 2 extension -- manifest constants for return values of the condition function
 *)
CONST
    CF_ACCEPT       = 00000h;
    CF_REJECT      = 00001h;
    CF_DEFER        = 00002h;

(*
 * WinSock 2 extension -- manifest constants for shutdown()
 *)
    SD_RECEIVE      = 000h;
    SD_SEND         = 001h;
    SD_BOTH         = 002h;

(*
 * WinSock 2 extension -- data type and manifest constants for socket groups
 *)
 TYPE
    GROUP       = CARDINAL;

CONST
    SG_UNCONSTRAINED_GROUP   = 001h;
    SG_CONSTRAINED_GROUP     = 002h;

(*
 * WinSock 2 extension -- data type for WSAEnumNetworkEvents()
 *)
TYPE
    WSANETWORKEVENTS =
    RECORD
    lNetworkEvents      : long;
    iErrorCode          : ARRAY [0..FD_MAX_EVENTS-1] OF int;
    END;
    LPWSANETWORKEVENTS = POINTER TO WSANETWORKEVENTS;

(*
 * WinSock 2 extension -- WSAPROTOCOL_INFO structure and associated
 * manifest constants
 *)
CONST
    MAX_PROTOCOL_CHAIN = 7;

    BASE_PROTOCOL      = 1;
    LAYERED_PROTOCOL   = 0;

TYPE
    WSAPROTOCOLCHAIN =
    RECORD
    ChainLen    : int;                                 (* the length of the chain,     *)
                                                  (* length = 0 means layered protocol, *)
                                                  (* length = 1 means base protocol, *)
                                                  (* length > 1 means protocol chain *)
    ChainEntries        : ARRAY [0..MAX_PROTOCOL_CHAIN-1] OF DWORD;       (* a list of dwCatalogEntryIds *)
    END;
    LPWSAPROTOCOLCHAIN = POINTER TO WSAPROTOCOLCHAIN;

CONST
    WSAPROTOCOL_LEN  = 255;

TYPE
    WSAPROTOCOL_INFOA =
    RECORD
    dwServiceFlags1     : DWORD;
    dwServiceFlags2     : DWORD;
    dwServiceFlags3     : DWORD;
    dwServiceFlags4     : DWORD;
    dwProviderFlags     : DWORD;
    ProviderId          : GUID;
    dwCatalogEntryId    : DWORD;
    ProtocolChain       : WSAPROTOCOLCHAIN;
    iVersion            : int;
    iAddressFamily      : int;
    iMaxSockAddr        : int;
    iMinSockAddr        : int;
    iSocketType         : int;
    iProtocol           : int;
    iProtocolMaxOffset  : int;
    iNetworkByteOrder   : int;
    iSecurityScheme     : int;
    dwMessageSize       : DWORD;
    dwProviderReserved  : DWORD;
    szProtocol          : ARRAY [0..WSAPROTOCOL_LEN+1-1] OF CHAR;
    END;
    LPWSAPROTOCOL_INFOA = POINTER TO WSAPROTOCOL_INFOA;

    WSAPROTOCOL_INFOW =
    RECORD
    dwServiceFlags1     : DWORD;
    dwServiceFlags2     : DWORD;
    dwServiceFlags3     : DWORD;
    dwServiceFlags4     : DWORD;
    dwProviderFlags     : DWORD;
    ProviderId          : GUID;
    dwCatalogEntryId    : DWORD;
    ProtocolChain       : WSAPROTOCOLCHAIN;
    iVersion            : int;
    iAddressFamily      : int;
    iMaxSockAddr        : int;
    iMinSockAddr        : int;
    iSocketType         : int;
    iProtocol           : int;
    iProtocolMaxOffset  : int;
    iNetworkByteOrder   : int;
    iSecurityScheme     : int;
    dwMessageSize       : DWORD;
    dwProviderReserved  : DWORD;
    szProtocol          : ARRAY [0..WSAPROTOCOL_LEN+1-1] OF UCHAR;
    END;
    LPWSAPROTOCOL_INFOW = POINTER TO WSAPROTOCOL_INFOW;

%IF UNICODE %THEN
    WSAPROTOCOL_INFO    = WSAPROTOCOL_INFOW;
    LPWSAPROTOCOL_INFO  = LPWSAPROTOCOL_INFOW;
%ELSE
    WSAPROTOCOL_INFO    = WSAPROTOCOL_INFOA;
    LPWSAPROTOCOL_INFO  = LPWSAPROTOCOL_INFOA;
%END

CONST
(* Flag bit definitions for dwProviderFlags *)
    PFL_MULTIPLE_PROTO_ENTRIES          = 000000001h;
    PFL_RECOMMENDED_PROTO_ENTRY         = 000000002h;
    PFL_HIDDEN                          = 000000004h;
    PFL_MATCHES_PROTOCOL_ZERO           = 000000008h;

(* Flag bit definitions for dwServiceFlags1 *)
    XP1_CONNECTIONLESS                  = 000000001h;
    XP1_GUARANTEED_DELIVERY             = 000000002h;
    XP1_GUARANTEED_ORDER                = 000000004h;
    XP1_MESSAGE_ORIENTED                = 000000008h;
    XP1_PSEUDO_STREAM                   = 000000010h;
    XP1_GRACEFUL_CLOSE                  = 000000020h;
    XP1_EXPEDITED_DATA                  = 000000040h;
    XP1_CONNECT_DATA                    = 000000080h;
    XP1_DISCONNECT_DATA                 = 000000100h;
    XP1_SUPPORT_BROADCAST               = 000000200h;
    XP1_SUPPORT_MULTIPOINT              = 000000400h;
    XP1_MULTIPOINT_CONTROL_PLANE        = 000000800h;
    XP1_MULTIPOINT_DATA_PLANE           = 000001000h;
    XP1_QOS_SUPPORTED                   = 000002000h;
    XP1_INTERRUPT                       = 000004000h;
    XP1_UNI_SEND                        = 000008000h;
    XP1_UNI_RECV                        = 000010000h;
    XP1_IFS_HANDLES                     = 000020000h;
    XP1_PARTIAL_MESSAGE                 = 000040000h;

    BIGENDIAN                           = 00000h;
    LITTLEENDIAN                        = 00001h;

    SECURITY_PROTOCOL_NONE              = 00000h;

(*
 * WinSock 2 extension -- manifest constants for WSAJoinLeaf()
 *)
    JL_SENDER_ONLY    = 001h;
    JL_RECEIVER_ONLY  = 002h;
    JL_BOTH           = 004h;

(*
 * WinSock 2 extension -- manifest constants for WSASocket()
 *)
    WSA_FLAG_OVERLAPPED           = 001h;
    WSA_FLAG_MULTIPOINT_C_ROOT    = 002h;
    WSA_FLAG_MULTIPOINT_C_LEAF    = 004h;
    WSA_FLAG_MULTIPOINT_D_ROOT    = 008h;
    WSA_FLAG_MULTIPOINT_D_LEAF    = 010h;

(*
 * WinSock 2 extension -- manifest constants for WSAIoctl()
 *)
    IOC_UNIX                      = 000000000h;
    IOC_WS2                       = 008000000h;
    IOC_PROTOCOL                  = 010000000h;
    IOC_VENDOR                    = 018000000h;

    (*
    _WSAIO(x,y)                   (IOC_VOID BOR (x) BOR (y))
    _WSAIOR(x,y)                  (IOC_OUT BOR (x) BOR (y))
    _WSAIOW(x,y)                  (IOC_IN BOR (x) BOR (y))
    _WSAIORW(x,y)                 (IOC_INOUT BOR (x) BOR (y))
    *)

    SIO_ASSOCIATE_HANDLE          = (IOC_IN BOR IOC_WS2 BOR 1);
    SIO_ENABLE_CIRCULAR_QUEUEING  = (IOC_VOID BOR IOC_WS2 BOR 2);
    SIO_FIND_ROUTE                = (IOC_OUT BOR IOC_WS2 BOR 3);
    SIO_FLUSH                     = (IOC_VOID BOR IOC_WS2 BOR 4);
    SIO_GET_BROADCAST_ADDRESS     = (IOC_OUT BOR IOC_WS2 BOR 5);
    SIO_GET_EXTENSION_FUNCTION_POINTER  = (IOC_INOUT BOR IOC_WS2 BOR 6);
    SIO_GET_QOS                   = (IOC_INOUT BOR IOC_WS2 BOR 7);
    SIO_GET_GROUP_QOS             = (IOC_INOUT BOR IOC_WS2 BOR 8);
    SIO_MULTIPOINT_LOOPBACK       = (IOC_IN BOR IOC_WS2 BOR 9);
    SIO_MULTICAST_SCOPE           = (IOC_IN BOR IOC_WS2 BOR 10);
    SIO_SET_QOS                   = (IOC_IN BOR IOC_WS2 BOR 11);
    SIO_SET_GROUP_QOS             = (IOC_IN BOR IOC_WS2 BOR 12);
    SIO_TRANSLATE_HANDLE          = (IOC_INOUT BOR IOC_WS2 BOR 13);
    SIO_ROUTING_INTERFACE_QUERY   = (IOC_INOUT BOR IOC_WS2 BOR 20);
    SIO_ROUTING_INTERFACE_CHANGE  = (IOC_IN BOR IOC_WS2 BOR 21);
    SIO_ADDRESS_LIST_QUERY        = (IOC_OUT BOR IOC_WS2 BOR 22);
    SIO_ADDRESS_LIST_CHANGE       = (IOC_VOID BOR IOC_WS2 BOR 23);
    SIO_QUERY_TARGET_PNP_HANDLE   = (IOC_OUT BOR IOC_WS2 BOR 24);

(*
 * WinSock 2 extension -- manifest constants for SIO_TRANSLATE_HANDLE ioctl
 *)
    TH_NETDEV        = 000000001h;
    TH_TAPI          = 000000002h;


(*
 * Microsoft Windows Extended data types required for the functions to
 * convert   back  and  forth  between  binary  and  string  forms  of
 * addresses.
 *)
TYPE
    SOCKADDR     = sockaddr;
    PSOCKADDR    = POINTER TO SOCKADDR;
    LPSOCKADDR   = PSOCKADDR;

(*
 * Manifest constants and type definitions related to name resolution and
 * registration (RNR) API
 *)
    BLOB =
    RECORD
    cbSize : ULONG;
    pBlobData : ADDRESS;
    END;
    LPBLOB = POINTER TO BLOB;

(*
 * Service Install Flags
 *)
CONST
    SERVICE_MULTIPLE       = 000000001h;

(*
 *& Name Spaces
 *)

    NS_ALL                      = 0;

    NS_SAP                      =1;
    NS_NDS                      =2;
    NS_PEER_BROWSE              =3;

    NS_TCPIP_LOCAL              =10;
    NS_TCPIP_HOSTS              =11;
    NS_DNS                      =12;
    NS_NETBT                    =13;
    NS_WINS                     =14;

    NS_NBP                      =20;

    NS_MS                       =30;
    NS_STDA                     =31;
    NS_NTDS                     =32;

    NS_X500                     =40;
    NS_NIS                      =41;
    NS_NISPLUS                  =42;

    NS_WRQ                      =50;

(*
 * Resolution flags for WSAGetAddressByName().
 * Note these are also used by the 1.1 API GetAddressByName, so
 * leave them around.
 *)
    RES_UNUSED_1                = 000000001h;
    RES_FLUSH_CACHE             = 000000002h;
    RES_SERVICE                 = 000000004h;

(*
 * Well known value names for Service Types
 *)

    SERVICE_TYPE_VALUE_IPXPORTA      : ARRAY OF CHAR = {"IpxSocket"};
    SERVICE_TYPE_VALUE_IPXPORTW      : ARRAY OF UCHAR = {"IpxSocket"};
    SERVICE_TYPE_VALUE_SAPIDA        : ARRAY OF CHAR = {"SapId"};
    SERVICE_TYPE_VALUE_SAPIDW        : ARRAY OF UCHAR = {"SapId"};

    SERVICE_TYPE_VALUE_TCPPORTA      : ARRAY OF CHAR = {"TcpPort"};
    SERVICE_TYPE_VALUE_TCPPORTW      : ARRAY OF UCHAR = {"TcpPort"};

    SERVICE_TYPE_VALUE_UDPPORTA      : ARRAY OF CHAR = {"UdpPort"};
    SERVICE_TYPE_VALUE_UDPPORTW      : ARRAY OF UCHAR = {"UdpPort"};

    SERVICE_TYPE_VALUE_OBJECTIDA     : ARRAY OF CHAR = {"ObjectId"};
    SERVICE_TYPE_VALUE_OBJECTIDW     : ARRAY OF UCHAR = {"ObjectId"};

%IF UNICODE %THEN
    SERVICE_TYPE_VALUE_SAPID        =SERVICE_TYPE_VALUE_SAPIDW;
    SERVICE_TYPE_VALUE_TCPPORT      =SERVICE_TYPE_VALUE_TCPPORTW;
    SERVICE_TYPE_VALUE_UDPPORT      =SERVICE_TYPE_VALUE_UDPPORTW;
    SERVICE_TYPE_VALUE_OBJECTID     =SERVICE_TYPE_VALUE_OBJECTIDW;
%ELSE
    SERVICE_TYPE_VALUE_SAPID        =SERVICE_TYPE_VALUE_SAPIDA;
    SERVICE_TYPE_VALUE_TCPPORT      =SERVICE_TYPE_VALUE_TCPPORTA;
    SERVICE_TYPE_VALUE_UDPPORT      =SERVICE_TYPE_VALUE_UDPPORTA;
    SERVICE_TYPE_VALUE_OBJECTID     =SERVICE_TYPE_VALUE_OBJECTIDA;
%END

(*
 * SockAddr Information
 *)
TYPE
    SOCKET_ADDRESS =
    RECORD
    lpSockaddr          : LPSOCKADDR;
    iSockaddrLength     : WINT;
    END;
    PSOCKET_ADDRESS = POINTER TO SOCKET_ADDRESS;
    LPSOCKET_ADDRESS = PSOCKET_ADDRESS;

(*
 * CSAddr Information
 *)
    CSADDR_INFO =
    RECORD
    LocalAddr   : SOCKET_ADDRESS;
    RemoteAddr  : SOCKET_ADDRESS;
    iSocketType : WINT;
    iProtocol   : WINT;
    END;
    PCSADDR_INFO = POINTER TO CSADDR_INFO;
    LPCSADDR_INFO = PCSADDR_INFO;

(*
 * Address list returned via SIO_ADDRESS_LIST_QUERY
 *)
    SOCKET_ADDRESS_LIST =
    RECORD
    iAddressCount       : WINT;
    Address             : ARRAY [0..0] OF SOCKET_ADDRESS;
    END;
    LPSOCKET_ADDRESS_LIST = POINTER TO SOCKET_ADDRESS_LIST;

(*
 *  Address Family/Protocol Tuples
 *)
    AFPROTOCOLS =
    RECORD
    iAddressFamily      : WINT;
    iProtocol           : WINT;
    END;
    PAFPROTOCOLS = POINTER TO AFPROTOCOLS;
    LPAFPROTOCOLS = PAFPROTOCOLS;

(*
 * Client Query API Typedefs
 *)

(*
 * The comparators
 *)
    WSAECOMPARATOR = (COMP_EQUAL, COMP_NOTLESS) BIG;
    PWSAECOMPARATOR  = POINTER TO WSAECOMPARATOR;
    LPWSAECOMPARATOR = PWSAECOMPARATOR;

    WSAVERSION =
    RECORD
    dwVersion           : DWORD;
    ecHow               : WSAECOMPARATOR;
    END;
    PWSAVERSION = POINTER TO WSAVERSION;
    LPWSAVERSION = PWSAVERSION;

    WSAQUERYSETA =
    RECORD
    dwSize                      : DWORD;
    lpszServiceInstanceName     : LPSTR;
    lpServiceClassId            : LPGUID;
    lpVersion                   : LPWSAVERSION;
    lpszComment                 : LPSTR;
    dwNameSpace                 : DWORD;
    lpNSProviderId              : LPGUID;
    lpszContext                 : LPSTR;
    dwNumberOfProtocols         : DWORD;
    lpafpProtocols              : LPAFPROTOCOLS;
    lpszQueryString             : LPSTR;
    dwNumberOfCsAddrs           : DWORD;
    lpcsaBuffer                 : LPCSADDR_INFO;
    dwOutputFlags               : DWORD;
    lpBlob                      : LPBLOB;
    END;
    PWSAQUERYSETA = POINTER TO WSAQUERYSETA;
    LPWSAQUERYSETA = PWSAQUERYSETA;

    WSAQUERYSETW =
    RECORD
    dwSize                      : DWORD;
    lpszServiceInstanceName     : LPWSTR;
    lpServiceClassId            : LPGUID;
    lpVersion                   : LPWSAVERSION;
    lpszComment                 : LPWSTR;
    dwNameSpace                 : DWORD;
    lpNSProviderId              : LPGUID;
    lpszContext                 : LPWSTR;
    dwNumberOfProtocols         : DWORD;
    lpafpProtocols              : LPAFPROTOCOLS;
    lpszQueryString             : LPWSTR;
    dwNumberOfCsAddrs           : DWORD;
    lpcsaBuffer                 : LPCSADDR_INFO;
    dwOutputFlags               : DWORD;
    lpBlob                      : LPBLOB;
    END;
    PWSAQUERYSETW = POINTER TO WSAQUERYSETW;
    LPWSAQUERYSETW = PWSAQUERYSETW;

%IF UNICODE %THEN
    WSAQUERYSET         = WSAQUERYSETW;
    PWSAQUERYSET        = PWSAQUERYSETW;
    LPWSAQUERYSET       = LPWSAQUERYSETW;
%ELSE
    WSAQUERYSET         = WSAQUERYSETA;
    PWSAQUERYSET        = PWSAQUERYSETA;
    LPWSAQUERYSET       = LPWSAQUERYSETA;
%END

CONST
    LUP_DEEP                = 00001h;
    LUP_CONTAINERS          = 00002h;
    LUP_NOCONTAINERS        = 00004h;
    LUP_NEAREST             = 00008h;
    LUP_RETURN_NAME         = 00010h;
    LUP_RETURN_TYPE         = 00020h;
    LUP_RETURN_VERSION      = 00040h;
    LUP_RETURN_COMMENT      = 00080h;
    LUP_RETURN_ADDR         = 00100h;
    LUP_RETURN_BLOB         = 00200h;
    LUP_RETURN_ALIASES      = 00400h;
    LUP_RETURN_QUERY_STRING = 00800h;
    LUP_RETURN_ALL          = 00FF0h;
    LUP_RES_SERVICE         = 08000h;

    LUP_FLUSHCACHE       = 01000h;
    LUP_FLUSHPREVIOUS    = 02000h;


(* Return flags*)

    RESULT_IS_ALIAS      = 00001h;

(*
 * Service Address Registration and Deregistration Data Types.
 *)
TYPE
    WSAESETSERVICEOP =
    (
    RNRSERVICE_REGISTER,
    RNRSERVICE_DEREGISTER,
    RNRSERVICE_DELETE
    ) BIG;
    PWSAESETSERVICEOP = POINTER TO WSAESETSERVICEOP;
    LPWSAESETSERVICEOP = PWSAESETSERVICEOP;

(*
 * Service Installation/Removal Data Types.
 *)

    WSANSCLASSINFOA =
    RECORD
    lpszName    : LPSTR;
    dwNameSpace : DWORD;
    dwValueType : DWORD;
    dwValueSize : DWORD;
    lpValue     : PVOID;
    END;
    PWSANSCLASSINFOA = POINTER TO WSANSCLASSINFOA;
    LPWSANSCLASSINFOA = PWSANSCLASSINFOA;

    WSANSCLASSINFOW =
    RECORD
    lpszName    : LPWSTR;
    dwNameSpace : DWORD;
    dwValueType : DWORD;
    dwValueSize : DWORD;
    lpValue     : PVOID;
    END;
    PWSANSCLASSINFOW = POINTER TO WSANSCLASSINFOW;
    LPWSANSCLASSINFOW = PWSANSCLASSINFOW;

%IF UNICODE %THEN
    WSANSCLASSINFO      = WSANSCLASSINFOW;
    PWSANSCLASSINFO     = PWSANSCLASSINFOW;
    LPWSANSCLASSINFO    = LPWSANSCLASSINFOW;
%ELSE
    WSANSCLASSINFO      = WSANSCLASSINFOA;
    PWSANSCLASSINFO     = PWSANSCLASSINFOA;
    LPWSANSCLASSINFO    = LPWSANSCLASSINFOA;
%END

    WSASERVICECLASSINFOA =
    RECORD
    lpServiceClassId    : LPGUID;
    lpszServiceClassName        : LPSTR;
    dwCount             : DWORD;
    lpClassInfos        : LPWSANSCLASSINFOA;
    END;
    PWSASERVICECLASSINFOA = POINTER TO WSASERVICECLASSINFOA;
    LPWSASERVICECLASSINFOA = PWSASERVICECLASSINFOA;

    WSASERVICECLASSINFOW =
    RECORD
    lpServiceClassId    : LPGUID;
    lpszServiceClassName        : LPWSTR;
    dwCount             : DWORD;
    lpClassInfos        : LPWSANSCLASSINFOW;
    END;
    PWSASERVICECLASSINFOW = POINTER TO WSASERVICECLASSINFOW;
    LPWSASERVICECLASSINFOW = PWSASERVICECLASSINFOW;

%IF UNICODE %THEN
    WSASERVICECLASSINFO         = WSASERVICECLASSINFOW;
    PWSASERVICECLASSINFO        = PWSASERVICECLASSINFOW;
    LPWSASERVICECLASSINFO       = LPWSASERVICECLASSINFOW;
%ELSE
    WSASERVICECLASSINFO         = WSASERVICECLASSINFOA;
    PWSASERVICECLASSINFO        = PWSASERVICECLASSINFOA;
    LPWSASERVICECLASSINFO       = LPWSASERVICECLASSINFOA;
%END

    WSANAMESPACE_INFOA =
    RECORD
    NSProviderId        : GUID;
    dwNameSpace         : DWORD;
    fActive             : BOOL;
    dwVersion           : DWORD;
    lpszIdentifier      : LPSTR;
    END;
    PWSANAMESPACE_INFOA = POINTER TO WSANAMESPACE_INFOA;
    LPWSANAMESPACE_INFOA = PWSANAMESPACE_INFOA;

    WSANAMESPACE_INFOW =
    RECORD
    NSProviderId        : GUID;
    dwNameSpace         : DWORD;
    fActive             : BOOL;
    dwVersion           : DWORD;
    lpszIdentifier      : LPWSTR;
    END;
    PWSANAMESPACE_INFOW = POINTER TO WSANAMESPACE_INFOW;
    LPWSANAMESPACE_INFOW = PWSANAMESPACE_INFOW;

%IF UNICODE %THEN
    WSANAMESPACE_INFO   = WSANAMESPACE_INFOW;
    PWSANAMESPACE_INFO  = PWSANAMESPACE_INFOW;
    LPWSANAMESPACE_INFO = LPWSANAMESPACE_INFOW;
%ELSE
    WSANAMESPACE_INFO   = WSANAMESPACE_INFOA;
    PWSANAMESPACE_INFO  = PWSANAMESPACE_INFOA;
    LPWSANAMESPACE_INFO = LPWSANAMESPACE_INFOA;
%END

(* Socket function prototypes *)


PROCEDURE accept(s : SOCKET;
                 VAR addr : sockaddr;
                 VAR addrlen : int) : SOCKET;

PROCEDURE bind(s : SOCKET;
               addr : sockaddr;
               namelen : int) : int;

PROCEDURE closesocket(s : SOCKET) : int;

PROCEDURE connect(s : SOCKET;
                  name : sockaddr;
                  namelen : int) : int;

PROCEDURE ioctlsocket(s : SOCKET;
                      cmd : long;
                      VAR INOUT argp : u_long) : int;

PROCEDURE getpeername(s : SOCKET;
                      VAR name : sockaddr;
                      VAR namelen : int) : int;

PROCEDURE getsockname(s : SOCKET;
                      VAR name : sockaddr;
                      VAR namelen : WINT) : WINT;

PROCEDURE getsockopt(s : SOCKET;
                     level : WINT;
                     optname : WINT;
                     VAR optval : ARRAY OF LOC;
                     VAR optlen : WINT) : WINT;

PROCEDURE htonl(hostlong : u_long) : u_long; MACRO;
BEGIN
    %IF LittleEndian %THEN
        RETURN SWAPENDIAN(hostlong);
    %ELSE
        RETURN hostlong;
    %END
END htonl;

PROCEDURE htons(hostshort : u_short) : u_short; MACRO;
BEGIN
    %IF LittleEndian %THEN
        RETURN SWAPENDIAN(hostshort);
    %ELSE
        RETURN hostshort;
    %END
END htons;

PROCEDURE inet_addr(cp : ARRAY OF ACHAR) : ULONG;

PROCEDURE inet_ntoa(in : VALUE in_addr) : LPSTR;

PROCEDURE listen(s : SOCKET;
                 backlog : WINT) : WINT;

PROCEDURE ntohl(netlong : u_long) : u_long; MACRO;
BEGIN
    %IF LittleEndian %THEN
        RETURN SWAPENDIAN(netlong);
    %ELSE
        RETURN netlong;
    %END
END ntohl;

PROCEDURE ntohs(netshort : u_short) : u_short; MACRO;
BEGIN
    %IF LittleEndian %THEN
        RETURN SWAPENDIAN(netshort);
    %ELSE
        RETURN netshort;
    %END
END ntohs;

PROCEDURE recv(s : SOCKET;
               buf : ADDRESS;
               len : WINT;
               flags : WINT) : WINT;

PROCEDURE recvfrom(s : SOCKET;
                   buf : ADDRESS;
                   len : WINT;
                   flags : WINT;
                   VAR from : SOCKADDR;
                   VAR fromlen : WINT) : WINT;

PROCEDURE select(nfds : WINT;
                 VAR INOUT readfds : fd_set;
                 VAR INOUT writefds : fd_set;
                 VAR INOUT exceptfds : fd_set;
                 timeout : timeval) : WINT;

PROCEDURE send(s : SOCKET;
               buf : ADDRESS;
               len : WINT;
               flags : WINT) : WINT;

PROCEDURE sendto(s : SOCKET;
                 buf : ADDRESS;
                 len : WINT;
                 flags : WINT;
                 to : SOCKADDR;
                 tolen : WINT) : WINT;

PROCEDURE setsockopt(s : SOCKET;
                     level : WINT;
                     optname : WINT;
                     optval : ARRAY OF LOC;
                     optlen : WINT) : WINT;

PROCEDURE shutdown(s : SOCKET; how : WINT) : WINT;

PROCEDURE socket(af : WINT;
                 type : WINT;
                 protocol : WINT) : SOCKET;

(* Database function prototypes *)

PROCEDURE gethostbyaddr(addr : ARRAY OF LOC;
                        len : WINT;
                        type : WINT) : LPHOSTENT;

PROCEDURE gethostbyname(name : ARRAY OF ACHAR) : LPHOSTENT;

PROCEDURE gethostname(VAR name : ARRAY OF ACHAR;
                      namelen : WINT) : WINT;

PROCEDURE getservbyport(port : WINT;
                        proto : ARRAY OF ACHAR) : LPSERVENT;

PROCEDURE getservbyname(name : ARRAY OF ACHAR;
                         proto : ARRAY OF ACHAR) : LPSERVENT;

PROCEDURE getprotobynumber(proto : WINT) : LPPROTOENT;

PROCEDURE getprotobyname(name : ARRAY OF ACHAR) : LPPROTOENT;

(* Microsoft Windows Extension function prototypes *)

PROCEDURE WSAStartup(wVersionRequired : WORD;
                     lpWSAData : LPWSADATA) : WINT;

PROCEDURE WSACleanup() : WINT;

PROCEDURE WSASetLastError(iError : WINT);

PROCEDURE WSAGetLastError() : WINT;

PROCEDURE WSAIsBlocking() : BOOL;

PROCEDURE WSAUnhookBlockingHook() : WINT;

PROCEDURE WSASetBlockingHook(lpBlockFunc : FARPROC) : FARPROC;

PROCEDURE WSACancelBlockingCall() : WINT;

PROCEDURE WSAAsyncGetServByName(hWnd : HWND;
                                wMsg : u_int;
                                name : ARRAY OF ACHAR;
                                proto : ARRAY OF ACHAR;
                                buf : ADDRESS;
                                buflen : WINT) : HANDLE;

PROCEDURE WSAAsyncGetServByPort(hWnd : HWND;
                                wMsg : u_int;
                                port : WINT;
                                proto : ARRAY OF ACHAR;
                                buf : ADDRESS;
                                buflen : WINT) : HANDLE;

PROCEDURE WSAAsyncGetProtoByName(hWnd : HWND;
                                 wMsg : u_int;
                                 VAR name : ARRAY OF ACHAR;
                                 buf : ADDRESS;
                                 buflen : WINT) : HANDLE;

PROCEDURE WSAAsyncGetProtoByNumber(hWnd : HWND;
                                   wMsg : u_int;
                                   number : WINT;
                                   buf : ADDRESS;
                                   buflen : WINT) : HANDLE;

PROCEDURE WSAAsyncGetHostByName(hWnd : HWND;
                                wMsg : u_int;
                                name : ARRAY OF ACHAR;
                                buf : ADDRESS;
                                buflen : WINT) : HANDLE;

PROCEDURE WSAAsyncGetHostByAddr(hWnd : HWND;
                                wMsg : u_int;
                                addr : ARRAY OF LOC;
                                len : WINT;
                                type : WINT;
                                buf : ADDRESS;
                                buflen : WINT) : HANDLE;

PROCEDURE WSACancelAsyncRequest(hAsyncTaskHandle : HANDLE) : WINT;

PROCEDURE WSAAsyncSelect(s : SOCKET;
                         hWnd : HWND;
                         wMsg : u_int;
                         lEvent : LONG) : WINT;

(*
 * WinSock 2 extensions -- data types for the condition function in
 * WSAAccept() and overlapped I/O completion routine.
 *)

TYPE
    LPCONDITIONPROC = PROCEDURE((*lpCallerId*)LPWSABUF,
                                (*lpCallerData*)LPWSABUF,
                                (*lpSQOS*)QOS,
                                (*lpGQOS*)QOS,
                                (*lpCalleeId*)LPWSABUF,
                                (*lpCalleeData*)LPWSABUF,
                                VAR (*g*) GROUP,
                                (*dwCallbackData*)DWORD) : int [EXPORT];

    LPWSAOVERLAPPED_COMPLETION_ROUTINE = PROCEDURE(
                                            (*dwError*)DWORD,
                                            (*cbTransferred*)DWORD,
                                            (*lpOverlapped*)LPWSAOVERLAPPED,
                                            (*dwFlags*)DWORD) [EXPORT];

(* WinSock 2 API new function prototypes *)

PROCEDURE WSAAccept(s : SOCKET;
                    VAR addr : sockaddr;
                    VAR addrlen : WINT;
                    lpfnCondition : LPCONDITIONPROC;
                    dwCallbackData : DWORD) : SOCKET;

PROCEDURE WSACloseEvent(hEvent : WSAEVENT) : BOOL;

PROCEDURE WSAConnect(s : SOCKET;
                     name : sockaddr;
                     namelen : int;
                     lpCallerData : LPWSABUF;
                     lpCalleeData : LPWSABUF;
                     lpSQOS : QOS;
                     lpGQOS : QOS) : int;

PROCEDURE WSACreateEvent() : WSAEVENT;

PROCEDURE WSADuplicateSocketA(s : SOCKET;
                              dwProcessId : DWORD;
                              lpProtocolInfo : WSAPROTOCOL_INFOA) : int;

PROCEDURE WSADuplicateSocketW(s : SOCKET;
                              dwProcessId : DWORD;
                              lpProtocolInfo : WSAPROTOCOL_INFOW) : int;

%IF UNICODE %THEN
PROCEDURE WSADuplicateSocket  =WSADuplicateSocketW;
%ELSE
PROCEDURE WSADuplicateSocket  =WSADuplicateSocketA;
%END

PROCEDURE WSAEnumNetworkEvents(s : SOCKET;
                               hEventObject : WSAEVENT;
                               lpNetworkEvents : WSANETWORKEVENTS) : int;

PROCEDURE WSAEnumProtocolsA(VAR lpiProtocols : WINT;
                            VAR lpProtocolBuffer : WSAPROTOCOL_INFOA;
                            VAR lpdwBufferLength : DWORD) : int;

PROCEDURE WSAEnumProtocolsW(VAR lpiProtocols : WINT;
                            VAR lpProtocolBuffer : WSAPROTOCOL_INFOW;
                            VAR lpdwBufferLength : DWORD) : int;

%IF UNICODE %THEN
PROCEDURE WSAEnumProtocols  =WSAEnumProtocolsW;
%ELSE
PROCEDURE WSAEnumProtocols  =WSAEnumProtocolsA;
%END

PROCEDURE WSAEventSelect(s : SOCKET;
                         hEventObject : WSAEVENT;
                         lNetworkEvents : long) : int;

PROCEDURE WSAGetOverlappedResult(s : SOCKET;
                                 VAR lpOverlapped : WSAOVERLAPPED;
                                 VAR lpcbTransfer : DWORD;
                                 fWait : BOOL;
                                 VAR lpdwFlags : DWORD) : BOOL;

PROCEDURE WSAGetQOSByName(s : SOCKET;
                          VAR lpQOSName : WSABUF;
                          VAR lpQOS : QOS) : BOOL;

PROCEDURE WSAHtonl(s : SOCKET;
                   hostlong : u_long;
                   VAR lpnetlong : u_long) : int;

PROCEDURE WSAHtons(s : SOCKET;
                   hostshort : u_short;
                   VAR lpnetshort : u_short) : int;

PROCEDURE WSAIoctl(s : SOCKET;
                   dwIoControlCode : DWORD;
                   lpvInBuffer : ARRAY OF LOC;
                   cbInBuffer : DWORD;
                   VAR lpvOutBuffer : ARRAY OF LOC;
                   cbOutBuffer : DWORD;
                   VAR lpcbBytesReturned : DWORD;
                   VAR lpOverlapped : WSAOVERLAPPED;
                   lpCompletionRoutine : LPWSAOVERLAPPED_COMPLETION_ROUTINE) : int;

PROCEDURE WSAJoinLeaf(s : SOCKET;
                      name : sockaddr;
                      namelen : int;
                      lpCallerData : WSABUF;
                      lpCalleeData : WSABUF;
                      lpSQOS : QOS;
                      lpGQOS : QOS;
                      dwFlags : DWORD) : SOCKET;

PROCEDURE WSANtohl(s : SOCKET;
                   netlong : u_long;
                   VAR lphostlong : u_long) : int;

PROCEDURE WSANtohs(s : SOCKET;
                   netshort : u_short;
                   VAR lphostshort : u_short) : int;

PROCEDURE WSARecv(s : SOCKET;
                  lpBuffers : ARRAY OF WSABUF;
                  dwBufferCount : DWORD;
                  VAR lpNumberOfBytesRecvd : DWORD;
                  VAR lpFlags : DWORD;
                  VAR lpOverlapped : WSAOVERLAPPED;
                  lpCompletionRoutine : LPWSAOVERLAPPED_COMPLETION_ROUTINE) : int;

PROCEDURE WSARecvDisconnect(s : SOCKET;
                            VAR lpInboundDisconnectData : WSABUF) : int;

PROCEDURE WSARecvFrom(s : SOCKET;
                      VAR lpBuffers : ARRAY OF WSABUF;
                      dwBufferCount : DWORD;
                      VAR lpNumberOfBytesRecvd : DWORD;
                      VAR lpFlags : DWORD;
                      VAR lpFrom : sockaddr;
                      VAR lpFromlen : WINT;
                      VAR lpOverlapped : WSAOVERLAPPED;
                      lpCompletionRoutine : LPWSAOVERLAPPED_COMPLETION_ROUTINE
                      ) : int;

PROCEDURE WSAResetEvent(hEvent : WSAEVENT) : BOOL;

PROCEDURE WSASend(s : SOCKET;
                  lpBuffers : ARRAY OF WSABUF;
                  dwBufferCount : DWORD;
                  VAR lpNumberOfBytesSent : DWORD;
                  dwFlags : DWORD;
                  VAR lpOverlapped : WSAOVERLAPPED;
                  lpCompletionRoutine : LPWSAOVERLAPPED_COMPLETION_ROUTINE
                  ) : int;

PROCEDURE WSASendDisconnect(s : SOCKET;
                            lpOutboundDisconnectData : WSABUF) : int;

PROCEDURE WSASendTo(s : SOCKET;
                    lpBuffers : ARRAY OF WSABUF;
                    dwBufferCount : DWORD;
                    VAR lpNumberOfBytesSent : DWORD;
                    dwFlags : DWORD;
                    lpTo : sockaddr;
                    iTolen : int;
                    VAR  lpOverlapped : WSAOVERLAPPED;
                    lpCompletionRoutine : LPWSAOVERLAPPED_COMPLETION_ROUTINE
                    ) : int;

PROCEDURE WSASetEvent(hEvent : WSAEVENT) : BOOL;

PROCEDURE WSASocketA(af : int;
                     type : int;
                     protocol : int;
                     VAR lpProtocolInfo : WSAPROTOCOL_INFOA;
                     g : GROUP;
                     dwFlags : DWORD) : SOCKET;

PROCEDURE WSASocketW(af : int;
                     type : int;
                     protocol : int;
                     VAR lpProtocolInfo : WSAPROTOCOL_INFOW;
                     g : GROUP;
                     dwFlags : DWORD) : SOCKET;

%IF UNICODE %THEN
PROCEDURE WSASocket  = WSASocketW;
%ELSE
PROCEDURE WSASocket  = WSASocketA;
%END

PROCEDURE WSAWaitForMultipleEvents(cEvents : DWORD;
                                   lphEvents : ARRAY OF WSAEVENT;
                                   fWaitAll : BOOL;
                                   dwTimeout : DWORD;
                                   fAlertable : BOOL) : DWORD;

PROCEDURE WSAAddressToStringA(lpsaAddress : SOCKADDR;
                              dwAddressLength : DWORD;
                              lpProtocolInfo : WSAPROTOCOL_INFOA;
                              VAR lpszAddressString : ARRAY OF ACHAR;
                              VAR lpdwAddressStringLength : DWORD) : WINT;

PROCEDURE WSAAddressToStringW(lpsaAddress : SOCKADDR;
                              dwAddressLength : DWORD;
                              lpProtocolInfo : WSAPROTOCOL_INFOW;
                              VAR INOUT lpszAddressString : ARRAY OF UCHAR;
                              VAR INOUT  lpdwAddressStringLength : DWORD) : WINT;

%IF UNICODE %THEN
PROCEDURE WSAAddressToString  = WSAAddressToStringW;
%ELSE
PROCEDURE WSAAddressToString  = WSAAddressToStringA;
%END

PROCEDURE WSAStringToAddressA(AddressString : ARRAY OF ACHAR;
                              AddressFamily :  WINT;
                              lpProtocolInfo : WSAPROTOCOL_INFOA;
                              VAR INOUT lpAddress : SOCKADDR;
                              VAR INOUT lpAddressLength : WINT) : WINT;

PROCEDURE WSAStringToAddressW(AddressString : ARRAY OF ACHAR;
                              AddressFamily :  WINT;
                              lpProtocolInfo : WSAPROTOCOL_INFOW;
                              VAR INOUT lpAddress : SOCKADDR;
                              VAR INOUT lpAddressLength : WINT) : WINT;

%IF UNICODE %THEN
PROCEDURE WSAStringToAddress  = WSAStringToAddressW;
%ELSE
PROCEDURE WSAStringToAddress  = WSAStringToAddressA;
%END

(* Registration and Name Resolution API functions *)

PROCEDURE WSALookupServiceBeginA(lpqsRestrictions : WSAQUERYSETA;
                                 dwControlFlags : DWORD;
                                 VAR OUT lphLookup : HANDLE) : WINT;

PROCEDURE WSALookupServiceBeginW(lpqsRestrictions : WSAQUERYSETW;
                                 dwControlFlags : DWORD;
                                 VAR OUT lphLookup : HANDLE) : WINT;

%IF UNICODE %THEN
PROCEDURE WSALookupServiceBegin  = WSALookupServiceBeginW;
%ELSE
PROCEDURE WSALookupServiceBegin  = WSALookupServiceBeginA;
%END

PROCEDURE WSALookupServiceNextA(hLookup : HANDLE;
                                dwControlFlags : DWORD;
                                VAR INOUT lpdwBufferLength : DWORD;
                                VAR OUT lpqsResults : WSAQUERYSETA) : WINT;

PROCEDURE WSALookupServiceNextW(hLookup : HANDLE;
                                dwControlFlags : DWORD;
                                VAR INOUT lpdwBufferLength : DWORD;
                                VAR OUT lpqsResults : WSAQUERYSETW) : WINT;

%IF UNICODE %THEN
PROCEDURE WSALookupServiceNext = WSALookupServiceNextW;
%ELSE
PROCEDURE WSALookupServiceNext = WSALookupServiceNextA;
%END

PROCEDURE WSALookupServiceEnd(hLookup : HANDLE) : WINT;

PROCEDURE WSAInstallServiceClassA(lpServiceClassInfo : WSASERVICECLASSINFOA) : WINT;

PROCEDURE WSAInstallServiceClassW(lpServiceClassInfo : WSASERVICECLASSINFOW) : WINT;

%IF UNICODE %THEN
PROCEDURE WSAInstallServiceClass = WSAInstallServiceClassW;
%ELSE
PROCEDURE WSAInstallServiceClass = WSAInstallServiceClassA;
%END

PROCEDURE WSARemoveServiceClass(lpServiceClassId : GUID) : WINT;

PROCEDURE WSAGetServiceClassInfoA(lpProviderId : GUID;
                                  lpServiceClassId : GUID;
                                  VAR INOUT lpdwBufSize : DWORD;
                                  VAR OUT lpServiceClassInfo : WSASERVICECLASSINFOA
                                  ) : WINT;

PROCEDURE WSAGetServiceClassInfoW(lpProviderId : GUID;
                                  lpServiceClassId : GUID;
                                  VAR INOUT lpdwBufSize : DWORD;
                                  VAR OUT lpServiceClassInfo : WSASERVICECLASSINFOW
                                  ) : WINT;

%IF UNICODE %THEN
PROCEDURE WSAGetServiceClassInfo = WSAGetServiceClassInfoW;
%ELSE
PROCEDURE WSAGetServiceClassInfo = WSAGetServiceClassInfoA;
%END

PROCEDURE WSAEnumNameSpaceProvidersA(VAR INOUT lpdwBufferLength : DWORD;
                                     lpnspBuffer : WSANAMESPACE_INFOA) : WINT;

PROCEDURE WSAEnumNameSpaceProvidersW(VAR INOUT lpdwBufferLength : DWORD;
                                     lpnspBuffer : WSANAMESPACE_INFOA) : WINT;

%IF UNICODE %THEN
PROCEDURE WSAEnumNameSpaceProviders = WSAEnumNameSpaceProvidersW;
%ELSE
PROCEDURE WSAEnumNameSpaceProviders = WSAEnumNameSpaceProvidersA;
%END

PROCEDURE WSAGetServiceClassNameByClassIdA(lpServiceClassId : GUID;
                                           VAR OUT lpszServiceClassName : ARRAY OF ACHAR;
                                           VAR INOUT lpdwBufferLength  : DWORD) : WINT;

PROCEDURE WSAGetServiceClassNameByClassIdW(lpServiceClassId : GUID;
                                           VAR OUT lpszServiceClassName : ARRAY OF UCHAR;
                                           VAR INOUT lpdwBufferLength  : DWORD) : WINT;

%IF UNICODE %THEN
PROCEDURE WSAGetServiceClassNameByClassId = WSAGetServiceClassNameByClassIdW;
%ELSE
PROCEDURE WSAGetServiceClassNameByClassId = WSAGetServiceClassNameByClassIdA;
%END

PROCEDURE WSASetServiceA(lpqsRegInfo : WSAQUERYSETA;
                         essoperation : WSAESETSERVICEOP;
                         dwControlFlags : DWORD) : WINT;

PROCEDURE WSASetServiceW(lpqsRegInfo : WSAQUERYSETW;
                         essoperation : WSAESETSERVICEOP;
                         dwControlFlags : DWORD) : WINT;
%IF UNICODE %THEN
PROCEDURE WSASetService = WSASetServiceW;
%ELSE
PROCEDURE WSASetService = WSASetServiceA;
%END

PROCEDURE WSAProviderConfigChange(
    VAR INOUT lpNotificationHandle : HANDLE;
    VAR lpOverlapped : WSAOVERLAPPED;
    lpCompletionRoutine : LPWSAOVERLAPPED_COMPLETION_ROUTINE) : WINT;

(*
 * Windows message parameter composition and decomposition
 * macros.
 *)

<*/PUSH/CALLS:StonyBrook*>
(* macros *)
 (* WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to a WSAAsyncGetXByY() routine.
 *)
PROCEDURE WSAMAKEASYNCREPLY(buflen, error : u_short) : LONG;

(*
 * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to WSAAsyncSelect().
 *)
PROCEDURE WSAMAKESELECTREPLY(event,error : u_short) : LONG;

(*
 * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application
 * to extract the buffer length from the lParam in the response
 * to a WSAAsyncGetXByY().
 *)
PROCEDURE WSAGETASYNCBUFLEN(lParam : LPARAM) : DWORD;

(*
 * WSAGETASYNCERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAGetXByY().
 *)
PROCEDURE WSAGETASYNCERROR(lParam : LPARAM) : DWORD;

(*
 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
 * to extract the event code from the lParam in the response
 * to a WSAAsyncSelect().
 *)
PROCEDURE WSAGETSELECTEVENT(lParam : LPARAM) : DWORD;

(*
 * WSAGETSELECTERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAAsyncSelect().
 *)
PROCEDURE WSAGETSELECTERROR(lParam : LPARAM) : DWORD;
<*/POP*>

(* ws2tcpip.h *)

(* Option to use with [gs]etsockopt at the IPPROTO_IP level *)

CONST
    IP_OPTIONS      =1; (* set/get IP options *)
    IP_HDRINCL      =2; (* header is included with data *)
    IP_TOS          =3; (* IP type of service and preced*)
    IP_TTL          =4; (* IP time to live *)
    IP_MULTICAST_IF     =9; (* set/get IP multicast i/f  *)
    IP_MULTICAST_TTL       =10; (* set/get IP multicast ttl *)
    IP_MULTICAST_LOOP      =11; (*set/get IP multicast loopback *)
    IP_ADD_MEMBERSHIP      =12; (* add an IP group membership *)
    IP_DROP_MEMBERSHIP     =13;(* drop an IP group membership *)
    IP_DONTFRAGMENT     =14; (* don't fragment IP datagrams *)
    IP_ADD_SOURCE_MEMBERSHIP  =15; (* join IP group/source *)
    IP_DROP_SOURCE_MEMBERSHIP =16; (* leave IP group/source *)
    IP_BLOCK_SOURCE           =17; (* block IP group/source *)
    IP_UNBLOCK_SOURCE         =18; (* unblock IP group/source *)
    IP_PKTINFO                =19; (* receive packet information for ipv4*)

(* Option to use with [gs]etsockopt at the IPPROTO_IPV6 level *)

    IPV6_HDRINCL            =2;  (* Header is included with data *)
    IPV6_UNICAST_HOPS       =4;  (* Set/get IP unicast hop limit *)
    IPV6_MULTICAST_IF       =9;  (* Set/get IP multicast interface *)
    IPV6_MULTICAST_HOPS     =10; (* Set/get IP multicast ttl *)
    IPV6_MULTICAST_LOOP     =11; (* Set/get IP multicast loopback *)
    IPV6_ADD_MEMBERSHIP     =12; (* Add an IP group membership *)
    IPV6_DROP_MEMBERSHIP    =13; (* Drop an IP group membership *)
    IPV6_JOIN_GROUP         =IPV6_ADD_MEMBERSHIP;
    IPV6_LEAVE_GROUP        =IPV6_DROP_MEMBERSHIP;
    IPV6_PKTINFO            =19; (* Receive packet information for ipv6 *)

END WINSOCK2.

(*
* Copyright (c) 1985-2000, Microsoft Corp. All rights reserved.             *
*)
(* Conversion from Microsoft WIN32 SDK C source to Modula-2 source *)
(* Copyright (c) 1995-2000, Stony Brook Software. All rights reserved. *)

DEFINITION MODULE WINNETWK;

FROM WIN32 IMPORT
    DWORD, LPSTR, LPWSTR, BOOL, HANDLE, LPVOID, HWND, WORD, UINT;

IMPORT WINERROR;

<*/CALLS:WIN32SYSTEM*>
<*/NOHIGH*>
<*/ALIGN:8/NOPACK*>

CONST


    WNNC_NET_MSNET              = 00010000h;
    WNNC_NET_LANMAN             = 00020000h;
    WNNC_NET_NETWARE            = 00030000h;
    WNNC_NET_VINES              = 00040000h;
    WNNC_NET_10NET              = 00050000h;
    WNNC_NET_LOCUS              = 00060000h;
    WNNC_NET_SUN_PC_NFS         = 00070000h;
    WNNC_NET_LANSTEP            = 00080000h;
    WNNC_NET_9TILES             = 00090000h;
    WNNC_NET_LANTASTIC          = 000A0000h;
    WNNC_NET_AS400              = 000B0000h;
    WNNC_NET_FTP_NFS            = 000C0000h;
    WNNC_NET_PATHWORKS          = 000D0000h;
    WNNC_NET_LIFENET            = 000E0000h;
    WNNC_NET_POWERLAN           = 000F0000h;
    WNNC_NET_BWNFS              = 00100000h;
    WNNC_NET_COGENT             = 00110000h;
    WNNC_NET_FARALLON           = 00120000h;
    WNNC_NET_APPLETALK          = 00130000h;
    WNNC_NET_INTERGRAPH         = 00140000h;
     WNNC_NET_SYMFONET   =00150000h;
     WNNC_NET_CLEARCASE  =00160000h;
     WNNC_NET_FRONTIER   =00170000h;
     WNNC_NET_BMC        =00180000h;
     WNNC_NET_DCE        =00190000h;
     WNNC_NET_DECORB     =00200000h;
     WNNC_NET_PROTSTOR   =00210000h;
     WNNC_NET_FJ_REDIR   =00220000h;
     WNNC_NET_DISTINCT   =00230000h;
     WNNC_NET_TWINS      =00240000h;
     WNNC_NET_RDR2SAMPLE =00250000h;


    RESOURCE_CONNECTED   = 000000001h;
    RESOURCE_GLOBALNET   = 000000002h;
    RESOURCE_REMEMBERED  = 000000003h;
    RESOURCETYPE_ANY     = 000000000h;

    RESOURCETYPE_DISK    = 000000001h;
    RESOURCETYPE_PRINT   = 000000002h;


    RESOURCE_RECENT      = 000000004h;
    RESOURCE_CONTEXT     = 000000005h;

    RESOURCETYPE_RESERVED= 000000008h;


    RESOURCETYPE_UNKNOWN        = 0FFFFFFFFh;

    RESOURCEUSAGE_CONNECTABLE   = 000000001h;
    RESOURCEUSAGE_CONTAINER     = 000000002h;


    RESOURCEUSAGE_NOLOCALDEVICE = 000000004h;
    RESOURCEUSAGE_SIBLING       = 000000008h;
    RESOURCEUSAGE_ATTACHED      = 00000010h;
    RESOURCEUSAGE_ALL           = (RESOURCEUSAGE_CONNECTABLE BOR
                                   RESOURCEUSAGE_CONTAINER);

    RESOURCEUSAGE_RESERVED      = 080000000h;

    RESOURCEDISPLAYTYPE_GENERIC = 000000000h;
    RESOURCEDISPLAYTYPE_DOMAIN  = 000000001h;
    RESOURCEDISPLAYTYPE_SERVER  = 000000002h;
    RESOURCEDISPLAYTYPE_SHARE   = 000000003h;
    RESOURCEDISPLAYTYPE_FILE    = 000000004h;
    RESOURCEDISPLAYTYPE_GROUP   = 000000005h;


    RESOURCEDISPLAYTYPE_NETWORK        = 00000006h;
    RESOURCEDISPLAYTYPE_ROOT           = 00000007h;
    RESOURCEDISPLAYTYPE_SHAREADMIN     = 00000008h;
    RESOURCEDISPLAYTYPE_DIRECTORY      = 00000009h;
    RESOURCEDISPLAYTYPE_TREE           = 0000000Ah;
    RESOURCEDISPLAYTYPE_NDSCONTAINER   = 0000000Bh;



TYPE
    NETRESOURCEA = RECORD
          dwScope        : DWORD;
          dwType         : DWORD;
          dwDisplayType  : DWORD;
          dwUsage        : DWORD;
          lpLocalName    : LPSTR;
          lpRemoteName   : LPSTR;
          lpComment      : LPSTR;
          lpProvider     : LPSTR;
    END;
    LPNETRESOURCEA       = POINTER TO NETRESOURCEA;

    NETRESOURCEW = RECORD
          dwScope        : DWORD;
          dwType         : DWORD;
          dwDisplayType  : DWORD;
          dwUsage        : DWORD;
          lpLocalName    : LPWSTR;
          lpRemoteName   : LPWSTR;
          lpComment      : LPWSTR;
          lpProvider     : LPWSTR;
    END;
    LPNETRESOURCEW       = POINTER TO NETRESOURCEW;

%IF UNICODE %THEN
    NETRESOURCE          = NETRESOURCEW;
%ELSE
    NETRESOURCE          = NETRESOURCEA;
%END
    LPNETRESOURCE        = POINTER TO NETRESOURCE;

CONST
    CONNECT_UPDATE_PROFILE      = 00000001h;

    CONNECT_UPDATE_RECENT       = 00000002h;
    CONNECT_TEMPORARY           = 00000004h;
    CONNECT_INTERACTIVE         = 00000008h;
    CONNECT_PROMPT              = 00000010h;
    CONNECT_NEED_DRIVE          = 00000020h;
    CONNECT_REFCOUNT            = 00000040h;
    CONNECT_REDIRECT            = 00000080h;
    CONNECT_LOCALDRIVE          = 00000100h;
    CONNECT_CURRENT_MEDIA       = 00000200h;
    CONNECT_DEFERRED            = 00000400h;
    CONNECT_RESERVED            = 0FF000000h;
    NETPROPERTY_PERSISTENT      = 1;


PROCEDURE WNetAddConnectionA(lpRemoteName : ARRAY OF ACHAR;
                             lpPassword : ARRAY OF ACHAR;
                             lpLocalName : ARRAY OF ACHAR) : DWORD;

PROCEDURE WNetAddConnectionW(lpRemoteName : ARRAY OF UCHAR;
                             lpPassword : ARRAY OF UCHAR;
                             lpLocalName : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE WNetAddConnection = WNetAddConnectionW;
%ELSE
PROCEDURE WNetAddConnection = WNetAddConnectionA;
%END


PROCEDURE WNetAddConnection2A(lpNetResource : LPNETRESOURCEA;
                              lpPassword : ARRAY OF ACHAR;
                              lpUserName : ARRAY OF ACHAR;
                              dwFlags : DWORD) : DWORD;

PROCEDURE WNetAddConnection2W(lpNetResource : LPNETRESOURCEW;
                              lpPassword : ARRAY OF UCHAR;
                              lpUserName : ARRAY OF UCHAR;
                              dwFlags : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE WNetAddConnection2 = WNetAddConnection2W;
%ELSE
PROCEDURE WNetAddConnection2 = WNetAddConnection2A;
%END

PROCEDURE WNetAddConnection3A(hwndOwner : HWND;
                             lpNetResource : LPNETRESOURCEA;
                             lpPassword : ARRAY OF ACHAR;
                             lpUserName : ARRAY OF ACHAR;
                             dwFlags : DWORD) : DWORD;

PROCEDURE WNetAddConnection3W(hwndOwner : HWND;
                             lpNetResource : LPNETRESOURCEW;
                             lpPassword : ARRAY OF UCHAR;
                             lpUserName : ARRAY OF UCHAR;
                             dwFlags : DWORD) : DWORD;
%IF UNICODE %THEN
PROCEDURE WNetAddConnection3 = WNetAddConnection3W;
%ELSE
PROCEDURE WNetAddConnection3 = WNetAddConnection3A;
%END

PROCEDURE WNetCancelConnectionA(lpName : ARRAY OF ACHAR;
                                fForce : BOOL) : DWORD;

PROCEDURE WNetCancelConnectionW(lpName : ARRAY OF UCHAR;
                                fForce : BOOL) : DWORD;

%IF UNICODE %THEN
PROCEDURE WNetCancelConnection = WNetCancelConnectionW;
%ELSE
PROCEDURE WNetCancelConnection = WNetCancelConnectionA;
%END

PROCEDURE WNetCancelConnection2A(lpName : ARRAY OF ACHAR;
                                 dwFlags : DWORD;
                                 fForce : BOOL) : DWORD;

PROCEDURE WNetCancelConnection2W(lpName : ARRAY OF UCHAR;
                                 dwFlags : DWORD;
                                 fForce : BOOL) : DWORD;

%IF UNICODE %THEN
PROCEDURE WNetCancelConnection2 = WNetCancelConnection2W;
%ELSE
PROCEDURE WNetCancelConnection2 = WNetCancelConnection2A;
%END

PROCEDURE WNetGetConnectionA(lpLocalName : ARRAY OF ACHAR;
                             VAR lpRemoteName : ARRAY OF ACHAR;
                             VAR lpnLength : DWORD) : DWORD;

PROCEDURE WNetGetConnectionW(lpLocalName : ARRAY OF UCHAR;
                             VAR lpRemoteName : ARRAY OF UCHAR;
                             VAR lpnLength : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE WNetGetConnection = WNetGetConnectionW;
%ELSE
PROCEDURE WNetGetConnection = WNetGetConnectionA;
%END


PROCEDURE WNetUseConnectionA(
        hwndOwner : HWND;
        VAR lpNetResource : NETRESOURCEA;
        lpUserID : ARRAY OF ACHAR;
        lpPassword : ARRAY OF ACHAR;
        dwFlags : DWORD;
        VAR lpAccessName : ARRAY OF ACHAR;
        VAR lpBufferSize : DWORD;
        VAR lpResult : DWORD
        ) : DWORD;

PROCEDURE WNetUseConnectionW(
        hwndOwner : HWND;
        VAR lpNetResource : NETRESOURCEW;
        lpUserID : ARRAY OF UCHAR;
        lpPassword : ARRAY OF UCHAR;
        dwFlags : DWORD;
        VAR lpAccessName : ARRAY OF UCHAR;
        VAR lpBufferSize : DWORD;
        VAR lpResult : DWORD
        ) : DWORD;

%IF UNICODE %THEN
PROCEDURE WNetUseConnection = WNetUseConnectionW;
%ELSE
PROCEDURE WNetUseConnection = WNetUseConnectionA;
%END

PROCEDURE WNetSetConnectionA(
                            lpName : ARRAY OF ACHAR;
                            dwProperties : DWORD;
                            pvValues : LPVOID
                            ) : DWORD;

PROCEDURE WNetSetConnectionW(
                            lpName : ARRAY OF UCHAR;
                            dwProperties : DWORD;
                            pvValues : LPVOID
                            ) : DWORD;
%IF UNICODE %THEN
PROCEDURE WNetSetConnection = WNetSetConnectionW;
%ELSE
PROCEDURE WNetSetConnection = WNetSetConnectionA;
%END


PROCEDURE WNetOpenEnumA(dwScope : DWORD;
                        dwType : DWORD;
                        dwUsage : DWORD;
                        lpNetResource : LPNETRESOURCEA;
                        VAR lphEnum : HANDLE) : DWORD;

PROCEDURE WNetOpenEnumW(dwScope : DWORD;
                        dwType : DWORD;
                        dwUsage : DWORD;
                        lpNetResource : LPNETRESOURCEW;
                        VAR lphEnum : HANDLE) : DWORD;

%IF UNICODE %THEN
PROCEDURE WNetOpenEnum = WNetOpenEnumW;
%ELSE
PROCEDURE WNetOpenEnum = WNetOpenEnumA;
%END

PROCEDURE WNetEnumResourceA(hEnum : HANDLE;
                            VAR lpcCount : DWORD;
                            lpBuffer : LPVOID;
                            VAR lpBufferSize : DWORD) : DWORD;

PROCEDURE WNetEnumResourceW(hEnum : HANDLE;
                            VAR lpcCount : DWORD;
                            lpBuffer : LPVOID;
                            VAR lpBufferSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE WNetEnumResource = WNetEnumResourceW;
%ELSE
PROCEDURE WNetEnumResource = WNetEnumResourceA;
%END

PROCEDURE WNetCloseEnum(hEnum : HANDLE) : DWORD;

CONST
    UNIVERSAL_NAME_INFO_LEVEL   = 1;
    REMOTE_NAME_INFO_LEVEL      = 2;

TYPE
    UNIVERSAL_NAME_INFOA = RECORD
        lpUniversalName : LPSTR;
    END;
    LPUNIVERSAL_NAME_INFOA      = POINTER TO UNIVERSAL_NAME_INFOA;

    UNIVERSAL_NAME_INFOW = RECORD
        lpUniversalName : LPWSTR;
    END;
    LPUNIVERSAL_NAME_INFOW      = POINTER TO UNIVERSAL_NAME_INFOW;
%IF UNICODE %THEN
    UNIVERSAL_NAME_INFO         = UNIVERSAL_NAME_INFOW;
%ELSE
    UNIVERSAL_NAME_INFO         = UNIVERSAL_NAME_INFOA;
%END
    LPUNIVERSAL_NAME_INFO       = POINTER TO UNIVERSAL_NAME_INFO;

    REMOTE_NAME_INFOA = RECORD
        lpUniversalName         : LPSTR;
        lpConnectionName        : LPSTR;
        lpRemainingPath         : LPSTR;
    END;
    LPREMOTE_NAME_INFOA         = POINTER TO REMOTE_NAME_INFOA;

    REMOTE_NAME_INFOW = RECORD
        lpUniversalName         : LPWSTR;
        lpConnectionName        : LPWSTR;
        lpRemainingPath         : LPWSTR;
    END;
    LPREMOTE_NAME_INFOW         = POINTER TO REMOTE_NAME_INFOW;
%IF UNICODE %THEN
    REMOTE_NAME_INFO    = REMOTE_NAME_INFOW;
%ELSE
    REMOTE_NAME_INFO    = REMOTE_NAME_INFOA;
%END
    LPREMOTE_NAME_INFO  = POINTER TO REMOTE_NAME_INFO;

PROCEDURE WNetGetUniversalNameA(lpLocalPath : ARRAY OF ACHAR;
                                 dwInfoLevel : DWORD;
                                 lpBuffer : LPVOID;
                                 VAR lpBufferSize : DWORD) : DWORD;

PROCEDURE WNetGetUniversalNameW(lpLocalPath : ARRAY OF UCHAR;
                                 dwInfoLevel : DWORD;
                                 lpBuffer : LPVOID;
                                 VAR lpBufferSize : DWORD) : DWORD;
%IF UNICODE %THEN
PROCEDURE WNetGetUniversalName = WNetGetUniversalNameW;
%ELSE
PROCEDURE WNetGetUniversalName = WNetGetUniversalNameA;
%END

PROCEDURE WNetGetUserA(lpName : ARRAY OF ACHAR;
                       VAR lpUserName : ARRAY OF ACHAR;
                       VAR lpnLength : DWORD) : DWORD;

PROCEDURE WNetGetUserW(lpName : ARRAY OF UCHAR;
                       VAR lpUserName : ARRAY OF UCHAR;
                       VAR lpnLength : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE WNetGetUser = WNetGetUserW;
%ELSE
PROCEDURE WNetGetUser = WNetGetUserA;
%END

CONST

    LOGON_DONE              = 00000001h;
    LOGON_PRIMARY           = 00000002h;
    LOGON_MUST_VALIDATE     = 00000004h;

    LOGOFF_PENDING          = 1;
    LOGOFF_COMMIT           = 2;
    LOGOFF_CANCEL           = 3;

    WNFMT_MULTILINE         = 1h;
    WNFMT_ABBREVIATED       = 2h;
    WNFMT_INENUM            = 10h;
    WNFMT_CONNECTION        = 20h;

PROCEDURE WNetGetProviderNameA(
                                dwNetType : DWORD;
                                VAR lpProviderName : ARRAY OF ACHAR;
                                VAR lpBufferSize : DWORD
                                ) : DWORD;

PROCEDURE WNetGetProviderNameW(
                                dwNetType : DWORD;
                                VAR lpProviderName : ARRAY OF UCHAR;
                                VAR lpBufferSize : DWORD
                                ) : DWORD;
%IF UNICODE %THEN
PROCEDURE WNetGetProviderName = WNetGetProviderNameW;
%ELSE
PROCEDURE WNetGetProviderName = WNetGetProviderNameA;
%END

TYPE
    NETINFOSTRUCT = RECORD
        cbStructure             : DWORD;
        dwProviderVersion       : DWORD;
        dwStatus                : DWORD;
        dwCharacteristics       : DWORD;
        dwHandle                : DWORD;
        wNetType                : WORD;
        dwPrinters              : DWORD;
        dwDrives                : DWORD;
    END;
    LPNETINFOSTRUCT = POINTER TO NETINFOSTRUCT;

CONST
    NETINFO_DLL16       = 00000001h;
    NETINFO_DISKRED     = 00000004h;
    NETINFO_PRINTERRED  = 00000008h;

PROCEDURE WNetGetNetworkInformationA(
                                    lpProvider : ARRAY OF ACHAR;
                                    VAR lpNetInfoStruct : NETINFOSTRUCT
                                    ) : DWORD;

PROCEDURE WNetGetNetworkInformationW(
                                    lpProvider : ARRAY OF UCHAR;
                                    VAR lpNetInfoStruct : NETINFOSTRUCT
                                    ) : DWORD;

%IF UNICODE %THEN
PROCEDURE WNetGetNetworkInformation = WNetGetNetworkInformationW;
%ELSE
PROCEDURE WNetGetNetworkInformation = WNetGetNetworkInformationA;
%END

TYPE
    PFNGETPROFILEPATHA = PROCEDURE(ARRAY OF ACHAR,
                                   VAR ARRAY OF ACHAR,
                                   UINT) : UINT [CPASCAL];

    PFNGETPROFILEPATHW = PROCEDURE(ARRAY OF UCHAR,
                                   VAR ARRAY OF UCHAR,
                                   UINT) : UINT [CPASCAL];
%IF UNICODE %THEN
    PFNGETPROFILEPATH = PFNGETPROFILEPATHW;
%ELSE
    PFNGETPROFILEPATH = PFNGETPROFILEPATHA;
%END

    PFNRECONCILEPROFILEA = PROCEDURE(ARRAY OF ACHAR,
                                     ARRAY OF ACHAR,
                                     DWORD) : UINT [CPascal];

    PFNRECONCILEPROFILEW = PROCEDURE(ARRAY OF UCHAR,
                                     ARRAY OF UCHAR,
                                     DWORD) : UINT [CPascal];

%IF UNICODE %THEN
    PFNRECONCILEPROFILE = PFNRECONCILEPROFILEW;
%ELSE
    PFNRECONCILEPROFILE = PFNRECONCILEPROFILEA;
%END

CONST
    RP_LOGON    = 1h;
    RP_INIFILE  = 2h;

TYPE
    PFNPROCESSPOLICIESA = PROCEDURE(HWND,
                                    ARRAY OF ACHAR,
                                    ARRAY OF ACHAR,
                                    ARRAY OF ACHAR,
                                    DWORD) : BOOL;

    PFNPROCESSPOLICIESW = PROCEDURE(HWND,
                                    ARRAY OF UCHAR,
                                    ARRAY OF UCHAR,
                                    ARRAY OF UCHAR,
                                    DWORD) : BOOL;

%IF UNICODE %THEN
    PFNPROCESSPOLICIES  = PFNPROCESSPOLICIESW;
%ELSE
    PFNPROCESSPOLICIES  = PFNPROCESSPOLICIESA;
%END

CONST
    PP_DISPLAYERRORS    = 01h;



PROCEDURE WNetConnectionDialog(hwnd : HWND;
                               dwType : DWORD) : DWORD;

PROCEDURE WNetDisconnectDialog(hwnd : HWND;
                               dwType : DWORD) : DWORD;


TYPE
    CONNECTDLGSTRUCTA = RECORD
        cbStructure     : DWORD;
        hwndOwner       : HWND;
        lpConnRes       : LPNETRESOURCEA;
        dwFlags         : DWORD;
        dwDevNum        : DWORD;
    END;
    LPCONNECTDLGSTRUCTA = POINTER TO CONNECTDLGSTRUCTA;

    CONNECTDLGSTRUCTW = RECORD
        cbStructure     : DWORD;
        hwndOwner       : HWND;
        lpConnRes       : LPNETRESOURCEW;
        dwFlags         : DWORD;
        dwDevNum        : DWORD;
    END;
    LPCONNECTDLGSTRUCTW = POINTER TO CONNECTDLGSTRUCTW;

%IF UNICODE %THEN
    CONNECTDLGSTRUCT = CONNECTDLGSTRUCTW;
%ELSE
    CONNECTDLGSTRUCT = CONNECTDLGSTRUCTA;
%END
    LPCONNECTDLGSTRUCT = POINTER TO CONNECTDLGSTRUCT;

CONST
    CONNDLG_RO_PATH     = 00000001h;
    CONNDLG_CONN_POINT  = 00000002h;
    CONNDLG_USE_MRU     = 00000004h;
    CONNDLG_HIDE_BOX    = 00000008h;

    CONNDLG_PERSIST     = 00000010h;
    CONNDLG_NOT_PERSIST = 00000020h;

PROCEDURE WNetConnectionDialog1A(
                                VAR lpConnDlgStruct : CONNECTDLGSTRUCTA
                                );

PROCEDURE WNetConnectionDialog1W(
                                VAR lpConnDlgStruct : CONNECTDLGSTRUCTW
                                );
%IF UNICODE %THEN
PROCEDURE WNetConnectionDialog1 = WNetConnectionDialog1W;
%ELSE
PROCEDURE WNetConnectionDialog1 = WNetConnectionDialog1A;
%END

TYPE
    DISCDLGSTRUCTA = RECORD
        cbStructure     : DWORD;
        hwndOwner       : HWND;
        lpLocalName     : LPSTR;
        lpRemoteName    : LPSTR;
        dwFlags         : DWORD;
    END;
    LPDISCDLGSTRUCTA = POINTER TO DISCDLGSTRUCTA;

    DISCDLGSTRUCTW = RECORD
        cbStructure     : DWORD;
        hwndOwner       : HWND;
        lpLocalName     : LPWSTR;
        lpRemoteName    : LPWSTR;
        dwFlags         : DWORD;
    END;
    LPDISCDLGSTRUCTW = POINTER TO DISCDLGSTRUCTW;

%IF UNICODE %THEN
    DISCDLGSTRUCT = DISCDLGSTRUCTW;
%ELSE
    DISCDLGSTRUCT = DISCDLGSTRUCTA;
%END
    LPDISCDLGSTRUCT = POINTER TO DISCDLGSTRUCT;

CONST
    DISC_UPDATE_PROFILE         = 00000001h;
    DISC_NO_FORCE               = 00000040h;

PROCEDURE WNetDisconnectDialog1A(
                                VAR lpConnDlgStruct : DISCDLGSTRUCTA
                                ) : DWORD;

PROCEDURE WNetDisconnectDialog1W(
                                VAR lpConnDlgStruct : DISCDLGSTRUCTW
                                ) : DWORD;

%IF UNICODE %THEN
PROCEDURE WNetDisconnectDialog1 = WNetDisconnectDialog1W;
%ELSE
PROCEDURE WNetDisconnectDialog1 = WNetDisconnectDialog1A;
%END


PROCEDURE WNetGetLastErrorA(VAR lpError : DWORD;
                            VAR lpErrorBuf : ARRAY OF ACHAR;
                            nErrorBufSize : DWORD;
                            VAR lpNameBuf : ARRAY OF ACHAR;
                            nNameBufSize : DWORD) : DWORD;

PROCEDURE WNetGetLastErrorW(VAR lpError : DWORD;
                            VAR lpErrorBuf : ARRAY OF UCHAR;
                            nErrorBufSize : DWORD;
                            VAR lpNameBuf : ARRAY OF UCHAR;
                            nNameBufSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE WNetGetLastError = WNetGetLastErrorW;
%ELSE
PROCEDURE WNetGetLastError = WNetGetLastErrorA;
%END


CONST
    WN_SUCCESS              = WINERROR.NO_ERROR;
    WN_NO_ERROR             = WINERROR.NO_ERROR;
    WN_NOT_SUPPORTED        = WINERROR.ERROR_NOT_SUPPORTED;
    WN_CANCEL               = WINERROR.ERROR_CANCELLED;
    WN_RETRY                = WINERROR.ERROR_RETRY;
    WN_NET_ERROR            = WINERROR.ERROR_UNEXP_NET_ERR;
    WN_MORE_DATA            = WINERROR.ERROR_MORE_DATA;
    WN_BAD_POINTER          = WINERROR.ERROR_INVALID_ADDRESS;
    WN_BAD_VALUE            = WINERROR.ERROR_INVALID_PARAMETER;
    WN_BAD_USER             = WINERROR.ERROR_BAD_USERNAME;
    WN_BAD_PASSWORD         = WINERROR.ERROR_INVALID_PASSWORD;
    WN_ACCESS_DENIED        = WINERROR.ERROR_ACCESS_DENIED;
    WN_FUNCTION_BUSY        = WINERROR.ERROR_BUSY;
    WN_WINDOWS_ERROR        = WINERROR.ERROR_UNEXP_NET_ERR;
    WN_OUT_OF_MEMORY        = WINERROR.ERROR_NOT_ENOUGH_MEMORY;
    WN_NO_NETWORK           = WINERROR.ERROR_NO_NETWORK;
    WN_EXTENDED_ERROR       = WINERROR.ERROR_EXTENDED_ERROR;
    WN_BAD_LEVEL            = WINERROR.ERROR_INVALID_LEVEL;
    WN_BAD_HANDLE           = WINERROR.ERROR_INVALID_HANDLE;
    WN_NOT_INITIALIZING     = WINERROR.ERROR_ALREADY_INITIALIZED;
    WN_NO_MORE_DEVICES      = WINERROR.ERROR_NO_MORE_DEVICES;

    WN_NOT_CONNECTED        = WINERROR.ERROR_NOT_CONNECTED;
    WN_OPEN_FILES           = WINERROR.ERROR_OPEN_FILES;
    WN_DEVICE_IN_USE        = WINERROR.ERROR_DEVICE_IN_USE;
    WN_BAD_NETNAME          = WINERROR.ERROR_BAD_NET_NAME;
    WN_BAD_LOCALNAME        = WINERROR.ERROR_BAD_DEVICE;
    WN_ALREADY_CONNECTED    = WINERROR.ERROR_ALREADY_ASSIGNED;
    WN_DEVICE_ERROR         = WINERROR.ERROR_GEN_FAILURE;
    WN_CONNECTION_CLOSED    = WINERROR.ERROR_CONNECTION_UNAVAIL;
    WN_NO_NET_OR_BAD_PATH   = WINERROR.ERROR_NO_NET_OR_BAD_PATH;
    WN_BAD_PROVIDER         = WINERROR.ERROR_BAD_PROVIDER;
    WN_CANNOT_OPEN_PROFILE  = WINERROR.ERROR_CANNOT_OPEN_PROFILE;
    WN_BAD_PROFILE          = WINERROR.ERROR_BAD_PROFILE;
    WN_BAD_DEV_TYPE         = WINERROR.ERROR_BAD_DEV_TYPE;
    WN_DEVICE_ALREADY_REMEMBERED    = WINERROR.ERROR_DEVICE_ALREADY_REMEMBERED;
    WN_CONNECTED_OTHER_PASSWORD     = WINERROR.ERROR_CONNECTED_OTHER_PASSWORD;

    WN_NO_MORE_ENTRIES      = WINERROR.ERROR_NO_MORE_ITEMS;
    WN_NOT_CONTAINER        = WINERROR.ERROR_NOT_CONTAINER;

    WN_NOT_AUTHENTICATED    = WINERROR.ERROR_NOT_AUTHENTICATED;
    WN_NOT_LOGGED_ON        = WINERROR.ERROR_NOT_LOGGED_ON;
    WN_NOT_VALIDATED        = WINERROR.ERROR_NO_LOGON_SERVERS;

TYPE
    NETCONNECTINFOSTRUCT = RECORD
        cbStructure     : DWORD;
        dwFlags         : DWORD;
        dwSpeed         : DWORD;
        dwDelay         : DWORD;
        dwOptDataSize   : DWORD;
    END;
    LPNETCONNECTINFOSTRUCT = POINTER TO LPNETCONNECTINFOSTRUCT;

CONST
    WNCON_FORNETCARD        = 000000001h;
    WNCON_NOTROUTED         = 000000002h;
    WNCON_SLOWLINK          = 000000004h;
    WNCON_DYNAMIC           = 000000008h;

PROCEDURE MultinetGetConnectionPerformanceA(lpNetResource : LPNETRESOURCEA;
                                            lpNetConnectInfoStruct : LPNETCONNECTINFOSTRUCT
                                            ) : DWORD;

PROCEDURE MultinetGetConnectionPerformanceW(lpNetResource : LPNETRESOURCEW;
                                            lpNetConnectInfoStruct : LPNETCONNECTINFOSTRUCT
                                            ) : DWORD;

%IF UNICODE %THEN
PROCEDURE MultinetGetConnectionPerformance = MultinetGetConnectionPerformanceW;
%ELSE
PROCEDURE MultinetGetConnectionPerformance = MultinetGetConnectionPerformanceA;
%END

END WINNETWK.

FROM http://www.eggheadcafe.com/ng/microsoft.public.win32.programmer.ui/post316794.asp
6/8/2004 12:27:20 AM    SetCursorPos+GetCursorPos+WM_TIMER	

Hello,  
  
I wrote the next function :  
  
void ChangeArrow(UINT resource)  
{  
POINT lpPoint;  
IF (resource != -1)  
curCursor = resource;  
SetCursor(LoadCursor(m_instance,MAKEINTRESOURCE(curCursor)));  
GetCursorPos(&lpPoint); // cursor position  
SetCursorPos(lpPoint.x,lpPoint.y);  
ShowCursor(TRUE);  
}  
  
Apperently when calling this function when I get WM_SETCURSOR  
It cause Any WM_TIMER not to be fired ( I guess due to an overFired messages  
OF WM_MOUSE,WM_SETCURSOR).  
When taking off from this function the :  
GetCursorPos(&lpPoint); // cursor position  
SetCursorPos(lpPoint.x,lpPoint.y);  
Things working fine.....  
What am I doing wrong ?  
  
Moris

6/8/2004 11:54:09 AM    Re: SetCursorPos+GetCursorPos+WM_TIMER	

|| Just for my own curiosity, why do you call GetCursorPos, SetCursorPos, and  
|| ShowCursor?  
| If I'm not using the GetCursorPos, SetCursorPos , When setting new cursor -  
| the affect only take place when I move the mouse,  
| I found this soulution from reading in the newsGroup - But apperently this  
| solution causing to other bugs.  
| I will be very happy to hear about other ideas....  
IF all you want to do is to set the current cursor, then all you need to do  
is to call SetCursor *in response to WM_SETCURSOR message* and return TRUE.  

6/8/2004 12:33:48 PM    Re: SetCursorPos+GetCursorPos+WM_TIMER	
IF I'm not using the GetCursorPos, SetCursorPos , When setting new cursor -  
the affect only take place when I move the mouse,  
I found this soulution from reading in the newsGroup - But apperently this  
solution causing to other bugs.  
I will be very happy to hear about other ideas....  
Thnaks  
  

OK, I forgot about that initial case, but its easily solvable by calling  
SetCursor explicitly once, initially, when the cursor should change. You  
could probably get by by explicitly using  
SendMessage(hWnd, WM_SETCURSOR, HTCLIENT, WM_MOUSEMOVE)  
instead.  
The GetCursorPos/SetCursorPos in the code you originally posted was probably  
meant to achieve the same thing, but its an overkill.  

6/9/2004 3:24:50 PM    Re: SetCursorPos+GetCursorPos+WM_TIMER	
It seems that using SendMessage , solved the problems.  
